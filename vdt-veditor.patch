diff -U 3 -dHrN -- vdt-veditor/about_veditor.html vdt/about_veditor.html
--- vdt-veditor/about_veditor.html	2016-06-24 10:29:40.836496072 -0600
+++ vdt/about_veditor.html	2016-06-24 10:29:40.824496406 -0600
@@ -1,32 +1,32 @@
-<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
-<html>
-<head>
-<title>About</title>
-<meta http-equiv=Content-Type content="text/html; charset=ISO-8859-1">
-</head>
-<body lang="EN-US">
-<h2>About This Content</h2>
-
-<p>August 12, 2006</p>
-
-<h3>License</h3>
-
-<p>The Eclipse Foundation makes available all content in this plug-in (&quot;Content&quot;).  
-Unless otherwise indicated below, the Content is provided to you under the terms and conditions of the
-Eclipse Public License Version 1.0 (&quot;EPL&quot;).  A copy of the EPL is available 
-at <a href="http://www.eclipse.org/org/documents/epl-v10.php">http://www.eclipse.org/legal/epl-v10.html</a>.
-For purposes of the EPL, &quot;Program&quot; will mean the Content.</p>
-
-<p>If you did not receive this Content directly from the Eclipse Foundation, the Content is 
-being redistributed by another party (&quot;Redistributor&quot;) and different terms and conditions may
-apply to your use of any object code in the Content.  Check the Redistributor&rsquo;s license 
-that was provided with the Content.  If no such license exists, contact the Redistributor.  Unless otherwise
-indicated below, the terms and conditions of the EPL still apply to any source code in the Content
-and such source code may be obtained at <a href="http://www.eclipse.org/">http://www.eclipse.org</a>.</p>
-
-<h3>Project web page</h3>
-
-<a href="http://veditor.sourceforge.net/">http://veditor.sourceforge.net/</a>.
-
-</body>
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
+<html>
+<head>
+<title>About</title>
+<meta http-equiv=Content-Type content="text/html; charset=ISO-8859-1">
+</head>
+<body lang="EN-US">
+<h2>About This Content</h2>
+
+<p>August 12, 2006</p>
+
+<h3>License</h3>
+
+<p>The Eclipse Foundation makes available all content in this plug-in (&quot;Content&quot;).  
+Unless otherwise indicated below, the Content is provided to you under the terms and conditions of the
+Eclipse Public License Version 1.0 (&quot;EPL&quot;).  A copy of the EPL is available 
+at <a href="http://www.eclipse.org/org/documents/epl-v10.php">http://www.eclipse.org/legal/epl-v10.html</a>.
+For purposes of the EPL, &quot;Program&quot; will mean the Content.</p>
+
+<p>If you did not receive this Content directly from the Eclipse Foundation, the Content is 
+being redistributed by another party (&quot;Redistributor&quot;) and different terms and conditions may
+apply to your use of any object code in the Content.  Check the Redistributor&rsquo;s license 
+that was provided with the Content.  If no such license exists, contact the Redistributor.  Unless otherwise
+indicated below, the terms and conditions of the EPL still apply to any source code in the Content
+and such source code may be obtained at <a href="http://www.eclipse.org/">http://www.eclipse.org</a>.</p>
+
+<h3>Project web page</h3>
+
+<a href="http://veditor.sourceforge.net/">http://veditor.sourceforge.net/</a>.
+
+</body>
 </html>
\ No newline at end of file
diff -U 3 -dHrN -- vdt-veditor/ChangeLogVeditor.txt vdt/ChangeLogVeditor.txt
--- vdt-veditor/ChangeLogVeditor.txt	2016-06-24 10:29:40.836496072 -0600
+++ vdt/ChangeLogVeditor.txt	2016-06-24 10:29:40.824496406 -0600
@@ -1,74 +1,74 @@
-﻿2008-05-11 tadashi-k
-	* Fixed bug that external files cannot be edited
-	* Fixed bug that files cannot be opened from Repository Exploring Perspective
-2008-05-05 tadashi-k
-	* Added Sort and Filter options in Outline and Hierarchy views
-	* Modify behavior of Go To Definition
-	* Added context dependent content assist
-	* Added Verilog directive scanner
-	* Fixed bugs about Verilog Content Assist
-	* Added option of scanning all files in the project
-	* Modify parsing Verilog comment
-	* Fixed bugs about parsing Verilog code
-2007-06-10 tadashi-k
-	* Fixed bugs about parsing compiler directives and case statement in Verilog
-	* Fixed bugs about parsing if statement in generate block
-	* Added Code Style preference page for Verilog code formatter
-	* Build for JRE 1.5 (no longer support 1.4)
-2007-05-22 Ali Ghorashi
-	* Fixed bugs 1723058 (generate declarations) and 1703662 (custom attributes)
-2007-04-14 tadashi-k
-	* Fixed indent bug in module instantiation
-	* Fixed openPage bug in Verilog and VHDL mixed design
-2007-02-11 tadashi-k
-	* Fixed parsing parameter statement in Verilog
-	* Preserve indent in template pattern
-2007-01-06 tadashi-k
-	* Added Verilog context types and templates
-	* Fixed a problem of VHDL "inModule" template
-	* Fixed 1573514
-2006-12-28 Ali Ghorashi
-	* Added Templates Support
-	* Added Toolbar menus for compiling
-	* Fixed 1613455
-2006-12-19  Øyvind Harboe
-	* The project now does not need to be named "veditor" to compile.
-2006-12-12 Ghorashi-A
-	* Fixed a problem with "end architecture" in vhdl parser
-	* Fixed a builder bug that looked at "/" as the current directry
-	* Fixed compile action so that all the files are saved before compiling if 
-	  the "Save Automatically Before Build" option is checked. 
-	* Moved Compile Action to build menu
-	* Added Block Command and Block Uncomment
-2006-12-10  tadashi-k
-	* fixed bugs about error parser and simulation
-2006-09-10  tadashi-k
-	* add Export-Package in MANIFEST.MF for test
-2006-08-27  tadashi-k
-	* add a new contributor to CONTRIBUTORS.txt
-2006-08-26  tadashi-k
-	* refactored ParserCore.jj and other files.
-	* implemented TextHover with declaration lines
-2006-08-17  tadashi-k
-	* fixed bugs: 1488462, 1519826, 1519835, 1537960
-2006-08-16  tadashi-k
-	* fixed bugs: 1529153, 1538377
-	* fixed bugs: ExtenalLauncher show error if launch in non-exist directory
-2006-08-14  Øyvind Harboe
-	* renamed ChangeLog to ChangeLog.txt & CONTRIBUTORS to CONTRIBUTORS.txt that allows
-	  BOM & UTF-8 encoding to be used.
-	、私は3つのビールを食べるように! 
-2006-08-12  tadashi-k
-	* Changed license from GPL to EPL
-2006-08-11 Øyvind Harboe	
-	* Added CONTRIBUTORS file
-2006-05-30 Øyvind Harboe	
-	* added ChangeLog
-	* bumped version number for plugin to 0.4.2
-	* Fixed NPE in ctrl-space for VHDL files. 
-	* renamed build.xml to buildjavacc.xml. The original build.xml file
-	  is used to generate .java from .jj files. The "build.xml" name
-	  is used by standard Eclipse naming w.r.t. build files for exporting
-	  the plugin
-	* added standard Eclipse plugin.xlm, which produces an emphemeral build.xml 
-	  which allows exporting veditor as a plugin
+﻿2008-05-11 tadashi-k
+	* Fixed bug that external files cannot be edited
+	* Fixed bug that files cannot be opened from Repository Exploring Perspective
+2008-05-05 tadashi-k
+	* Added Sort and Filter options in Outline and Hierarchy views
+	* Modify behavior of Go To Definition
+	* Added context dependent content assist
+	* Added Verilog directive scanner
+	* Fixed bugs about Verilog Content Assist
+	* Added option of scanning all files in the project
+	* Modify parsing Verilog comment
+	* Fixed bugs about parsing Verilog code
+2007-06-10 tadashi-k
+	* Fixed bugs about parsing compiler directives and case statement in Verilog
+	* Fixed bugs about parsing if statement in generate block
+	* Added Code Style preference page for Verilog code formatter
+	* Build for JRE 1.5 (no longer support 1.4)
+2007-05-22 Ali Ghorashi
+	* Fixed bugs 1723058 (generate declarations) and 1703662 (custom attributes)
+2007-04-14 tadashi-k
+	* Fixed indent bug in module instantiation
+	* Fixed openPage bug in Verilog and VHDL mixed design
+2007-02-11 tadashi-k
+	* Fixed parsing parameter statement in Verilog
+	* Preserve indent in template pattern
+2007-01-06 tadashi-k
+	* Added Verilog context types and templates
+	* Fixed a problem of VHDL "inModule" template
+	* Fixed 1573514
+2006-12-28 Ali Ghorashi
+	* Added Templates Support
+	* Added Toolbar menus for compiling
+	* Fixed 1613455
+2006-12-19  Øyvind Harboe
+	* The project now does not need to be named "veditor" to compile.
+2006-12-12 Ghorashi-A
+	* Fixed a problem with "end architecture" in vhdl parser
+	* Fixed a builder bug that looked at "/" as the current directry
+	* Fixed compile action so that all the files are saved before compiling if 
+	  the "Save Automatically Before Build" option is checked. 
+	* Moved Compile Action to build menu
+	* Added Block Command and Block Uncomment
+2006-12-10  tadashi-k
+	* fixed bugs about error parser and simulation
+2006-09-10  tadashi-k
+	* add Export-Package in MANIFEST.MF for test
+2006-08-27  tadashi-k
+	* add a new contributor to CONTRIBUTORS.txt
+2006-08-26  tadashi-k
+	* refactored ParserCore.jj and other files.
+	* implemented TextHover with declaration lines
+2006-08-17  tadashi-k
+	* fixed bugs: 1488462, 1519826, 1519835, 1537960
+2006-08-16  tadashi-k
+	* fixed bugs: 1529153, 1538377
+	* fixed bugs: ExtenalLauncher show error if launch in non-exist directory
+2006-08-14  Øyvind Harboe
+	* renamed ChangeLog to ChangeLog.txt & CONTRIBUTORS to CONTRIBUTORS.txt that allows
+	  BOM & UTF-8 encoding to be used.
+	、私は3つのビールを食べるように! 
+2006-08-12  tadashi-k
+	* Changed license from GPL to EPL
+2006-08-11 Øyvind Harboe	
+	* Added CONTRIBUTORS file
+2006-05-30 Øyvind Harboe	
+	* added ChangeLog
+	* bumped version number for plugin to 0.4.2
+	* Fixed NPE in ctrl-space for VHDL files. 
+	* renamed build.xml to buildjavacc.xml. The original build.xml file
+	  is used to generate .java from .jj files. The "build.xml" name
+	  is used by standard Eclipse naming w.r.t. build files for exporting
+	  the plugin
+	* added standard Eclipse plugin.xlm, which produces an emphemeral build.xml 
+	  which allows exporting veditor as a plugin
diff -U 3 -dHrN -- vdt-veditor/CONTRIBUTORS_VEDITOR.txt vdt/CONTRIBUTORS_VEDITOR.txt
--- vdt-veditor/CONTRIBUTORS_VEDITOR.txt	2016-06-24 10:29:40.840495962 -0600
+++ vdt/CONTRIBUTORS_VEDITOR.txt	2016-06-24 10:29:40.828496294 -0600
@@ -1,5 +1,5 @@
-﻿KOBAYASHI Tadashi - initial API and implementation
-Øyvind Harboe - various odd bugfixes to VHDL and update site.
-Ken Horn - bugfixes
-Ali Ghorashi - Bug Fixes, Block Comment/Uncomment, templates, and other features
-Stijn Last - VHDL Feature improvements
+﻿KOBAYASHI Tadashi - initial API and implementation
+Øyvind Harboe - various odd bugfixes to VHDL and update site.
+Ken Horn - bugfixes
+Ali Ghorashi - Bug Fixes, Block Comment/Uncomment, templates, and other features
+Stijn Last - VHDL Feature improvements
diff -U 3 -dHrN -- vdt-veditor/_generated/com/elphel/vdt/veditor/parser/verilog/JavaCharStream.java vdt/_generated/com/elphel/vdt/veditor/parser/verilog/JavaCharStream.java
--- vdt-veditor/_generated/com/elphel/vdt/veditor/parser/verilog/JavaCharStream.java	2016-06-24 10:29:40.828496294 -0600
+++ vdt/_generated/com/elphel/vdt/veditor/parser/verilog/JavaCharStream.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,584 +1,620 @@
-/* Generated By:JavaCC: Do not edit this line. JavaCharStream.java Version 4.0 */
-package net.sourceforge.veditor.parser;
-
-/**
- * An implementation of interface CharStream, where the stream is assumed to
- * contain only ASCII characters (with java-like unicode escape processing).
- */
-
-public class JavaCharStream
-{
-  public static final boolean staticFlag = false;
-  static final int hexval(char c) throws java.io.IOException {
-    switch(c)
-    {
-       case '0' :
-          return 0;
-       case '1' :
-          return 1;
-       case '2' :
-          return 2;
-       case '3' :
-          return 3;
-       case '4' :
-          return 4;
-       case '5' :
-          return 5;
-       case '6' :
-          return 6;
-       case '7' :
-          return 7;
-       case '8' :
-          return 8;
-       case '9' :
-          return 9;
-
-       case 'a' :
-       case 'A' :
-          return 10;
-       case 'b' :
-       case 'B' :
-          return 11;
-       case 'c' :
-       case 'C' :
-          return 12;
-       case 'd' :
-       case 'D' :
-          return 13;
-       case 'e' :
-       case 'E' :
-          return 14;
-       case 'f' :
-       case 'F' :
-          return 15;
-    }
-
-    throw new java.io.IOException(); // Should never come here
-  }
-
-  public int bufpos = -1;
-  int bufsize;
-  int available;
-  int tokenBegin;
-  protected int bufline[];
-  protected int bufcolumn[];
-
-  protected int column = 0;
-  protected int line = 1;
-
-  protected boolean prevCharIsCR = false;
-  protected boolean prevCharIsLF = false;
-
-  protected java.io.Reader inputStream;
-
-  protected char[] nextCharBuf;
-  protected char[] buffer;
-  protected int maxNextCharInd = 0;
-  protected int nextCharInd = -1;
-  protected int inBuf = 0;
-  protected int tabSize = 8;
-
-  protected void setTabSize(int i) { tabSize = i; }
-  protected int getTabSize(int i) { return tabSize; }
-
-  protected void ExpandBuff(boolean wrapAround)
-  {
-     char[] newbuffer = new char[bufsize + 2048];
-     int newbufline[] = new int[bufsize + 2048];
-     int newbufcolumn[] = new int[bufsize + 2048];
-
-     try
-     {
-        if (wrapAround)
-        {
-           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
-           System.arraycopy(buffer, 0, newbuffer,
-                                             bufsize - tokenBegin, bufpos);
-           buffer = newbuffer;
-
-           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
-           System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
-           bufline = newbufline;
-
-           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
-           System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
-           bufcolumn = newbufcolumn;
-
-           bufpos += (bufsize - tokenBegin);
-        }
-        else
-        {
-           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
-           buffer = newbuffer;
-
-           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
-           bufline = newbufline;
-
-           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
-           bufcolumn = newbufcolumn;
-
-           bufpos -= tokenBegin;
-        }
-     }
-     catch (Throwable t)
-     {
-        throw new Error(t.getMessage());
-     }
-
-     available = (bufsize += 2048);
-     tokenBegin = 0;
-  }
-
-  protected void FillBuff() throws java.io.IOException
-  {
-     int i;
-     if (maxNextCharInd == 4096)
-        maxNextCharInd = nextCharInd = 0;
-
-     try {
-        if ((i = inputStream.read(nextCharBuf, maxNextCharInd,
-                                            4096 - maxNextCharInd)) == -1)
-        {
-           inputStream.close();
-           throw new java.io.IOException();
-        }
-        else
-           maxNextCharInd += i;
-        return;
-     }
-     catch(java.io.IOException e) {
-        if (bufpos != 0)
-        {
-           --bufpos;
-           backup(0);
-        }
-        else
-        {
-           bufline[bufpos] = line;
-           bufcolumn[bufpos] = column;
-        }
-        throw e;
-     }
-  }
-
-  protected char ReadByte() throws java.io.IOException
-  {
-     if (++nextCharInd >= maxNextCharInd)
-        FillBuff();
-
-     return nextCharBuf[nextCharInd];
-  }
-
-  public char BeginToken() throws java.io.IOException
-  {     
-     if (inBuf > 0)
-     {
-        --inBuf;
-
-        if (++bufpos == bufsize)
-           bufpos = 0;
-
-        tokenBegin = bufpos;
-        return buffer[bufpos];
-     }
-
-     tokenBegin = 0;
-     bufpos = -1;
-
-     return readChar();
-  }     
-
-  protected void AdjustBuffSize()
-  {
-     if (available == bufsize)
-     {
-        if (tokenBegin > 2048)
-        {
-           bufpos = 0;
-           available = tokenBegin;
-        }
-        else
-           ExpandBuff(false);
-     }
-     else if (available > tokenBegin)
-        available = bufsize;
-     else if ((tokenBegin - available) < 2048)
-        ExpandBuff(true);
-     else
-        available = tokenBegin;
-  }
-
-  protected void UpdateLineColumn(char c)
-  {
-     column++;
-
-     if (prevCharIsLF)
-     {
-        prevCharIsLF = false;
-        line += (column = 1);
-     }
-     else if (prevCharIsCR)
-     {
-        prevCharIsCR = false;
-        if (c == '\n')
-        {
-           prevCharIsLF = true;
-        }
-        else
-           line += (column = 1);
-     }
-
-     switch (c)
-     {
-        case '\r' :
-           prevCharIsCR = true;
-           break;
-        case '\n' :
-           prevCharIsLF = true;
-           break;
-        case '\t' :
-           column--;
-           column += (tabSize - (column % tabSize));
-           break;
-        default :
-           break;
-     }
-
-     bufline[bufpos] = line;
-     bufcolumn[bufpos] = column;
-  }
-
-  public char readChar() throws java.io.IOException
-  {
-     if (inBuf > 0)
-     {
-        --inBuf;
-
-        if (++bufpos == bufsize)
-           bufpos = 0;
-
-        return buffer[bufpos];
-     }
-
-     char c;
-
-     if (++bufpos == available)
-        AdjustBuffSize();
-
-     if ((buffer[bufpos] = c = ReadByte()) == '\\')
-     {
-        UpdateLineColumn(c);
-
-        int backSlashCnt = 1;
-
-        for (;;) // Read all the backslashes
-        {
-           if (++bufpos == available)
-              AdjustBuffSize();
-
-           try
-           {
-              if ((buffer[bufpos] = c = ReadByte()) != '\\')
-              {
-                 UpdateLineColumn(c);
-                 // found a non-backslash char.
-                 if ((c == 'u') && ((backSlashCnt & 1) == 1))
-                 {
-                    if (--bufpos < 0)
-                       bufpos = bufsize - 1;
-
-                    break;
-                 }
-
-                 backup(backSlashCnt);
-                 return '\\';
-              }
-           }
-           catch(java.io.IOException e)
-           {
-              if (backSlashCnt > 1)
-                 backup(backSlashCnt);
-
-              return '\\';
-           }
-
-           UpdateLineColumn(c);
-           backSlashCnt++;
-        }
-
-        // Here, we have seen an odd number of backslash's followed by a 'u'
-        try
-        {
-           while ((c = ReadByte()) == 'u')
-              ++column;
-
-           buffer[bufpos] = c = (char)(hexval(c) << 12 |
-                                       hexval(ReadByte()) << 8 |
-                                       hexval(ReadByte()) << 4 |
-                                       hexval(ReadByte()));
-
-           column += 4;
-        }
-        catch(java.io.IOException e)
-        {
-           throw new Error("Invalid escape character at line " + line +
-                                         " column " + column + ".");
-        }
-
-        if (backSlashCnt == 1)
-           return c;
-        else
-        {
-           backup(backSlashCnt - 1);
-           return '\\';
-        }
-     }
-     else
-     {
-        UpdateLineColumn(c);
-        return (c);
-     }
-  }
-
-  /**
-   * @deprecated 
-   * @see #getEndColumn
-   */
-
-  public int getColumn() {
-     return bufcolumn[bufpos];
-  }
-
-  /**
-   * @deprecated 
-   * @see #getEndLine
-   */
-
-  public int getLine() {
-     return bufline[bufpos];
-  }
-
-  public int getEndColumn() {
-     return bufcolumn[bufpos];
-  }
-
-  public int getEndLine() {
-     return bufline[bufpos];
-  }
-
-  public int getBeginColumn() {
-     return bufcolumn[tokenBegin];
-  }
-
-  public int getBeginLine() {
-     return bufline[tokenBegin];
-  }
-
-  public void backup(int amount) {
-
-    inBuf += amount;
-    if ((bufpos -= amount) < 0)
-       bufpos += bufsize;
-  }
-
-  public JavaCharStream(java.io.Reader dstream,
-                 int startline, int startcolumn, int buffersize)
-  {
-    inputStream = dstream;
-    line = startline;
-    column = startcolumn - 1;
-
-    available = bufsize = buffersize;
-    buffer = new char[buffersize];
-    bufline = new int[buffersize];
-    bufcolumn = new int[buffersize];
-    nextCharBuf = new char[4096];
-  }
-
-  public JavaCharStream(java.io.Reader dstream,
-                                        int startline, int startcolumn)
-  {
-     this(dstream, startline, startcolumn, 4096);
-  }
-
-  public JavaCharStream(java.io.Reader dstream)
-  {
-     this(dstream, 1, 1, 4096);
-  }
-  public void ReInit(java.io.Reader dstream,
-                 int startline, int startcolumn, int buffersize)
-  {
-    inputStream = dstream;
-    line = startline;
-    column = startcolumn - 1;
-
-    if (buffer == null || buffersize != buffer.length)
-    {
-      available = bufsize = buffersize;
-      buffer = new char[buffersize];
-      bufline = new int[buffersize];
-      bufcolumn = new int[buffersize];
-      nextCharBuf = new char[4096];
-    }
-    prevCharIsLF = prevCharIsCR = false;
-    tokenBegin = inBuf = maxNextCharInd = 0;
-    nextCharInd = bufpos = -1;
-  }
-
-  public void ReInit(java.io.Reader dstream,
-                                        int startline, int startcolumn)
-  {
-     ReInit(dstream, startline, startcolumn, 4096);
-  }
-
-  public void ReInit(java.io.Reader dstream)
-  {
-     ReInit(dstream, 1, 1, 4096);
-  }
-  public JavaCharStream(java.io.InputStream dstream, String encoding, int startline,
-  int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException
-  {
-     this(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
-  }
-
-  public JavaCharStream(java.io.InputStream dstream, int startline,
-  int startcolumn, int buffersize)
-  {
-     this(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
-  }
-
-  public JavaCharStream(java.io.InputStream dstream, String encoding, int startline,
-                        int startcolumn) throws java.io.UnsupportedEncodingException
-  {
-     this(dstream, encoding, startline, startcolumn, 4096);
-  }
-
-  public JavaCharStream(java.io.InputStream dstream, int startline,
-                        int startcolumn)
-  {
-     this(dstream, startline, startcolumn, 4096);
-  }
-
-  public JavaCharStream(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException
-  {
-     this(dstream, encoding, 1, 1, 4096);
-  }
-
-  public JavaCharStream(java.io.InputStream dstream)
-  {
-     this(dstream, 1, 1, 4096);
-  }
-
-  public void ReInit(java.io.InputStream dstream, String encoding, int startline,
-  int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException
-  {
-     ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
-  }
-
-  public void ReInit(java.io.InputStream dstream, int startline,
-  int startcolumn, int buffersize)
-  {
-     ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
-  }
-  public void ReInit(java.io.InputStream dstream, String encoding, int startline,
-                     int startcolumn) throws java.io.UnsupportedEncodingException
-  {
-     ReInit(dstream, encoding, startline, startcolumn, 4096);
-  }
-  public void ReInit(java.io.InputStream dstream, int startline,
-                     int startcolumn)
-  {
-     ReInit(dstream, startline, startcolumn, 4096);
-  }
-  public void ReInit(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException
-  {
-     ReInit(dstream, encoding, 1, 1, 4096);
-  }
-
-  public void ReInit(java.io.InputStream dstream)
-  {
-     ReInit(dstream, 1, 1, 4096);
-  }
-
-  public String GetImage()
-  {
-     if (bufpos >= tokenBegin)
-        return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
-     else
-        return new String(buffer, tokenBegin, bufsize - tokenBegin) +
-                              new String(buffer, 0, bufpos + 1);
-  }
-
-  public char[] GetSuffix(int len)
-  {
-     char[] ret = new char[len];
-
-     if ((bufpos + 1) >= len)
-        System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
-     else
-     {
-        System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,
-                                                          len - bufpos - 1);
-        System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
-     }
-
-     return ret;
-  }
-
-  public void Done()
-  {
-     nextCharBuf = null;
-     buffer = null;
-     bufline = null;
-     bufcolumn = null;
-  }
-
-  /**
-   * Method to adjust line and column numbers for the start of a token.
-   */
-  public void adjustBeginLineColumn(int newLine, int newCol)
-  {
-     int start = tokenBegin;
-     int len;
-
-     if (bufpos >= tokenBegin)
-     {
-        len = bufpos - tokenBegin + inBuf + 1;
-     }
-     else
-     {
-        len = bufsize - tokenBegin + bufpos + 1 + inBuf;
-     }
-
-     int i = 0, j = 0, k = 0;
-     int nextColDiff = 0, columnDiff = 0;
-
-     while (i < len &&
-            bufline[j = start % bufsize] == bufline[k = ++start % bufsize])
-     {
-        bufline[j] = newLine;
-        nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];
-        bufcolumn[j] = newCol + columnDiff;
-        columnDiff = nextColDiff;
-        i++;
-     } 
-
-     if (i < len)
-     {
-        bufline[j] = newLine++;
-        bufcolumn[j] = newCol + columnDiff;
-
-        while (i++ < len)
-        {
-           if (bufline[j = start % bufsize] != bufline[++start % bufsize])
-              bufline[j] = newLine++;
-           else
-              bufline[j] = newLine;
-        }
-     }
-
-     line = bufline[j];
-     column = bufcolumn[j];
-  }
-
-}
+/* Generated By:JavaCC: Do not edit this line. JavaCharStream.java Version 6.0 */
+/* JavaCCOptions:STATIC=false,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
+package com.elphel.vdt.veditor.parser.verilog;
+
+/**
+ * An implementation of interface CharStream, where the stream is assumed to
+ * contain only ASCII characters (with java-like unicode escape processing).
+ */
+
+public
+class JavaCharStream
+{
+  /** Whether parser is static. */
+  public static final boolean staticFlag = false;
+
+  static final int hexval(char c) throws java.io.IOException {
+    switch(c)
+    {
+       case '0' :
+          return 0;
+       case '1' :
+          return 1;
+       case '2' :
+          return 2;
+       case '3' :
+          return 3;
+       case '4' :
+          return 4;
+       case '5' :
+          return 5;
+       case '6' :
+          return 6;
+       case '7' :
+          return 7;
+       case '8' :
+          return 8;
+       case '9' :
+          return 9;
+
+       case 'a' :
+       case 'A' :
+          return 10;
+       case 'b' :
+       case 'B' :
+          return 11;
+       case 'c' :
+       case 'C' :
+          return 12;
+       case 'd' :
+       case 'D' :
+          return 13;
+       case 'e' :
+       case 'E' :
+          return 14;
+       case 'f' :
+       case 'F' :
+          return 15;
+    }
+
+    throw new java.io.IOException(); // Should never come here
+  }
+
+/** Position in buffer. */
+  public int bufpos = -1;
+  int bufsize;
+  int available;
+  int tokenBegin;
+  protected int bufline[];
+  protected int bufcolumn[];
+
+  protected int column = 0;
+  protected int line = 1;
+
+  protected boolean prevCharIsCR = false;
+  protected boolean prevCharIsLF = false;
+
+  protected java.io.Reader inputStream;
+
+  protected char[] nextCharBuf;
+  protected char[] buffer;
+  protected int maxNextCharInd = 0;
+  protected int nextCharInd = -1;
+  protected int inBuf = 0;
+  protected int tabSize = 8;
+  protected boolean trackLineColumn = true;
+
+  public void setTabSize(int i) { tabSize = i; }
+  public int getTabSize() { return tabSize; }
+
+  protected void ExpandBuff(boolean wrapAround)
+  {
+    char[] newbuffer = new char[bufsize + 2048];
+    int newbufline[] = new int[bufsize + 2048];
+    int newbufcolumn[] = new int[bufsize + 2048];
+
+    try
+    {
+      if (wrapAround)
+      {
+        System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
+        System.arraycopy(buffer, 0, newbuffer, bufsize - tokenBegin, bufpos);
+        buffer = newbuffer;
+
+        System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
+        System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
+        bufline = newbufline;
+
+        System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
+        System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
+        bufcolumn = newbufcolumn;
+
+        bufpos += (bufsize - tokenBegin);
+    }
+    else
+    {
+        System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
+        buffer = newbuffer;
+
+        System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
+        bufline = newbufline;
+
+        System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
+        bufcolumn = newbufcolumn;
+
+        bufpos -= tokenBegin;
+      }
+    }
+    catch (Throwable t)
+    {
+      throw new Error(t.getMessage());
+    }
+
+    available = (bufsize += 2048);
+    tokenBegin = 0;
+  }
+
+  protected void FillBuff() throws java.io.IOException
+  {
+    int i;
+    if (maxNextCharInd == 4096)
+      maxNextCharInd = nextCharInd = 0;
+
+    try {
+      if ((i = inputStream.read(nextCharBuf, maxNextCharInd,
+                                          4096 - maxNextCharInd)) == -1)
+      {
+        inputStream.close();
+        throw new java.io.IOException();
+      }
+      else
+         maxNextCharInd += i;
+      return;
+    }
+    catch(java.io.IOException e) {
+      if (bufpos != 0)
+      {
+        --bufpos;
+        backup(0);
+      }
+      else
+      {
+        bufline[bufpos] = line;
+        bufcolumn[bufpos] = column;
+      }
+      throw e;
+    }
+  }
+
+  protected char ReadByte() throws java.io.IOException
+  {
+    if (++nextCharInd >= maxNextCharInd)
+      FillBuff();
+
+    return nextCharBuf[nextCharInd];
+  }
+
+/** @return starting character for token. */
+  public char BeginToken() throws java.io.IOException
+  {
+    if (inBuf > 0)
+    {
+      --inBuf;
+
+      if (++bufpos == bufsize)
+        bufpos = 0;
+
+      tokenBegin = bufpos;
+      return buffer[bufpos];
+    }
+
+    tokenBegin = 0;
+    bufpos = -1;
+
+    return readChar();
+  }
+
+  protected void AdjustBuffSize()
+  {
+    if (available == bufsize)
+    {
+      if (tokenBegin > 2048)
+      {
+        bufpos = 0;
+        available = tokenBegin;
+      }
+      else
+        ExpandBuff(false);
+    }
+    else if (available > tokenBegin)
+      available = bufsize;
+    else if ((tokenBegin - available) < 2048)
+      ExpandBuff(true);
+    else
+      available = tokenBegin;
+  }
+
+  protected void UpdateLineColumn(char c)
+  {
+    column++;
+
+    if (prevCharIsLF)
+    {
+      prevCharIsLF = false;
+      line += (column = 1);
+    }
+    else if (prevCharIsCR)
+    {
+      prevCharIsCR = false;
+      if (c == '\n')
+      {
+        prevCharIsLF = true;
+      }
+      else
+        line += (column = 1);
+    }
+
+    switch (c)
+    {
+      case '\r' :
+        prevCharIsCR = true;
+        break;
+      case '\n' :
+        prevCharIsLF = true;
+        break;
+      case '\t' :
+        column--;
+        column += (tabSize - (column % tabSize));
+        break;
+      default :
+        break;
+    }
+
+    bufline[bufpos] = line;
+    bufcolumn[bufpos] = column;
+  }
+
+/** Read a character. */
+  public char readChar() throws java.io.IOException
+  {
+    if (inBuf > 0)
+    {
+      --inBuf;
+
+      if (++bufpos == bufsize)
+        bufpos = 0;
+
+      return buffer[bufpos];
+    }
+
+    char c;
+
+    if (++bufpos == available)
+      AdjustBuffSize();
+
+    if ((buffer[bufpos] = c = ReadByte()) == '\\')
+    {
+      if (trackLineColumn) { UpdateLineColumn(c); }
+
+      int backSlashCnt = 1;
+
+      for (;;) // Read all the backslashes
+      {
+        if (++bufpos == available)
+          AdjustBuffSize();
+
+        try
+        {
+          if ((buffer[bufpos] = c = ReadByte()) != '\\')
+          {
+            if (trackLineColumn) { UpdateLineColumn(c); }
+            // found a non-backslash char.
+            if ((c == 'u') && ((backSlashCnt & 1) == 1))
+            {
+              if (--bufpos < 0)
+                bufpos = bufsize - 1;
+
+              break;
+            }
+
+            backup(backSlashCnt);
+            return '\\';
+          }
+        }
+        catch(java.io.IOException e)
+        {
+	  // We are returning one backslash so we should only backup (count-1)
+          if (backSlashCnt > 1)
+            backup(backSlashCnt-1);
+
+          return '\\';
+        }
+
+        if (trackLineColumn) { UpdateLineColumn(c); }
+        backSlashCnt++;
+      }
+
+      // Here, we have seen an odd number of backslash's followed by a 'u'
+      try
+      {
+        while ((c = ReadByte()) == 'u')
+          ++column;
+
+        buffer[bufpos] = c = (char)(hexval(c) << 12 |
+                                    hexval(ReadByte()) << 8 |
+                                    hexval(ReadByte()) << 4 |
+                                    hexval(ReadByte()));
+
+        column += 4;
+      }
+      catch(java.io.IOException e)
+      {
+        throw new Error("Invalid escape character at line " + line +
+                                         " column " + column + ".");
+      }
+
+      if (backSlashCnt == 1)
+        return c;
+      else
+      {
+        backup(backSlashCnt - 1);
+        return '\\';
+      }
+    }
+    else
+    {
+      UpdateLineColumn(c);
+      return c;
+    }
+  }
+
+  @Deprecated
+  /**
+   * @deprecated
+   * @see #getEndColumn
+   */
+  public int getColumn() {
+    return bufcolumn[bufpos];
+  }
+
+  @Deprecated
+  /**
+   * @deprecated
+   * @see #getEndLine
+   */
+  public int getLine() {
+    return bufline[bufpos];
+  }
+
+/** Get end column. */
+  public int getEndColumn() {
+    return bufcolumn[bufpos];
+  }
+
+/** Get end line. */
+  public int getEndLine() {
+    return bufline[bufpos];
+  }
+
+/** @return column of token start */
+  public int getBeginColumn() {
+    return bufcolumn[tokenBegin];
+  }
+
+/** @return line number of token start */
+  public int getBeginLine() {
+    return bufline[tokenBegin];
+  }
+
+/** Retreat. */
+  public void backup(int amount) {
+
+    inBuf += amount;
+    if ((bufpos -= amount) < 0)
+      bufpos += bufsize;
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.Reader dstream,
+                 int startline, int startcolumn, int buffersize)
+  {
+    inputStream = dstream;
+    line = startline;
+    column = startcolumn - 1;
+
+    available = bufsize = buffersize;
+    buffer = new char[buffersize];
+    bufline = new int[buffersize];
+    bufcolumn = new int[buffersize];
+    nextCharBuf = new char[4096];
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.Reader dstream,
+                                        int startline, int startcolumn)
+  {
+    this(dstream, startline, startcolumn, 4096);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.Reader dstream)
+  {
+    this(dstream, 1, 1, 4096);
+  }
+/** Reinitialise. */
+  public void ReInit(java.io.Reader dstream,
+                 int startline, int startcolumn, int buffersize)
+  {
+    inputStream = dstream;
+    line = startline;
+    column = startcolumn - 1;
+
+    if (buffer == null || buffersize != buffer.length)
+    {
+      available = bufsize = buffersize;
+      buffer = new char[buffersize];
+      bufline = new int[buffersize];
+      bufcolumn = new int[buffersize];
+      nextCharBuf = new char[4096];
+    }
+    prevCharIsLF = prevCharIsCR = false;
+    tokenBegin = inBuf = maxNextCharInd = 0;
+    nextCharInd = bufpos = -1;
+  }
+
+/** Reinitialise. */
+  public void ReInit(java.io.Reader dstream,
+                                        int startline, int startcolumn)
+  {
+    ReInit(dstream, startline, startcolumn, 4096);
+  }
+
+/** Reinitialise. */
+  public void ReInit(java.io.Reader dstream)
+  {
+    ReInit(dstream, 1, 1, 4096);
+  }
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream, String encoding, int startline,
+  int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException
+  {
+    this(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream, int startline,
+  int startcolumn, int buffersize)
+  {
+    this(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream, String encoding, int startline,
+                        int startcolumn) throws java.io.UnsupportedEncodingException
+  {
+    this(dstream, encoding, startline, startcolumn, 4096);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream, int startline,
+                        int startcolumn)
+  {
+    this(dstream, startline, startcolumn, 4096);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException
+  {
+    this(dstream, encoding, 1, 1, 4096);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream)
+  {
+    this(dstream, 1, 1, 4096);
+  }
+
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, String encoding, int startline,
+  int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException
+  {
+    ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
+  }
+
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, int startline,
+  int startcolumn, int buffersize)
+  {
+    ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
+  }
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, String encoding, int startline,
+                     int startcolumn) throws java.io.UnsupportedEncodingException
+  {
+    ReInit(dstream, encoding, startline, startcolumn, 4096);
+  }
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, int startline,
+                     int startcolumn)
+  {
+    ReInit(dstream, startline, startcolumn, 4096);
+  }
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException
+  {
+    ReInit(dstream, encoding, 1, 1, 4096);
+  }
+
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream)
+  {
+    ReInit(dstream, 1, 1, 4096);
+  }
+
+  /** @return token image as String */
+  public String GetImage()
+  {
+    if (bufpos >= tokenBegin)
+      return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
+    else
+      return new String(buffer, tokenBegin, bufsize - tokenBegin) +
+                              new String(buffer, 0, bufpos + 1);
+  }
+
+  /** @return suffix */
+  public char[] GetSuffix(int len)
+  {
+    char[] ret = new char[len];
+
+    if ((bufpos + 1) >= len)
+      System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
+    else
+    {
+      System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,
+                                                        len - bufpos - 1);
+      System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
+    }
+
+    return ret;
+  }
+
+  /** Set buffers back to null when finished. */
+  public void Done()
+  {
+    nextCharBuf = null;
+    buffer = null;
+    bufline = null;
+    bufcolumn = null;
+  }
+
+  /**
+   * Method to adjust line and column numbers for the start of a token.
+   */
+  public void adjustBeginLineColumn(int newLine, int newCol)
+  {
+    int start = tokenBegin;
+    int len;
+
+    if (bufpos >= tokenBegin)
+    {
+      len = bufpos - tokenBegin + inBuf + 1;
+    }
+    else
+    {
+      len = bufsize - tokenBegin + bufpos + 1 + inBuf;
+    }
+
+    int i = 0, j = 0, k = 0;
+    int nextColDiff = 0, columnDiff = 0;
+
+    while (i < len && bufline[j = start % bufsize] == bufline[k = ++start % bufsize])
+    {
+      bufline[j] = newLine;
+      nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];
+      bufcolumn[j] = newCol + columnDiff;
+      columnDiff = nextColDiff;
+      i++;
+    }
+
+    if (i < len)
+    {
+      bufline[j] = newLine++;
+      bufcolumn[j] = newCol + columnDiff;
+
+      while (i++ < len)
+      {
+        if (bufline[j = start % bufsize] != bufline[++start % bufsize])
+          bufline[j] = newLine++;
+        else
+          bufline[j] = newLine;
+      }
+    }
+
+    line = bufline[j];
+    column = bufcolumn[j];
+  }
+  boolean getTrackLineColumn() { return trackLineColumn; }
+  void setTrackLineColumn(boolean tlc) { trackLineColumn = tlc; }
+
+}
+/* JavaCC - OriginalChecksum=751c648385bd32bb5b99a57613d58ec6 (do not edit this line) */
diff -U 3 -dHrN -- vdt-veditor/_generated/com/elphel/vdt/veditor/parser/verilog/ParseException.java vdt/_generated/com/elphel/vdt/veditor/parser/verilog/ParseException.java
--- vdt-veditor/_generated/com/elphel/vdt/veditor/parser/verilog/ParseException.java	2016-06-24 10:29:40.828496294 -0600
+++ vdt/_generated/com/elphel/vdt/veditor/parser/verilog/ParseException.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,197 +1,187 @@
-/* Generated By:JavaCC: Do not edit this line. ParseException.java Version 3.0 */
-package net.sourceforge.veditor.parser;
-
-/**
- * This exception is thrown when parse errors are encountered.
- * You can explicitly create objects of this exception type by
- * calling the method generateParseException in the generated
- * parser.
- *
- * You can modify this class to customize your error reporting
- * mechanisms so long as you retain the public fields.
- */
-public class ParseException extends Exception {
-
-  /**
-     * 
-     */
-    private static final long serialVersionUID = 7811742812760162144L;
-
-/**
-   * This constructor is used by the method "generateParseException"
-   * in the generated parser.  Calling this constructor generates
-   * a new object of this type with the fields "currentToken",
-   * "expectedTokenSequences", and "tokenImage" set.  The boolean
-   * flag "specialConstructor" is also set to true to indicate that
-   * this constructor was used to create this object.
-   * This constructor calls its super class with the empty string
-   * to force the "toString" method of parent class "Throwable" to
-   * print the error message in the form:
-   *     ParseException: <result of getMessage>
-   */
-  public ParseException(Token currentTokenVal,
-                        int[][] expectedTokenSequencesVal,
-                        String[] tokenImageVal
-                       )
-  {
-    super("");
-    specialConstructor = true;
-    currentToken = currentTokenVal;
-    expectedTokenSequences = expectedTokenSequencesVal;
-    tokenImage = tokenImageVal;
-  }
-
-  /**
-   * The following constructors are for use by you for whatever
-   * purpose you can think of.  Constructing the exception in this
-   * manner makes the exception behave in the normal way - i.e., as
-   * documented in the class "Throwable".  The fields "errorToken",
-   * "expectedTokenSequences", and "tokenImage" do not contain
-   * relevant information.  The JavaCC generated code does not use
-   * these constructors.
-   */
-
-  public ParseException() {
-    super();
-    specialConstructor = false;
-  }
-
-  public ParseException(String message) {
-    super(message);
-    specialConstructor = false;
-  }
-
-  /**
-   * This variable determines which constructor was used to create
-   * this object and thereby affects the semantics of the
-   * "getMessage" method (see below).
-   */
-  protected boolean specialConstructor;
-
-  /**
-   * This is the last token that has been consumed successfully.  If
-   * this object has been created due to a parse error, the token
-   * followng this token will (therefore) be the first error token.
-   */
-  public Token currentToken;
-
-  /**
-   * Each entry in this array is an array of integers.  Each array
-   * of integers represents a sequence of tokens (by their ordinal
-   * values) that is expected at this point of the parse.
-   */
-  public int[][] expectedTokenSequences;
-
-  /**
-   * This is a reference to the "tokenImage" array of the generated
-   * parser within which the parse error occurred.  This array is
-   * defined in the generated ...Constants interface.
-   */
-  public String[] tokenImage;
-
-  /**
-   * This method has the standard behavior when this object has been
-   * created using the standard constructors.  Otherwise, it uses
-   * "currentToken" and "expectedTokenSequences" to generate a parse
-   * error message and returns it.  If this object has been created
-   * due to a parse error, and you do not catch it (it gets thrown
-   * from the parser), then this method is called during the printing
-   * of the final stack trace, and hence the correct error message
-   * gets displayed.
-   */
-  public String getMessage() {
-    if (!specialConstructor) {
-      return super.getMessage();
-    }
-    StringBuffer expected = new StringBuffer();
-    int maxSize = 0;
-    for (int i = 0; i < expectedTokenSequences.length; i++) {
-      if (maxSize < expectedTokenSequences[i].length) {
-        maxSize = expectedTokenSequences[i].length;
-      }
-      for (int j = 0; j < expectedTokenSequences[i].length; j++) {
-        expected.append(tokenImage[expectedTokenSequences[i][j]]).append(" ");
-      }
-      if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0) {
-        expected.append("...");
-      }
-      expected.append(eol).append("    ");
-    }
-    String retval = "Encountered \"";
-    Token tok = currentToken.next;
-    for (int i = 0; i < maxSize; i++) {
-      if (i != 0) retval += " ";
-      if (tok.kind == 0) {
-        retval += tokenImage[0];
-        break;
-      }
-      retval += add_escapes(tok.image);
-      tok = tok.next; 
-    }
-    retval += "\" at line " + currentToken.next.beginLine + ", column " + currentToken.next.beginColumn;
-    retval += "." + eol;
-    if (expectedTokenSequences.length == 1) {
-      retval += "Was expecting:" + eol + "    ";
-    } else {
-      retval += "Was expecting one of:" + eol + "    ";
-    }
-    retval += expected.toString();
-    return retval;
-  }
-
-  /**
-   * The end of line string for this machine.
-   */
-  protected String eol = System.getProperty("line.separator", "\n");
- 
-  /**
-   * Used to convert raw characters to their escaped version
-   * when these raw version cannot be used as part of an ASCII
-   * string literal.
-   */
-  protected String add_escapes(String str) {
-      StringBuffer retval = new StringBuffer();
-      char ch;
-      for (int i = 0; i < str.length(); i++) {
-        switch (str.charAt(i))
-        {
-           case 0 :
-              continue;
-           case '\b':
-              retval.append("\\b");
-              continue;
-           case '\t':
-              retval.append("\\t");
-              continue;
-           case '\n':
-              retval.append("\\n");
-              continue;
-           case '\f':
-              retval.append("\\f");
-              continue;
-           case '\r':
-              retval.append("\\r");
-              continue;
-           case '\"':
-              retval.append("\\\"");
-              continue;
-           case '\'':
-              retval.append("\\\'");
-              continue;
-           case '\\':
-              retval.append("\\\\");
-              continue;
-           default:
-              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
-                 String s = "0000" + Integer.toString(ch, 16);
-                 retval.append("\\u" + s.substring(s.length() - 4, s.length()));
-              } else {
-                 retval.append(ch);
-              }
-              continue;
-        }
-      }
-      return retval.toString();
-   }
-
-}
+/* Generated By:JavaCC: Do not edit this line. ParseException.java Version 6.0 */
+/* JavaCCOptions:KEEP_LINE_COL=null */
+package com.elphel.vdt.veditor.parser.verilog;
+
+/**
+ * This exception is thrown when parse errors are encountered.
+ * You can explicitly create objects of this exception type by
+ * calling the method generateParseException in the generated
+ * parser.
+ *
+ * You can modify this class to customize your error reporting
+ * mechanisms so long as you retain the public fields.
+ */
+public class ParseException extends Exception {
+
+  /**
+   * The version identifier for this Serializable class.
+   * Increment only if the <i>serialized</i> form of the
+   * class changes.
+   */
+  private static final long serialVersionUID = 1L;
+
+  /**
+   * This constructor is used by the method "generateParseException"
+   * in the generated parser.  Calling this constructor generates
+   * a new object of this type with the fields "currentToken",
+   * "expectedTokenSequences", and "tokenImage" set.
+   */
+  public ParseException(Token currentTokenVal,
+                        int[][] expectedTokenSequencesVal,
+                        String[] tokenImageVal
+                       )
+  {
+    super(initialise(currentTokenVal, expectedTokenSequencesVal, tokenImageVal));
+    currentToken = currentTokenVal;
+    expectedTokenSequences = expectedTokenSequencesVal;
+    tokenImage = tokenImageVal;
+  }
+
+  /**
+   * The following constructors are for use by you for whatever
+   * purpose you can think of.  Constructing the exception in this
+   * manner makes the exception behave in the normal way - i.e., as
+   * documented in the class "Throwable".  The fields "errorToken",
+   * "expectedTokenSequences", and "tokenImage" do not contain
+   * relevant information.  The JavaCC generated code does not use
+   * these constructors.
+   */
+
+  public ParseException() {
+    super();
+  }
+
+  /** Constructor with message. */
+  public ParseException(String message) {
+    super(message);
+  }
+
+
+  /**
+   * This is the last token that has been consumed successfully.  If
+   * this object has been created due to a parse error, the token
+   * followng this token will (therefore) be the first error token.
+   */
+  public Token currentToken;
+
+  /**
+   * Each entry in this array is an array of integers.  Each array
+   * of integers represents a sequence of tokens (by their ordinal
+   * values) that is expected at this point of the parse.
+   */
+  public int[][] expectedTokenSequences;
+
+  /**
+   * This is a reference to the "tokenImage" array of the generated
+   * parser within which the parse error occurred.  This array is
+   * defined in the generated ...Constants interface.
+   */
+  public String[] tokenImage;
+
+  /**
+   * It uses "currentToken" and "expectedTokenSequences" to generate a parse
+   * error message and returns it.  If this object has been created
+   * due to a parse error, and you do not catch it (it gets thrown
+   * from the parser) the correct error message
+   * gets displayed.
+   */
+  private static String initialise(Token currentToken,
+                           int[][] expectedTokenSequences,
+                           String[] tokenImage) {
+    String eol = System.getProperty("line.separator", "\n");
+    StringBuffer expected = new StringBuffer();
+    int maxSize = 0;
+    for (int i = 0; i < expectedTokenSequences.length; i++) {
+      if (maxSize < expectedTokenSequences[i].length) {
+        maxSize = expectedTokenSequences[i].length;
+      }
+      for (int j = 0; j < expectedTokenSequences[i].length; j++) {
+        expected.append(tokenImage[expectedTokenSequences[i][j]]).append(' ');
+      }
+      if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0) {
+        expected.append("...");
+      }
+      expected.append(eol).append("    ");
+    }
+    String retval = "Encountered \"";
+    Token tok = currentToken.next;
+    for (int i = 0; i < maxSize; i++) {
+      if (i != 0) retval += " ";
+      if (tok.kind == 0) {
+        retval += tokenImage[0];
+        break;
+      }
+      retval += " " + tokenImage[tok.kind];
+      retval += " \"";
+      retval += add_escapes(tok.image);
+      retval += " \"";
+      tok = tok.next;
+    }
+    retval += "\" at line " + currentToken.next.beginLine + ", column " + currentToken.next.beginColumn;
+    retval += "." + eol;
+    if (expectedTokenSequences.length == 1) {
+      retval += "Was expecting:" + eol + "    ";
+    } else {
+      retval += "Was expecting one of:" + eol + "    ";
+    }
+    retval += expected.toString();
+    return retval;
+  }
+
+  /**
+   * The end of line string for this machine.
+   */
+  protected String eol = System.getProperty("line.separator", "\n");
+
+  /**
+   * Used to convert raw characters to their escaped version
+   * when these raw version cannot be used as part of an ASCII
+   * string literal.
+   */
+  static String add_escapes(String str) {
+      StringBuffer retval = new StringBuffer();
+      char ch;
+      for (int i = 0; i < str.length(); i++) {
+        switch (str.charAt(i))
+        {
+           case 0 :
+              continue;
+           case '\b':
+              retval.append("\\b");
+              continue;
+           case '\t':
+              retval.append("\\t");
+              continue;
+           case '\n':
+              retval.append("\\n");
+              continue;
+           case '\f':
+              retval.append("\\f");
+              continue;
+           case '\r':
+              retval.append("\\r");
+              continue;
+           case '\"':
+              retval.append("\\\"");
+              continue;
+           case '\'':
+              retval.append("\\\'");
+              continue;
+           case '\\':
+              retval.append("\\\\");
+              continue;
+           default:
+              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
+                 String s = "0000" + Integer.toString(ch, 16);
+                 retval.append("\\u" + s.substring(s.length() - 4, s.length()));
+              } else {
+                 retval.append(ch);
+              }
+              continue;
+        }
+      }
+      return retval.toString();
+   }
+
+}
+/* JavaCC - OriginalChecksum=c75fae9c19fa9314957b1ec647c3bfc6 (do not edit this line) */
diff -U 3 -dHrN -- vdt-veditor/_generated/com/elphel/vdt/veditor/parser/verilog/Token.java vdt/_generated/com/elphel/vdt/veditor/parser/verilog/Token.java
--- vdt-veditor/_generated/com/elphel/vdt/veditor/parser/verilog/Token.java	2016-06-24 10:29:40.832496184 -0600
+++ vdt/_generated/com/elphel/vdt/veditor/parser/verilog/Token.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,81 +1,131 @@
-/* Generated By:JavaCC: Do not edit this line. Token.java Version 3.0 */
-package net.sourceforge.veditor.parser;
-
-/**
- * Describes the input token stream.
- */
-
-public class Token {
-
-  /**
-   * An integer that describes the kind of this token.  This numbering
-   * system is determined by JavaCCParser, and a table of these numbers is
-   * stored in the file ...Constants.java.
-   */
-  public int kind;
-
-  /**
-   * beginLine and beginColumn describe the position of the first character
-   * of this token; endLine and endColumn describe the position of the
-   * last character of this token.
-   */
-  public int beginLine, beginColumn, endLine, endColumn;
-
-  /**
-   * The string image of the token.
-   */
-  public String image;
-
-  /**
-   * A reference to the next regular (non-special) token from the input
-   * stream.  If this is the last token from the input stream, or if the
-   * token manager has not read tokens beyond this one, this field is
-   * set to null.  This is true only if this token is also a regular
-   * token.  Otherwise, see below for a description of the contents of
-   * this field.
-   */
-  public Token next;
-
-  /**
-   * This field is used to access special tokens that occur prior to this
-   * token, but after the immediately preceding regular (non-special) token.
-   * If there are no such special tokens, this field is set to null.
-   * When there are more than one such special token, this field refers
-   * to the last of these special tokens, which in turn refers to the next
-   * previous special token through its specialToken field, and so on
-   * until the first special token (whose specialToken field is null).
-   * The next fields of special tokens refer to other special tokens that
-   * immediately follow it (without an intervening regular token).  If there
-   * is no such token, this field is null.
-   */
-  public Token specialToken;
-
-  /**
-   * Returns the image.
-   */
-  public String toString()
-  {
-     return image;
-  }
-
-  /**
-   * Returns a new Token object, by default. However, if you want, you
-   * can create and return subclass objects based on the value of ofKind.
-   * Simply add the cases to the switch for all those special cases.
-   * For example, if you have a subclass of Token called IDToken that
-   * you want to create if ofKind is ID, simlpy add something like :
-   *
-   *    case MyParserConstants.ID : return new IDToken();
-   *
-   * to the following switch statement. Then you can cast matchedToken
-   * variable to the appropriate type and use it in your lexical actions.
-   */
-  public static final Token newToken(int ofKind)
-  {
-     switch(ofKind)
-     {
-       default : return new Token();
-     }
-  }
-
-}
+/* Generated By:JavaCC: Do not edit this line. Token.java Version 6.0 */
+/* JavaCCOptions:TOKEN_EXTENDS=,KEEP_LINE_COL=null,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
+package com.elphel.vdt.veditor.parser.verilog;
+
+/**
+ * Describes the input token stream.
+ */
+
+public class Token implements java.io.Serializable {
+
+  /**
+   * The version identifier for this Serializable class.
+   * Increment only if the <i>serialized</i> form of the
+   * class changes.
+   */
+  private static final long serialVersionUID = 1L;
+
+  /**
+   * An integer that describes the kind of this token.  This numbering
+   * system is determined by JavaCCParser, and a table of these numbers is
+   * stored in the file ...Constants.java.
+   */
+  public int kind;
+
+  /** The line number of the first character of this Token. */
+  public int beginLine;
+  /** The column number of the first character of this Token. */
+  public int beginColumn;
+  /** The line number of the last character of this Token. */
+  public int endLine;
+  /** The column number of the last character of this Token. */
+  public int endColumn;
+
+  /**
+   * The string image of the token.
+   */
+  public String image;
+
+  /**
+   * A reference to the next regular (non-special) token from the input
+   * stream.  If this is the last token from the input stream, or if the
+   * token manager has not read tokens beyond this one, this field is
+   * set to null.  This is true only if this token is also a regular
+   * token.  Otherwise, see below for a description of the contents of
+   * this field.
+   */
+  public Token next;
+
+  /**
+   * This field is used to access special tokens that occur prior to this
+   * token, but after the immediately preceding regular (non-special) token.
+   * If there are no such special tokens, this field is set to null.
+   * When there are more than one such special token, this field refers
+   * to the last of these special tokens, which in turn refers to the next
+   * previous special token through its specialToken field, and so on
+   * until the first special token (whose specialToken field is null).
+   * The next fields of special tokens refer to other special tokens that
+   * immediately follow it (without an intervening regular token).  If there
+   * is no such token, this field is null.
+   */
+  public Token specialToken;
+
+  /**
+   * An optional attribute value of the Token.
+   * Tokens which are not used as syntactic sugar will often contain
+   * meaningful values that will be used later on by the compiler or
+   * interpreter. This attribute value is often different from the image.
+   * Any subclass of Token that actually wants to return a non-null value can
+   * override this method as appropriate.
+   */
+  public Object getValue() {
+    return null;
+  }
+
+  /**
+   * No-argument constructor
+   */
+  public Token() {}
+
+  /**
+   * Constructs a new token for the specified Image.
+   */
+  public Token(int kind)
+  {
+    this(kind, null);
+  }
+
+  /**
+   * Constructs a new token for the specified Image and Kind.
+   */
+  public Token(int kind, String image)
+  {
+    this.kind = kind;
+    this.image = image;
+  }
+
+  /**
+   * Returns the image.
+   */
+  public String toString()
+  {
+    return image;
+  }
+
+  /**
+   * Returns a new Token object, by default. However, if you want, you
+   * can create and return subclass objects based on the value of ofKind.
+   * Simply add the cases to the switch for all those special cases.
+   * For example, if you have a subclass of Token called IDToken that
+   * you want to create if ofKind is ID, simply add something like :
+   *
+   *    case MyParserConstants.ID : return new IDToken(ofKind, image);
+   *
+   * to the following switch statement. Then you can cast matchedToken
+   * variable to the appropriate type and use sit in your lexical actions.
+   */
+  public static Token newToken(int ofKind, String image)
+  {
+    switch(ofKind)
+    {
+      default : return new Token(ofKind, image);
+    }
+  }
+
+  public static Token newToken(int ofKind)
+  {
+    return newToken(ofKind, null);
+  }
+
+}
+/* JavaCC - OriginalChecksum=e80a8b92a6bec0520c9325dc7435f8bb (do not edit this line) */
diff -U 3 -dHrN -- vdt-veditor/_generated/com/elphel/vdt/veditor/parser/verilog/TokenMgrError.java vdt/_generated/com/elphel/vdt/veditor/parser/verilog/TokenMgrError.java
--- vdt-veditor/_generated/com/elphel/vdt/veditor/parser/verilog/TokenMgrError.java	2016-06-24 10:29:40.832496184 -0600
+++ vdt/_generated/com/elphel/vdt/veditor/parser/verilog/TokenMgrError.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,138 +1,147 @@
-/* Generated By:JavaCC: Do not edit this line. TokenMgrError.java Version 3.0 */
-package net.sourceforge.veditor.parser;
-
-public class TokenMgrError extends Error
-{
-   /*
-    * Ordinals for various reasons why an Error of this type can be thrown.
-    */
-
-   /**
-     * 
-     */
-    private static final long serialVersionUID = 8717981741131339532L;
-
-/**
-    * Lexical error occured.
-    */
-   static final int LEXICAL_ERROR = 0;
-
-   /**
-    * An attempt wass made to create a second instance of a static token manager.
-    */
-   static final int STATIC_LEXER_ERROR = 1;
-
-   /**
-    * Tried to change to an invalid lexical state.
-    */
-   static final int INVALID_LEXICAL_STATE = 2;
-
-   /**
-    * Detected (and bailed out of) an infinite loop in the token manager.
-    */
-   static final int LOOP_DETECTED = 3;
-
-   /**
-    * Indicates the reason why the exception is thrown. It will have
-    * one of the above 4 values.
-    */
-   int errorCode;
-
-   /**
-    * Replaces unprintable characters by their espaced (or unicode escaped)
-    * equivalents in the given string
-    */
-   protected static final String addEscapes(String str) {
-      StringBuffer retval = new StringBuffer();
-      char ch;
-      for (int i = 0; i < str.length(); i++) {
-        switch (str.charAt(i))
-        {
-           case 0 :
-              continue;
-           case '\b':
-              retval.append("\\b");
-              continue;
-           case '\t':
-              retval.append("\\t");
-              continue;
-           case '\n':
-              retval.append("\\n");
-              continue;
-           case '\f':
-              retval.append("\\f");
-              continue;
-           case '\r':
-              retval.append("\\r");
-              continue;
-           case '\"':
-              retval.append("\\\"");
-              continue;
-           case '\'':
-              retval.append("\\\'");
-              continue;
-           case '\\':
-              retval.append("\\\\");
-              continue;
-           default:
-              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
-                 String s = "0000" + Integer.toString(ch, 16);
-                 retval.append("\\u" + s.substring(s.length() - 4, s.length()));
-              } else {
-                 retval.append(ch);
-              }
-              continue;
-        }
-      }
-      return retval.toString();
-   }
-
-   /**
-    * Returns a detailed message for the Error when it is thrown by the
-    * token manager to indicate a lexical error.
-    * Parameters : 
-    *    EOFSeen     : indicates if EOF caused the lexicl error
-    *    curLexState : lexical state in which this error occured
-    *    errorLine   : line number when the error occured
-    *    errorColumn : column number when the error occured
-    *    errorAfter  : prefix that was seen before this error occured
-    *    curchar     : the offending character
-    * Note: You can customize the lexical error message by modifying this method.
-    */
-   protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {
-      return("Lexical error at line " +
-           errorLine + ", column " +
-           errorColumn + ".  Encountered: " +
-           (EOFSeen ? "<EOF> " : ("\"" + addEscapes(String.valueOf(curChar)) + "\"") + " (" + (int)curChar + "), ") +
-           "after : \"" + addEscapes(errorAfter) + "\"");
-   }
-
-   /**
-    * You can also modify the body of this method to customize your error messages.
-    * For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
-    * of end-users concern, so you can return something like : 
-    *
-    *     "Internal Error : Please file a bug report .... "
-    *
-    * from this method for such cases in the release version of your parser.
-    */
-   public String getMessage() {
-      return super.getMessage();
-   }
-
-   /*
-    * Constructors of various flavors follow.
-    */
-
-   public TokenMgrError() {
-   }
-
-   public TokenMgrError(String message, int reason) {
-      super(message);
-      errorCode = reason;
-   }
-
-   public TokenMgrError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar, int reason) {
-      this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason);
-   }
-}
+/* Generated By:JavaCC: Do not edit this line. TokenMgrError.java Version 6.0 */
+/* JavaCCOptions: */
+package com.elphel.vdt.veditor.parser.verilog;
+
+/** Token Manager Error. */
+public class TokenMgrError extends Error
+{
+
+  /**
+   * The version identifier for this Serializable class.
+   * Increment only if the <i>serialized</i> form of the
+   * class changes.
+   */
+  private static final long serialVersionUID = 1L;
+
+  /*
+   * Ordinals for various reasons why an Error of this type can be thrown.
+   */
+
+  /**
+   * Lexical error occurred.
+   */
+  static final int LEXICAL_ERROR = 0;
+
+  /**
+   * An attempt was made to create a second instance of a static token manager.
+   */
+  static final int STATIC_LEXER_ERROR = 1;
+
+  /**
+   * Tried to change to an invalid lexical state.
+   */
+  static final int INVALID_LEXICAL_STATE = 2;
+
+  /**
+   * Detected (and bailed out of) an infinite loop in the token manager.
+   */
+  static final int LOOP_DETECTED = 3;
+
+  /**
+   * Indicates the reason why the exception is thrown. It will have
+   * one of the above 4 values.
+   */
+  int errorCode;
+
+  /**
+   * Replaces unprintable characters by their escaped (or unicode escaped)
+   * equivalents in the given string
+   */
+  protected static final String addEscapes(String str) {
+    StringBuffer retval = new StringBuffer();
+    char ch;
+    for (int i = 0; i < str.length(); i++) {
+      switch (str.charAt(i))
+      {
+        case 0 :
+          continue;
+        case '\b':
+          retval.append("\\b");
+          continue;
+        case '\t':
+          retval.append("\\t");
+          continue;
+        case '\n':
+          retval.append("\\n");
+          continue;
+        case '\f':
+          retval.append("\\f");
+          continue;
+        case '\r':
+          retval.append("\\r");
+          continue;
+        case '\"':
+          retval.append("\\\"");
+          continue;
+        case '\'':
+          retval.append("\\\'");
+          continue;
+        case '\\':
+          retval.append("\\\\");
+          continue;
+        default:
+          if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
+            String s = "0000" + Integer.toString(ch, 16);
+            retval.append("\\u" + s.substring(s.length() - 4, s.length()));
+          } else {
+            retval.append(ch);
+          }
+          continue;
+      }
+    }
+    return retval.toString();
+  }
+
+  /**
+   * Returns a detailed message for the Error when it is thrown by the
+   * token manager to indicate a lexical error.
+   * Parameters :
+   *    EOFSeen     : indicates if EOF caused the lexical error
+   *    curLexState : lexical state in which this error occurred
+   *    errorLine   : line number when the error occurred
+   *    errorColumn : column number when the error occurred
+   *    errorAfter  : prefix that was seen before this error occurred
+   *    curchar     : the offending character
+   * Note: You can customize the lexical error message by modifying this method.
+   */
+  protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {
+    return("Lexical error at line " +
+          errorLine + ", column " +
+          errorColumn + ".  Encountered: " +
+          (EOFSeen ? "<EOF> " : ("\"" + addEscapes(String.valueOf(curChar)) + "\"") + " (" + (int)curChar + "), ") +
+          "after : \"" + addEscapes(errorAfter) + "\"");
+  }
+
+  /**
+   * You can also modify the body of this method to customize your error messages.
+   * For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
+   * of end-users concern, so you can return something like :
+   *
+   *     "Internal Error : Please file a bug report .... "
+   *
+   * from this method for such cases in the release version of your parser.
+   */
+  public String getMessage() {
+    return super.getMessage();
+  }
+
+  /*
+   * Constructors of various flavors follow.
+   */
+
+  /** No arg constructor. */
+  public TokenMgrError() {
+  }
+
+  /** Constructor with message and reason. */
+  public TokenMgrError(String message, int reason) {
+    super(message);
+    errorCode = reason;
+  }
+
+  /** Full Constructor. */
+  public TokenMgrError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar, int reason) {
+    this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason);
+  }
+}
+/* JavaCC - OriginalChecksum=4e9300b90fece49edb6b2b7a3e63ba36 (do not edit this line) */
diff -U 3 -dHrN -- vdt-veditor/_generated/com/elphel/vdt/veditor/parser/verilog/VerilogParserCoreConstants.java vdt/_generated/com/elphel/vdt/veditor/parser/verilog/VerilogParserCoreConstants.java
--- vdt-veditor/_generated/com/elphel/vdt/veditor/parser/verilog/VerilogParserCoreConstants.java	2016-06-24 10:29:40.832496184 -0600
+++ vdt/_generated/com/elphel/vdt/veditor/parser/verilog/VerilogParserCoreConstants.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,140 +1,411 @@
-/* Generated By:JavaCC: Do not edit this line. VerilogParserCoreConstants.java */
-package net.sourceforge.veditor.parser;
-
-public interface VerilogParserCoreConstants {
-
-  int EOF = 0;
-  int MULTI_LINE_COMMENT = 2;
-  int ENDIF = 4;
-  int SINGLE_LINE_COMMENT = 11;
-  int DELSE = 12;
-  int DIRECTIVE = 13;
-  int MODULE = 14;
-  int ENDMODULE = 15;
-  int BEGIN = 16;
-  int END = 17;
-  int FORK = 18;
-  int JOIN = 19;
-  int SPECIFY = 20;
-  int ENDSPECIFY = 21;
-  int IF = 22;
-  int ELSE = 23;
-  int WHILE = 24;
-  int FOR = 25;
-  int FOREVER = 26;
-  int REPEAT = 27;
-  int CASE = 28;
-  int CASEX = 29;
-  int ENDCASE = 30;
-  int FUNCTION = 31;
-  int ENDFUNCTION = 32;
-  int TASK = 33;
-  int ENDTASK = 34;
-  int GENERATE = 35;
-  int ENDGENERATE = 36;
-  int INPUT = 37;
-  int OUTPUT = 38;
-  int INOUT = 39;
-  int INTEGER = 40;
-  int WIRE = 41;
-  int REG = 42;
-  int EVENT = 43;
-  int GENVAR = 44;
-  int REAL = 45;
-  int PARAMETER = 46;
-  int SIGNED = 47;
-  int STMT_HEAD = 48;
-  int BLOCK_HEAD = 49;
-  int LPAREN = 50;
-  int RPAREN = 51;
-  int LBRACE = 52;
-  int RBRACE = 53;
-  int LBRACKET = 54;
-  int RBRACKET = 55;
-  int EOS = 56;
-  int PARA = 57;
-  int AT = 58;
-  int BQ = 59;
-  int DOLLAR = 60;
-  int COMMA = 61;
-  int COLON = 62;
-  int EQUAL = 63;
-  int IDENT = 64;
-  int SPC_CHAR = 65;
-  int OTHER = 66;
-
-  int DEFAULT = 0;
-  int IN_MULTI_LINE_COMMENT = 1;
-  int IN_ELSE_BLOCK = 2;
-
-  String[] tokenImage = {
-    "<EOF>",
-    "\"/*\"",
-    "\"*/\"",
-    "<token of kind 3>",
-    "\"`endif\"",
-    "<token of kind 5>",
-    "\" \"",
-    "\"\\t\"",
-    "\"\\r\"",
-    "\"\\n\"",
-    "\"\\f\"",
-    "<SINGLE_LINE_COMMENT>",
-    "\"\\n`else\"",
-    "<DIRECTIVE>",
-    "\"module\"",
-    "\"endmodule\"",
-    "\"begin\"",
-    "\"end\"",
-    "\"fork\"",
-    "\"join\"",
-    "\"specify\"",
-    "\"endspecify\"",
-    "\"if\"",
-    "\"else\"",
-    "\"while\"",
-    "\"for\"",
-    "\"forever\"",
-    "\"repeat\"",
-    "\"case\"",
-    "\"casex\"",
-    "\"endcase\"",
-    "\"function\"",
-    "\"endfunction\"",
-    "\"task\"",
-    "\"endtask\"",
-    "\"generate\"",
-    "\"endgenerate\"",
-    "\"input\"",
-    "\"output\"",
-    "\"inout\"",
-    "\"integer\"",
-    "\"wire\"",
-    "\"reg\"",
-    "\"event\"",
-    "\"genvar\"",
-    "\"real\"",
-    "\"parameter\"",
-    "\"signed\"",
-    "<STMT_HEAD>",
-    "<BLOCK_HEAD>",
-    "\"(\"",
-    "\")\"",
-    "\"{\"",
-    "\"}\"",
-    "\"[\"",
-    "\"]\"",
-    "\";\"",
-    "\"#\"",
-    "\"@\"",
-    "\"`\"",
-    "\"$\"",
-    "\",\"",
-    "\":\"",
-    "\"=\"",
-    "<IDENT>",
-    "<SPC_CHAR>",
-    "\"[.]\"",
-  };
-
-}
+/* Generated By:JavaCC: Do not edit this line. VerilogParserCoreConstants.java */
+package com.elphel.vdt.veditor.parser.verilog;
+
+
+/**
+ * Token literal values and constants.
+ * Generated by org.javacc.parser.OtherFilesGen#start()
+ */
+public interface VerilogParserCoreConstants {
+
+  /** End of File. */
+  int EOF = 0;
+  /** RegularExpression Id. */
+  int MULTI_LINE_COMMENT = 2;
+  /** RegularExpression Id. */
+  int PROPERTY_COMMENT = 5;
+  /** RegularExpression Id. */
+  int SINGLE_LINE_COMMENT = 12;
+  /** RegularExpression Id. */
+  int MODULE = 13;
+  /** RegularExpression Id. */
+  int ENDMODULE = 14;
+  /** RegularExpression Id. */
+  int PRIMITIVE = 15;
+  /** RegularExpression Id. */
+  int ENDPRIMITIVE = 16;
+  /** RegularExpression Id. */
+  int TABLE = 17;
+  /** RegularExpression Id. */
+  int ENDTABLE = 18;
+  /** RegularExpression Id. */
+  int BEGIN = 19;
+  /** RegularExpression Id. */
+  int END = 20;
+  /** RegularExpression Id. */
+  int FORK = 21;
+  /** RegularExpression Id. */
+  int JOIN = 22;
+  /** RegularExpression Id. */
+  int SPECIFY = 23;
+  /** RegularExpression Id. */
+  int ENDSPECIFY = 24;
+  /** RegularExpression Id. */
+  int IF = 25;
+  /** RegularExpression Id. */
+  int ELSE = 26;
+  /** RegularExpression Id. */
+  int WHILE = 27;
+  /** RegularExpression Id. */
+  int FOR = 28;
+  /** RegularExpression Id. */
+  int FOREVER = 29;
+  /** RegularExpression Id. */
+  int REPEAT = 30;
+  /** RegularExpression Id. */
+  int WAIT = 31;
+  /** RegularExpression Id. */
+  int CASE = 32;
+  /** RegularExpression Id. */
+  int DEFAULT_LABEL = 33;
+  /** RegularExpression Id. */
+  int ENDCASE = 34;
+  /** RegularExpression Id. */
+  int FUNCTION = 35;
+  /** RegularExpression Id. */
+  int ENDFUNCTION = 36;
+  /** RegularExpression Id. */
+  int TASK = 37;
+  /** RegularExpression Id. */
+  int ENDTASK = 38;
+  /** RegularExpression Id. */
+  int GENERATE = 39;
+  /** RegularExpression Id. */
+  int ENDGENERATE = 40;
+  /** RegularExpression Id. */
+  int INPUT = 41;
+  /** RegularExpression Id. */
+  int OUTPUT = 42;
+  /** RegularExpression Id. */
+  int INOUT = 43;
+  /** RegularExpression Id. */
+  int INTEGER = 44;
+  /** RegularExpression Id. */
+  int REG = 45;
+  /** RegularExpression Id. */
+  int WIRE = 46;
+  /** RegularExpression Id. */
+  int EVENT = 47;
+  /** RegularExpression Id. */
+  int GENVAR = 48;
+  /** RegularExpression Id. */
+  int REAL = 49;
+  /** RegularExpression Id. */
+  int PARAMETER = 50;
+  /** RegularExpression Id. */
+  int LOCALPARAM = 51;
+  /** RegularExpression Id. */
+  int SIGNED = 52;
+  /** RegularExpression Id. */
+  int PROPERTY = 53;
+  /** RegularExpression Id. */
+  int ENDPROPERTY = 54;
+  /** RegularExpression Id. */
+  int ASSERT = 55;
+  /** RegularExpression Id. */
+  int ASSIGN = 56;
+  /** RegularExpression Id. */
+  int DEASSIGN = 57;
+  /** RegularExpression Id. */
+  int FORCE = 58;
+  /** RegularExpression Id. */
+  int RELEASE = 59;
+  /** RegularExpression Id. */
+  int TIME = 60;
+  /** RegularExpression Id. */
+  int REALTIME = 61;
+  /** RegularExpression Id. */
+  int DEFPARAM = 62;
+  /** RegularExpression Id. */
+  int OR = 63;
+  /** RegularExpression Id. */
+  int DISABLE = 64;
+  /** RegularExpression Id. */
+  int ALWAYS = 65;
+  /** RegularExpression Id. */
+  int INITIAL = 66;
+  /** RegularExpression Id. */
+  int EDGE = 67;
+  /** RegularExpression Id. */
+  int SUPPLY = 68;
+  /** RegularExpression Id. */
+  int NET_TYPE = 69;
+  /** RegularExpression Id. */
+  int STRENGTH = 70;
+  /** RegularExpression Id. */
+  int PRIM_1IN_XOUT = 71;
+  /** RegularExpression Id. */
+  int PRIM_1OUT_XIN = 72;
+  /** RegularExpression Id. */
+  int PRIM_1OUT_1IN_1CNTL = 73;
+  /** RegularExpression Id. */
+  int PRIM_1OUT = 74;
+  /** RegularExpression Id. */
+  int PRIM_1OUT_1IN_NC_PC = 75;
+  /** RegularExpression Id. */
+  int PRIM_BI = 76;
+  /** RegularExpression Id. */
+  int LPAREN = 77;
+  /** RegularExpression Id. */
+  int RPAREN = 78;
+  /** RegularExpression Id. */
+  int LBRACE = 79;
+  /** RegularExpression Id. */
+  int RBRACE = 80;
+  /** RegularExpression Id. */
+  int LBRACKET = 81;
+  /** RegularExpression Id. */
+  int RBRACKET = 82;
+  /** RegularExpression Id. */
+  int EOS = 83;
+  /** RegularExpression Id. */
+  int PARA = 84;
+  /** RegularExpression Id. */
+  int AT = 85;
+  /** RegularExpression Id. */
+  int DOLLAR = 86;
+  /** RegularExpression Id. */
+  int COMMA = 87;
+  /** RegularExpression Id. */
+  int DOT = 88;
+  /** RegularExpression Id. */
+  int AGN = 89;
+  /** RegularExpression Id. */
+  int GT = 90;
+  /** RegularExpression Id. */
+  int LT = 91;
+  /** RegularExpression Id. */
+  int BANG = 92;
+  /** RegularExpression Id. */
+  int TILDE = 93;
+  /** RegularExpression Id. */
+  int HOOK = 94;
+  /** RegularExpression Id. */
+  int COLON = 95;
+  /** RegularExpression Id. */
+  int PCOLON = 96;
+  /** RegularExpression Id. */
+  int MCOLON = 97;
+  /** RegularExpression Id. */
+  int EQ = 98;
+  /** RegularExpression Id. */
+  int LE = 99;
+  /** RegularExpression Id. */
+  int GE = 100;
+  /** RegularExpression Id. */
+  int NE = 101;
+  /** RegularExpression Id. */
+  int SC_OR = 102;
+  /** RegularExpression Id. */
+  int SC_AND = 103;
+  /** RegularExpression Id. */
+  int PLUS = 104;
+  /** RegularExpression Id. */
+  int MINUS = 105;
+  /** RegularExpression Id. */
+  int STAR = 106;
+  /** RegularExpression Id. */
+  int SLASH = 107;
+  /** RegularExpression Id. */
+  int BIT_AND = 108;
+  /** RegularExpression Id. */
+  int BIT_OR = 109;
+  /** RegularExpression Id. */
+  int XOR = 110;
+  /** RegularExpression Id. */
+  int REM = 111;
+  /** RegularExpression Id. */
+  int LSHIFT = 112;
+  /** RegularExpression Id. */
+  int RSHIFT = 113;
+  /** RegularExpression Id. */
+  int NEG_AND = 114;
+  /** RegularExpression Id. */
+  int NEG_OR = 115;
+  /** RegularExpression Id. */
+  int NEG_XOR = 116;
+  /** RegularExpression Id. */
+  int XOR_NEG = 117;
+  /** RegularExpression Id. */
+  int EQ_C = 118;
+  /** RegularExpression Id. */
+  int NE_C = 119;
+  /** RegularExpression Id. */
+  int POWER = 120;
+  /** RegularExpression Id. */
+  int ALSHIFT = 121;
+  /** RegularExpression Id. */
+  int ARSHIFT = 122;
+  /** RegularExpression Id. */
+  int IDENT = 123;
+  /** RegularExpression Id. */
+  int SYSTEM_IDENT = 124;
+  /** RegularExpression Id. */
+  int LETTER = 125;
+  /** RegularExpression Id. */
+  int BACKSLASH = 126;
+  /** RegularExpression Id. */
+  int INTEGER_LITERAL = 127;
+  /** RegularExpression Id. */
+  int NUMBER_LITERAL = 128;
+  /** RegularExpression Id. */
+  int DECIMAL_LITERAL = 129;
+  /** RegularExpression Id. */
+  int HEX_LITERAL = 130;
+  /** RegularExpression Id. */
+  int OCTAL_LITERAL = 131;
+  /** RegularExpression Id. */
+  int BINARY_LITERAL = 132;
+  /** RegularExpression Id. */
+  int REAL_LITERAL = 133;
+  /** RegularExpression Id. */
+  int STRING_LITERAL = 134;
+
+  /** Lexical state. */
+  int DEFAULT = 0;
+  /** Lexical state. */
+  int IN_MULTI_LINE_COMMENT = 1;
+  /** Lexical state. */
+  int IN_PROPERTY = 2;
+
+  /** Literal token values. */
+  String[] tokenImage = {
+    "<EOF>",
+    "\"/*\"",
+    "\"*/\"",
+    "<token of kind 3>",
+    "<token of kind 4>",
+    "\"*)\"",
+    "<token of kind 6>",
+    "\" \"",
+    "\"\\t\"",
+    "\"\\r\"",
+    "\"\\n\"",
+    "\"\\f\"",
+    "<SINGLE_LINE_COMMENT>",
+    "\"module\"",
+    "\"endmodule\"",
+    "\"primitive\"",
+    "\"endprimitive\"",
+    "\"table\"",
+    "\"endtable\"",
+    "\"begin\"",
+    "\"end\"",
+    "\"fork\"",
+    "\"join\"",
+    "\"specify\"",
+    "\"endspecify\"",
+    "\"if\"",
+    "\"else\"",
+    "\"while\"",
+    "\"for\"",
+    "\"forever\"",
+    "\"repeat\"",
+    "\"wait\"",
+    "<CASE>",
+    "\"default\"",
+    "\"endcase\"",
+    "\"function\"",
+    "\"endfunction\"",
+    "\"task\"",
+    "\"endtask\"",
+    "\"generate\"",
+    "\"endgenerate\"",
+    "\"input\"",
+    "\"output\"",
+    "\"inout\"",
+    "\"integer\"",
+    "\"reg\"",
+    "\"wire\"",
+    "\"event\"",
+    "\"genvar\"",
+    "\"real\"",
+    "\"parameter\"",
+    "\"localparam\"",
+    "\"signed\"",
+    "\"property\"",
+    "\"endproperty\"",
+    "<ASSERT>",
+    "\"assign\"",
+    "\"deassign\"",
+    "\"force\"",
+    "\"release\"",
+    "\"time\"",
+    "\"realtime\"",
+    "\"defparam\"",
+    "\"or\"",
+    "\"disable\"",
+    "\"always\"",
+    "\"initial\"",
+    "<EDGE>",
+    "<SUPPLY>",
+    "<NET_TYPE>",
+    "<STRENGTH>",
+    "<PRIM_1IN_XOUT>",
+    "<PRIM_1OUT_XIN>",
+    "<PRIM_1OUT_1IN_1CNTL>",
+    "<PRIM_1OUT>",
+    "<PRIM_1OUT_1IN_NC_PC>",
+    "<PRIM_BI>",
+    "\"(\"",
+    "\")\"",
+    "\"{\"",
+    "\"}\"",
+    "\"[\"",
+    "\"]\"",
+    "\";\"",
+    "\"#\"",
+    "\"@\"",
+    "\"$\"",
+    "\",\"",
+    "\".\"",
+    "\"=\"",
+    "\">\"",
+    "\"<\"",
+    "\"!\"",
+    "\"~\"",
+    "\"?\"",
+    "\":\"",
+    "\"+:\"",
+    "\"-:\"",
+    "\"==\"",
+    "\"<=\"",
+    "\">=\"",
+    "\"!=\"",
+    "\"||\"",
+    "\"&&\"",
+    "\"+\"",
+    "\"-\"",
+    "\"*\"",
+    "\"/\"",
+    "\"&\"",
+    "\"|\"",
+    "\"^\"",
+    "\"%\"",
+    "\"<<\"",
+    "\">>\"",
+    "\"~&\"",
+    "\"~|\"",
+    "\"~^\"",
+    "\"^~\"",
+    "\"===\"",
+    "\"!==\"",
+    "\"**\"",
+    "\"<<<\"",
+    "\">>>\"",
+    "<IDENT>",
+    "<SYSTEM_IDENT>",
+    "<LETTER>",
+    "\"\\\\\"",
+    "<INTEGER_LITERAL>",
+    "<NUMBER_LITERAL>",
+    "<DECIMAL_LITERAL>",
+    "<HEX_LITERAL>",
+    "<OCTAL_LITERAL>",
+    "<BINARY_LITERAL>",
+    "<REAL_LITERAL>",
+    "<STRING_LITERAL>",
+    "\"->\"",
+  };
+
+}
diff -U 3 -dHrN -- vdt-veditor/_generated/com/elphel/vdt/veditor/parser/verilog/VerilogParserCore.java vdt/_generated/com/elphel/vdt/veditor/parser/verilog/VerilogParserCore.java
--- vdt-veditor/_generated/com/elphel/vdt/veditor/parser/verilog/VerilogParserCore.java	2016-06-24 10:29:40.832496184 -0600
+++ vdt/_generated/com/elphel/vdt/veditor/parser/verilog/VerilogParserCore.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,1237 +1,5359 @@
-/* Generated By:JavaCC: Do not edit this line. VerilogParserCore.java */
-package net.sourceforge.veditor.parser;
-
-public abstract class VerilogParserCore implements VerilogParserCoreConstants {
-        protected abstract void addModule(int begin, String name);
-        protected abstract void endModule(int line);
-        protected abstract void addPort(int line, String portName);
-        protected abstract void addVariable(int line, String varName);
-        protected abstract void addParameter(int line, String name, String value);
-        protected abstract void addElement(int begin, int end, String type, String name);
-        protected abstract void addInstance(int begin, int end, String module, String inst);
-        protected abstract void beginStatement();
-        protected abstract void endStatement();
-        protected abstract void setPrefix(String fix);
-        protected abstract void addPrefix(String fix);
-
-        public void parse() throws ParseException
-        {
-                modules();
-        }
-
-  final public void modules() throws ParseException {
-        Token name ;
-        Token end ;
-    label_1:
-    while (true) {
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case MODULE:
-        ;
-        break;
-      default:
-        jj_la1[0] = jj_gen;
-        break label_1;
-      }
-      jj_consume_token(MODULE);
-      name = identifier();
-                        addModule( name.beginLine, name.image );
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case LPAREN:
-        jj_consume_token(LPAREN);
-        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-        case INPUT:
-        case OUTPUT:
-        case INOUT:
-        case BQ:
-        case IDENT:
-          argument();
-          label_2:
-          while (true) {
-            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-            case COMMA:
-              ;
-              break;
-            default:
-              jj_la1[1] = jj_gen;
-              break label_2;
-            }
-            jj_consume_token(COMMA);
-            argument();
-          }
-          break;
-        default:
-          jj_la1[2] = jj_gen;
-          ;
-        }
-        jj_consume_token(RPAREN);
-        break;
-      default:
-        jj_la1[3] = jj_gen;
-        ;
-      }
-      jj_consume_token(EOS);
-      label_3:
-      while (true) {
-        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-        case SPECIFY:
-        case FUNCTION:
-        case TASK:
-        case GENERATE:
-        case INPUT:
-        case OUTPUT:
-        case INOUT:
-        case INTEGER:
-        case WIRE:
-        case REG:
-        case EVENT:
-        case GENVAR:
-        case REAL:
-        case PARAMETER:
-        case SIGNED:
-        case STMT_HEAD:
-        case BLOCK_HEAD:
-        case BQ:
-        case IDENT:
-          ;
-          break;
-        default:
-          jj_la1[4] = jj_gen;
-          break label_3;
-        }
-        moduleBody();
-      }
-      end = jj_consume_token(ENDMODULE);
-                        endModule( end.beginLine );
-    }
-  }
-
-  final public void argument() throws ParseException {
-        Token ident;
-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case INPUT:
-    case OUTPUT:
-    case INOUT:
-      portHead();
-      ident = identifier();
-                        addPort( ident.beginLine, ident.image );
-      break;
-    case BQ:
-    case IDENT:
-      identifier();
-      break;
-    default:
-      jj_la1[5] = jj_gen;
-      jj_consume_token(-1);
-      throw new ParseException();
-    }
-  }
-
-  final public void portHead() throws ParseException {
-        String mod, var;
-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case INPUT:
-      jj_consume_token(INPUT);
-      break;
-    case OUTPUT:
-      jj_consume_token(OUTPUT);
-      break;
-    case INOUT:
-      jj_consume_token(INOUT);
-      break;
-    default:
-      jj_la1[6] = jj_gen;
-      jj_consume_token(-1);
-      throw new ParseException();
-    }
-                setPrefix(token.image);
-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case INTEGER:
-    case WIRE:
-    case REG:
-    case EVENT:
-    case GENVAR:
-    case REAL:
-    case SIGNED:
-      var = variableModifier();
-                                     addPrefix(" " + var);
-      break;
-    default:
-      jj_la1[7] = jj_gen;
-      ;
-    }
-    bitRange();
-  }
-
-  final public void moduleBody() throws ParseException {
-        Token   module, inst, iend ;
-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case INPUT:
-    case OUTPUT:
-    case INOUT:
-      portHead();
-                            beginStatement();
-      port();
-                                                       endStatement();
-      break;
-    case PARAMETER:
-      jj_consume_token(PARAMETER);
-                             beginStatement();
-      parameter();
-                                                             endStatement();
-      break;
-    case INTEGER:
-    case WIRE:
-    case REG:
-    case EVENT:
-    case GENVAR:
-    case REAL:
-    case SIGNED:
-      variableHead();
-                                beginStatement();
-      variable();
-                                                               endStatement();
-      break;
-    case STMT_HEAD:
-      jj_consume_token(STMT_HEAD);
-                             beginStatement();
-      skipTo(EOS);
-                                                               endStatement();
-      break;
-    case BLOCK_HEAD:
-      jj_consume_token(BLOCK_HEAD);
-                              beginStatement();
-      statement();
-                                                              endStatement();
-      break;
-    case SPECIFY:
-      jj_consume_token(SPECIFY);
-                           beginStatement();
-      skipTo(ENDSPECIFY);
-                                                                    endStatement();
-      break;
-    case FUNCTION:
-      jj_consume_token(FUNCTION);
-                            beginStatement();
-      function();
-                                                           endStatement();
-      break;
-    case TASK:
-      jj_consume_token(TASK);
-                        beginStatement();
-      task();
-                                                   endStatement();
-      break;
-    case GENERATE:
-      generate();
-      break;
-    case BQ:
-    case IDENT:
-      module = identifier();
-                  beginStatement();
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case PARA:
-        jj_consume_token(PARA);
-        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-        case BQ:
-        case IDENT:
-          identifier();
-          break;
-        case LPAREN:
-          jj_consume_token(LPAREN);
-          skipParen();
-          jj_consume_token(RPAREN);
-          break;
-        default:
-          jj_la1[8] = jj_gen;
-          jj_consume_token(-1);
-          throw new ParseException();
-        }
-        break;
-      default:
-        jj_la1[9] = jj_gen;
-        ;
-      }
-      inst = identifier();
-      jj_consume_token(LPAREN);
-      skipParen();
-      jj_consume_token(RPAREN);
-      iend = jj_consume_token(EOS);
-                        addInstance( module.beginLine, iend.endLine, module.image, inst.image );
-                        endStatement();
-      break;
-    default:
-      jj_la1[10] = jj_gen;
-      jj_consume_token(-1);
-      throw new ParseException();
-    }
-  }
-
-  final public void variableHead() throws ParseException {
-        String mod;
-    mod = variableModifier();
-                setPrefix(mod);
-    bitRange();
-  }
-
-  final public String variableModifier() throws ParseException {
-        String value = null;
-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case REAL:
-      jj_consume_token(REAL);
-      break;
-    case INTEGER:
-      jj_consume_token(INTEGER);
-      break;
-    case EVENT:
-      jj_consume_token(EVENT);
-      break;
-    case GENVAR:
-      jj_consume_token(GENVAR);
-      break;
-    case SIGNED:
-      jj_consume_token(SIGNED);
-      break;
-    case WIRE:
-      jj_consume_token(WIRE);
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case SIGNED:
-        jj_consume_token(SIGNED);
-                                            value = "wire signed";
-        break;
-      default:
-        jj_la1[11] = jj_gen;
-        ;
-      }
-      break;
-    case REG:
-      jj_consume_token(REG);
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case SIGNED:
-        jj_consume_token(SIGNED);
-                                            value = "reg signed";
-        break;
-      default:
-        jj_la1[12] = jj_gen;
-        ;
-      }
-      break;
-    default:
-      jj_la1[13] = jj_gen;
-      jj_consume_token(-1);
-      throw new ParseException();
-    }
-                if (value == null)
-                        {if (true) return token.image;}
-                else
-                        {if (true) return value;}
-    throw new Error("Missing return statement in function");
-  }
-
-  final public void bitRange() throws ParseException {
-        Token msb, lsb;
-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case LBRACKET:
-      jj_consume_token(LBRACKET);
-      msb = skipTo(COLON);
-      lsb = skipTo(RBRACKET);
-                        addPrefix("[" + msb.image + ":" + lsb.image + "]");
-      break;
-    default:
-      jj_la1[14] = jj_gen;
-      ;
-    }
-                addPrefix(" ");
-  }
-
-  final public Token identifier() throws ParseException {
-        Token token ;
-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case BQ:
-      jj_consume_token(BQ);
-      break;
-    default:
-      jj_la1[15] = jj_gen;
-      ;
-    }
-    token = jj_consume_token(IDENT);
-                {if (true) return token ;}
-    throw new Error("Missing return statement in function");
-  }
-
-  final public void port() throws ParseException {
-        Token port ;
-    port = identifier();
-                addPort( port.beginLine, port.image );
-    label_4:
-    while (true) {
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case COMMA:
-        ;
-        break;
-      default:
-        jj_la1[16] = jj_gen;
-        break label_4;
-      }
-      jj_consume_token(COMMA);
-      port = identifier();
-                        addPort( port.beginLine, port.image );
-    }
-    jj_consume_token(EOS);
-  }
-
-  final public void variable() throws ParseException {
-        Token variable ;
-    variable = identifier();
-    label_5:
-    while (true) {
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case LBRACKET:
-        ;
-        break;
-      default:
-        jj_la1[17] = jj_gen;
-        break label_5;
-      }
-      jj_consume_token(LBRACKET);
-      skipTo(RBRACKET);
-    }
-                addVariable( variable.beginLine, variable.image );
-    label_6:
-    while (true) {
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case COMMA:
-        ;
-        break;
-      default:
-        jj_la1[18] = jj_gen;
-        break label_6;
-      }
-      jj_consume_token(COMMA);
-      variable = identifier();
-      label_7:
-      while (true) {
-        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-        case LBRACKET:
-          ;
-          break;
-        default:
-          jj_la1[19] = jj_gen;
-          break label_7;
-        }
-        jj_consume_token(LBRACKET);
-        skipTo(RBRACKET);
-      }
-                        addVariable( variable.beginLine, variable.image );
-    }
-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case EOS:
-      jj_consume_token(EOS);
-      break;
-    case EQUAL:
-      jj_consume_token(EQUAL);
-      skipTo(EOS);
-      break;
-    default:
-      jj_la1[20] = jj_gen;
-      jj_consume_token(-1);
-      throw new ParseException();
-    }
-  }
-
-  final public void parameter() throws ParseException {
-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case INTEGER:
-    case REAL:
-    case LBRACKET:
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case REAL:
-        jj_consume_token(REAL);
-        break;
-      case INTEGER:
-        jj_consume_token(INTEGER);
-        break;
-      case LBRACKET:
-        jj_consume_token(LBRACKET);
-        skipTo(RBRACKET);
-        break;
-      default:
-        jj_la1[21] = jj_gen;
-        jj_consume_token(-1);
-        throw new ParseException();
-      }
-      break;
-    default:
-      jj_la1[22] = jj_gen;
-      ;
-    }
-    parameterAssign();
-    label_8:
-    while (true) {
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case COMMA:
-        ;
-        break;
-      default:
-        jj_la1[23] = jj_gen;
-        break label_8;
-      }
-      jj_consume_token(COMMA);
-      parameterAssign();
-    }
-    jj_consume_token(EOS);
-  }
-
-  final public void parameterAssign() throws ParseException {
-        Token parameter;
-        Token value;
-    parameter = identifier();
-    jj_consume_token(EQUAL);
-    value = skipToOr(COMMA, EOS);
-                addParameter(parameter.beginLine, parameter.image, value.image);
-  }
-
-  final public void delay() throws ParseException {
-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case AT:
-      jj_consume_token(AT);
-      break;
-    case PARA:
-      jj_consume_token(PARA);
-      break;
-    default:
-      jj_la1[24] = jj_gen;
-      jj_consume_token(-1);
-      throw new ParseException();
-    }
-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case LPAREN:
-      jj_consume_token(LPAREN);
-      skipParen();
-      jj_consume_token(RPAREN);
-      break;
-    case BQ:
-    case IDENT:
-      identifier();
-      break;
-    default:
-      jj_la1[25] = jj_gen;
-      jj_consume_token(-1);
-      throw new ParseException();
-    }
-  }
-
-  final public void statement() throws ParseException {
-    label_9:
-    while (true) {
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case PARA:
-      case AT:
-        ;
-        break;
-      default:
-        jj_la1[26] = jj_gen;
-        break label_9;
-      }
-      delay();
-    }
-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case EOS:
-      jj_consume_token(EOS);
-      break;
-    case COLON:
-      jj_consume_token(COLON);
-      identifier();
-      break;
-    case STMT_HEAD:
-      jj_consume_token(STMT_HEAD);
-      skipTo(EOS);
-      break;
-    case IF:
-      ifStatement();
-      break;
-    case BEGIN:
-    case FORK:
-      block();
-      break;
-    case DOLLAR:
-      jj_consume_token(DOLLAR);
-      skipTo(EOS);
-      break;
-    case LBRACE:
-      jj_consume_token(LBRACE);
-      skipTo(EOS);
-      break;
-    case BQ:
-    case IDENT:
-      identifier();
-      skipTo(EOS);
-      break;
-    case CASE:
-    case CASEX:
-      caseStatement();
-      break;
-    case WHILE:
-      whileStatement();
-      break;
-    case FOR:
-      forStatement();
-      break;
-    case FOREVER:
-      foreverStatement();
-      break;
-    case REPEAT:
-      repeatStatement();
-      break;
-    default:
-      jj_la1[27] = jj_gen;
-      jj_consume_token(-1);
-      throw new ParseException();
-    }
-  }
-
-  final public void block() throws ParseException {
-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case BEGIN:
-      jj_consume_token(BEGIN);
-      break;
-    case FORK:
-      jj_consume_token(FORK);
-      break;
-    default:
-      jj_la1[28] = jj_gen;
-      jj_consume_token(-1);
-      throw new ParseException();
-    }
-    label_10:
-    while (true) {
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case BEGIN:
-      case FORK:
-      case IF:
-      case WHILE:
-      case FOR:
-      case FOREVER:
-      case REPEAT:
-      case CASE:
-      case CASEX:
-      case STMT_HEAD:
-      case LBRACE:
-      case EOS:
-      case PARA:
-      case AT:
-      case BQ:
-      case DOLLAR:
-      case COLON:
-      case IDENT:
-        ;
-        break;
-      default:
-        jj_la1[29] = jj_gen;
-        break label_10;
-      }
-      statement();
-    }
-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case END:
-      jj_consume_token(END);
-      break;
-    case JOIN:
-      jj_consume_token(JOIN);
-      break;
-    default:
-      jj_la1[30] = jj_gen;
-      jj_consume_token(-1);
-      throw new ParseException();
-    }
-  }
-
-  final public void function() throws ParseException {
-        Token name, end ;
-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case LBRACKET:
-      jj_consume_token(LBRACKET);
-      skipParen();
-      jj_consume_token(RBRACKET);
-      break;
-    default:
-      jj_la1[31] = jj_gen;
-      ;
-    }
-    name = identifier();
-    end = skipTo(ENDFUNCTION);
-                addElement( name.beginLine, end.endLine, "function", name.image );
-  }
-
-  final public void task() throws ParseException {
-        Token name, end ;
-    name = identifier();
-    end = skipTo(ENDTASK);
-                addElement( name.beginLine, end.endLine, "task", name.image );
-  }
-
-  final public void generate() throws ParseException {
-    jj_consume_token(GENERATE);
-    label_11:
-    while (true) {
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case SPECIFY:
-      case IF:
-      case FOR:
-      case FUNCTION:
-      case TASK:
-      case GENERATE:
-      case INPUT:
-      case OUTPUT:
-      case INOUT:
-      case INTEGER:
-      case WIRE:
-      case REG:
-      case EVENT:
-      case GENVAR:
-      case REAL:
-      case PARAMETER:
-      case SIGNED:
-      case STMT_HEAD:
-      case BLOCK_HEAD:
-      case BQ:
-      case IDENT:
-        ;
-        break;
-      default:
-        jj_la1[32] = jj_gen;
-        break label_11;
-      }
-      generateStatement();
-    }
-    jj_consume_token(ENDGENERATE);
-  }
-
-  final public void generateStatement() throws ParseException {
-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case FOR:
-      generateForStatement();
-      break;
-    case IF:
-      generateIfStatement();
-      break;
-    case SPECIFY:
-    case FUNCTION:
-    case TASK:
-    case GENERATE:
-    case INPUT:
-    case OUTPUT:
-    case INOUT:
-    case INTEGER:
-    case WIRE:
-    case REG:
-    case EVENT:
-    case GENVAR:
-    case REAL:
-    case PARAMETER:
-    case SIGNED:
-    case STMT_HEAD:
-    case BLOCK_HEAD:
-    case BQ:
-    case IDENT:
-      moduleBody();
-      break;
-    default:
-      jj_la1[33] = jj_gen;
-      jj_consume_token(-1);
-      throw new ParseException();
-    }
-  }
-
-  final public void ifStatement() throws ParseException {
-    jj_consume_token(IF);
-    jj_consume_token(LPAREN);
-    skipParen();
-    jj_consume_token(RPAREN);
-    statement();
-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case ELSE:
-      jj_consume_token(ELSE);
-      statement();
-      break;
-    default:
-      jj_la1[34] = jj_gen;
-      ;
-    }
-  }
-
-  final public void caseStatement() throws ParseException {
-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case CASE:
-      jj_consume_token(CASE);
-      break;
-    case CASEX:
-      jj_consume_token(CASEX);
-      break;
-    default:
-      jj_la1[35] = jj_gen;
-      jj_consume_token(-1);
-      throw new ParseException();
-    }
-    jj_consume_token(LPAREN);
-    skipParen();
-    jj_consume_token(RPAREN);
-    label_12:
-    while (true) {
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case BQ:
-      case IDENT:
-        ;
-        break;
-      default:
-        jj_la1[36] = jj_gen;
-        break label_12;
-      }
-      identifier();
-      label_13:
-      while (true) {
-        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-        case COMMA:
-          ;
-          break;
-        default:
-          jj_la1[37] = jj_gen;
-          break label_13;
-        }
-        jj_consume_token(COMMA);
-        identifier();
-      }
-      jj_consume_token(COLON);
-      statement();
-    }
-    jj_consume_token(ENDCASE);
-  }
-
-  final public void whileStatement() throws ParseException {
-    jj_consume_token(WHILE);
-    jj_consume_token(LPAREN);
-    skipParen();
-    jj_consume_token(RPAREN);
-    statement();
-  }
-
-  final public void forStatement() throws ParseException {
-    jj_consume_token(FOR);
-    jj_consume_token(LPAREN);
-    skipParen();
-    jj_consume_token(RPAREN);
-    statement();
-  }
-
-  final public void foreverStatement() throws ParseException {
-    jj_consume_token(FOREVER);
-    statement();
-  }
-
-  final public void repeatStatement() throws ParseException {
-    jj_consume_token(REPEAT);
-    jj_consume_token(LPAREN);
-    skipParen();
-    jj_consume_token(RPAREN);
-    statement();
-  }
-
-  final public void generateForStatement() throws ParseException {
-    jj_consume_token(FOR);
-    jj_consume_token(LPAREN);
-    skipParen();
-    jj_consume_token(RPAREN);
-    jj_consume_token(BEGIN);
-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case COLON:
-      jj_consume_token(COLON);
-      identifier();
-      break;
-    default:
-      jj_la1[38] = jj_gen;
-      ;
-    }
-    label_14:
-    while (true) {
-      generateStatement();
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case SPECIFY:
-      case IF:
-      case FOR:
-      case FUNCTION:
-      case TASK:
-      case GENERATE:
-      case INPUT:
-      case OUTPUT:
-      case INOUT:
-      case INTEGER:
-      case WIRE:
-      case REG:
-      case EVENT:
-      case GENVAR:
-      case REAL:
-      case PARAMETER:
-      case SIGNED:
-      case STMT_HEAD:
-      case BLOCK_HEAD:
-      case BQ:
-      case IDENT:
-        ;
-        break;
-      default:
-        jj_la1[39] = jj_gen;
-        break label_14;
-      }
-    }
-    jj_consume_token(END);
-  }
-
-  final public void generateIfStatement() throws ParseException {
-    jj_consume_token(IF);
-    jj_consume_token(LPAREN);
-    skipParen();
-    jj_consume_token(RPAREN);
-    jj_consume_token(BEGIN);
-    label_15:
-    while (true) {
-      generateStatement();
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case SPECIFY:
-      case IF:
-      case FOR:
-      case FUNCTION:
-      case TASK:
-      case GENERATE:
-      case INPUT:
-      case OUTPUT:
-      case INOUT:
-      case INTEGER:
-      case WIRE:
-      case REG:
-      case EVENT:
-      case GENVAR:
-      case REAL:
-      case PARAMETER:
-      case SIGNED:
-      case STMT_HEAD:
-      case BLOCK_HEAD:
-      case BQ:
-      case IDENT:
-        ;
-        break;
-      default:
-        jj_la1[40] = jj_gen;
-        break label_15;
-      }
-    }
-    jj_consume_token(END);
-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case ELSE:
-      jj_consume_token(ELSE);
-      jj_consume_token(BEGIN);
-      label_16:
-      while (true) {
-        generateStatement();
-        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-        case SPECIFY:
-        case IF:
-        case FOR:
-        case FUNCTION:
-        case TASK:
-        case GENERATE:
-        case INPUT:
-        case OUTPUT:
-        case INOUT:
-        case INTEGER:
-        case WIRE:
-        case REG:
-        case EVENT:
-        case GENVAR:
-        case REAL:
-        case PARAMETER:
-        case SIGNED:
-        case STMT_HEAD:
-        case BLOCK_HEAD:
-        case BQ:
-        case IDENT:
-          ;
-          break;
-        default:
-          jj_la1[41] = jj_gen;
-          break label_16;
-        }
-      }
-      jj_consume_token(END);
-      break;
-    default:
-      jj_la1[42] = jj_gen;
-      ;
-    }
-  }
-
-  void unexpectedEof(Token token) throws ParseException {
-        ParseException ex = new ParseException("unexpected EOF");
-        ex.currentToken = token;
-        throw ex;
-  }
-
-  Token skipTo(int skip) throws ParseException {
-        Token current = token;
-        Token token ;
-        StringBuffer image = new StringBuffer();
-
-        for(;;)
-        {
-                token = getToken(1);
-                if (token.kind == EOF)
-                        unexpectedEof(current);
-                if (token.kind == skip)
-                {
-                        getNextToken();
-                        break ;
-                }
-
-                image.append(token.image);
-                getNextToken();
-        }
-        token.image = image.toString();
-        return token ;
-  }
-
-  Token skipToOr(int skip1, int skip2) throws ParseException {
-        Token current = token;
-        Token token ;
-        StringBuffer image = new StringBuffer();
-
-        for(;;)
-        {
-                token = getToken(1);
-                if (token.kind == EOF)
-                        unexpectedEof(current);
-                if (token.kind == skip1 || token.kind == skip2)
-                {
-                        // preserve skip token
-                        break ;
-                }
-
-                image.append(token.image);
-                getNextToken();
-        }
-        token.image = image.toString();
-        return token ;
-  }
-
-  void skipParen() throws ParseException {
-        Token current = token;
-        Token token;
-        int nesting = 1 ;
-        for(;;)
-        {
-                token = getToken(1);
-                if (token.kind == EOF)
-                        unexpectedEof(current);
-                if (token.kind == LPAREN || token.kind == LBRACKET)
-                        nesting++;
-                if (token.kind == RPAREN || token.kind == RBRACKET)
-                {
-                        nesting--;
-                        if ( nesting == 0 )
-                                break;
-                }
-                getNextToken();
-        }
-  }
-
-  void skipToEndcase() throws ParseException {
-        Token current = token;
-        Token token ;
-        int nesting = 1 ;
-        for(;;)
-        {
-                token = getToken( 1 );
-                if ( token.kind == EOF )
-                        unexpectedEof(current);
-                if ( token.kind == CASE )
-                        nesting++;
-                if ( token.kind == ENDCASE )
-                {
-                        nesting--;
-                        if ( nesting == 0 )
-                        {
-                                getNextToken();
-                                break;
-                        }
-                }
-                getNextToken();
-        }
-  }
-
-  public VerilogParserCoreTokenManager token_source;
-  JavaCharStream jj_input_stream;
-  public Token token, jj_nt;
-  private int jj_ntk;
-  private int jj_gen;
-  final private int[] jj_la1 = new int[43];
-  static private int[] jj_la1_0;
-  static private int[] jj_la1_1;
-  static private int[] jj_la1_2;
-  static {
-      jj_la1_0();
-      jj_la1_1();
-      jj_la1_2();
-   }
-   private static void jj_la1_0() {
-      jj_la1_0 = new int[] {0x4000,0x0,0x0,0x0,0x80100000,0x0,0x0,0x0,0x0,0x0,0x80100000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3f450000,0x50000,0x3f450000,0xa0000,0x0,0x82500000,0x82500000,0x800000,0x30000000,0x0,0x0,0x0,0x82500000,0x82500000,0x82500000,0x800000,};
-   }
-   private static void jj_la1_1() {
-      jj_la1_1 = new int[] {0x0,0x20000000,0x80000e0,0x40000,0x803ffea,0x80000e0,0xe0,0xbf00,0x8040000,0x2000000,0x803ffea,0x8000,0x8000,0xbf00,0x400000,0x8000000,0x20000000,0x400000,0x20000000,0x400000,0x81000000,0x402100,0x402100,0x20000000,0x6000000,0x8040000,0x6000000,0x59110000,0x0,0x5f110000,0x0,0x400000,0x803ffea,0x803ffea,0x0,0x0,0x8000000,0x20000000,0x40000000,0x803ffea,0x803ffea,0x803ffea,0x0,};
-   }
-   private static void jj_la1_2() {
-      jj_la1_2 = new int[] {0x0,0x0,0x1,0x0,0x1,0x1,0x0,0x0,0x1,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x1,0x0,0x1,0x0,0x0,0x1,0x1,0x0,0x0,0x1,0x0,0x0,0x1,0x1,0x1,0x0,};
-   }
-
-  public VerilogParserCore(java.io.InputStream stream) {
-     this(stream, null);
-  }
-  public VerilogParserCore(java.io.InputStream stream, String encoding) {
-    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
-    token_source = new VerilogParserCoreTokenManager(jj_input_stream);
-    token = new Token();
-    jj_ntk = -1;
-    jj_gen = 0;
-    for (int i = 0; i < 43; i++) jj_la1[i] = -1;
-  }
-
-  public void ReInit(java.io.InputStream stream) {
-     ReInit(stream, null);
-  }
-  public void ReInit(java.io.InputStream stream, String encoding) {
-    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
-    token_source.ReInit(jj_input_stream);
-    token = new Token();
-    jj_ntk = -1;
-    jj_gen = 0;
-    for (int i = 0; i < 43; i++) jj_la1[i] = -1;
-  }
-
-  public VerilogParserCore(java.io.Reader stream) {
-    jj_input_stream = new JavaCharStream(stream, 1, 1);
-    token_source = new VerilogParserCoreTokenManager(jj_input_stream);
-    token = new Token();
-    jj_ntk = -1;
-    jj_gen = 0;
-    for (int i = 0; i < 43; i++) jj_la1[i] = -1;
-  }
-
-  public void ReInit(java.io.Reader stream) {
-    jj_input_stream.ReInit(stream, 1, 1);
-    token_source.ReInit(jj_input_stream);
-    token = new Token();
-    jj_ntk = -1;
-    jj_gen = 0;
-    for (int i = 0; i < 43; i++) jj_la1[i] = -1;
-  }
-
-  public VerilogParserCore(VerilogParserCoreTokenManager tm) {
-    token_source = tm;
-    token = new Token();
-    jj_ntk = -1;
-    jj_gen = 0;
-    for (int i = 0; i < 43; i++) jj_la1[i] = -1;
-  }
-
-  public void ReInit(VerilogParserCoreTokenManager tm) {
-    token_source = tm;
-    token = new Token();
-    jj_ntk = -1;
-    jj_gen = 0;
-    for (int i = 0; i < 43; i++) jj_la1[i] = -1;
-  }
-
-  final private Token jj_consume_token(int kind) throws ParseException {
-    Token oldToken;
-    if ((oldToken = token).next != null) token = token.next;
-    else token = token.next = token_source.getNextToken();
-    jj_ntk = -1;
-    if (token.kind == kind) {
-      jj_gen++;
-      return token;
-    }
-    token = oldToken;
-    jj_kind = kind;
-    throw generateParseException();
-  }
-
-  final public Token getNextToken() {
-    if (token.next != null) token = token.next;
-    else token = token.next = token_source.getNextToken();
-    jj_ntk = -1;
-    jj_gen++;
-    return token;
-  }
-
-  final public Token getToken(int index) {
-    Token t = token;
-    for (int i = 0; i < index; i++) {
-      if (t.next != null) t = t.next;
-      else t = t.next = token_source.getNextToken();
-    }
-    return t;
-  }
-
-  final private int jj_ntk() {
-    if ((jj_nt=token.next) == null)
-      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
-    else
-      return (jj_ntk = jj_nt.kind);
-  }
-
-  private java.util.Vector jj_expentries = new java.util.Vector();
-  private int[] jj_expentry;
-  private int jj_kind = -1;
-
-  public ParseException generateParseException() {
-    jj_expentries.removeAllElements();
-    boolean[] la1tokens = new boolean[67];
-    for (int i = 0; i < 67; i++) {
-      la1tokens[i] = false;
-    }
-    if (jj_kind >= 0) {
-      la1tokens[jj_kind] = true;
-      jj_kind = -1;
-    }
-    for (int i = 0; i < 43; i++) {
-      if (jj_la1[i] == jj_gen) {
-        for (int j = 0; j < 32; j++) {
-          if ((jj_la1_0[i] & (1<<j)) != 0) {
-            la1tokens[j] = true;
-          }
-          if ((jj_la1_1[i] & (1<<j)) != 0) {
-            la1tokens[32+j] = true;
-          }
-          if ((jj_la1_2[i] & (1<<j)) != 0) {
-            la1tokens[64+j] = true;
-          }
-        }
-      }
-    }
-    for (int i = 0; i < 67; i++) {
-      if (la1tokens[i]) {
-        jj_expentry = new int[1];
-        jj_expentry[0] = i;
-        jj_expentries.addElement(jj_expentry);
-      }
-    }
-    int[][] exptokseq = new int[jj_expentries.size()][];
-    for (int i = 0; i < jj_expentries.size(); i++) {
-      exptokseq[i] = (int[])jj_expentries.elementAt(i);
-    }
-    return new ParseException(token, exptokseq, tokenImage);
-  }
-
-  final public void enable_tracing() {
-  }
-
-  final public void disable_tracing() {
-  }
-
-}
+/* VerilogParserCore.java */
+/* Generated By:JavaCC: Do not edit this line. VerilogParserCore.java */
+package com.elphel.vdt.veditor.parser.verilog;
+
+public abstract class VerilogParserCore implements VerilogParserCoreConstants {
+        public static final int STATEMENT = 0;
+        public static final int ASSIGN_STMT = 1;
+        public static final int INITIAL_BLOCK = 2;
+        public static final int ALWAYS_BLOCK = 3;
+        protected static enum PORT_TYPE {INSTANCE, PRIMITIVE, TASK, FUNCTION, SYSTEM_TASK, SYSTEM_FUNCTION};
+
+        protected abstract void begin(int mode);
+        protected abstract void end(int mode);
+        protected abstract void beginOutlineElement(Token begin, String name, String type);
+        protected abstract void endOutlineElement(Token end, String name, String type);
+
+        protected void beginOutlineElement(Token begin, String type) {
+                beginOutlineElement(begin, begin.image, type);
+        }
+        protected void endOutlineElement(Token end, String type) {
+                endOutlineElement(end, end.image, type);
+        }
+
+        protected abstract void addCollapsible(int startLine,int endLine);
+        protected abstract Expression operator(Expression arg, Token op);
+        protected abstract Expression operator(Expression arg1, Token op, Expression arg2);
+        protected abstract Expression operator(Expression arg1, Token op, Expression arg2, Expression arg3);
+        protected abstract Expression variableReference(Identifier ident);
+        protected abstract void badBitRange(Identifier ident,String badRange);
+
+        protected abstract Expression functionReference(Identifier ident);
+
+        protected abstract void parameterAssignment(String name, Expression value, int line);
+        protected abstract void variableAssignment(Identifier ident);
+        protected abstract void taskReference(Identifier ident);
+        protected abstract void namedPortConnection(Expression arg, String module, Identifier port, PORT_TYPE port_type);
+        protected abstract void positionalPortConnection(Expression arg, String module, int portIndex, PORT_TYPE port_type);
+        protected abstract void primitivePortConnection(Expression arg, boolean inp, boolean out, PORT_TYPE port_type, int line);
+
+        protected abstract void namedParameterConnection(Expression arg, String module, Identifier parameter);
+        protected abstract void positionalParameterConnection(Expression arg, String module, int parameterIndex);
+
+        protected abstract void evaluateAssignment(Token asn, int lvalue, Expression exp);
+        protected abstract void beginGenerateBlock(Identifier block);
+        protected abstract void endGenerateBlock(Identifier block);
+        protected abstract void setIdentifierUsed(Identifier ident);
+
+  final public void verilogText() throws ParseException {
+    label_1:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case MODULE:
+      case PRIMITIVE:
+      case IDENT:{
+        ;
+        break;
+        }
+      default:
+        jj_la1[0] = jj_gen;
+        break label_1;
+      }
+      moduleOrPrimitiveDecl();
+    }
+  }
+
+  final public void moduleOrPrimitiveDecl() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case MODULE:
+    case IDENT:{
+      moduleDecl();
+      break;
+      }
+    case PRIMITIVE:{
+      primitiveDecl();
+      break;
+      }
+    default:
+      jj_la1[1] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void moduleDecl() throws ParseException {Identifier name;
+        Token end;
+    label_2:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case IDENT:{
+        ;
+        break;
+        }
+      default:
+        jj_la1[2] = jj_gen;
+        break label_2;
+      }
+      jj_consume_token(IDENT);
+    }
+    jj_consume_token(MODULE);
+    name = identifier();
+beginOutlineElement(name, "module#");
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case PARA:{
+      jj_consume_token(PARA);
+      jj_consume_token(LPAREN);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case PARAMETER:{
+        parameterArg();
+        label_3:
+        while (true) {
+          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+          case COMMA:{
+            ;
+            break;
+            }
+          default:
+            jj_la1[3] = jj_gen;
+            break label_3;
+          }
+          jj_consume_token(COMMA);
+          parameterArg();
+        }
+        break;
+        }
+      default:
+        jj_la1[4] = jj_gen;
+        ;
+      }
+      jj_consume_token(RPAREN);
+      break;
+      }
+    default:
+      jj_la1[5] = jj_gen;
+      ;
+    }
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case LPAREN:{
+      jj_consume_token(LPAREN);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case INPUT:
+      case OUTPUT:
+      case INOUT:
+      case IDENT:{
+        argument();
+        label_4:
+        while (true) {
+          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+          case COMMA:{
+            ;
+            break;
+            }
+          default:
+            jj_la1[6] = jj_gen;
+            break label_4;
+          }
+          jj_consume_token(COMMA);
+          argument();
+        }
+        break;
+        }
+      default:
+        jj_la1[7] = jj_gen;
+        ;
+      }
+      jj_consume_token(RPAREN);
+      break;
+      }
+    default:
+      jj_la1[8] = jj_gen;
+      ;
+    }
+    jj_consume_token(EOS);
+    label_5:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case SPECIFY:
+      case FUNCTION:
+      case TASK:
+      case GENERATE:
+      case INPUT:
+      case OUTPUT:
+      case INOUT:
+      case INTEGER:
+      case REG:
+      case WIRE:
+      case EVENT:
+      case GENVAR:
+      case REAL:
+      case PARAMETER:
+      case LOCALPARAM:
+      case PROPERTY:
+      case ASSERT:
+      case ASSIGN:
+      case TIME:
+      case REALTIME:
+      case DEFPARAM:
+      case OR:
+      case ALWAYS:
+      case INITIAL:
+      case SUPPLY:
+      case NET_TYPE:
+      case PRIM_1IN_XOUT:
+      case PRIM_1OUT_XIN:
+      case PRIM_1OUT_1IN_1CNTL:
+      case PRIM_1OUT:
+      case PRIM_1OUT_1IN_NC_PC:
+      case PRIM_BI:
+      case EOS:
+      case IDENT:{
+        ;
+        break;
+        }
+      default:
+        jj_la1[9] = jj_gen;
+        break label_5;
+      }
+      moduleItem();
+    }
+    end = jj_consume_token(ENDMODULE);
+endOutlineElement(end, name. image, "module#");
+  }
+
+  final public void primitiveDecl() throws ParseException {Identifier name;
+        Token end;
+    jj_consume_token(PRIMITIVE);
+    name = identifier();
+beginOutlineElement(name, "module#primitive");
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case LPAREN:{
+      jj_consume_token(LPAREN);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case INPUT:
+      case OUTPUT:
+      case INOUT:
+      case IDENT:{
+        argument();
+        label_6:
+        while (true) {
+          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+          case COMMA:{
+            ;
+            break;
+            }
+          default:
+            jj_la1[10] = jj_gen;
+            break label_6;
+          }
+          jj_consume_token(COMMA);
+          argument();
+        }
+        break;
+        }
+      default:
+        jj_la1[11] = jj_gen;
+        ;
+      }
+      jj_consume_token(RPAREN);
+      break;
+      }
+    default:
+      jj_la1[12] = jj_gen;
+      ;
+    }
+    jj_consume_token(EOS);
+    label_7:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case TABLE:
+      case INPUT:
+      case OUTPUT:
+      case INOUT:
+      case INTEGER:
+      case REG:
+      case WIRE:
+      case EVENT:
+      case GENVAR:
+      case REAL:
+      case TIME:
+      case REALTIME:
+      case SUPPLY:
+      case NET_TYPE:{
+        ;
+        break;
+        }
+      default:
+        jj_la1[13] = jj_gen;
+        break label_7;
+      }
+      primitiveItem();
+    }
+    end = jj_consume_token(ENDPRIMITIVE);
+endOutlineElement(end, name. image, "module#primitive");
+  }
+
+  final public void primitiveItem() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case INPUT:
+    case OUTPUT:
+    case INOUT:{
+      portDecl();
+      break;
+      }
+    case INTEGER:
+    case REG:
+    case WIRE:
+    case EVENT:
+    case GENVAR:
+    case REAL:
+    case TIME:
+    case REALTIME:
+    case SUPPLY:
+    case NET_TYPE:{
+      variableDecl();
+      break;
+      }
+    case TABLE:{
+      tableDecl();
+      break;
+      }
+    default:
+      jj_la1[14] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void tableDecl() throws ParseException {Token start ;
+    start = jj_consume_token(TABLE);
+    skipTo(ENDTABLE);
+addCollapsible(start.beginLine, token.endLine);
+end(STATEMENT);
+  }
+
+  final public void parameterArg() throws ParseException {Token name,value;
+        String mod, range;
+    jj_consume_token(PARAMETER);
+    mod = parameterModifier();
+    //	range = bitRange()
+            range = bitRangeWithDepend();
+    parameterAssign("parameter", mod, range);
+  }
+
+  final public String parameterModifier() throws ParseException {String ret = " ";
+    label_8:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case INTEGER:
+      case REAL:
+      case SIGNED:{
+        ;
+        break;
+        }
+      default:
+        jj_la1[15] = jj_gen;
+        break label_8;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case REAL:{
+        jj_consume_token(REAL);
+        break;
+        }
+      case INTEGER:{
+        jj_consume_token(INTEGER);
+        break;
+        }
+      case SIGNED:{
+        jj_consume_token(SIGNED);
+        break;
+        }
+      default:
+        jj_la1[16] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+ret += token.image + " ";
+    }
+{if ("" != null) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public void defparamAssign(String type, String mod, String range) throws ParseException {Identifier name;
+        Expression value;
+    name = complexIdentifier();
+    jj_consume_token(AGN);
+    value = constantExpression();
+String types = type + "#" + mod + "#" + range + "#" + value.toString();
+                beginOutlineElement(name, types);
+                parameterAssignment(name.image, value, value.beginLine);
+                endOutlineElement(name, types);
+  }
+
+  final public void parameterAssign(String type, String mod, String range) throws ParseException {Identifier name;
+        Expression value;
+        int pos;
+        String [] deps;
+    name = identifier();
+    jj_consume_token(AGN);
+    value = constantExpression();
+pos=range.indexOf("]");
+                if (( pos >0 ) && ( pos < ( range.length() - 1 )))      { // contains dependencies
+                        deps=range.split( "]" );
+                        range=deps[0] + "]";
+                name.setEncodedDepends(deps[1]);
+                }
+                String types = type + "#" + mod + "#" + range + "#" + value.toString();
+                beginOutlineElement(name, types);
+                parameterAssignment(name.image, value, value.beginLine);
+                endOutlineElement(name, types);
+  }
+
+  final public void argument() throws ParseException {Token direction;
+        Identifier name;
+        String modifier="";
+        String range;
+        Token asn;
+        Expression exp;
+        int pos;
+        String [] deps;
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case INPUT:
+    case OUTPUT:
+    case INOUT:{
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case INPUT:{
+        direction = jj_consume_token(INPUT);
+        break;
+        }
+      case OUTPUT:{
+        direction = jj_consume_token(OUTPUT);
+        break;
+        }
+      case INOUT:{
+        direction = jj_consume_token(INOUT);
+        break;
+        }
+      default:
+        jj_la1[17] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      modifier = variableModifier();
+      //		range = bitRange()
+                      range = bitRangeWithDepend();
+      name = identifier();
+pos=range.indexOf("]");
+                        if (( pos >0 ) && ( pos < ( range.length() - 1 )))      { // contains dependencies
+                                deps=range.split( "]" );
+                                range=deps[0] + "]";
+//	        	name.addEncodedDeps(deps[1]);
+                        name.setEncodedDepends(deps[1]);
+                        }
+                        String types = "port#" + direction.image + "#" + modifier + "#" + range;
+                        beginOutlineElement(name, types);
+                        endOutlineElement(name, types);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case AGN:{
+        asn = jj_consume_token(AGN);
+        exp = expression();
+variableAssignment(name);
+                                evaluateAssignment(asn, name.getWidth(), exp);
+        break;
+        }
+      default:
+        jj_la1[18] = jj_gen;
+        ;
+      }
+      break;
+      }
+    case IDENT:{
+      identifier();
+      break;
+      }
+    default:
+      jj_la1[19] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void functionArgument() throws ParseException {Token direction;
+        Identifier name;
+        String modifier="";
+        String range;
+        Token asn;
+        Expression exp;
+        int pos;
+        String [] deps;
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case INPUT:{
+      // C++ style argument
+                      direction = jj_consume_token(INPUT);
+      modifier = variableModifier();
+      //		range = bitRange()
+                      range = bitRangeWithDepend();
+      name = identifier();
+pos=range.indexOf("]");
+                        if (( pos >0 ) && ( pos < ( range.length() - 1 )))      { // contains dependencies
+                                deps=range.split( "]" );
+                                range=deps[0] + "]";
+//	        	name.addEncodedDeps(deps[1]);
+                        name.setEncodedDepends(deps[1]);
+                        }
+                        String types = "port#" + direction.image + "#" + modifier + "#" + range;
+                        beginOutlineElement(name, types);
+                        endOutlineElement(name, types);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case AGN:{
+        asn = jj_consume_token(AGN);
+        exp = expression();
+variableAssignment(name);
+                                evaluateAssignment(asn, name.getWidth(), exp);
+        break;
+        }
+      default:
+        jj_la1[20] = jj_gen;
+        ;
+      }
+      break;
+      }
+    case IDENT:{
+      identifier();
+      break;
+      }
+    default:
+      jj_la1[21] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void moduleItem() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case FUNCTION:
+    case TASK:
+    case INTEGER:
+    case REG:
+    case WIRE:
+    case EVENT:
+    case GENVAR:
+    case REAL:
+    case PARAMETER:
+    case LOCALPARAM:
+    case ASSERT:
+    case ASSIGN:
+    case TIME:
+    case REALTIME:
+    case DEFPARAM:
+    case OR:
+    case ALWAYS:
+    case INITIAL:
+    case SUPPLY:
+    case NET_TYPE:
+    case PRIM_1IN_XOUT:
+    case PRIM_1OUT_XIN:
+    case PRIM_1OUT_1IN_1CNTL:
+    case PRIM_1OUT:
+    case PRIM_1OUT_1IN_NC_PC:
+    case PRIM_BI:
+    case EOS:
+    case IDENT:{
+      moduleOrGenerateItem();
+      break;
+      }
+    case INPUT:
+    case OUTPUT:
+    case INOUT:{
+      portDecl();
+      break;
+      }
+    case SPECIFY:{
+      jj_consume_token(SPECIFY);
+begin(STATEMENT);
+      skipTo(ENDSPECIFY);
+end(STATEMENT);
+      break;
+      }
+    case GENERATE:{
+      generate();
+      break;
+      }
+    case PROPERTY:{
+      jj_consume_token(PROPERTY);
+      skipTo(ENDPROPERTY);
+      break;
+      }
+    default:
+      jj_la1[22] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void moduleOrGenerateItem() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case INTEGER:
+    case REG:
+    case WIRE:
+    case EVENT:
+    case GENVAR:
+    case REAL:
+    case TIME:
+    case REALTIME:
+    case SUPPLY:
+    case NET_TYPE:{
+      variableDecl();
+      break;
+      }
+    case PARAMETER:
+    case LOCALPARAM:{
+      parameterDecl();
+      break;
+      }
+    case DEFPARAM:{
+      defparamDecl();
+      break;
+      }
+    case TASK:{
+      taskDecl();
+      break;
+      }
+    case FUNCTION:{
+      functionDecl();
+      break;
+      }
+    case ASSIGN:{
+      assign();
+      break;
+      }
+    case OR:
+    case PRIM_1IN_XOUT:
+    case PRIM_1OUT_XIN:
+    case PRIM_1OUT_1IN_1CNTL:
+    case PRIM_1OUT:
+    case PRIM_1OUT_1IN_NC_PC:
+    case PRIM_BI:{
+      primitiveInstance();
+      break;
+      }
+    default:
+      jj_la1[23] = jj_gen;
+      if (jj_2_1(3)) {
+        moduleInstance();
+      } else {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case ALWAYS:
+        case INITIAL:{
+          initialAlways();
+          break;
+          }
+        case ASSERT:{
+          jj_consume_token(ASSERT);
+          skipTo(EOS);
+          break;
+          }
+        case IDENT:{
+          identifier();
+          jj_consume_token(COLON);
+          jj_consume_token(ASSERT);
+          skipTo(EOS);
+          break;
+          }
+        case EOS:{
+          jj_consume_token(EOS);
+          break;
+          }
+        default:
+          jj_la1[24] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+      }
+    }
+  }
+
+//| <DEFPARAM> {begin(STATEMENT);} skipTo( EOS ) {end(STATEMENT);}
+  final public 
+void portDecl() throws ParseException {Token direction;
+        String modifier;
+        String range;
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case INPUT:{
+      direction = jj_consume_token(INPUT);
+      break;
+      }
+    case OUTPUT:{
+      direction = jj_consume_token(OUTPUT);
+      break;
+      }
+    case INOUT:{
+      direction = jj_consume_token(INOUT);
+      break;
+      }
+    default:
+      jj_la1[25] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    modifier = variableModifier();
+begin(STATEMENT);
+    range = bitRangeWithDepend();
+    portDeclSingle(direction, modifier, range);
+    label_9:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case COMMA:{
+        ;
+        break;
+        }
+      default:
+        jj_la1[26] = jj_gen;
+        break label_9;
+      }
+      jj_consume_token(COMMA);
+      portDeclSingle(direction, modifier, range);
+    }
+    jj_consume_token(EOS);
+end(STATEMENT);
+  }
+
+  final public void functionPortDecl() throws ParseException {Token direction;
+        String modifier;
+        String range;
+    direction = jj_consume_token(INPUT);
+    modifier = variableModifier();
+begin(STATEMENT);
+    range = bitRangeWithDepend();
+    portDeclSingle(direction, modifier, range);
+    label_10:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case COMMA:{
+        ;
+        break;
+        }
+      default:
+        jj_la1[27] = jj_gen;
+        break label_10;
+      }
+      jj_consume_token(COMMA);
+      portDeclSingle(direction, modifier, range);
+    }
+    jj_consume_token(EOS);
+end(STATEMENT);
+  }
+
+  final public String variableModifier() throws ParseException {String ret = "";
+    label_11:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case INTEGER:
+      case REG:
+      case WIRE:
+      case REAL:
+      case SIGNED:
+      case TIME:
+      case REALTIME:{
+        ;
+        break;
+        }
+      default:
+        jj_la1[28] = jj_gen;
+        break label_11;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case REAL:{
+        jj_consume_token(REAL);
+        break;
+        }
+      case REALTIME:{
+        jj_consume_token(REALTIME);
+        break;
+        }
+      case INTEGER:{
+        jj_consume_token(INTEGER);
+        break;
+        }
+      case WIRE:{
+        jj_consume_token(WIRE);
+        break;
+        }
+      case REG:{
+        jj_consume_token(REG);
+        break;
+        }
+      case SIGNED:{
+        jj_consume_token(SIGNED);
+        break;
+        }
+      case TIME:{
+        jj_consume_token(TIME);
+        break;
+        }
+      default:
+        jj_la1[29] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+ret += token.image + " ";
+    }
+{if ("" != null) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public void portDeclSingle(Token direction, String modifier, String range) throws ParseException {Identifier name;
+        Token asn;
+        Expression exp;
+        int pos;
+        String [] deps;
+    name = identifier();
+pos=range.indexOf("]");
+                if (( pos >0 ) && ( pos < ( range.length() - 1 )))      { // contains dependencies
+                        deps=range.split( "]" );
+                        range=deps[0] + "]";
+//	        name.addEncodedDeps(deps[1]);
+                name.setEncodedDepends(deps[1]);
+                }
+                String type = "port#" + direction.image + "#" + modifier + "#" + range + "#cstyle";
+                beginOutlineElement(name, type);
+                endOutlineElement(name, type);
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case AGN:{
+      asn = jj_consume_token(AGN);
+      exp = expression();
+variableAssignment(name);
+                        evaluateAssignment(asn, name.getWidth(), exp);
+      break;
+      }
+    default:
+      jj_la1[30] = jj_gen;
+      ;
+    }
+  }
+
+/* 
+void primitiveInstance():
+{
+	String prim;
+}
+{
+	(     <PRIM_1IN_XOUT> | "or"
+      	| <PRIM_1OUT_XIN>      
+		| <PRIM_1OUT_1IN_1CNTL>
+		| <PRIM_1OUT>
+		| <PRIM_1OUT_1IN_NC_PC>
+		| <PRIM_BI>
+	) { prim = token.image;}
+	[ LOOKAHEAD(2) strength() ] [ delay3() ]
+	[ identifier() bitRange() ] "(" portConnect(prim) ")"
+	( "," identifier() bitRange() "(" portConnect(prim) ")" )*
+	";"
+}
+
+void moduleInstanceOld():
+{
+	Identifier module, inst;
+	Token iend ;
+}
+{ 
+	module = identifier() 
+	{ begin(STATEMENT); }
+	
+	(   //module instantiation
+		(   [ "#" ( identifier() | number() | "(" parameterConnectOld() ")" ) ]
+			inst = identifier()
+			{
+				beginOutlineElement(module, inst.image, "instance#"+module.image);
+			}
+			[ "(" [ portConnect(module.image) ] ")" ]
+		    iend = ";"
+		    {			
+				endOutlineElement(iend, inst.image, "instance#"+module.image);
+				addCollapsible(module.beginLine, iend.endLine);
+		     }
+		 )
+	 |   //user defined primitive	 
+		 (  "(" portConnect(module.image) ")"
+		 	iend = ";"
+		 )
+	)
+	{ end(STATEMENT); }
+}
+*/
+  final public 
+void moduleInstance() throws ParseException {Identifier module, inst;
+        Token iend ;
+    module = identifier();
+begin(STATEMENT);
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case PARA:
+    case IDENT:{
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case PARA:{
+        jj_consume_token(PARA);
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case IDENT:
+        case INTEGER_LITERAL:
+        case REAL_LITERAL:
+        case STRING_LITERAL:{
+          singleParameterConnect(module.image);
+          break;
+          }
+        case LPAREN:{
+          jj_consume_token(LPAREN);
+          parameterConnect(module.image);
+          jj_consume_token(RPAREN);
+          break;
+          }
+        default:
+          jj_la1[31] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+        break;
+        }
+      default:
+        jj_la1[32] = jj_gen;
+        ;
+      }
+      inst = identifier();
+beginOutlineElement(module, inst.image, "instance#"+module.image);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case LPAREN:{
+        jj_consume_token(LPAREN);
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case LPAREN:
+        case LBRACE:
+        case DOT:
+        case BANG:
+        case TILDE:
+        case PLUS:
+        case MINUS:
+        case BIT_AND:
+        case BIT_OR:
+        case XOR:
+        case NEG_AND:
+        case NEG_OR:
+        case NEG_XOR:
+        case XOR_NEG:
+        case IDENT:
+        case SYSTEM_IDENT:
+        case INTEGER_LITERAL:
+        case REAL_LITERAL:
+        case STRING_LITERAL:{
+          portConnect(module.image, PORT_TYPE.INSTANCE);
+          break;
+          }
+        default:
+          jj_la1[33] = jj_gen;
+          ;
+        }
+        jj_consume_token(RPAREN);
+        break;
+        }
+      default:
+        jj_la1[34] = jj_gen;
+        ;
+      }
+      iend = jj_consume_token(EOS);
+endOutlineElement(iend, inst.image, "instance#"+module.image);
+                                addCollapsible(module.beginLine, iend.endLine);
+      break;
+      }
+    case LPAREN:{
+      jj_consume_token(LPAREN);
+beginOutlineElement(module, module.image+":"+module.beginLine+":"+module.beginColumn, "instance#"+module.image);
+      portConnect(module.image, PORT_TYPE.PRIMITIVE);
+      jj_consume_token(RPAREN);
+      iend = jj_consume_token(EOS);
+endOutlineElement(iend, module.image+":"+module.beginLine+":"+module.beginColumn, "instance#"+module.image);
+                                addCollapsible(module.beginLine, iend.endLine);
+      break;
+      }
+    default:
+      jj_la1[35] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+end(STATEMENT);
+  }
+
+// just identifier or number ( module_name # ident module_instance_name (...);
+  final public void singleParameterConnect(String module) throws ParseException {Expression arg = null;
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case INTEGER_LITERAL:
+    case REAL_LITERAL:
+    case STRING_LITERAL:{
+      arg = number();
+      break;
+      }
+    case IDENT:{
+      arg = identifierExpression();
+      break;
+      }
+    default:
+      jj_la1[36] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+positionalParameterConnection(arg, module, 0); // single parameter
+
+  }
+
+  final public Expression identifierExpression() throws ParseException {Expression ret;
+        Identifier ident;
+    ident = identifier();
+{if ("" != null) return variableReference(ident);}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public void parameterConnectOld() throws ParseException {Expression arg = null;
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case DOT:{
+      jj_consume_token(DOT);
+      identifier();
+      jj_consume_token(LPAREN);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case LPAREN:
+      case LBRACE:
+      case BANG:
+      case TILDE:
+      case PLUS:
+      case MINUS:
+      case BIT_AND:
+      case BIT_OR:
+      case XOR:
+      case NEG_AND:
+      case NEG_OR:
+      case NEG_XOR:
+      case XOR_NEG:
+      case IDENT:
+      case SYSTEM_IDENT:
+      case INTEGER_LITERAL:
+      case REAL_LITERAL:
+      case STRING_LITERAL:{
+        constantExpression();
+        break;
+        }
+      default:
+        jj_la1[37] = jj_gen;
+        ;
+      }
+      jj_consume_token(RPAREN);
+      label_12:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case COMMA:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[38] = jj_gen;
+          break label_12;
+        }
+        jj_consume_token(COMMA);
+        jj_consume_token(DOT);
+        identifier();
+        jj_consume_token(LPAREN);
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case LPAREN:
+        case LBRACE:
+        case BANG:
+        case TILDE:
+        case PLUS:
+        case MINUS:
+        case BIT_AND:
+        case BIT_OR:
+        case XOR:
+        case NEG_AND:
+        case NEG_OR:
+        case NEG_XOR:
+        case XOR_NEG:
+        case IDENT:
+        case SYSTEM_IDENT:
+        case INTEGER_LITERAL:
+        case REAL_LITERAL:
+        case STRING_LITERAL:{
+          constantExpression();
+          break;
+          }
+        default:
+          jj_la1[39] = jj_gen;
+          ;
+        }
+        jj_consume_token(RPAREN);
+      }
+      break;
+      }
+    case LPAREN:
+    case LBRACE:
+    case BANG:
+    case TILDE:
+    case PLUS:
+    case MINUS:
+    case BIT_AND:
+    case BIT_OR:
+    case XOR:
+    case NEG_AND:
+    case NEG_OR:
+    case NEG_XOR:
+    case XOR_NEG:
+    case IDENT:
+    case SYSTEM_IDENT:
+    case INTEGER_LITERAL:
+    case REAL_LITERAL:
+    case STRING_LITERAL:{
+      constantExpression();
+      label_13:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case COMMA:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[40] = jj_gen;
+          break label_13;
+        }
+        jj_consume_token(COMMA);
+        constantExpression();
+      }
+      break;
+      }
+    default:
+      jj_la1[41] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void parameterConnect(String module) throws ParseException {int count = 0;
+    count = parameterConnectSingle(module, count);
+    label_14:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case COMMA:{
+        ;
+        break;
+        }
+      default:
+        jj_la1[42] = jj_gen;
+        break label_14;
+      }
+      jj_consume_token(COMMA);
+      count = parameterConnectSingle(module, count);
+    }
+  }
+
+  final public int parameterConnectSingle(String module, int count) throws ParseException {Identifier parameter;
+        Expression arg = null;
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case DOT:{
+      jj_consume_token(DOT);
+      parameter = identifier();
+      jj_consume_token(LPAREN);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case LPAREN:
+      case LBRACE:
+      case BANG:
+      case TILDE:
+      case PLUS:
+      case MINUS:
+      case BIT_AND:
+      case BIT_OR:
+      case XOR:
+      case NEG_AND:
+      case NEG_OR:
+      case NEG_XOR:
+      case XOR_NEG:
+      case IDENT:
+      case SYSTEM_IDENT:
+      case INTEGER_LITERAL:
+      case REAL_LITERAL:
+      case STRING_LITERAL:{
+        arg = constantExpression();
+        break;
+        }
+      default:
+        jj_la1[43] = jj_gen;
+        ;
+      }
+      jj_consume_token(RPAREN);
+namedParameterConnection(arg, module, parameter);
+                {if ("" != null) return count + 1;}
+      break;
+      }
+    case LPAREN:
+    case LBRACE:
+    case BANG:
+    case TILDE:
+    case PLUS:
+    case MINUS:
+    case BIT_AND:
+    case BIT_OR:
+    case XOR:
+    case NEG_AND:
+    case NEG_OR:
+    case NEG_XOR:
+    case XOR_NEG:
+    case IDENT:
+    case SYSTEM_IDENT:
+    case INTEGER_LITERAL:
+    case REAL_LITERAL:
+    case STRING_LITERAL:{
+      arg = constantExpression();
+positionalParameterConnection(arg, module, count);
+                {if ("" != null) return count + 1;}
+      break;
+      }
+    default:
+      jj_la1[44] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    throw new Error("Missing return statement in function");
+  }
+
+  final public void portConnect(String module, PORT_TYPE port_type) throws ParseException {int count = 0;
+    count = portConnectSingle(module, count, port_type);
+    label_15:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case COMMA:{
+        ;
+        break;
+        }
+      default:
+        jj_la1[45] = jj_gen;
+        break label_15;
+      }
+      jj_consume_token(COMMA);
+      count = portConnectSingle(module, count, port_type);
+    }
+  }
+
+  final public int portConnectSingle(String module, int count, PORT_TYPE port_type) throws ParseException {Identifier port;
+        Expression arg = null;
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case DOT:{
+      jj_consume_token(DOT);
+      port = identifier();
+      jj_consume_token(LPAREN);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case LPAREN:
+      case LBRACE:
+      case BANG:
+      case TILDE:
+      case PLUS:
+      case MINUS:
+      case BIT_AND:
+      case BIT_OR:
+      case XOR:
+      case NEG_AND:
+      case NEG_OR:
+      case NEG_XOR:
+      case XOR_NEG:
+      case IDENT:
+      case SYSTEM_IDENT:
+      case INTEGER_LITERAL:
+      case REAL_LITERAL:
+      case STRING_LITERAL:{
+        arg = expression();
+        break;
+        }
+      default:
+        jj_la1[46] = jj_gen;
+        ;
+      }
+      jj_consume_token(RPAREN);
+namedPortConnection(arg, module, port, port_type); //PORT_TYPE.INSTANCE); //TODO: make variable
+                {if ("" != null) return count + 1;}
+      break;
+      }
+    case LPAREN:
+    case LBRACE:
+    case BANG:
+    case TILDE:
+    case PLUS:
+    case MINUS:
+    case BIT_AND:
+    case BIT_OR:
+    case XOR:
+    case NEG_AND:
+    case NEG_OR:
+    case NEG_XOR:
+    case XOR_NEG:
+    case IDENT:
+    case SYSTEM_IDENT:
+    case INTEGER_LITERAL:
+    case REAL_LITERAL:
+    case STRING_LITERAL:{
+      arg = expression();
+positionalPortConnection(arg, module, count, port_type); //count, PORT_TYPE.INSTANCE); //TODO: make variable
+                {if ("" != null) return count + 1;}
+      break;
+      }
+    default:
+      jj_la1[47] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    throw new Error("Missing return statement in function");
+  }
+
+// Handling primitive in/outs
+  final public void primitiveInstance() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case PRIM_1OUT_XIN:
+    case PRIM_1OUT_1IN_1CNTL:
+    case PRIM_1OUT:
+    case PRIM_1OUT_1IN_NC_PC:{
+      primitiveInstance_1out_xin();
+      break;
+      }
+    case OR:
+    case PRIM_1IN_XOUT:{
+      primitiveInstance_xout_1in();
+      break;
+      }
+    case PRIM_BI:{
+      primitiveInstance_2inout_1in();
+      break;
+      }
+    default:
+      jj_la1[48] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void primitiveInstance_1out_xin() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case PRIM_1OUT_XIN:{
+      jj_consume_token(PRIM_1OUT_XIN);
+      break;
+      }
+    case PRIM_1OUT_1IN_1CNTL:{
+      jj_consume_token(PRIM_1OUT_1IN_1CNTL);
+      break;
+      }
+    case PRIM_1OUT:{
+      jj_consume_token(PRIM_1OUT);
+      break;
+      }
+    case PRIM_1OUT_1IN_NC_PC:{
+      jj_consume_token(PRIM_1OUT_1IN_NC_PC);
+      break;
+      }
+    default:
+      jj_la1[49] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    if (jj_2_2(2)) {
+      strength();
+    } else {
+      ;
+    }
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case PARA:{
+      delay3();
+      break;
+      }
+    default:
+      jj_la1[50] = jj_gen;
+      ;
+    }
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case IDENT:{
+      identifier();
+      bitRange();
+      break;
+      }
+    default:
+      jj_la1[51] = jj_gen;
+      ;
+    }
+    jj_consume_token(LPAREN);
+    portConnectOut();
+    label_16:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case COMMA:{
+        ;
+        break;
+        }
+      default:
+        jj_la1[52] = jj_gen;
+        break label_16;
+      }
+      jj_consume_token(COMMA);
+      portConnectIn();
+    }
+    jj_consume_token(RPAREN);
+    label_17:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case COMMA:{
+        ;
+        break;
+        }
+      default:
+        jj_la1[53] = jj_gen;
+        break label_17;
+      }
+      jj_consume_token(COMMA);
+      identifier();
+      bitRange();
+      jj_consume_token(LPAREN);
+      portConnectOut();
+      label_18:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case COMMA:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[54] = jj_gen;
+          break label_18;
+        }
+        jj_consume_token(COMMA);
+        portConnectIn();
+      }
+      jj_consume_token(RPAREN);
+    }
+    jj_consume_token(EOS);
+  }
+
+  final public void primitiveInstance_xout_1in() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case PRIM_1IN_XOUT:{
+      jj_consume_token(PRIM_1IN_XOUT);
+      break;
+      }
+    case OR:{
+      jj_consume_token(OR);
+      break;
+      }
+    default:
+      jj_la1[55] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    if (jj_2_3(2)) {
+      strength();
+    } else {
+      ;
+    }
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case PARA:{
+      delay3();
+      break;
+      }
+    default:
+      jj_la1[56] = jj_gen;
+      ;
+    }
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case IDENT:{
+      identifier();
+      bitRange();
+      break;
+      }
+    default:
+      jj_la1[57] = jj_gen;
+      ;
+    }
+    jj_consume_token(LPAREN);
+    portConnectOut();
+    jj_consume_token(COMMA);
+    label_19:
+    while (true) {
+      if (jj_2_4(2)) {
+        ;
+      } else {
+        break label_19;
+      }
+      portConnectOut();
+      jj_consume_token(COMMA);
+    }
+    portConnectIn();
+    jj_consume_token(RPAREN);
+    label_20:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case COMMA:{
+        ;
+        break;
+        }
+      default:
+        jj_la1[58] = jj_gen;
+        break label_20;
+      }
+      jj_consume_token(COMMA);
+      identifier();
+      bitRange();
+      jj_consume_token(LPAREN);
+      portConnectOut();
+      jj_consume_token(COMMA);
+      label_21:
+      while (true) {
+        if (jj_2_5(2)) {
+          ;
+        } else {
+          break label_21;
+        }
+        portConnectOut();
+        jj_consume_token(COMMA);
+      }
+      portConnectIn();
+      jj_consume_token(RPAREN);
+    }
+    jj_consume_token(EOS);
+  }
+
+  final public void primitiveInstance_2inout_1in() throws ParseException {
+    jj_consume_token(PRIM_BI);
+    if (jj_2_6(2)) {
+      strength();
+    } else {
+      ;
+    }
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case PARA:{
+      delay3();
+      break;
+      }
+    default:
+      jj_la1[59] = jj_gen;
+      ;
+    }
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case IDENT:{
+      identifier();
+      bitRange();
+      break;
+      }
+    default:
+      jj_la1[60] = jj_gen;
+      ;
+    }
+    jj_consume_token(LPAREN);
+    portConnectInOut();
+    jj_consume_token(COMMA);
+    portConnectInOut();
+    jj_consume_token(COMMA);
+    portConnectIn();
+    jj_consume_token(RPAREN);
+    label_22:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case COMMA:{
+        ;
+        break;
+        }
+      default:
+        jj_la1[61] = jj_gen;
+        break label_22;
+      }
+      jj_consume_token(COMMA);
+      identifier();
+      bitRange();
+      jj_consume_token(LPAREN);
+      portConnectInOut();
+      jj_consume_token(COMMA);
+      portConnectInOut();
+      jj_consume_token(COMMA);
+      portConnectIn();
+      jj_consume_token(RPAREN);
+    }
+    jj_consume_token(EOS);
+  }
+
+  final public void portConnectIn() throws ParseException {Expression arg = null;
+    arg = expression();
+primitivePortConnection(arg, true, false, PORT_TYPE.PRIMITIVE, arg.beginLine); //TODO: make variable to use for system tasks/func?
+
+  }
+
+  final public void portConnectOut() throws ParseException {Expression arg = null;
+    arg = expression();
+primitivePortConnection(arg, false, true, PORT_TYPE.PRIMITIVE, arg.beginLine); //TODO: make variable to use for system tasks/func?
+
+  }
+
+  final public void portConnectInOut() throws ParseException {Expression arg = null;
+    arg = expression();
+primitivePortConnection(arg, false, true, PORT_TYPE.PRIMITIVE, arg.beginLine); //TODO: make variable to use for system tasks/func?
+
+  }
+
+  final public void assign() throws ParseException {int width;
+        Token asn;
+        Expression exp;
+    jj_consume_token(ASSIGN);
+begin(ASSIGN_STMT);
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case LPAREN:{
+      strength();
+      break;
+      }
+    default:
+      jj_la1[62] = jj_gen;
+      ;
+    }
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case PARA:{
+      delay3();
+      break;
+      }
+    default:
+      jj_la1[63] = jj_gen;
+      ;
+    }
+    width = lvalue();
+    asn = jj_consume_token(AGN);
+    exp = expression();
+evaluateAssignment(asn, width, exp);
+    label_23:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case COMMA:{
+        ;
+        break;
+        }
+      default:
+        jj_la1[64] = jj_gen;
+        break label_23;
+      }
+      jj_consume_token(COMMA);
+      width = lvalue();
+      asn = jj_consume_token(AGN);
+      exp = expression();
+evaluateAssignment(asn, width, exp);
+    }
+    jj_consume_token(EOS);
+end(ASSIGN_STMT);
+  }
+
+  final public void variableDecl() throws ParseException {Token variable;
+        String type;
+        String range;
+    type = variableType();
+begin(STATEMENT);
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case LPAREN:{
+      strength();
+      break;
+      }
+    default:
+      jj_la1[65] = jj_gen;
+      ;
+    }
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case SIGNED:{
+      jj_consume_token(SIGNED);
+type += " signed";
+      break;
+      }
+    default:
+      jj_la1[66] = jj_gen;
+      ;
+    }
+    range = bitRange();
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case PARA:{
+      delay3();
+      break;
+      }
+    default:
+      jj_la1[67] = jj_gen;
+      ;
+    }
+    variableDeclSingle(type, range);
+    label_24:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case COMMA:{
+        ;
+        break;
+        }
+      default:
+        jj_la1[68] = jj_gen;
+        break label_24;
+      }
+      jj_consume_token(COMMA);
+      variableDeclSingle(type, range);
+    }
+    jj_consume_token(EOS);
+end(STATEMENT);
+  }
+
+  final public String variableType() throws ParseException {String type;
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case WIRE:
+    case SUPPLY:
+    case NET_TYPE:{
+      type = netType();
+{if ("" != null) return type;}
+      break;
+      }
+    case INTEGER:
+    case REG:
+    case EVENT:
+    case GENVAR:
+    case REAL:
+    case TIME:
+    case REALTIME:{
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case REG:{
+        jj_consume_token(REG);
+        break;
+        }
+      case REAL:{
+        jj_consume_token(REAL);
+        break;
+        }
+      case INTEGER:{
+        jj_consume_token(INTEGER);
+        break;
+        }
+      case EVENT:{
+        jj_consume_token(EVENT);
+        break;
+        }
+      case GENVAR:{
+        jj_consume_token(GENVAR);
+        break;
+        }
+      case TIME:{
+        jj_consume_token(TIME);
+        break;
+        }
+      case REALTIME:{
+        jj_consume_token(REALTIME);
+        break;
+        }
+      default:
+        jj_la1[69] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+{if ("" != null) return token.image;}
+      break;
+      }
+    default:
+      jj_la1[70] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    throw new Error("Missing return statement in function");
+  }
+
+  final public void variableDeclSingle(String mod, String range) throws ParseException {Identifier variable;
+        Token asn;
+        Expression exp;
+        int dimension = 0;
+    variable = identifier();
+    label_25:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case LBRACKET:{
+        ;
+        break;
+        }
+      default:
+        jj_la1[71] = jj_gen;
+        break label_25;
+      }
+      jj_consume_token(LBRACKET);
+      constantExpression();
+      jj_consume_token(COLON);
+      constantExpression();
+      jj_consume_token(RBRACKET);
+dimension++;
+    }
+String type = "variable#" + mod + "#" + range + "#" + dimension;
+                beginOutlineElement(variable, type);
+                endOutlineElement(variable, type);
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case AGN:{
+      asn = jj_consume_token(AGN);
+      exp = expression();
+variableAssignment(variable);
+                        evaluateAssignment(asn, variable.getWidth(), exp);
+      break;
+      }
+    default:
+      jj_la1[72] = jj_gen;
+      ;
+    }
+  }
+
+  final public void delay3() throws ParseException {
+    jj_consume_token(PARA);
+    if (jj_2_7(3)) {
+      delayValue();
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case LPAREN:{
+        jj_consume_token(LPAREN);
+        minTypMaxExpresstion();
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case COMMA:{
+          jj_consume_token(COMMA);
+          minTypMaxExpresstion();
+          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+          case COMMA:{
+            jj_consume_token(COMMA);
+            minTypMaxExpresstion();
+            break;
+            }
+          default:
+            jj_la1[73] = jj_gen;
+            ;
+          }
+          break;
+          }
+        default:
+          jj_la1[74] = jj_gen;
+          ;
+        }
+        jj_consume_token(RPAREN);
+        break;
+        }
+      default:
+        jj_la1[75] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+  }
+
+  final public void parameterDecl() throws ParseException {String type;
+        String mod, range;
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case PARAMETER:{
+      jj_consume_token(PARAMETER);
+type = "parameter";
+      break;
+      }
+    case LOCALPARAM:{
+      jj_consume_token(LOCALPARAM);
+type = "localparam";
+      break;
+      }
+    default:
+      jj_la1[76] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    mod = parameterModifier();
+    //	range = bitRange()
+            range = bitRangeWithDepend();
+    parameterAssign(type, mod, range);
+    label_26:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case COMMA:{
+        ;
+        break;
+        }
+      default:
+        jj_la1[77] = jj_gen;
+        break label_26;
+      }
+      jj_consume_token(COMMA);
+      parameterAssign(type, mod, range);
+    }
+    jj_consume_token(EOS);
+  }
+
+  final public void defparamDecl() throws ParseException {String type;
+        String mod, range;
+    jj_consume_token(DEFPARAM);
+type = "defparam";
+    mod = parameterModifier();
+    //	range = bitRange()
+            range = bitRangeWithDepend();
+    defparamAssign(type, mod, range);
+    label_27:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case COMMA:{
+        ;
+        break;
+        }
+      default:
+        jj_la1[78] = jj_gen;
+        break label_27;
+      }
+      jj_consume_token(COMMA);
+      parameterAssign(type, mod, range);
+    }
+    jj_consume_token(EOS);
+  }
+
+  final public void initialAlways() throws ParseException {Token start;
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case INITIAL:{
+      start = jj_consume_token(INITIAL);
+      break;
+      }
+    case ALWAYS:{
+      start = jj_consume_token(ALWAYS);
+      break;
+      }
+    default:
+      jj_la1[79] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+if (start.image.equals("initial"))
+                        begin(INITIAL_BLOCK);
+                else
+                        begin(ALWAYS_BLOCK);
+    statement();
+if (start.image.equals("initial"))
+                        end(INITIAL_BLOCK);
+                else
+                        end(ALWAYS_BLOCK);
+                addCollapsible(start.beginLine,token.endLine);
+  }
+
+  final public void statement() throws ParseException {Token end;
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case LBRACE:
+    case IDENT:
+    case SYSTEM_IDENT:{
+      assignOrTaskEnable();
+      break;
+      }
+    case ASSIGN:
+    case DEASSIGN:
+    case FORCE:
+    case RELEASE:{
+      proceduralContinuousAssignment();
+      break;
+      }
+    case PARA:
+    case AT:{
+      proceduralTimingControlStatement();
+      break;
+      }
+    case IF:{
+      ifStatement();
+      break;
+      }
+    case CASE:{
+      caseStatement();
+      break;
+      }
+    case WHILE:{
+      whileStatement();
+      break;
+      }
+    case FOR:{
+      forStatement();
+      break;
+      }
+    case FOREVER:{
+      foreverStatement();
+      break;
+      }
+    case REPEAT:{
+      repeatStatement();
+      break;
+      }
+    case WAIT:{
+      waitStatement();
+      break;
+      }
+    case DISABLE:{
+      jj_consume_token(DISABLE);
+      identifier();
+      jj_consume_token(EOS);
+      break;
+      }
+    case 135:{
+      jj_consume_token(135);
+      identifier();
+      jj_consume_token(EOS);
+      break;
+      }
+    case BEGIN:
+    case FORK:{
+      block();
+      break;
+      }
+    case EOS:{
+      jj_consume_token(EOS);
+      break;
+      }
+    default:
+      jj_la1[80] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void assignOrTaskEnable() throws ParseException {Identifier ident;
+        Token asn;
+        Expression exp;
+        int width;
+        Token iend;
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case IDENT:{
+      ident = complexIdentifier();
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case AGN:
+      case LE:{
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case AGN:{
+          asn = jj_consume_token(AGN);
+          break;
+          }
+        case LE:{
+          asn = jj_consume_token(LE);
+          break;
+          }
+        default:
+          jj_la1[81] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case PARA:
+        case AT:{
+          delayOrEventControl();
+          break;
+          }
+        default:
+          jj_la1[82] = jj_gen;
+          ;
+        }
+        exp = expression();
+        jj_consume_token(EOS);
+variableAssignment(ident);
+                        evaluateAssignment(asn, ident.getWidth(), exp);
+        break;
+        }
+      case LPAREN:
+      case EOS:{
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case LPAREN:{
+          jj_consume_token(LPAREN);
+beginOutlineElement(ident, ident.image+":"+ident.beginLine+":"+ident.beginColumn, "taskenable#"+ident.image);
+          portConnect(ident.image, PORT_TYPE.TASK);
+          jj_consume_token(RPAREN);
+          iend = jj_consume_token(EOS);
+          break;
+          }
+        case EOS:{
+          iend = jj_consume_token(EOS);
+beginOutlineElement(ident, ident.image+":"+ident.beginLine+":"+ident.beginColumn, "taskenable#"+ident.image);
+          break;
+          }
+        default:
+          jj_la1[83] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+endOutlineElement(iend, ident.image+":"+ident.beginLine+":"+ident.beginColumn, "taskenable#"+ident.image);
+                        addCollapsible(ident.beginLine, iend.endLine);
+                        taskReference(ident);
+        break;
+        }
+      default:
+        jj_la1[84] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      break;
+      }
+    case LBRACE:{
+      width = lvalueConcatenation();
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case AGN:{
+        asn = jj_consume_token(AGN);
+        break;
+        }
+      case LE:{
+        asn = jj_consume_token(LE);
+        break;
+        }
+      default:
+        jj_la1[85] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case PARA:
+      case AT:{
+        delayOrEventControl();
+        break;
+        }
+      default:
+        jj_la1[86] = jj_gen;
+        ;
+      }
+      exp = expression();
+      jj_consume_token(EOS);
+evaluateAssignment(asn, width, exp);
+      break;
+      }
+    case SYSTEM_IDENT:{
+      jj_consume_token(SYSTEM_IDENT);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case LPAREN:{
+        jj_consume_token(LPAREN);
+        expression();
+        label_28:
+        while (true) {
+          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+          case COMMA:{
+            ;
+            break;
+            }
+          default:
+            jj_la1[87] = jj_gen;
+            break label_28;
+          }
+          jj_consume_token(COMMA);
+          expression();
+        }
+        jj_consume_token(RPAREN);
+        break;
+        }
+      default:
+        jj_la1[88] = jj_gen;
+        ;
+      }
+      jj_consume_token(EOS);
+      break;
+      }
+    default:
+      jj_la1[89] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void delayOrEventControl() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case PARA:{
+      delayContol();
+      break;
+      }
+    case AT:{
+      eventContol();
+      break;
+      }
+    default:
+      jj_la1[90] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void delayContol() throws ParseException {
+    jj_consume_token(PARA);
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case IDENT:
+    case INTEGER_LITERAL:
+    case REAL_LITERAL:
+    case STRING_LITERAL:{
+      delayValue();
+      break;
+      }
+    case LPAREN:{
+      jj_consume_token(LPAREN);
+      minTypMaxExpresstion();
+      jj_consume_token(RPAREN);
+      break;
+      }
+    default:
+      jj_la1[91] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void delayValue() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case INTEGER_LITERAL:
+    case REAL_LITERAL:
+    case STRING_LITERAL:{
+      number();
+      break;
+      }
+    case IDENT:{
+      identifierUsed();
+      break;
+      }
+    default:
+      jj_la1[92] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void identifierUsed() throws ParseException {Identifier ident;
+    ident = identifier();
+setIdentifierUsed(ident);
+  }
+
+  final public void eventContol() throws ParseException {
+    jj_consume_token(AT);
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case IDENT:{
+      identifier();
+      break;
+      }
+    case STAR:{
+      jj_consume_token(STAR);
+      break;
+      }
+    case LPAREN:{
+      jj_consume_token(LPAREN);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case EDGE:
+      case LPAREN:
+      case LBRACE:
+      case BANG:
+      case TILDE:
+      case PLUS:
+      case MINUS:
+      case BIT_AND:
+      case BIT_OR:
+      case XOR:
+      case NEG_AND:
+      case NEG_OR:
+      case NEG_XOR:
+      case XOR_NEG:
+      case IDENT:
+      case SYSTEM_IDENT:
+      case INTEGER_LITERAL:
+      case REAL_LITERAL:
+      case STRING_LITERAL:{
+        eventExpression();
+        break;
+        }
+      case STAR:{
+        jj_consume_token(STAR);
+        break;
+        }
+      default:
+        jj_la1[93] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      jj_consume_token(RPAREN);
+      break;
+      }
+    default:
+      jj_la1[94] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void eventExpression() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case LPAREN:
+    case LBRACE:
+    case BANG:
+    case TILDE:
+    case PLUS:
+    case MINUS:
+    case BIT_AND:
+    case BIT_OR:
+    case XOR:
+    case NEG_AND:
+    case NEG_OR:
+    case NEG_XOR:
+    case XOR_NEG:
+    case IDENT:
+    case SYSTEM_IDENT:
+    case INTEGER_LITERAL:
+    case REAL_LITERAL:
+    case STRING_LITERAL:{
+      expression();
+      break;
+      }
+    case EDGE:{
+      jj_consume_token(EDGE);
+      expression();
+      break;
+      }
+    default:
+      jj_la1[95] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    label_29:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case OR:
+      case COMMA:{
+        ;
+        break;
+        }
+      default:
+        jj_la1[96] = jj_gen;
+        break label_29;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case COMMA:{
+        jj_consume_token(COMMA);
+        break;
+        }
+      case OR:{
+        jj_consume_token(OR);
+        break;
+        }
+      default:
+        jj_la1[97] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case LPAREN:
+      case LBRACE:
+      case BANG:
+      case TILDE:
+      case PLUS:
+      case MINUS:
+      case BIT_AND:
+      case BIT_OR:
+      case XOR:
+      case NEG_AND:
+      case NEG_OR:
+      case NEG_XOR:
+      case XOR_NEG:
+      case IDENT:
+      case SYSTEM_IDENT:
+      case INTEGER_LITERAL:
+      case REAL_LITERAL:
+      case STRING_LITERAL:{
+        expression();
+        break;
+        }
+      case EDGE:{
+        jj_consume_token(EDGE);
+        expression();
+        break;
+        }
+      default:
+        jj_la1[98] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+  }
+
+  final public void proceduralContinuousAssignment() throws ParseException {int width;
+        Token asn;
+        Expression exp;
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case ASSIGN:{
+      jj_consume_token(ASSIGN);
+      width = lvalue();
+      asn = jj_consume_token(AGN);
+      exp = expression();
+      jj_consume_token(EOS);
+evaluateAssignment(asn, width, exp);
+      break;
+      }
+    case DEASSIGN:{
+      jj_consume_token(DEASSIGN);
+      lvalue();
+      jj_consume_token(EOS);
+      break;
+      }
+    case FORCE:{
+      jj_consume_token(FORCE);
+      width = lvalue();
+      asn = jj_consume_token(AGN);
+      exp = expression();
+      jj_consume_token(EOS);
+evaluateAssignment(asn, width, exp);
+      break;
+      }
+    case RELEASE:{
+      jj_consume_token(RELEASE);
+      lvalue();
+      jj_consume_token(EOS);
+      break;
+      }
+    default:
+      jj_la1[99] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void proceduralTimingControlStatement() throws ParseException {
+    delayOrEventControl();
+    statement();
+  }
+
+  final public void ifStatement() throws ParseException {
+    jj_consume_token(IF);
+    jj_consume_token(LPAREN);
+    expression();
+    jj_consume_token(RPAREN);
+    statement();
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case ELSE:{
+      jj_consume_token(ELSE);
+      statement();
+      break;
+      }
+    default:
+      jj_la1[100] = jj_gen;
+      ;
+    }
+  }
+
+  final public void caseStatement() throws ParseException {
+    jj_consume_token(CASE);
+    jj_consume_token(LPAREN);
+    expression();
+    jj_consume_token(RPAREN);
+    label_30:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case LPAREN:
+      case LBRACE:
+      case BANG:
+      case TILDE:
+      case PLUS:
+      case MINUS:
+      case BIT_AND:
+      case BIT_OR:
+      case XOR:
+      case NEG_AND:
+      case NEG_OR:
+      case NEG_XOR:
+      case XOR_NEG:
+      case IDENT:
+      case SYSTEM_IDENT:
+      case INTEGER_LITERAL:
+      case REAL_LITERAL:
+      case STRING_LITERAL:{
+        expression();
+        label_31:
+        while (true) {
+          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+          case COMMA:{
+            ;
+            break;
+            }
+          default:
+            jj_la1[101] = jj_gen;
+            break label_31;
+          }
+          jj_consume_token(COMMA);
+          expression();
+        }
+        jj_consume_token(COLON);
+        statement();
+        break;
+        }
+      case DEFAULT_LABEL:{
+        jj_consume_token(DEFAULT_LABEL);
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case COLON:{
+          jj_consume_token(COLON);
+          break;
+          }
+        default:
+          jj_la1[102] = jj_gen;
+          ;
+        }
+        statement();
+        break;
+        }
+      default:
+        jj_la1[103] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case DEFAULT_LABEL:
+      case LPAREN:
+      case LBRACE:
+      case BANG:
+      case TILDE:
+      case PLUS:
+      case MINUS:
+      case BIT_AND:
+      case BIT_OR:
+      case XOR:
+      case NEG_AND:
+      case NEG_OR:
+      case NEG_XOR:
+      case XOR_NEG:
+      case IDENT:
+      case SYSTEM_IDENT:
+      case INTEGER_LITERAL:
+      case REAL_LITERAL:
+      case STRING_LITERAL:{
+        ;
+        break;
+        }
+      default:
+        jj_la1[104] = jj_gen;
+        break label_30;
+      }
+    }
+    jj_consume_token(ENDCASE);
+  }
+
+  final public void whileStatement() throws ParseException {
+    jj_consume_token(WHILE);
+    jj_consume_token(LPAREN);
+    expression();
+    jj_consume_token(RPAREN);
+    statement();
+  }
+
+  final public void forStatement() throws ParseException {
+    jj_consume_token(FOR);
+    jj_consume_token(LPAREN);
+    lvalue();
+    jj_consume_token(AGN);
+    expression();
+    jj_consume_token(EOS);
+    expression();
+    jj_consume_token(EOS);
+    lvalue();
+    jj_consume_token(AGN);
+    expression();
+    jj_consume_token(RPAREN);
+    statement();
+  }
+
+  final public void foreverStatement() throws ParseException {
+    jj_consume_token(FOREVER);
+    statement();
+  }
+
+  final public void repeatStatement() throws ParseException {
+    jj_consume_token(REPEAT);
+    jj_consume_token(LPAREN);
+    expression();
+    jj_consume_token(RPAREN);
+    statement();
+  }
+
+  final public void waitStatement() throws ParseException {
+    jj_consume_token(WAIT);
+    jj_consume_token(LPAREN);
+    expression();
+    jj_consume_token(RPAREN);
+    statement();
+  }
+
+  final public void block() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case BEGIN:{
+      jj_consume_token(BEGIN);
+      break;
+      }
+    case FORK:{
+      jj_consume_token(FORK);
+      break;
+      }
+    default:
+      jj_la1[105] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case COLON:{
+      jj_consume_token(COLON);
+      identifier();
+      label_32:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case INTEGER:
+        case REG:
+        case WIRE:
+        case EVENT:
+        case GENVAR:
+        case REAL:
+        case PARAMETER:
+        case LOCALPARAM:
+        case TIME:
+        case REALTIME:
+        case DEFPARAM:
+        case SUPPLY:
+        case NET_TYPE:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[106] = jj_gen;
+          break label_32;
+        }
+        blockItem();
+      }
+      break;
+      }
+    default:
+      jj_la1[107] = jj_gen;
+      ;
+    }
+    label_33:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case BEGIN:
+      case FORK:
+      case IF:
+      case WHILE:
+      case FOR:
+      case FOREVER:
+      case REPEAT:
+      case WAIT:
+      case CASE:
+      case ASSIGN:
+      case DEASSIGN:
+      case FORCE:
+      case RELEASE:
+      case DISABLE:
+      case LBRACE:
+      case EOS:
+      case PARA:
+      case AT:
+      case IDENT:
+      case SYSTEM_IDENT:
+      case 135:{
+        ;
+        break;
+        }
+      default:
+        jj_la1[108] = jj_gen;
+        break label_33;
+      }
+      statement();
+    }
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case END:{
+      jj_consume_token(END);
+      break;
+      }
+    case JOIN:{
+      jj_consume_token(JOIN);
+      break;
+      }
+    default:
+      jj_la1[109] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void blockItem() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case PARAMETER:
+    case LOCALPARAM:{
+      parameterDecl();
+      break;
+      }
+    case INTEGER:
+    case REG:
+    case WIRE:
+    case EVENT:
+    case GENVAR:
+    case REAL:
+    case TIME:
+    case REALTIME:
+    case SUPPLY:
+    case NET_TYPE:{
+      variableDecl();
+      break;
+      }
+    case DEFPARAM:{
+      defparamDecl();
+      break;
+      }
+    default:
+      jj_la1[110] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void functionDecl() throws ParseException {
+    jj_consume_token(FUNCTION);
+begin(STATEMENT);
+    function();
+end(STATEMENT);
+  }
+
+  final public void taskDecl() throws ParseException {
+    jj_consume_token(TASK);
+begin(STATEMENT);
+    task();
+end(STATEMENT);
+  }
+
+  final public void functionOld() throws ParseException {String range;
+        Identifier name;
+        Token end ;
+    variableModifier();
+    range = bitRange();
+    name = identifier();
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case LPAREN:{
+      jj_consume_token(LPAREN);
+      skipTo(RPAREN);
+      break;
+      }
+    default:
+      jj_la1[111] = jj_gen;
+      ;
+    }
+    jj_consume_token(EOS);
+beginOutlineElement(name, "function#" + range);
+    end = skipTo(ENDFUNCTION);
+endOutlineElement(end, name.image, "function#" + range);
+                addCollapsible(name.beginLine, end.endLine);
+  }
+
+  final public void function() throws ParseException {String range;
+        Identifier name;
+        Token end ;
+        int pos;
+        String [] deps;
+    variableModifier();
+    //	range = bitRange()
+            range = bitRangeWithDepend();
+    name = identifier();
+pos=range.indexOf("]");
+                if (( pos >0 ) && ( pos < ( range.length() - 1 )))      { // contains dependencies
+                        deps=range.split( "]" );
+                        range=deps[0] + "]";
+                name.setEncodedDepends(deps[1]);
+                }
+                beginOutlineElement(name, "function#" + range);
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case LPAREN:{
+      jj_consume_token(LPAREN);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case INPUT:
+      case IDENT:{
+        functionArgument();
+        label_34:
+        while (true) {
+          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+          case COMMA:{
+            ;
+            break;
+            }
+          default:
+            jj_la1[112] = jj_gen;
+            break label_34;
+          }
+          jj_consume_token(COMMA);
+          functionArgument();
+        }
+        break;
+        }
+      default:
+        jj_la1[113] = jj_gen;
+        ;
+      }
+      jj_consume_token(RPAREN);
+      break;
+      }
+    default:
+      jj_la1[114] = jj_gen;
+      ;
+    }
+    jj_consume_token(EOS);
+    label_35:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case INPUT:
+      case INTEGER:
+      case REG:
+      case WIRE:
+      case EVENT:
+      case GENVAR:
+      case REAL:
+      case PARAMETER:
+      case LOCALPARAM:
+      case TIME:
+      case REALTIME:
+      case DEFPARAM:
+      case SUPPLY:
+      case NET_TYPE:{
+        ;
+        break;
+        }
+      default:
+        jj_la1[115] = jj_gen;
+        break label_35;
+      }
+      functionItem();
+    }
+    statement();
+    // TODO: limit what is allowed in a function
+    
+            end = jj_consume_token(ENDFUNCTION);
+endOutlineElement(end, name.image, "function#" + range);
+                addCollapsible(name.beginLine, end.endLine);
+  }
+
+  final public void functionItem() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case INPUT:{
+      functionPortDecl();
+      break;
+      }
+    case INTEGER:
+    case REG:
+    case WIRE:
+    case EVENT:
+    case GENVAR:
+    case REAL:
+    case TIME:
+    case REALTIME:
+    case SUPPLY:
+    case NET_TYPE:{
+      variableDecl();
+      break;
+      }
+    case PARAMETER:
+    case LOCALPARAM:{
+      parameterDecl();
+      break;
+      }
+    case DEFPARAM:{
+      defparamDecl();
+      break;
+      }
+    default:
+      jj_la1[116] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void taskOld() throws ParseException {Identifier name;
+        Token end ;
+    name = identifier();
+    jj_consume_token(EOS);
+beginOutlineElement(name, "task#");
+    label_36:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case INPUT:
+      case OUTPUT:
+      case INOUT:
+      case INTEGER:
+      case REG:
+      case WIRE:
+      case EVENT:
+      case GENVAR:
+      case REAL:
+      case PARAMETER:
+      case LOCALPARAM:
+      case TIME:
+      case REALTIME:
+      case DEFPARAM:
+      case SUPPLY:
+      case NET_TYPE:{
+        ;
+        break;
+        }
+      default:
+        jj_la1[117] = jj_gen;
+        break label_36;
+      }
+      taskItem();
+    }
+    statement();
+    end = jj_consume_token(ENDTASK);
+endOutlineElement(end, name.image, "task#");
+                addCollapsible(name.beginLine, end.endLine);
+  }
+
+  final public void task() throws ParseException {Identifier name;
+        Token end ;
+    name = identifier();
+beginOutlineElement(name, "task#");
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case LPAREN:{
+      jj_consume_token(LPAREN);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case INPUT:
+      case OUTPUT:
+      case INOUT:
+      case IDENT:{
+        argument();
+        label_37:
+        while (true) {
+          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+          case COMMA:{
+            ;
+            break;
+            }
+          default:
+            jj_la1[118] = jj_gen;
+            break label_37;
+          }
+          jj_consume_token(COMMA);
+          argument();
+        }
+        break;
+        }
+      default:
+        jj_la1[119] = jj_gen;
+        ;
+      }
+      jj_consume_token(RPAREN);
+      break;
+      }
+    default:
+      jj_la1[120] = jj_gen;
+      ;
+    }
+    jj_consume_token(EOS);
+    label_38:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case INPUT:
+      case OUTPUT:
+      case INOUT:
+      case INTEGER:
+      case REG:
+      case WIRE:
+      case EVENT:
+      case GENVAR:
+      case REAL:
+      case PARAMETER:
+      case LOCALPARAM:
+      case TIME:
+      case REALTIME:
+      case DEFPARAM:
+      case SUPPLY:
+      case NET_TYPE:{
+        ;
+        break;
+        }
+      default:
+        jj_la1[121] = jj_gen;
+        break label_38;
+      }
+      taskItem();
+    }
+    statement();
+    end = jj_consume_token(ENDTASK);
+endOutlineElement(end, name.image, "task#");
+                addCollapsible(name.beginLine, end.endLine);
+  }
+
+  final public void taskItem() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case INPUT:
+    case OUTPUT:
+    case INOUT:{
+      portDecl();
+      break;
+      }
+    case INTEGER:
+    case REG:
+    case WIRE:
+    case EVENT:
+    case GENVAR:
+    case REAL:
+    case TIME:
+    case REALTIME:
+    case SUPPLY:
+    case NET_TYPE:{
+      variableDecl();
+      break;
+      }
+    case PARAMETER:
+    case LOCALPARAM:{
+      parameterDecl();
+      break;
+      }
+    case DEFPARAM:{
+      defparamDecl();
+      break;
+      }
+    default:
+      jj_la1[122] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void generate() throws ParseException {
+    jj_consume_token(GENERATE);
+    label_39:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case BEGIN:
+      case IF:
+      case FOR:
+      case CASE:
+      case FUNCTION:
+      case TASK:
+      case INTEGER:
+      case REG:
+      case WIRE:
+      case EVENT:
+      case GENVAR:
+      case REAL:
+      case PARAMETER:
+      case LOCALPARAM:
+      case ASSERT:
+      case ASSIGN:
+      case TIME:
+      case REALTIME:
+      case DEFPARAM:
+      case OR:
+      case ALWAYS:
+      case INITIAL:
+      case SUPPLY:
+      case NET_TYPE:
+      case PRIM_1IN_XOUT:
+      case PRIM_1OUT_XIN:
+      case PRIM_1OUT_1IN_1CNTL:
+      case PRIM_1OUT:
+      case PRIM_1OUT_1IN_NC_PC:
+      case PRIM_BI:
+      case EOS:
+      case IDENT:{
+        ;
+        break;
+        }
+      default:
+        jj_la1[123] = jj_gen;
+        break label_39;
+      }
+      generateItem();
+    }
+    jj_consume_token(ENDGENERATE);
+  }
+
+  final public void generateItem() throws ParseException {Identifier block = null;
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case FUNCTION:
+    case TASK:
+    case INTEGER:
+    case REG:
+    case WIRE:
+    case EVENT:
+    case GENVAR:
+    case REAL:
+    case PARAMETER:
+    case LOCALPARAM:
+    case ASSERT:
+    case ASSIGN:
+    case TIME:
+    case REALTIME:
+    case DEFPARAM:
+    case OR:
+    case ALWAYS:
+    case INITIAL:
+    case SUPPLY:
+    case NET_TYPE:
+    case PRIM_1IN_XOUT:
+    case PRIM_1OUT_XIN:
+    case PRIM_1OUT_1IN_1CNTL:
+    case PRIM_1OUT:
+    case PRIM_1OUT_1IN_NC_PC:
+    case PRIM_BI:
+    case EOS:
+    case IDENT:{
+      moduleOrGenerateItem();
+      break;
+      }
+    case IF:{
+      generateIfStatement();
+      break;
+      }
+    case CASE:{
+      generateCaseStatement();
+      break;
+      }
+    case FOR:{
+      generateForStatement();
+      break;
+      }
+    case BEGIN:{
+      jj_consume_token(BEGIN);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case COLON:{
+        jj_consume_token(COLON);
+        block = identifier();
+        break;
+        }
+      default:
+        jj_la1[124] = jj_gen;
+        ;
+      }
+if (block != null)
+                                beginGenerateBlock(block);
+      label_40:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case BEGIN:
+        case IF:
+        case FOR:
+        case CASE:
+        case FUNCTION:
+        case TASK:
+        case INTEGER:
+        case REG:
+        case WIRE:
+        case EVENT:
+        case GENVAR:
+        case REAL:
+        case PARAMETER:
+        case LOCALPARAM:
+        case ASSERT:
+        case ASSIGN:
+        case TIME:
+        case REALTIME:
+        case DEFPARAM:
+        case OR:
+        case ALWAYS:
+        case INITIAL:
+        case SUPPLY:
+        case NET_TYPE:
+        case PRIM_1IN_XOUT:
+        case PRIM_1OUT_XIN:
+        case PRIM_1OUT_1IN_1CNTL:
+        case PRIM_1OUT:
+        case PRIM_1OUT_1IN_NC_PC:
+        case PRIM_BI:
+        case EOS:
+        case IDENT:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[125] = jj_gen;
+          break label_40;
+        }
+        generateItem();
+      }
+      jj_consume_token(END);
+if (block != null) {
+                                endGenerateBlock(block);
+                        }
+      break;
+      }
+    default:
+      jj_la1[126] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void generateIfStatement() throws ParseException {
+    jj_consume_token(IF);
+    jj_consume_token(LPAREN);
+    constantExpression();
+    jj_consume_token(RPAREN);
+    generateItem();
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case ELSE:{
+      jj_consume_token(ELSE);
+      generateItem();
+      break;
+      }
+    default:
+      jj_la1[127] = jj_gen;
+      ;
+    }
+  }
+
+  final public void generateCaseStatement() throws ParseException {
+    jj_consume_token(CASE);
+    jj_consume_token(LPAREN);
+    constantExpression();
+    jj_consume_token(RPAREN);
+    label_41:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case LPAREN:
+      case LBRACE:
+      case BANG:
+      case TILDE:
+      case PLUS:
+      case MINUS:
+      case BIT_AND:
+      case BIT_OR:
+      case XOR:
+      case NEG_AND:
+      case NEG_OR:
+      case NEG_XOR:
+      case XOR_NEG:
+      case IDENT:
+      case SYSTEM_IDENT:
+      case INTEGER_LITERAL:
+      case REAL_LITERAL:
+      case STRING_LITERAL:{
+        constantExpression();
+        label_42:
+        while (true) {
+          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+          case COMMA:{
+            ;
+            break;
+            }
+          default:
+            jj_la1[128] = jj_gen;
+            break label_42;
+          }
+          jj_consume_token(COMMA);
+          constantExpression();
+        }
+        jj_consume_token(COLON);
+        generateItem();
+        break;
+        }
+      case DEFAULT_LABEL:{
+        jj_consume_token(DEFAULT_LABEL);
+        jj_consume_token(COLON);
+        generateItem();
+        break;
+        }
+      default:
+        jj_la1[129] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case DEFAULT_LABEL:
+      case LPAREN:
+      case LBRACE:
+      case BANG:
+      case TILDE:
+      case PLUS:
+      case MINUS:
+      case BIT_AND:
+      case BIT_OR:
+      case XOR:
+      case NEG_AND:
+      case NEG_OR:
+      case NEG_XOR:
+      case XOR_NEG:
+      case IDENT:
+      case SYSTEM_IDENT:
+      case INTEGER_LITERAL:
+      case REAL_LITERAL:
+      case STRING_LITERAL:{
+        ;
+        break;
+        }
+      default:
+        jj_la1[130] = jj_gen;
+        break label_41;
+      }
+    }
+    jj_consume_token(ENDCASE);
+  }
+
+  final public void generateForStatement() throws ParseException {
+    jj_consume_token(FOR);
+    jj_consume_token(LPAREN);
+    lvalue();
+    jj_consume_token(AGN);
+    expression();
+    jj_consume_token(EOS);
+    expression();
+    jj_consume_token(EOS);
+    lvalue();
+    jj_consume_token(AGN);
+    expression();
+    jj_consume_token(RPAREN);
+    generateItem();
+  }
+
+  final public String netType() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case WIRE:{
+      jj_consume_token(WIRE);
+      break;
+      }
+    case NET_TYPE:{
+      jj_consume_token(NET_TYPE);
+      break;
+      }
+    case SUPPLY:{
+      jj_consume_token(SUPPLY);
+      break;
+      }
+    default:
+      jj_la1[131] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+{if ("" != null) return token.image;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public void strength() throws ParseException {
+    jj_consume_token(LPAREN);
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case STRENGTH:{
+      jj_consume_token(STRENGTH);
+      break;
+      }
+    case SUPPLY:{
+      jj_consume_token(SUPPLY);
+      break;
+      }
+    default:
+      jj_la1[132] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case COMMA:{
+      jj_consume_token(COMMA);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case STRENGTH:{
+        jj_consume_token(STRENGTH);
+        break;
+        }
+      case SUPPLY:{
+        jj_consume_token(SUPPLY);
+        break;
+        }
+      default:
+        jj_la1[133] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      break;
+      }
+    default:
+      jj_la1[134] = jj_gen;
+      ;
+    }
+    jj_consume_token(RPAREN);
+  }
+
+  final public int lvalue() throws ParseException {int width;
+        Identifier ident;
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case IDENT:{
+      ident = complexIdentifier();
+variableAssignment(ident);
+                {if ("" != null) return ident.getWidth();}
+      break;
+      }
+    case LBRACE:{
+      width = lvalueConcatenation();
+{if ("" != null) return width;}
+      break;
+      }
+    default:
+      jj_la1[135] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    throw new Error("Missing return statement in function");
+  }
+
+  final public int lvalueConcatenation() throws ParseException {int width;
+        int ret;
+    jj_consume_token(LBRACE);
+    ret = lvalue();
+    label_43:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case COMMA:{
+        ;
+        break;
+        }
+      default:
+        jj_la1[136] = jj_gen;
+        break label_43;
+      }
+      jj_consume_token(COMMA);
+      width = lvalue();
+if (width == 0 || ret == 0)
+                                ret = 0;
+                        else
+                                ret += width;
+    }
+    jj_consume_token(RBRACE);
+{if ("" != null) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Identifier identifier() throws ParseException {Token token;
+    token = jj_consume_token(IDENT);
+{if ("" != null) return new Identifier(token);}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Expression constantExpression() throws ParseException {Expression ret;
+    ret = expression();
+{if ("" != null) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Expression expression() throws ParseException {Expression ret, exp1, exp2;
+        Token op;
+    ret = logicalOrExpresstion();
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case HOOK:{
+      op = jj_consume_token(HOOK);
+      exp1 = expression();
+      jj_consume_token(COLON);
+      exp2 = expression();
+ret = operator(ret, op, exp1, exp2);
+      break;
+      }
+    default:
+      jj_la1[137] = jj_gen;
+      ;
+    }
+{if ("" != null) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Expression logicalOrExpresstion() throws ParseException {Expression ret, exp;
+        Token op;
+    ret = logicalAndExpresstion();
+    label_44:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case SC_OR:{
+        ;
+        break;
+        }
+      default:
+        jj_la1[138] = jj_gen;
+        break label_44;
+      }
+      op = jj_consume_token(SC_OR);
+      exp = logicalAndExpresstion();
+ret = operator(ret, op, exp);
+    }
+{if ("" != null) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Expression logicalAndExpresstion() throws ParseException {Expression ret, exp;
+        Token op;
+    ret = bitOrExpresstion();
+    label_45:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case SC_AND:{
+        ;
+        break;
+        }
+      default:
+        jj_la1[139] = jj_gen;
+        break label_45;
+      }
+      op = jj_consume_token(SC_AND);
+      exp = bitOrExpresstion();
+ret = operator(ret, op, exp);
+    }
+{if ("" != null) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Expression bitOrExpresstion() throws ParseException {Expression ret, exp;
+        Token op;
+    ret = bitAndExpresstion();
+    label_46:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case BIT_OR:{
+        ;
+        break;
+        }
+      default:
+        jj_la1[140] = jj_gen;
+        break label_46;
+      }
+      op = jj_consume_token(BIT_OR);
+      exp = bitAndExpresstion();
+ret = operator(ret, op, exp);
+    }
+{if ("" != null) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Expression bitAndExpresstion() throws ParseException {Expression ret, exp;
+        Token op;
+    ret = equalityExpression();
+    label_47:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case BIT_AND:
+      case XOR:
+      case NEG_XOR:
+      case XOR_NEG:{
+        ;
+        break;
+        }
+      default:
+        jj_la1[141] = jj_gen;
+        break label_47;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case BIT_AND:{
+        op = jj_consume_token(BIT_AND);
+        break;
+        }
+      case XOR:{
+        op = jj_consume_token(XOR);
+        break;
+        }
+      case NEG_XOR:{
+        op = jj_consume_token(NEG_XOR);
+        break;
+        }
+      case XOR_NEG:{
+        op = jj_consume_token(XOR_NEG);
+        break;
+        }
+      default:
+        jj_la1[142] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      exp = equalityExpression();
+ret = operator(ret, op, exp);
+    }
+{if ("" != null) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Expression equalityExpression() throws ParseException {Expression ret, exp;
+        Token op;
+    ret = relationalExpression();
+    label_48:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case EQ:
+      case NE:
+      case EQ_C:
+      case NE_C:{
+        ;
+        break;
+        }
+      default:
+        jj_la1[143] = jj_gen;
+        break label_48;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case EQ:{
+        op = jj_consume_token(EQ);
+        break;
+        }
+      case EQ_C:{
+        op = jj_consume_token(EQ_C);
+        break;
+        }
+      case NE:{
+        op = jj_consume_token(NE);
+        break;
+        }
+      case NE_C:{
+        op = jj_consume_token(NE_C);
+        break;
+        }
+      default:
+        jj_la1[144] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      exp = relationalExpression();
+ret = operator(ret, op, exp);
+    }
+{if ("" != null) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Expression relationalExpression() throws ParseException {Expression ret, exp;
+        Token op;
+    ret = shiftExpression();
+    label_49:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case GT:
+      case LT:
+      case LE:
+      case GE:{
+        ;
+        break;
+        }
+      default:
+        jj_la1[145] = jj_gen;
+        break label_49;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case LT:{
+        op = jj_consume_token(LT);
+        break;
+        }
+      case LE:{
+        op = jj_consume_token(LE);
+        break;
+        }
+      case GT:{
+        op = jj_consume_token(GT);
+        break;
+        }
+      case GE:{
+        op = jj_consume_token(GE);
+        break;
+        }
+      default:
+        jj_la1[146] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      exp = shiftExpression();
+ret = operator(ret, op, exp);
+    }
+{if ("" != null) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Expression shiftExpression() throws ParseException {Expression ret, exp;
+        Token op;
+    ret = addExpression();
+    label_50:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case LSHIFT:
+      case RSHIFT:
+      case ALSHIFT:
+      case ARSHIFT:{
+        ;
+        break;
+        }
+      default:
+        jj_la1[147] = jj_gen;
+        break label_50;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case LSHIFT:{
+        op = jj_consume_token(LSHIFT);
+        break;
+        }
+      case RSHIFT:{
+        op = jj_consume_token(RSHIFT);
+        break;
+        }
+      case ALSHIFT:{
+        op = jj_consume_token(ALSHIFT);
+        break;
+        }
+      case ARSHIFT:{
+        op = jj_consume_token(ARSHIFT);
+        break;
+        }
+      default:
+        jj_la1[148] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      exp = addExpression();
+ret = operator(ret, op, exp);
+    }
+{if ("" != null) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Expression addExpression() throws ParseException {Expression ret, exp;
+        Token op;
+    ret = multiplyExpression();
+    label_51:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case PLUS:
+      case MINUS:{
+        ;
+        break;
+        }
+      default:
+        jj_la1[149] = jj_gen;
+        break label_51;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case PLUS:{
+        op = jj_consume_token(PLUS);
+        break;
+        }
+      case MINUS:{
+        op = jj_consume_token(MINUS);
+        break;
+        }
+      default:
+        jj_la1[150] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      exp = multiplyExpression();
+ret = operator(ret, op, exp);
+    }
+{if ("" != null) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Expression multiplyExpression() throws ParseException {Expression ret, exp;
+        Token op;
+    ret = unaryExpression();
+    label_52:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case STAR:
+      case SLASH:
+      case REM:
+      case POWER:{
+        ;
+        break;
+        }
+      default:
+        jj_la1[151] = jj_gen;
+        break label_52;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case STAR:{
+        op = jj_consume_token(STAR);
+        break;
+        }
+      case SLASH:{
+        op = jj_consume_token(SLASH);
+        break;
+        }
+      case REM:{
+        op = jj_consume_token(REM);
+        break;
+        }
+      case POWER:{
+        op = jj_consume_token(POWER);
+        break;
+        }
+      default:
+        jj_la1[152] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      exp = unaryExpression();
+ret = operator(ret, op, exp);
+    }
+{if ("" != null) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Expression unaryExpression() throws ParseException {Expression ret, exp;
+        Token op = null;
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case BANG:
+    case TILDE:
+    case PLUS:
+    case MINUS:
+    case BIT_AND:
+    case BIT_OR:
+    case XOR:
+    case NEG_AND:
+    case NEG_OR:
+    case NEG_XOR:
+    case XOR_NEG:{
+      op = unaryOperator();
+      break;
+      }
+    default:
+      jj_la1[153] = jj_gen;
+      ;
+    }
+    ret = primary();
+if (op != null)
+                        {if ("" != null) return operator(ret, op);}
+                else
+                        {if ("" != null) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Expression primary() throws ParseException {Expression ret;
+        Identifier ident;
+        boolean isFunc = false;
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case INTEGER_LITERAL:
+    case REAL_LITERAL:
+    case STRING_LITERAL:{
+      ret = number();
+      break;
+      }
+    case IDENT:{
+      ident = complexIdentifier();
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case LPAREN:{
+        functionArgs(ident);
+isFunc = true;
+        break;
+        }
+      default:
+        jj_la1[154] = jj_gen;
+        ;
+      }
+if (isFunc) {
+                                ret = functionReference(ident);
+                        } else {
+                                ret = variableReference(ident);
+                        }
+      break;
+      }
+    case SYSTEM_IDENT:{
+      jj_consume_token(SYSTEM_IDENT);
+      label_53:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case SYSTEM_IDENT:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[155] = jj_gen;
+          break label_53;
+        }
+        jj_consume_token(SYSTEM_IDENT);
+      }
+      if (jj_2_8(2)) {
+        sysFunctionArgs();
+      } else {
+        ;
+      }
+ret = new Expression();
+      break;
+      }
+    case LBRACE:{
+      ret = concatenation();
+      break;
+      }
+    case LPAREN:{
+      jj_consume_token(LPAREN);
+      ret = minTypMaxExpresstion();
+      jj_consume_token(RPAREN);
+      break;
+      }
+    default:
+      jj_la1[156] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+if (ret == null)
+                        {if ("" != null) return new Expression();}
+                else
+                        {if ("" != null) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Identifier complexIdentifier() throws ParseException {Identifier ident, concat;
+        Token token;
+    ident = identifier();
+    bitOrAry(ident);
+    label_54:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case AT:
+      case DOT:{
+        ;
+        break;
+        }
+      default:
+        jj_la1[157] = jj_gen;
+        break label_54;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case AT:{
+        token = jj_consume_token(AT);
+        break;
+        }
+      case DOT:{
+        token = jj_consume_token(DOT);
+        break;
+        }
+      default:
+        jj_la1[158] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      concat = identifier();
+      bitOrAry(concat);
+ident.endLine = concat.endLine;
+                        ident.endColumn = concat.endColumn;
+                        ident.image += token.image + concat.image;
+                        ident.setWidth(concat.getWidthBit());
+                        ident.setDimension(concat.getDimension());
+                        ident.setEncodedDepends(concat.getEncodedDepends()); //Andrey: trying to add dependency on parameters used in bit selection
+
+    }
+{if ("" != null) return ident;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Expression minTypMaxExpresstion() throws ParseException {Expression exp;
+    exp = expression();
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case COLON:{
+      jj_consume_token(COLON);
+      expression();
+      jj_consume_token(COLON);
+      expression();
+      break;
+      }
+    default:
+      jj_la1[159] = jj_gen;
+      ;
+    }
+{if ("" != null) return exp;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public void bitOrAry(Identifier ident) throws ParseException {int width = 0;
+        int lowBit = 0;
+        int dim = 0;
+        Expression msb=null, lsb;
+        Token token=null;
+    label_55:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case LBRACKET:{
+        ;
+        break;
+        }
+      default:
+        jj_la1[160] = jj_gen;
+        break label_55;
+      }
+      jj_consume_token(LBRACKET);
+      msb = expression();
+width = 1;
+                        dim++;
+                        if (msb.isValid())
+                                lowBit = msb.intValue();
+                        else
+                            badBitRange(ident, msb.stringValue());
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case COLON:
+      case PCOLON:
+      case MCOLON:{
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case COLON:{
+          token = jj_consume_token(COLON);
+          break;
+          }
+        case PCOLON:{
+          token = jj_consume_token(PCOLON);
+          break;
+          }
+        case MCOLON:{
+          token = jj_consume_token(MCOLON);
+          break;
+          }
+        default:
+          jj_la1[161] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+        lsb = expression();
+msb.addAllDepends(lsb);
+                                if (token.image.equals(":"))
+                                 {
+                                        if (msb.isValid() && lsb.isValid())
+                                        {
+                                                width = msb.intValue() - lsb.intValue() + 1;
+                                                lowBit = lsb.intValue();
+                                    }
+                                else
+                                {
+                                                width = 0;
+                                                lowBit = 0;
+                                                if (!lsb.isValid())
+                                                    badBitRange(ident, lsb.stringValue());
+                                        }
+                                } else if (token.image.equals("+:")){ // indexed part-select
+                                        if (lsb.isValid())
+                                                width = lsb.intValue();
+                                        else
+                                        {
+                                                width = 0;
+                                            badBitRange(ident, lsb.stringValue());
+                                        }
+                                        if (msb.isValid())
+                                                lowBit = msb.intValue();
+                                else
+                                                lowBit = 0;
+                                } else if (token.image.equals("-:")){ // indexed part-select
+                                        if (lsb.isValid())
+                                                width = lsb.intValue();
+                                        else
+                                                width = 0;
+                                        if (msb.isValid())
+                                                lowBit = msb.intValue()-width +((width >0)?1:0);
+                                else
+                                                lowBit = 0;
+                                        if (!lsb.isValid() && !msb.isValid())
+                                                badBitRange(ident, lsb.stringValue());
+                                } else { // dead code?
+                                        if (lsb.isValid())
+                                        {
+                                                width = lsb.intValue();
+//						width = 1;
+//						lowBit = lsb.intValue();
+                                        }
+                                        else
+                                        {
+                                                width = 0;
+                                            badBitRange(ident, lsb.stringValue());
+                                        }
+                                }
+        break;
+        }
+      default:
+        jj_la1[162] = jj_gen;
+        ;
+      }
+      token = jj_consume_token(RBRACKET);
+    }
+ident.setWidth(width,lowBit);
+                ident.setDimension(dim);
+                ident.extendPosition(token); // is token pointing to "]" ?
+                if (msb!=null) ident.setEncodedDepends(msb.encodeDepends());
+  }
+
+  final public String bitRangeWithDepend() throws ParseException {Expression msb, lsb;
+        String depends;
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case LBRACKET:{
+      jj_consume_token(LBRACKET);
+      msb = expression();
+      jj_consume_token(COLON);
+      lsb = expression();
+      jj_consume_token(RBRACKET);
+msb.addAllDepends(lsb);
+                        depends=msb.encodeDepends();
+                        if (msb.isValid() && lsb.isValid())
+                        {
+                                {if ("" != null) return "[" + msb.intValue() + ":" + lsb.intValue() + "]" + depends;}
+                        }
+                        else
+                                {if ("" != null) return "[X]" + depends;} // invalid width
+
+      break;
+      }
+    default:
+      jj_la1[163] = jj_gen;
+      ;
+    }
+{if ("" != null) return "";} // No bit range
+
+    throw new Error("Missing return statement in function");
+  }
+
+//TODO: Andrey:  bitRange() maybe needed to be upgraded to bitRangeWithDepend(), as for ports
+  final public String bitRange() throws ParseException {Expression msb, lsb;
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case LBRACKET:{
+      jj_consume_token(LBRACKET);
+      msb = expression();
+      jj_consume_token(COLON);
+      lsb = expression();
+      jj_consume_token(RBRACKET);
+if (msb.isValid() && lsb.isValid())
+                                {if ("" != null) return "[" + msb.intValue() + ":" + lsb.intValue() + "]";}
+                        else
+                                {if ("" != null) return "";}
+      break;
+      }
+    default:
+      jj_la1[164] = jj_gen;
+      ;
+    }
+{if ("" != null) return "";}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Token unaryOperator() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case TILDE:{
+      jj_consume_token(TILDE);
+      break;
+      }
+    case PLUS:{
+      jj_consume_token(PLUS);
+      break;
+      }
+    case MINUS:{
+      jj_consume_token(MINUS);
+      break;
+      }
+    case BANG:{
+      jj_consume_token(BANG);
+      break;
+      }
+    case BIT_AND:{
+      jj_consume_token(BIT_AND);
+      break;
+      }
+    case NEG_AND:{
+      jj_consume_token(NEG_AND);
+      break;
+      }
+    case BIT_OR:{
+      jj_consume_token(BIT_OR);
+      break;
+      }
+    case NEG_OR:{
+      jj_consume_token(NEG_OR);
+      break;
+      }
+    case XOR:{
+      jj_consume_token(XOR);
+      break;
+      }
+    case NEG_XOR:{
+      jj_consume_token(NEG_XOR);
+      break;
+      }
+    case XOR_NEG:{
+      jj_consume_token(XOR_NEG);
+      break;
+      }
+    default:
+      jj_la1[165] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+{if ("" != null) return token;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public Expression concatenation() throws ParseException {int width;
+        int value;
+        boolean valid;
+        boolean assignable;
+        Expression exp;
+        Expression refs = new Expression();
+    jj_consume_token(LBRACE);
+    exp = expression();
+width = exp.getWidth();
+                value = exp.intValue();
+                valid = exp.isValid();
+                assignable = exp.isAssignable();
+                refs.addReference(exp);
+                refs.extendPosition(exp);
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case LBRACE:
+    case COMMA:{
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case COMMA:{
+        label_56:
+        while (true) {
+          jj_consume_token(COMMA);
+          exp = expression();
+if (width == 0 || exp.getWidth() == 0)
+                                width = 0;
+                        else
+                                width += exp.getWidth();
+                        value = (value << width) | exp.intValue();
+                        valid = valid && exp.isValid();
+                        assignable = assignable && exp.isAssignable();
+                        refs.addReference(exp);
+                        refs.extendPosition(exp);
+          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+          case COMMA:{
+            ;
+            break;
+            }
+          default:
+            jj_la1[166] = jj_gen;
+            break label_56;
+          }
+        }
+        break;
+        }
+      case LBRACE:{
+        jj_consume_token(LBRACE);
+        exp = expression();
+        jj_consume_token(RBRACE);
+width = valid ? (value * exp.getWidth()) : 0;
+                        value = exp.intValue();
+                        valid = exp.isValid();
+                        assignable = exp.isAssignable();
+                        exp.extendPosition(refs);
+                        refs = exp;
+        break;
+        }
+      default:
+        jj_la1[167] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      break;
+      }
+    default:
+      jj_la1[168] = jj_gen;
+      ;
+    }
+    jj_consume_token(RBRACE);
+Expression ret = new Expression(width);
+                if (valid)
+                        ret.setValue(value);
+                ret.setAssignable(assignable);
+                ret.addReference(refs);
+                ret.extendPosition(refs);
+                {if ("" != null) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+// for system functions - no checks of arguments
+  final public void sysFunctionArgs() throws ParseException {
+    jj_consume_token(LPAREN);
+    expression();
+    label_57:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case COMMA:{
+        ;
+        break;
+        }
+      default:
+        jj_la1[169] = jj_gen;
+        break label_57;
+      }
+      jj_consume_token(COMMA);
+      expression();
+    }
+    jj_consume_token(RPAREN);
+  }
+
+// for normal functions
+  final public void functionArgs(Identifier ident) throws ParseException {Token iend;
+    jj_consume_token(LPAREN);
+beginOutlineElement(ident, ident.image+":"+ident.beginLine+":"+ident.beginColumn, "functionreference#"+ident.image);
+    portConnect(ident.image, PORT_TYPE.FUNCTION);
+    iend = jj_consume_token(RPAREN);
+endOutlineElement(iend, ident.image+":"+ident.beginLine+":"+ident.beginColumn, "functionreference#"+ident.image);
+                        addCollapsible(ident.beginLine, iend.endLine);
+  }
+
+  final public Expression number() throws ParseException {Expression ret = new Expression();
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case INTEGER_LITERAL:{
+      jj_consume_token(INTEGER_LITERAL);
+ret.parseIntegerLiteral(token.image);
+      break;
+      }
+    case REAL_LITERAL:{
+      jj_consume_token(REAL_LITERAL);
+ret.parseRealLiteral(token.image);
+      break;
+      }
+    case STRING_LITERAL:{
+      jj_consume_token(STRING_LITERAL);
+ret.parseStringLiteral(token.image);
+      break;
+      }
+    default:
+      jj_la1[170] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+ret.extendPosition(token);
+                {if ("" != null) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  void unexpectedEof(Token token) throws ParseException {ParseException ex = new ParseException("unexpected EOF");
+        ex.currentToken = token;
+        throw ex;
+  }
+
+  Token skipTo(int skip) throws ParseException {Token current = token;
+        Token token ;
+        StringBuffer image = new StringBuffer();
+
+        for(;;)
+        {
+                token = getToken(1);
+                if (token.kind == EOF)
+                        unexpectedEof(current);
+                if (token.kind == skip)
+                {
+                        getNextToken();
+                        break ;
+                }
+
+                image.append(token.image);
+                getNextToken();
+        }
+        token.image = image.toString();
+        return token ;
+  }
+
+  private boolean jj_2_1(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_1(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(0, xla); }
+  }
+
+  private boolean jj_2_2(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_2(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(1, xla); }
+  }
+
+  private boolean jj_2_3(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_3(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(2, xla); }
+  }
+
+  private boolean jj_2_4(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_4(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(3, xla); }
+  }
+
+  private boolean jj_2_5(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_5(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(4, xla); }
+  }
+
+  private boolean jj_2_6(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_6(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(5, xla); }
+  }
+
+  private boolean jj_2_7(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_7(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(6, xla); }
+  }
+
+  private boolean jj_2_8(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_8(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(7, xla); }
+  }
+
+  private boolean jj_3R_68()
+ {
+    if (jj_3R_75()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_75()
+ {
+    if (jj_3R_63()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_109()
+ {
+    if (jj_3R_74()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_90()
+ {
+    if (jj_3R_93()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_108()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(93)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(104)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(105)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(92)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(108)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(114)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(109)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(115)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(110)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(116)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(117)) return true;
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_110()
+ {
+    if (jj_3R_114()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_115()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_67()
+ {
+    if (jj_3R_74()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_61()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_67()) {
+    jj_scanpos = xsp;
+    if (jj_3R_68()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_107()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_109()) {
+    jj_scanpos = xsp;
+    if (jj_3R_110()) {
+    jj_scanpos = xsp;
+    if (jj_3R_111()) {
+    jj_scanpos = xsp;
+    if (jj_3R_112()) {
+    jj_scanpos = xsp;
+    if (jj_3R_113()) return true;
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_93()
+ {
+    if (jj_3R_63()) return true;
+    return false;
+  }
+
+  private boolean jj_3_1()
+ {
+    if (jj_3R_58()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_63()
+ {
+    if (jj_scan_token(IDENT)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_89()
+ {
+    if (jj_3R_74()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_84()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_89()) {
+    jj_scanpos = xsp;
+    if (jj_3R_90()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_106()
+ {
+    if (jj_3R_108()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_104()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_106()) jj_scanpos = xsp;
+    if (jj_3R_107()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_70()
+ {
+    if (jj_scan_token(LPAREN)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_65()
+ {
+    if (jj_scan_token(LPAREN)) return true;
+    if (jj_3R_71()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_76()
+ {
+    if (jj_3R_84()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_105()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(106)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(107)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(111)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(120)) return true;
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_69()
+ {
+    if (jj_scan_token(PARA)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_76()) {
+    jj_scanpos = xsp;
+    if (jj_3R_77()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3_5()
+ {
+    if (jj_3R_60()) return true;
+    if (jj_scan_token(COMMA)) return true;
+    return false;
+  }
+
+  private boolean jj_3_4()
+ {
+    if (jj_3R_60()) return true;
+    if (jj_scan_token(COMMA)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_64()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_69()) jj_scanpos = xsp;
+    if (jj_3R_63()) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_70()) jj_scanpos = xsp;
+    if (jj_scan_token(EOS)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_102()
+ {
+    if (jj_3R_104()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_105()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_103()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(104)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(105)) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_58()
+ {
+    if (jj_3R_63()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_64()) {
+    jj_scanpos = xsp;
+    if (jj_3R_65()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_59()
+ {
+    if (jj_scan_token(LPAREN)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(70)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(68)) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_100()
+ {
+    if (jj_3R_102()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_103()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_60()
+ {
+    if (jj_3R_66()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_101()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(112)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(113)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(121)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(122)) return true;
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_98()
+ {
+    if (jj_3R_100()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_101()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_99()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(91)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(99)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(90)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(100)) return true;
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3_6()
+ {
+    if (jj_3R_59()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_96()
+ {
+    if (jj_3R_98()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_99()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3_3()
+ {
+    if (jj_3R_59()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_97()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(98)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(118)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(101)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(119)) return true;
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_83()
+ {
+    if (jj_scan_token(STRING_LITERAL)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_82()
+ {
+    if (jj_scan_token(REAL_LITERAL)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_81()
+ {
+    if (jj_scan_token(INTEGER_LITERAL)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_74()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_81()) {
+    jj_scanpos = xsp;
+    if (jj_3R_82()) {
+    jj_scanpos = xsp;
+    if (jj_3R_83()) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3_2()
+ {
+    if (jj_3R_59()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_94()
+ {
+    if (jj_3R_96()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_97()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_95()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(108)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(110)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(116)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(117)) return true;
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_121()
+ {
+    if (jj_scan_token(LBRACKET)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_91()
+ {
+    if (jj_3R_94()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_95()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_120()
+ {
+    if (jj_scan_token(LPAREN)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_118()
+ {
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_121()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_62()
+ {
+    if (jj_scan_token(LPAREN)) return true;
+    if (jj_3R_66()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_86()
+ {
+    if (jj_3R_66()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_92()
+ {
+    if (jj_scan_token(BIT_OR)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_87()
+ {
+    if (jj_3R_91()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_92()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_78()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_85()) {
+    jj_scanpos = xsp;
+    if (jj_3R_86()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_85()
+ {
+    if (jj_scan_token(DOT)) return true;
+    return false;
+  }
+
+  private boolean jj_3_7()
+ {
+    if (jj_3R_61()) return true;
+    return false;
+  }
+
+  private boolean jj_3_8()
+ {
+    if (jj_3R_62()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_117()
+ {
+    if (jj_3R_66()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_88()
+ {
+    if (jj_scan_token(SC_AND)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_71()
+ {
+    if (jj_3R_78()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_79()
+ {
+    if (jj_3R_87()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_88()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_119()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(85)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(88)) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_80()
+ {
+    if (jj_scan_token(SC_OR)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_72()
+ {
+    if (jj_3R_79()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_80()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_115()
+ {
+    if (jj_3R_120()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_73()
+ {
+    if (jj_scan_token(HOOK)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_114()
+ {
+    if (jj_3R_63()) return true;
+    if (jj_3R_118()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_119()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_113()
+ {
+    if (jj_scan_token(LPAREN)) return true;
+    if (jj_3R_117()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_112()
+ {
+    if (jj_3R_116()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_116()
+ {
+    if (jj_scan_token(LBRACE)) return true;
+    if (jj_3R_66()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_66()
+ {
+    if (jj_3R_72()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_73()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_77()
+ {
+    if (jj_scan_token(LPAREN)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_111()
+ {
+    if (jj_scan_token(SYSTEM_IDENT)) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_scan_token(124)) { jj_scanpos = xsp; break; }
+    }
+    xsp = jj_scanpos;
+    if (jj_3_8()) jj_scanpos = xsp;
+    return false;
+  }
+
+  /** Generated Token Manager. */
+  public VerilogParserCoreTokenManager token_source;
+  JavaCharStream jj_input_stream;
+  /** Current token. */
+  public Token token;
+  /** Next token. */
+  public Token jj_nt;
+  private int jj_ntk;
+  private Token jj_scanpos, jj_lastpos;
+  private int jj_la;
+  private int jj_gen;
+  final private int[] jj_la1 = new int[171];
+  static private int[] jj_la1_0;
+  static private int[] jj_la1_1;
+  static private int[] jj_la1_2;
+  static private int[] jj_la1_3;
+  static private int[] jj_la1_4;
+  static {
+      jj_la1_init_0();
+      jj_la1_init_1();
+      jj_la1_init_2();
+      jj_la1_init_3();
+      jj_la1_init_4();
+   }
+   private static void jj_la1_init_0() {
+      jj_la1_0 = new int[] {0xa000,0xa000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800000,0x0,0x0,0x0,0x20000,0x20000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfa280000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000000,0x0,0x0,0x0,0x0,0x280000,0x0,0x0,0xfa280000,0x500000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x12080000,0x0,0x12080000,0x12080000,0x4000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
+   }
+   private static void jj_la1_init_1() {
+      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x40000,0x0,0x0,0xe00,0x0,0xf1affea8,0x0,0xe00,0x0,0x3003fe00,0x3003fe00,0x121000,0x121000,0xe00,0x0,0xe00,0x0,0x200,0xf1affea8,0xf10ff028,0x800000,0xe00,0x0,0x0,0x30127000,0x30127000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100000,0x0,0x0,0x3003b000,0x3003f000,0x0,0x0,0x0,0x0,0x0,0xc0000,0x0,0x0,0x0,0xf000001,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x80000000,0x0,0xf000000,0x0,0x0,0x0,0x2,0x2,0x0,0x700ff000,0x0,0xf000001,0x0,0x700ff000,0x0,0x0,0x200,0x0,0x700ff200,0x700ff200,0x700ffe00,0x0,0xe00,0x0,0x700ffe00,0x700ffe00,0xf18ff029,0x0,0xf18ff029,0xf18ff029,0x0,0x0,0x2,0x2,0x4000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
+   }
+   private static void jj_la1_init_2() {
+      jj_la1_2 = new int[] {0x0,0x0,0x0,0x800000,0x0,0x100000,0x800000,0x0,0x2000,0x81fb6,0x800000,0x0,0x2000,0x30,0x30,0x0,0x0,0x0,0x2000000,0x0,0x2000000,0x0,0x81fb6,0x1fb0,0x80006,0x0,0x800000,0x800000,0x0,0x0,0x2000000,0x2000,0x100000,0x3100a000,0x2000,0x102000,0x0,0x3000a000,0x800000,0x3000a000,0x800000,0x3100a000,0x800000,0x3000a000,0x3100a000,0x800000,0x3000a000,0x3100a000,0x1f80,0xf00,0x100000,0x0,0x800000,0x800000,0x800000,0x80,0x100000,0x0,0x800000,0x100000,0x0,0x800000,0x2000,0x100000,0x800000,0x2000,0x0,0x100000,0x800000,0x0,0x30,0x20000,0x2000000,0x800000,0x800000,0x2000,0x0,0x800000,0x800000,0x6,0x388001,0x2000000,0x300000,0x82000,0x2082000,0x2000000,0x300000,0x800000,0x2000,0x8000,0x300000,0x2000,0x0,0x3000a008,0x2000,0x3000a008,0x800000,0x800000,0x3000a008,0x0,0x0,0x800000,0x80000000,0x3000a000,0x3000a000,0x0,0x30,0x80000000,0x388001,0x0,0x30,0x2000,0x800000,0x0,0x2000,0x30,0x30,0x30,0x800000,0x0,0x2000,0x30,0x30,0x81fb6,0x80000000,0x81fb6,0x81fb6,0x0,0x800000,0x3000a000,0x3000a000,0x30,0x50,0x50,0x800000,0x8000,0x800000,0x40000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc000000,0xc000000,0x0,0x0,0x0,0x0,0x0,0x0,0x30000000,0x2000,0x0,0xa000,0x1200000,0x1200000,0x80000000,0x20000,0x80000000,0x80000000,0x20000,0x20000,0x30000000,0x800000,0x808000,0x808000,0x800000,0x0,};
+   }
+   private static void jj_la1_init_3() {
+      jj_la1_3 = new int[] {0x8000000,0x8000000,0x8000000,0x0,0x0,0x0,0x0,0x8000000,0x0,0x8000000,0x0,0x8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x0,0x8000000,0x8000000,0x0,0x8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x88000000,0x0,0x983c7300,0x0,0x8000000,0x88000000,0x983c7300,0x0,0x983c7300,0x0,0x983c7300,0x0,0x983c7300,0x983c7300,0x0,0x983c7300,0x983c7300,0x0,0x0,0x0,0x8000000,0x0,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0x8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x18000000,0x8,0x0,0x0,0x8,0x8,0x0,0x0,0x0,0x18000000,0x0,0x88000000,0x88000000,0x983c7700,0x8000400,0x983c7300,0x0,0x0,0x983c7300,0x0,0x0,0x0,0x0,0x983c7300,0x983c7300,0x0,0x0,0x0,0x18000000,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0x0,0x8000000,0x0,0x8000000,0x8000000,0x0,0x0,0x983c7300,0x983c7300,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0x40,0x80,0x2000,0x305000,0x305000,0xc00024,0xc00024,0x18,0x18,0x6030000,0x6030000,0x300,0x300,0x1008c00,0x1008c00,0x3c7300,0x0,0x10000000,0x98000000,0x0,0x0,0x0,0x0,0x3,0x3,0x0,0x0,0x3c7300,0x0,0x0,0x0,0x0,0x80000000,};
+   }
+   private static void jj_la1_init_4() {
+      jj_la1_4 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x60,0x0,0x60,0x0,0x0,0x60,0x60,0x0,0x60,0x0,0x60,0x0,0x60,0x60,0x0,0x60,0x60,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x60,0x60,0x60,0x0,0x60,0x0,0x0,0x60,0x0,0x0,0x0,0x0,0x60,0x60,0x0,0x0,0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x60,0x60,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x60,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x60,};
+   }
+  final private JJCalls[] jj_2_rtns = new JJCalls[8];
+  private boolean jj_rescan = false;
+  private int jj_gc = 0;
+
+  /** Constructor with InputStream. */
+  public VerilogParserCore(java.io.InputStream stream) {
+     this(stream, null);
+  }
+  /** Constructor with InputStream and supplied encoding */
+  public VerilogParserCore(java.io.InputStream stream, String encoding) {
+    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
+    token_source = new VerilogParserCoreTokenManager(jj_input_stream);
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 171; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  /** Reinitialise. */
+  public void ReInit(java.io.InputStream stream) {
+     ReInit(stream, null);
+  }
+  /** Reinitialise. */
+  public void ReInit(java.io.InputStream stream, String encoding) {
+    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
+    token_source.ReInit(jj_input_stream);
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 171; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  /** Constructor. */
+  public VerilogParserCore(java.io.Reader stream) {
+    jj_input_stream = new JavaCharStream(stream, 1, 1);
+    token_source = new VerilogParserCoreTokenManager(jj_input_stream);
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 171; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  /** Reinitialise. */
+  public void ReInit(java.io.Reader stream) {
+    jj_input_stream.ReInit(stream, 1, 1);
+    token_source.ReInit(jj_input_stream);
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 171; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  /** Constructor with generated Token Manager. */
+  public VerilogParserCore(VerilogParserCoreTokenManager tm) {
+    token_source = tm;
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 171; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  /** Reinitialise. */
+  public void ReInit(VerilogParserCoreTokenManager tm) {
+    token_source = tm;
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 171; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  private Token jj_consume_token(int kind) throws ParseException {
+    Token oldToken;
+    if ((oldToken = token).next != null) token = token.next;
+    else token = token.next = token_source.getNextToken();
+    jj_ntk = -1;
+    if (token.kind == kind) {
+      jj_gen++;
+      if (++jj_gc > 100) {
+        jj_gc = 0;
+        for (int i = 0; i < jj_2_rtns.length; i++) {
+          JJCalls c = jj_2_rtns[i];
+          while (c != null) {
+            if (c.gen < jj_gen) c.first = null;
+            c = c.next;
+          }
+        }
+      }
+      return token;
+    }
+    token = oldToken;
+    jj_kind = kind;
+    throw generateParseException();
+  }
+
+  @SuppressWarnings("serial")
+  static private final class LookaheadSuccess extends java.lang.Error { }
+  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
+  private boolean jj_scan_token(int kind) {
+    if (jj_scanpos == jj_lastpos) {
+      jj_la--;
+      if (jj_scanpos.next == null) {
+        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
+      } else {
+        jj_lastpos = jj_scanpos = jj_scanpos.next;
+      }
+    } else {
+      jj_scanpos = jj_scanpos.next;
+    }
+    if (jj_rescan) {
+      int i = 0; Token tok = token;
+      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
+      if (tok != null) jj_add_error_token(kind, i);
+    }
+    if (jj_scanpos.kind != kind) return true;
+    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
+    return false;
+  }
+
+
+/** Get the next Token. */
+  final public Token getNextToken() {
+    if (token.next != null) token = token.next;
+    else token = token.next = token_source.getNextToken();
+    jj_ntk = -1;
+    jj_gen++;
+    return token;
+  }
+
+/** Get the specific Token. */
+  final public Token getToken(int index) {
+    Token t = token;
+    for (int i = 0; i < index; i++) {
+      if (t.next != null) t = t.next;
+      else t = t.next = token_source.getNextToken();
+    }
+    return t;
+  }
+
+  private int jj_ntk_f() {
+    if ((jj_nt=token.next) == null)
+      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
+    else
+      return (jj_ntk = jj_nt.kind);
+  }
+
+  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
+  private int[] jj_expentry;
+  private int jj_kind = -1;
+  private int[] jj_lasttokens = new int[100];
+  private int jj_endpos;
+
+  private void jj_add_error_token(int kind, int pos) {
+    if (pos >= 100) return;
+    if (pos == jj_endpos + 1) {
+      jj_lasttokens[jj_endpos++] = kind;
+    } else if (jj_endpos != 0) {
+      jj_expentry = new int[jj_endpos];
+      for (int i = 0; i < jj_endpos; i++) {
+        jj_expentry[i] = jj_lasttokens[i];
+      }
+      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
+        int[] oldentry = (int[])(it.next());
+        if (oldentry.length == jj_expentry.length) {
+          for (int i = 0; i < jj_expentry.length; i++) {
+            if (oldentry[i] != jj_expentry[i]) {
+              continue jj_entries_loop;
+            }
+          }
+          jj_expentries.add(jj_expentry);
+          break jj_entries_loop;
+        }
+      }
+      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
+    }
+  }
+
+  /** Generate ParseException. */
+  public ParseException generateParseException() {
+    jj_expentries.clear();
+    boolean[] la1tokens = new boolean[136];
+    if (jj_kind >= 0) {
+      la1tokens[jj_kind] = true;
+      jj_kind = -1;
+    }
+    for (int i = 0; i < 171; i++) {
+      if (jj_la1[i] == jj_gen) {
+        for (int j = 0; j < 32; j++) {
+          if ((jj_la1_0[i] & (1<<j)) != 0) {
+            la1tokens[j] = true;
+          }
+          if ((jj_la1_1[i] & (1<<j)) != 0) {
+            la1tokens[32+j] = true;
+          }
+          if ((jj_la1_2[i] & (1<<j)) != 0) {
+            la1tokens[64+j] = true;
+          }
+          if ((jj_la1_3[i] & (1<<j)) != 0) {
+            la1tokens[96+j] = true;
+          }
+          if ((jj_la1_4[i] & (1<<j)) != 0) {
+            la1tokens[128+j] = true;
+          }
+        }
+      }
+    }
+    for (int i = 0; i < 136; i++) {
+      if (la1tokens[i]) {
+        jj_expentry = new int[1];
+        jj_expentry[0] = i;
+        jj_expentries.add(jj_expentry);
+      }
+    }
+    jj_endpos = 0;
+    jj_rescan_token();
+    jj_add_error_token(0, 0);
+    int[][] exptokseq = new int[jj_expentries.size()][];
+    for (int i = 0; i < jj_expentries.size(); i++) {
+      exptokseq[i] = jj_expentries.get(i);
+    }
+    return new ParseException(token, exptokseq, tokenImage);
+  }
+
+  /** Enable tracing. */
+  final public void enable_tracing() {
+  }
+
+  /** Disable tracing. */
+  final public void disable_tracing() {
+  }
+
+  private void jj_rescan_token() {
+    jj_rescan = true;
+    for (int i = 0; i < 8; i++) {
+    try {
+      JJCalls p = jj_2_rtns[i];
+      do {
+        if (p.gen > jj_gen) {
+          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
+          switch (i) {
+            case 0: jj_3_1(); break;
+            case 1: jj_3_2(); break;
+            case 2: jj_3_3(); break;
+            case 3: jj_3_4(); break;
+            case 4: jj_3_5(); break;
+            case 5: jj_3_6(); break;
+            case 6: jj_3_7(); break;
+            case 7: jj_3_8(); break;
+          }
+        }
+        p = p.next;
+      } while (p != null);
+      } catch(LookaheadSuccess ls) { }
+    }
+    jj_rescan = false;
+  }
+
+  private void jj_save(int index, int xla) {
+    JJCalls p = jj_2_rtns[index];
+    while (p.gen > jj_gen) {
+      if (p.next == null) { p = p.next = new JJCalls(); break; }
+      p = p.next;
+    }
+    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
+  }
+
+  static final class JJCalls {
+    int gen;
+    Token first;
+    int arg;
+    JJCalls next;
+  }
+
+                                                                     // Andrey - parameters used in delays
+
+}
diff -U 3 -dHrN -- vdt-veditor/_generated/com/elphel/vdt/veditor/parser/verilog/VerilogParserCoreTokenManager.java vdt/_generated/com/elphel/vdt/veditor/parser/verilog/VerilogParserCoreTokenManager.java
--- vdt-veditor/_generated/com/elphel/vdt/veditor/parser/verilog/VerilogParserCoreTokenManager.java	2016-06-24 10:29:40.836496072 -0600
+++ vdt/_generated/com/elphel/vdt/veditor/parser/verilog/VerilogParserCoreTokenManager.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,1588 +1,2672 @@
-/* Generated By:JavaCC: Do not edit this line. VerilogParserCoreTokenManager.java */
-package net.sourceforge.veditor.parser;
-
-public class VerilogParserCoreTokenManager implements VerilogParserCoreConstants
-{
-  public  java.io.PrintStream debugStream = System.out;
-  public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }
-private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1)
-{
-   switch (pos)
-   {
-      case 0:
-         if ((active0 & 0x200000000L) != 0L)
-         {
-            jjmatchedKind = 64;
-            return 40;
-         }
-         if ((active0 & 0x400000000000L) != 0L)
-         {
-            jjmatchedKind = 64;
-            return 52;
-         }
-         if ((active0 & 0x1200L) != 0L)
-            return 70;
-         if ((active0 & 0x2L) != 0L)
-         {
-            jjmatchedKind = 65;
-            return 0;
-         }
-         if ((active0 & 0x10000L) != 0L)
-         {
-            jjmatchedKind = 64;
-            return 26;
-         }
-         if ((active0 & 0xbe5dffbec000L) != 0L)
-         {
-            jjmatchedKind = 64;
-            return 35;
-         }
-         if ((active0 & 0x1a000400000L) != 0L)
-         {
-            jjmatchedKind = 64;
-            return 33;
-         }
-         return -1;
-      case 1:
-         if ((active0 & 0xfe5fffbfc000L) != 0L)
-         {
-            jjmatchedKind = 64;
-            jjmatchedPos = 1;
-            return 35;
-         }
-         if ((active0 & 0x1000L) != 0L)
-            return 6;
-         if ((active0 & 0x1a000000000L) != 0L)
-         {
-            jjmatchedKind = 64;
-            jjmatchedPos = 1;
-            return 32;
-         }
-         if ((active0 & 0x400000L) != 0L)
-            return 35;
-         return -1;
-      case 2:
-         if ((active0 & 0xfbeab9994000L) != 0L)
-         {
-            if (jjmatchedPos != 2)
-            {
-               jjmatchedKind = 64;
-               jjmatchedPos = 2;
-            }
-            return 35;
-         }
-         if ((active0 & 0x41546268000L) != 0L)
-            return 35;
-         if ((active0 & 0x1000L) != 0L)
-         {
-            if (jjmatchedPos != 2)
-            {
-               jjmatchedKind = 13;
-               jjmatchedPos = 2;
-            }
-            return 7;
-         }
-         return -1;
-      case 3:
-         if ((active0 & 0x1000L) != 0L)
-         {
-            if (jjmatchedPos != 3)
-            {
-               jjmatchedKind = 13;
-               jjmatchedPos = 3;
-            }
-            return 7;
-         }
-         if ((active0 & 0x2202308c0000L) != 0L)
-            return 35;
-         if ((active0 & 0xd9fdcd31c000L) != 0L)
-         {
-            if (jjmatchedPos != 3)
-            {
-               jjmatchedKind = 64;
-               jjmatchedPos = 3;
-            }
-            return 35;
-         }
-         return -1;
-      case 4:
-         if ((active0 & 0x8a021010000L) != 0L)
-            return 35;
-         if ((active0 & 0x1000L) != 0L)
-         {
-            jjmatchedKind = 13;
-            jjmatchedPos = 4;
-            return 7;
-         }
-         if ((active0 & 0xd15dcc30c000L) != 0L)
-         {
-            jjmatchedKind = 64;
-            jjmatchedPos = 4;
-            return 35;
-         }
-         return -1;
-      case 5:
-         if ((active0 & 0x411dc4308000L) != 0L)
-         {
-            jjmatchedKind = 64;
-            jjmatchedPos = 5;
-            return 35;
-         }
-         if ((active0 & 0x904008004000L) != 0L)
-            return 35;
-         if ((active0 & 0x1000L) != 0L)
-            return 7;
-         return -1;
-      case 6:
-         if ((active0 & 0x10444100000L) != 0L)
-            return 35;
-         if ((active0 & 0x401980208000L) != 0L)
-         {
-            jjmatchedKind = 64;
-            jjmatchedPos = 6;
-            return 35;
-         }
-         return -1;
-      case 7:
-         if ((active0 & 0x880000000L) != 0L)
-            return 35;
-         if ((active0 & 0x401100208000L) != 0L)
-         {
-            jjmatchedKind = 64;
-            jjmatchedPos = 7;
-            return 35;
-         }
-         return -1;
-      case 8:
-         if ((active0 & 0x1100200000L) != 0L)
-         {
-            jjmatchedKind = 64;
-            jjmatchedPos = 8;
-            return 35;
-         }
-         if ((active0 & 0x400000008000L) != 0L)
-            return 35;
-         return -1;
-      case 9:
-         if ((active0 & 0x1100000000L) != 0L)
-         {
-            jjmatchedKind = 64;
-            jjmatchedPos = 9;
-            return 35;
-         }
-         if ((active0 & 0x200000L) != 0L)
-            return 35;
-         return -1;
-      default :
-         return -1;
-   }
-}
-private final int jjStartNfa_0(int pos, long active0, long active1)
-{
-   return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0, active1), pos + 1);
-}
-private final int jjStopAtPos(int pos, int kind)
-{
-   jjmatchedKind = kind;
-   jjmatchedPos = pos;
-   return pos + 1;
-}
-private final int jjStartNfaWithStates_0(int pos, int kind, int state)
-{
-   jjmatchedKind = kind;
-   jjmatchedPos = pos;
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) { return pos + 1; }
-   return jjMoveNfa_0(state, pos + 1);
-}
-private final int jjMoveStringLiteralDfa0_0()
-{
-   switch(curChar)
-   {
-      case 10:
-         jjmatchedKind = 9;
-         return jjMoveStringLiteralDfa1_0(0x1000L, 0x0L);
-      case 12:
-         return jjStopAtPos(0, 10);
-      case 13:
-         return jjStopAtPos(0, 8);
-      case 35:
-         return jjStopAtPos(0, 57);
-      case 36:
-         return jjStopAtPos(0, 60);
-      case 40:
-         return jjStopAtPos(0, 50);
-      case 41:
-         return jjStopAtPos(0, 51);
-      case 44:
-         return jjStopAtPos(0, 61);
-      case 47:
-         return jjMoveStringLiteralDfa1_0(0x2L, 0x0L);
-      case 58:
-         return jjStopAtPos(0, 62);
-      case 59:
-         return jjStopAtPos(0, 56);
-      case 61:
-         return jjStopAtPos(0, 63);
-      case 64:
-         return jjStopAtPos(0, 58);
-      case 91:
-         jjmatchedKind = 54;
-         return jjMoveStringLiteralDfa1_0(0x0L, 0x4L);
-      case 93:
-         return jjStopAtPos(0, 55);
-      case 96:
-         return jjStopAtPos(0, 59);
-      case 98:
-         return jjMoveStringLiteralDfa1_0(0x10000L, 0x0L);
-      case 99:
-         return jjMoveStringLiteralDfa1_0(0x30000000L, 0x0L);
-      case 101:
-         return jjMoveStringLiteralDfa1_0(0x81540a28000L, 0x0L);
-      case 102:
-         return jjMoveStringLiteralDfa1_0(0x86040000L, 0x0L);
-      case 103:
-         return jjMoveStringLiteralDfa1_0(0x100800000000L, 0x0L);
-      case 105:
-         return jjMoveStringLiteralDfa1_0(0x1a000400000L, 0x0L);
-      case 106:
-         return jjMoveStringLiteralDfa1_0(0x80000L, 0x0L);
-      case 109:
-         return jjMoveStringLiteralDfa1_0(0x4000L, 0x0L);
-      case 111:
-         return jjMoveStringLiteralDfa1_0(0x4000000000L, 0x0L);
-      case 112:
-         return jjMoveStringLiteralDfa1_0(0x400000000000L, 0x0L);
-      case 114:
-         return jjMoveStringLiteralDfa1_0(0x240008000000L, 0x0L);
-      case 115:
-         return jjMoveStringLiteralDfa1_0(0x800000100000L, 0x0L);
-      case 116:
-         return jjMoveStringLiteralDfa1_0(0x200000000L, 0x0L);
-      case 119:
-         return jjMoveStringLiteralDfa1_0(0x20001000000L, 0x0L);
-      case 123:
-         return jjStopAtPos(0, 52);
-      case 125:
-         return jjStopAtPos(0, 53);
-      default :
-         return jjMoveNfa_0(2, 0);
-   }
-}
-private final int jjMoveStringLiteralDfa1_0(long active0, long active1)
-{
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      jjStopStringLiteralDfa_0(0, active0, active1);
-      return 1;
-   }
-   switch(curChar)
-   {
-      case 42:
-         if ((active0 & 0x2L) != 0L)
-            return jjStopAtPos(1, 1);
-         break;
-      case 46:
-         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x4L);
-      case 96:
-         return jjMoveStringLiteralDfa2_0(active0, 0x1000L, active1, 0L);
-      case 97:
-         return jjMoveStringLiteralDfa2_0(active0, 0x400230000000L, active1, 0L);
-      case 101:
-         return jjMoveStringLiteralDfa2_0(active0, 0x340808010000L, active1, 0L);
-      case 102:
-         if ((active0 & 0x400000L) != 0L)
-            return jjStartNfaWithStates_0(1, 22, 35);
-         break;
-      case 104:
-         return jjMoveStringLiteralDfa2_0(active0, 0x1000000L, active1, 0L);
-      case 105:
-         return jjMoveStringLiteralDfa2_0(active0, 0x820000000000L, active1, 0L);
-      case 108:
-         return jjMoveStringLiteralDfa2_0(active0, 0x800000L, active1, 0L);
-      case 110:
-         return jjMoveStringLiteralDfa2_0(active0, 0x1b540228000L, active1, 0L);
-      case 111:
-         return jjMoveStringLiteralDfa2_0(active0, 0x60c4000L, active1, 0L);
-      case 112:
-         return jjMoveStringLiteralDfa2_0(active0, 0x100000L, active1, 0L);
-      case 117:
-         return jjMoveStringLiteralDfa2_0(active0, 0x4080000000L, active1, 0L);
-      case 118:
-         return jjMoveStringLiteralDfa2_0(active0, 0x80000000000L, active1, 0L);
-      default :
-         break;
-   }
-   return jjStartNfa_0(0, active0, active1);
-}
-private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1)
-{
-   if (((active0 &= old0) | (active1 &= old1)) == 0L)
-      return jjStartNfa_0(0, old0, old1); 
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      jjStopStringLiteralDfa_0(1, active0, active1);
-      return 2;
-   }
-   switch(curChar)
-   {
-      case 93:
-         if ((active1 & 0x4L) != 0L)
-            return jjStopAtPos(2, 66);
-         break;
-      case 97:
-         return jjMoveStringLiteralDfa3_0(active0, 0x200000000000L, active1, 0L);
-      case 100:
-         if ((active0 & 0x20000L) != 0L)
-         {
-            jjmatchedKind = 17;
-            jjmatchedPos = 2;
-         }
-         return jjMoveStringLiteralDfa3_0(active0, 0x154020c000L, active1, 0L);
-      case 101:
-         return jjMoveStringLiteralDfa3_0(active0, 0x80000101000L, active1, 0L);
-      case 103:
-         if ((active0 & 0x40000000000L) != 0L)
-            return jjStartNfaWithStates_0(2, 42, 35);
-         return jjMoveStringLiteralDfa3_0(active0, 0x800000010000L, active1, 0L);
-      case 105:
-         return jjMoveStringLiteralDfa3_0(active0, 0x1080000L, active1, 0L);
-      case 110:
-         return jjMoveStringLiteralDfa3_0(active0, 0x100880000000L, active1, 0L);
-      case 111:
-         return jjMoveStringLiteralDfa3_0(active0, 0x8000000000L, active1, 0L);
-      case 112:
-         return jjMoveStringLiteralDfa3_0(active0, 0x2008000000L, active1, 0L);
-      case 114:
-         if ((active0 & 0x2000000L) != 0L)
-         {
-            jjmatchedKind = 25;
-            jjmatchedPos = 2;
-         }
-         return jjMoveStringLiteralDfa3_0(active0, 0x420004040000L, active1, 0L);
-      case 115:
-         return jjMoveStringLiteralDfa3_0(active0, 0x230800000L, active1, 0L);
-      case 116:
-         return jjMoveStringLiteralDfa3_0(active0, 0x14000000000L, active1, 0L);
-      default :
-         break;
-   }
-   return jjStartNfa_0(1, active0, active1);
-}
-private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1)
-{
-   if (((active0 &= old0) | (active1 &= old1)) == 0L)
-      return jjStartNfa_0(1, old0, old1); 
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      jjStopStringLiteralDfa_0(2, active0, 0L);
-      return 3;
-   }
-   switch(curChar)
-   {
-      case 97:
-         return jjMoveStringLiteralDfa4_0(active0, 0x400000000000L);
-      case 99:
-         return jjMoveStringLiteralDfa4_0(active0, 0xc0100000L);
-      case 101:
-         if ((active0 & 0x800000L) != 0L)
-            return jjStartNfaWithStates_0(3, 23, 35);
-         else if ((active0 & 0x10000000L) != 0L)
-         {
-            jjmatchedKind = 28;
-            jjmatchedPos = 3;
-         }
-         else if ((active0 & 0x20000000000L) != 0L)
-            return jjStartNfaWithStates_0(3, 41, 35);
-         return jjMoveStringLiteralDfa4_0(active0, 0x1082c000000L);
-      case 102:
-         return jjMoveStringLiteralDfa4_0(active0, 0x100000000L);
-      case 103:
-         return jjMoveStringLiteralDfa4_0(active0, 0x1000000000L);
-      case 105:
-         return jjMoveStringLiteralDfa4_0(active0, 0x10000L);
-      case 107:
-         if ((active0 & 0x40000L) != 0L)
-            return jjStartNfaWithStates_0(3, 18, 35);
-         else if ((active0 & 0x200000000L) != 0L)
-            return jjStartNfaWithStates_0(3, 33, 35);
-         break;
-      case 108:
-         if ((active0 & 0x200000000000L) != 0L)
-            return jjStartNfaWithStates_0(3, 45, 35);
-         return jjMoveStringLiteralDfa4_0(active0, 0x1001000L);
-      case 109:
-         return jjMoveStringLiteralDfa4_0(active0, 0x8000L);
-      case 110:
-         if ((active0 & 0x80000L) != 0L)
-            return jjStartNfaWithStates_0(3, 19, 35);
-         return jjMoveStringLiteralDfa4_0(active0, 0x880000000000L);
-      case 112:
-         return jjMoveStringLiteralDfa4_0(active0, 0x4000000000L);
-      case 115:
-         return jjMoveStringLiteralDfa4_0(active0, 0x200000L);
-      case 116:
-         return jjMoveStringLiteralDfa4_0(active0, 0x400000000L);
-      case 117:
-         return jjMoveStringLiteralDfa4_0(active0, 0xa000004000L);
-      case 118:
-         return jjMoveStringLiteralDfa4_0(active0, 0x100000000000L);
-      default :
-         break;
-   }
-   return jjStartNfa_0(2, active0, 0L);
-}
-private final int jjMoveStringLiteralDfa4_0(long old0, long active0)
-{
-   if (((active0 &= old0)) == 0L)
-      return jjStartNfa_0(2, old0, 0L);
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      jjStopStringLiteralDfa_0(3, active0, 0L);
-      return 4;
-   }
-   switch(curChar)
-   {
-      case 97:
-         return jjMoveStringLiteralDfa5_0(active0, 0x100448000000L);
-      case 101:
-         if ((active0 & 0x1000000L) != 0L)
-            return jjStartNfaWithStates_0(4, 24, 35);
-         return jjMoveStringLiteralDfa5_0(active0, 0x801000000000L);
-      case 103:
-         return jjMoveStringLiteralDfa5_0(active0, 0x10000000000L);
-      case 105:
-         return jjMoveStringLiteralDfa5_0(active0, 0x100000L);
-      case 108:
-         return jjMoveStringLiteralDfa5_0(active0, 0x4000L);
-      case 109:
-         return jjMoveStringLiteralDfa5_0(active0, 0x400000000000L);
-      case 110:
-         if ((active0 & 0x10000L) != 0L)
-            return jjStartNfaWithStates_0(4, 16, 35);
-         break;
-      case 111:
-         return jjMoveStringLiteralDfa5_0(active0, 0x8000L);
-      case 112:
-         return jjMoveStringLiteralDfa5_0(active0, 0x200000L);
-      case 114:
-         return jjMoveStringLiteralDfa5_0(active0, 0x800000000L);
-      case 115:
-         return jjMoveStringLiteralDfa5_0(active0, 0x1000L);
-      case 116:
-         if ((active0 & 0x2000000000L) != 0L)
-            return jjStartNfaWithStates_0(4, 37, 35);
-         else if ((active0 & 0x8000000000L) != 0L)
-            return jjStartNfaWithStates_0(4, 39, 35);
-         else if ((active0 & 0x80000000000L) != 0L)
-            return jjStartNfaWithStates_0(4, 43, 35);
-         return jjMoveStringLiteralDfa5_0(active0, 0x80000000L);
-      case 117:
-         return jjMoveStringLiteralDfa5_0(active0, 0x4100000000L);
-      case 118:
-         return jjMoveStringLiteralDfa5_0(active0, 0x4000000L);
-      case 120:
-         if ((active0 & 0x20000000L) != 0L)
-            return jjStartNfaWithStates_0(4, 29, 35);
-         break;
-      default :
-         break;
-   }
-   return jjStartNfa_0(3, active0, 0L);
-}
-private final int jjMoveStringLiteralDfa5_0(long old0, long active0)
-{
-   if (((active0 &= old0)) == 0L)
-      return jjStartNfa_0(3, old0, 0L);
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      jjStopStringLiteralDfa_0(4, active0, 0L);
-      return 5;
-   }
-   switch(curChar)
-   {
-      case 97:
-         return jjMoveStringLiteralDfa6_0(active0, 0x800000000L);
-      case 100:
-         if ((active0 & 0x800000000000L) != 0L)
-            return jjStartNfaWithStates_0(5, 47, 35);
-         return jjMoveStringLiteralDfa6_0(active0, 0x8000L);
-      case 101:
-         if ((active0 & 0x1000L) != 0L)
-            return jjStartNfaWithStates_0(5, 12, 7);
-         else if ((active0 & 0x4000L) != 0L)
-            return jjStartNfaWithStates_0(5, 14, 35);
-         return jjMoveStringLiteralDfa6_0(active0, 0x410004200000L);
-      case 102:
-         return jjMoveStringLiteralDfa6_0(active0, 0x100000L);
-      case 105:
-         return jjMoveStringLiteralDfa6_0(active0, 0x80000000L);
-      case 110:
-         return jjMoveStringLiteralDfa6_0(active0, 0x1100000000L);
-      case 114:
-         if ((active0 & 0x100000000000L) != 0L)
-            return jjStartNfaWithStates_0(5, 44, 35);
-         break;
-      case 115:
-         return jjMoveStringLiteralDfa6_0(active0, 0x440000000L);
-      case 116:
-         if ((active0 & 0x8000000L) != 0L)
-            return jjStartNfaWithStates_0(5, 27, 35);
-         else if ((active0 & 0x4000000000L) != 0L)
-            return jjStartNfaWithStates_0(5, 38, 35);
-         break;
-      default :
-         break;
-   }
-   return jjStartNfa_0(4, active0, 0L);
-}
-private final int jjMoveStringLiteralDfa6_0(long old0, long active0)
-{
-   if (((active0 &= old0)) == 0L)
-      return jjStartNfa_0(4, old0, 0L);
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      jjStopStringLiteralDfa_0(5, active0, 0L);
-      return 6;
-   }
-   switch(curChar)
-   {
-      case 99:
-         return jjMoveStringLiteralDfa7_0(active0, 0x100200000L);
-      case 101:
-         if ((active0 & 0x40000000L) != 0L)
-            return jjStartNfaWithStates_0(6, 30, 35);
-         return jjMoveStringLiteralDfa7_0(active0, 0x1000000000L);
-      case 107:
-         if ((active0 & 0x400000000L) != 0L)
-            return jjStartNfaWithStates_0(6, 34, 35);
-         break;
-      case 111:
-         return jjMoveStringLiteralDfa7_0(active0, 0x80000000L);
-      case 114:
-         if ((active0 & 0x4000000L) != 0L)
-            return jjStartNfaWithStates_0(6, 26, 35);
-         else if ((active0 & 0x10000000000L) != 0L)
-            return jjStartNfaWithStates_0(6, 40, 35);
-         break;
-      case 116:
-         return jjMoveStringLiteralDfa7_0(active0, 0x400800000000L);
-      case 117:
-         return jjMoveStringLiteralDfa7_0(active0, 0x8000L);
-      case 121:
-         if ((active0 & 0x100000L) != 0L)
-            return jjStartNfaWithStates_0(6, 20, 35);
-         break;
-      default :
-         break;
-   }
-   return jjStartNfa_0(5, active0, 0L);
-}
-private final int jjMoveStringLiteralDfa7_0(long old0, long active0)
-{
-   if (((active0 &= old0)) == 0L)
-      return jjStartNfa_0(5, old0, 0L);
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      jjStopStringLiteralDfa_0(6, active0, 0L);
-      return 7;
-   }
-   switch(curChar)
-   {
-      case 101:
-         if ((active0 & 0x800000000L) != 0L)
-            return jjStartNfaWithStates_0(7, 35, 35);
-         return jjMoveStringLiteralDfa8_0(active0, 0x400000000000L);
-      case 105:
-         return jjMoveStringLiteralDfa8_0(active0, 0x200000L);
-      case 108:
-         return jjMoveStringLiteralDfa8_0(active0, 0x8000L);
-      case 110:
-         if ((active0 & 0x80000000L) != 0L)
-            return jjStartNfaWithStates_0(7, 31, 35);
-         break;
-      case 114:
-         return jjMoveStringLiteralDfa8_0(active0, 0x1000000000L);
-      case 116:
-         return jjMoveStringLiteralDfa8_0(active0, 0x100000000L);
-      default :
-         break;
-   }
-   return jjStartNfa_0(6, active0, 0L);
-}
-private final int jjMoveStringLiteralDfa8_0(long old0, long active0)
-{
-   if (((active0 &= old0)) == 0L)
-      return jjStartNfa_0(6, old0, 0L);
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      jjStopStringLiteralDfa_0(7, active0, 0L);
-      return 8;
-   }
-   switch(curChar)
-   {
-      case 97:
-         return jjMoveStringLiteralDfa9_0(active0, 0x1000000000L);
-      case 101:
-         if ((active0 & 0x8000L) != 0L)
-            return jjStartNfaWithStates_0(8, 15, 35);
-         break;
-      case 102:
-         return jjMoveStringLiteralDfa9_0(active0, 0x200000L);
-      case 105:
-         return jjMoveStringLiteralDfa9_0(active0, 0x100000000L);
-      case 114:
-         if ((active0 & 0x400000000000L) != 0L)
-            return jjStartNfaWithStates_0(8, 46, 35);
-         break;
-      default :
-         break;
-   }
-   return jjStartNfa_0(7, active0, 0L);
-}
-private final int jjMoveStringLiteralDfa9_0(long old0, long active0)
-{
-   if (((active0 &= old0)) == 0L)
-      return jjStartNfa_0(7, old0, 0L);
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      jjStopStringLiteralDfa_0(8, active0, 0L);
-      return 9;
-   }
-   switch(curChar)
-   {
-      case 111:
-         return jjMoveStringLiteralDfa10_0(active0, 0x100000000L);
-      case 116:
-         return jjMoveStringLiteralDfa10_0(active0, 0x1000000000L);
-      case 121:
-         if ((active0 & 0x200000L) != 0L)
-            return jjStartNfaWithStates_0(9, 21, 35);
-         break;
-      default :
-         break;
-   }
-   return jjStartNfa_0(8, active0, 0L);
-}
-private final int jjMoveStringLiteralDfa10_0(long old0, long active0)
-{
-   if (((active0 &= old0)) == 0L)
-      return jjStartNfa_0(8, old0, 0L);
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      jjStopStringLiteralDfa_0(9, active0, 0L);
-      return 10;
-   }
-   switch(curChar)
-   {
-      case 101:
-         if ((active0 & 0x1000000000L) != 0L)
-            return jjStartNfaWithStates_0(10, 36, 35);
-         break;
-      case 110:
-         if ((active0 & 0x100000000L) != 0L)
-            return jjStartNfaWithStates_0(10, 32, 35);
-         break;
-      default :
-         break;
-   }
-   return jjStartNfa_0(9, active0, 0L);
-}
-private final void jjCheckNAdd(int state)
-{
-   if (jjrounds[state] != jjround)
-   {
-      jjstateSet[jjnewStateCnt++] = state;
-      jjrounds[state] = jjround;
-   }
-}
-private final void jjAddStates(int start, int end)
-{
-   do {
-      jjstateSet[jjnewStateCnt++] = jjnextStates[start];
-   } while (start++ != end);
-}
-private final void jjCheckNAddTwoStates(int state1, int state2)
-{
-   jjCheckNAdd(state1);
-   jjCheckNAdd(state2);
-}
-private final void jjCheckNAddStates(int start, int end)
-{
-   do {
-      jjCheckNAdd(jjnextStates[start]);
-   } while (start++ != end);
-}
-private final void jjCheckNAddStates(int start)
-{
-   jjCheckNAdd(jjnextStates[start]);
-   jjCheckNAdd(jjnextStates[start + 1]);
-}
-static final long[] jjbitVec0 = {
-   0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL
-};
-static final long[] jjbitVec2 = {
-   0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL
-};
-private final int jjMoveNfa_0(int startState, int curPos)
-{
-   int[] nextStates;
-   int startsAt = 0;
-   jjnewStateCnt = 70;
-   int i = 1;
-   jjstateSet[0] = startState;
-   int j, kind = 0x7fffffff;
-   for (;;)
-   {
-      if (++jjround == 0x7fffffff)
-         ReInitRounds();
-      if (curChar < 64)
-      {
-         long l = 1L << curChar;
-         MatchLoop: do
-         {
-            switch(jjstateSet[--i])
-            {
-               case 33:
-               case 35:
-                  if ((0x83ff408400000000L & l) == 0L)
-                     break;
-                  if (kind > 64)
-                     kind = 64;
-                  jjCheckNAdd(35);
-                  break;
-               case 32:
-                  if ((0x83ff408400000000L & l) == 0L)
-                     break;
-                  if (kind > 64)
-                     kind = 64;
-                  jjCheckNAdd(35);
-                  break;
-               case 40:
-                  if ((0x83ff408400000000L & l) == 0L)
-                     break;
-                  if (kind > 64)
-                     kind = 64;
-                  jjCheckNAdd(35);
-                  break;
-               case 70:
-               case 4:
-                  if (curChar == 32)
-                     jjCheckNAddTwoStates(4, 5);
-                  break;
-               case 2:
-                  if ((0xfffffffefffffdffL & l) != 0L)
-                  {
-                     if (kind > 65)
-                        kind = 65;
-                  }
-                  if ((0x83ff408400000000L & l) != 0L)
-                  {
-                     if (kind > 64)
-                        kind = 64;
-                     jjCheckNAdd(35);
-                  }
-                  else if (curChar == 10)
-                     jjCheckNAddTwoStates(4, 5);
-                  else if (curChar == 47)
-                     jjstateSet[jjnewStateCnt++] = 0;
-                  break;
-               case 52:
-                  if ((0x83ff408400000000L & l) == 0L)
-                     break;
-                  if (kind > 64)
-                     kind = 64;
-                  jjCheckNAdd(35);
-                  break;
-               case 26:
-                  if ((0x83ff408400000000L & l) == 0L)
-                     break;
-                  if (kind > 64)
-                     kind = 64;
-                  jjCheckNAdd(35);
-                  break;
-               case 0:
-                  if (curChar != 47)
-                     break;
-                  if (kind > 11)
-                     kind = 11;
-                  jjCheckNAdd(1);
-                  break;
-               case 1:
-                  if ((0xfffffffffffffbffL & l) == 0L)
-                     break;
-                  if (kind > 11)
-                     kind = 11;
-                  jjCheckNAdd(1);
-                  break;
-               case 3:
-                  if (curChar == 10)
-                     jjCheckNAddTwoStates(4, 5);
-                  break;
-               case 7:
-                  if ((0xfffffffffffffbffL & l) == 0L)
-                     break;
-                  if (kind > 13)
-                     kind = 13;
-                  jjstateSet[jjnewStateCnt++] = 7;
-                  break;
-               case 36:
-                  if ((0xfffffffefffffdffL & l) != 0L && kind > 65)
-                     kind = 65;
-                  break;
-               case 41:
-                  if (curChar == 48 && kind > 48)
-                     kind = 48;
-                  break;
-               case 44:
-                  if (curChar == 49 && kind > 48)
-                     kind = 48;
-                  break;
-               default : break;
-            }
-         } while(i != startsAt);
-      }
-      else if (curChar < 128)
-      {
-         long l = 1L << (curChar & 077);
-         MatchLoop: do
-         {
-            switch(jjstateSet[--i])
-            {
-               case 33:
-                  if ((0x7fffffe87fffffeL & l) != 0L)
-                  {
-                     if (kind > 64)
-                        kind = 64;
-                     jjCheckNAdd(35);
-                  }
-                  if (curChar == 110)
-                     jjstateSet[jjnewStateCnt++] = 32;
-                  break;
-               case 32:
-                  if ((0x7fffffe87fffffeL & l) != 0L)
-                  {
-                     if (kind > 64)
-                        kind = 64;
-                     jjCheckNAdd(35);
-                  }
-                  if (curChar == 105)
-                     jjstateSet[jjnewStateCnt++] = 31;
-                  break;
-               case 40:
-                  if ((0x7fffffe87fffffeL & l) != 0L)
-                  {
-                     if (kind > 64)
-                        kind = 64;
-                     jjCheckNAdd(35);
-                  }
-                  if (curChar == 114)
-                     jjstateSet[jjnewStateCnt++] = 45;
-                  else if (curChar == 105)
-                     jjstateSet[jjnewStateCnt++] = 39;
-                  if (curChar == 114)
-                     jjstateSet[jjnewStateCnt++] = 42;
-                  break;
-               case 70:
-               case 5:
-                  if (curChar == 96)
-                     jjstateSet[jjnewStateCnt++] = 6;
-                  break;
-               case 2:
-                  if (kind > 65)
-                     kind = 65;
-                  if ((0x7fffffe87fffffeL & l) != 0L)
-                  {
-                     if (kind > 64)
-                        kind = 64;
-                     jjCheckNAdd(35);
-                  }
-                  if (curChar == 97)
-                     jjAddStates(0, 1);
-                  else if (curChar == 112)
-                     jjAddStates(2, 3);
-                  else if (curChar == 116)
-                     jjAddStates(4, 6);
-                  else if (curChar == 105)
-                     jjstateSet[jjnewStateCnt++] = 33;
-                  else if (curChar == 98)
-                     jjstateSet[jjnewStateCnt++] = 26;
-                  else if (curChar == 100)
-                     jjstateSet[jjnewStateCnt++] = 23;
-                  else if (curChar == 108)
-                     jjstateSet[jjnewStateCnt++] = 16;
-                  break;
-               case 52:
-                  if ((0x7fffffe87fffffeL & l) != 0L)
-                  {
-                     if (kind > 64)
-                        kind = 64;
-                     jjCheckNAdd(35);
-                  }
-                  if (curChar == 117)
-                     jjstateSet[jjnewStateCnt++] = 58;
-                  if (curChar == 117)
-                     jjstateSet[jjnewStateCnt++] = 51;
-                  break;
-               case 26:
-                  if ((0x7fffffe87fffffeL & l) != 0L)
-                  {
-                     if (kind > 64)
-                        kind = 64;
-                     jjCheckNAdd(35);
-                  }
-                  if (curChar == 117)
-                     jjstateSet[jjnewStateCnt++] = 25;
-                  break;
-               case 1:
-                  if (kind > 11)
-                     kind = 11;
-                  jjstateSet[jjnewStateCnt++] = 1;
-                  break;
-               case 6:
-                  if ((0x7fffffe00000000L & l) == 0L)
-                     break;
-                  if (kind > 13)
-                     kind = 13;
-                  jjCheckNAdd(7);
-                  break;
-               case 7:
-                  if (kind > 13)
-                     kind = 13;
-                  jjCheckNAdd(7);
-                  break;
-               case 8:
-                  if (curChar == 109 && kind > 48)
-                     kind = 48;
-                  break;
-               case 9:
-               case 18:
-                  if (curChar == 97)
-                     jjCheckNAdd(8);
-                  break;
-               case 10:
-                  if (curChar == 114)
-                     jjstateSet[jjnewStateCnt++] = 9;
-                  break;
-               case 11:
-                  if (curChar == 97)
-                     jjstateSet[jjnewStateCnt++] = 10;
-                  break;
-               case 12:
-                  if (curChar == 112)
-                     jjstateSet[jjnewStateCnt++] = 11;
-                  break;
-               case 13:
-                  if (curChar == 108)
-                     jjstateSet[jjnewStateCnt++] = 12;
-                  break;
-               case 14:
-                  if (curChar == 97)
-                     jjstateSet[jjnewStateCnt++] = 13;
-                  break;
-               case 15:
-                  if (curChar == 99)
-                     jjstateSet[jjnewStateCnt++] = 14;
-                  break;
-               case 16:
-                  if (curChar == 111)
-                     jjstateSet[jjnewStateCnt++] = 15;
-                  break;
-               case 17:
-                  if (curChar == 108)
-                     jjstateSet[jjnewStateCnt++] = 16;
-                  break;
-               case 19:
-                  if (curChar == 114)
-                     jjstateSet[jjnewStateCnt++] = 18;
-                  break;
-               case 20:
-                  if (curChar == 97)
-                     jjstateSet[jjnewStateCnt++] = 19;
-                  break;
-               case 21:
-                  if (curChar == 112)
-                     jjstateSet[jjnewStateCnt++] = 20;
-                  break;
-               case 22:
-                  if (curChar == 102)
-                     jjstateSet[jjnewStateCnt++] = 21;
-                  break;
-               case 23:
-                  if (curChar == 101)
-                     jjstateSet[jjnewStateCnt++] = 22;
-                  break;
-               case 24:
-                  if (curChar == 100)
-                     jjstateSet[jjnewStateCnt++] = 23;
-                  break;
-               case 25:
-                  if (curChar == 102 && kind > 48)
-                     kind = 48;
-                  break;
-               case 27:
-                  if (curChar == 98)
-                     jjstateSet[jjnewStateCnt++] = 26;
-                  break;
-               case 28:
-                  if (curChar == 108 && kind > 49)
-                     kind = 49;
-                  break;
-               case 29:
-                  if (curChar == 97)
-                     jjstateSet[jjnewStateCnt++] = 28;
-                  break;
-               case 30:
-                  if (curChar == 105)
-                     jjstateSet[jjnewStateCnt++] = 29;
-                  break;
-               case 31:
-                  if (curChar == 116)
-                     jjstateSet[jjnewStateCnt++] = 30;
-                  break;
-               case 34:
-                  if (curChar == 105)
-                     jjstateSet[jjnewStateCnt++] = 33;
-                  break;
-               case 35:
-                  if ((0x7fffffe87fffffeL & l) == 0L)
-                     break;
-                  if (kind > 64)
-                     kind = 64;
-                  jjCheckNAdd(35);
-                  break;
-               case 36:
-                  if (kind > 65)
-                     kind = 65;
-                  break;
-               case 37:
-                  if (curChar == 116)
-                     jjAddStates(4, 6);
-                  break;
-               case 38:
-                  if (curChar == 101 && kind > 48)
-                     kind = 48;
-                  break;
-               case 39:
-                  if (curChar == 109)
-                     jjstateSet[jjnewStateCnt++] = 38;
-                  break;
-               case 42:
-                  if (curChar == 105)
-                     jjstateSet[jjnewStateCnt++] = 41;
-                  break;
-               case 43:
-                  if (curChar == 114)
-                     jjstateSet[jjnewStateCnt++] = 42;
-                  break;
-               case 45:
-                  if (curChar == 105)
-                     jjstateSet[jjnewStateCnt++] = 44;
-                  break;
-               case 46:
-                  if (curChar == 114)
-                     jjstateSet[jjnewStateCnt++] = 45;
-                  break;
-               case 47:
-                  if (curChar == 112)
-                     jjAddStates(2, 3);
-                  break;
-               case 48:
-                  if (curChar == 112 && kind > 48)
-                     kind = 48;
-                  break;
-               case 49:
-                  if (curChar == 117)
-                     jjstateSet[jjnewStateCnt++] = 48;
-                  break;
-               case 50:
-                  if (curChar == 108)
-                     jjstateSet[jjnewStateCnt++] = 49;
-                  break;
-               case 51:
-                  if (curChar == 108)
-                     jjstateSet[jjnewStateCnt++] = 50;
-                  break;
-               case 53:
-                  if (curChar == 110 && kind > 48)
-                     kind = 48;
-                  break;
-               case 54:
-                  if (curChar == 119)
-                     jjCheckNAdd(53);
-                  break;
-               case 55:
-                  if (curChar == 111)
-                     jjstateSet[jjnewStateCnt++] = 54;
-                  break;
-               case 56:
-                  if (curChar == 100)
-                     jjstateSet[jjnewStateCnt++] = 55;
-                  break;
-               case 57:
-                  if (curChar == 108)
-                     jjstateSet[jjnewStateCnt++] = 56;
-                  break;
-               case 58:
-                  if (curChar == 108)
-                     jjstateSet[jjnewStateCnt++] = 57;
-                  break;
-               case 59:
-                  if (curChar == 117)
-                     jjstateSet[jjnewStateCnt++] = 58;
-                  break;
-               case 60:
-                  if (curChar == 97)
-                     jjAddStates(0, 1);
-                  break;
-               case 61:
-                  if (curChar == 103)
-                     jjCheckNAdd(53);
-                  break;
-               case 62:
-                  if (curChar == 105)
-                     jjstateSet[jjnewStateCnt++] = 61;
-                  break;
-               case 63:
-                  if (curChar == 115)
-                     jjstateSet[jjnewStateCnt++] = 62;
-                  break;
-               case 64:
-                  if (curChar == 115)
-                     jjstateSet[jjnewStateCnt++] = 63;
-                  break;
-               case 65:
-                  if (curChar == 115 && kind > 49)
-                     kind = 49;
-                  break;
-               case 66:
-                  if (curChar == 121)
-                     jjstateSet[jjnewStateCnt++] = 65;
-                  break;
-               case 67:
-                  if (curChar == 97)
-                     jjstateSet[jjnewStateCnt++] = 66;
-                  break;
-               case 68:
-                  if (curChar == 119)
-                     jjstateSet[jjnewStateCnt++] = 67;
-                  break;
-               case 69:
-                  if (curChar == 108)
-                     jjstateSet[jjnewStateCnt++] = 68;
-                  break;
-               default : break;
-            }
-         } while(i != startsAt);
-      }
-      else
-      {
-         int hiByte = (int)(curChar >> 8);
-         int i1 = hiByte >> 6;
-         long l1 = 1L << (hiByte & 077);
-         int i2 = (curChar & 0xff) >> 6;
-         long l2 = 1L << (curChar & 077);
-         MatchLoop: do
-         {
-            switch(jjstateSet[--i])
-            {
-               case 2:
-                  if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 65)
-                     kind = 65;
-                  break;
-               case 1:
-                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
-                     break;
-                  if (kind > 11)
-                     kind = 11;
-                  jjstateSet[jjnewStateCnt++] = 1;
-                  break;
-               case 7:
-                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
-                     break;
-                  if (kind > 13)
-                     kind = 13;
-                  jjstateSet[jjnewStateCnt++] = 7;
-                  break;
-               default : break;
-            }
-         } while(i != startsAt);
-      }
-      if (kind != 0x7fffffff)
-      {
-         jjmatchedKind = kind;
-         jjmatchedPos = curPos;
-         kind = 0x7fffffff;
-      }
-      ++curPos;
-      if ((i = jjnewStateCnt) == (startsAt = 70 - (jjnewStateCnt = startsAt)))
-         return curPos;
-      try { curChar = input_stream.readChar(); }
-      catch(java.io.IOException e) { return curPos; }
-   }
-}
-private final int jjMoveStringLiteralDfa0_1()
-{
-   switch(curChar)
-   {
-      case 42:
-         return jjMoveStringLiteralDfa1_1(0x4L);
-      default :
-         return 1;
-   }
-}
-private final int jjMoveStringLiteralDfa1_1(long active0)
-{
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      return 1;
-   }
-   switch(curChar)
-   {
-      case 47:
-         if ((active0 & 0x4L) != 0L)
-            return jjStopAtPos(1, 2);
-         break;
-      default :
-         return 2;
-   }
-   return 2;
-}
-private final int jjMoveStringLiteralDfa0_2()
-{
-   switch(curChar)
-   {
-      case 96:
-         return jjMoveStringLiteralDfa1_2(0x10L);
-      default :
-         return 1;
-   }
-}
-private final int jjMoveStringLiteralDfa1_2(long active0)
-{
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      return 1;
-   }
-   switch(curChar)
-   {
-      case 101:
-         return jjMoveStringLiteralDfa2_2(active0, 0x10L);
-      default :
-         return 2;
-   }
-}
-private final int jjMoveStringLiteralDfa2_2(long old0, long active0)
-{
-   if (((active0 &= old0)) == 0L)
-      return 2;
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      return 2;
-   }
-   switch(curChar)
-   {
-      case 110:
-         return jjMoveStringLiteralDfa3_2(active0, 0x10L);
-      default :
-         return 3;
-   }
-}
-private final int jjMoveStringLiteralDfa3_2(long old0, long active0)
-{
-   if (((active0 &= old0)) == 0L)
-      return 3;
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      return 3;
-   }
-   switch(curChar)
-   {
-      case 100:
-         return jjMoveStringLiteralDfa4_2(active0, 0x10L);
-      default :
-         return 4;
-   }
-}
-private final int jjMoveStringLiteralDfa4_2(long old0, long active0)
-{
-   if (((active0 &= old0)) == 0L)
-      return 4;
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      return 4;
-   }
-   switch(curChar)
-   {
-      case 105:
-         return jjMoveStringLiteralDfa5_2(active0, 0x10L);
-      default :
-         return 5;
-   }
-}
-private final int jjMoveStringLiteralDfa5_2(long old0, long active0)
-{
-   if (((active0 &= old0)) == 0L)
-      return 5;
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      return 5;
-   }
-   switch(curChar)
-   {
-      case 102:
-         if ((active0 & 0x10L) != 0L)
-            return jjStopAtPos(5, 4);
-         break;
-      default :
-         return 6;
-   }
-   return 6;
-}
-static final int[] jjnextStates = {
-   64, 69, 52, 59, 40, 43, 46, 
-};
-private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2)
-{
-   switch(hiByte)
-   {
-      case 0:
-         return ((jjbitVec2[i2] & l2) != 0L);
-      default : 
-         if ((jjbitVec0[i1] & l1) != 0L)
-            return true;
-         return false;
-   }
-}
-public static final String[] jjstrLiteralImages = {
-"", null, null, null, null, null, null, null, null, null, null, null, null, 
-null, "\155\157\144\165\154\145", "\145\156\144\155\157\144\165\154\145", 
-"\142\145\147\151\156", "\145\156\144", "\146\157\162\153", "\152\157\151\156", 
-"\163\160\145\143\151\146\171", "\145\156\144\163\160\145\143\151\146\171", "\151\146", "\145\154\163\145", 
-"\167\150\151\154\145", "\146\157\162", "\146\157\162\145\166\145\162", "\162\145\160\145\141\164", 
-"\143\141\163\145", "\143\141\163\145\170", "\145\156\144\143\141\163\145", 
-"\146\165\156\143\164\151\157\156", "\145\156\144\146\165\156\143\164\151\157\156", "\164\141\163\153", 
-"\145\156\144\164\141\163\153", "\147\145\156\145\162\141\164\145", 
-"\145\156\144\147\145\156\145\162\141\164\145", "\151\156\160\165\164", "\157\165\164\160\165\164", "\151\156\157\165\164", 
-"\151\156\164\145\147\145\162", "\167\151\162\145", "\162\145\147", "\145\166\145\156\164", 
-"\147\145\156\166\141\162", "\162\145\141\154", "\160\141\162\141\155\145\164\145\162", 
-"\163\151\147\156\145\144", null, null, "\50", "\51", "\173", "\175", "\133", "\135", "\73", "\43", 
-"\100", "\140", "\44", "\54", "\72", "\75", null, null, "\133\56\135", };
-public static final String[] lexStateNames = {
-   "DEFAULT", 
-   "IN_MULTI_LINE_COMMENT", 
-   "IN_ELSE_BLOCK", 
-};
-public static final int[] jjnewLexState = {
-   -1, 1, 0, -1, 0, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
-   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
-   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
-};
-static final long[] jjtoToken = {
-   0xffffffffffffc001L, 0x7L, 
-};
-static final long[] jjtoSkip = {
-   0x3fd4L, 0x0L, 
-};
-static final long[] jjtoSpecial = {
-   0x3800L, 0x0L, 
-};
-static final long[] jjtoMore = {
-   0x2aL, 0x0L, 
-};
-protected JavaCharStream input_stream;
-private final int[] jjrounds = new int[70];
-private final int[] jjstateSet = new int[140];
-StringBuffer image;
-int jjimageLen;
-int lengthOfMatch;
-protected char curChar;
-public VerilogParserCoreTokenManager(JavaCharStream stream){
-   if (JavaCharStream.staticFlag)
-      throw new Error("ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.");
-   input_stream = stream;
-}
-public VerilogParserCoreTokenManager(JavaCharStream stream, int lexState){
-   this(stream);
-   SwitchTo(lexState);
-}
-public void ReInit(JavaCharStream stream)
-{
-   jjmatchedPos = jjnewStateCnt = 0;
-   curLexState = defaultLexState;
-   input_stream = stream;
-   ReInitRounds();
-}
-private final void ReInitRounds()
-{
-   int i;
-   jjround = 0x80000001;
-   for (i = 70; i-- > 0;)
-      jjrounds[i] = 0x80000000;
-}
-public void ReInit(JavaCharStream stream, int lexState)
-{
-   ReInit(stream);
-   SwitchTo(lexState);
-}
-public void SwitchTo(int lexState)
-{
-   if (lexState >= 3 || lexState < 0)
-      throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", TokenMgrError.INVALID_LEXICAL_STATE);
-   else
-      curLexState = lexState;
-}
-
-protected Token jjFillToken()
-{
-   Token t = Token.newToken(jjmatchedKind);
-   t.kind = jjmatchedKind;
-   String im = jjstrLiteralImages[jjmatchedKind];
-   t.image = (im == null) ? input_stream.GetImage() : im;
-   t.beginLine = input_stream.getBeginLine();
-   t.beginColumn = input_stream.getBeginColumn();
-   t.endLine = input_stream.getEndLine();
-   t.endColumn = input_stream.getEndColumn();
-   return t;
-}
-
-int curLexState = 0;
-int defaultLexState = 0;
-int jjnewStateCnt;
-int jjround;
-int jjmatchedPos;
-int jjmatchedKind;
-
-public Token getNextToken() 
-{
-  int kind;
-  Token specialToken = null;
-  Token matchedToken;
-  int curPos = 0;
-
-  EOFLoop :
-  for (;;)
-  {   
-   try   
-   {     
-      curChar = input_stream.BeginToken();
-   }     
-   catch(java.io.IOException e)
-   {        
-      jjmatchedKind = 0;
-      matchedToken = jjFillToken();
-      matchedToken.specialToken = specialToken;
-      return matchedToken;
-   }
-   image = null;
-   jjimageLen = 0;
-
-   for (;;)
-   {
-     switch(curLexState)
-     {
-       case 0:
-         try { input_stream.backup(0);
-            while (curChar <= 32 && (0x100000200L & (1L << curChar)) != 0L)
-               curChar = input_stream.BeginToken();
-         }
-         catch (java.io.IOException e1) { continue EOFLoop; }
-         jjmatchedKind = 0x7fffffff;
-         jjmatchedPos = 0;
-         curPos = jjMoveStringLiteralDfa0_0();
-         break;
-       case 1:
-         jjmatchedKind = 0x7fffffff;
-         jjmatchedPos = 0;
-         curPos = jjMoveStringLiteralDfa0_1();
-         if (jjmatchedPos == 0 && jjmatchedKind > 3)
-         {
-            jjmatchedKind = 3;
-         }
-         break;
-       case 2:
-         jjmatchedKind = 0x7fffffff;
-         jjmatchedPos = 0;
-         curPos = jjMoveStringLiteralDfa0_2();
-         if (jjmatchedPos == 0 && jjmatchedKind > 5)
-         {
-            jjmatchedKind = 5;
-         }
-         break;
-     }
-     if (jjmatchedKind != 0x7fffffff)
-     {
-        if (jjmatchedPos + 1 < curPos)
-           input_stream.backup(curPos - jjmatchedPos - 1);
-        if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
-        {
-           matchedToken = jjFillToken();
-           matchedToken.specialToken = specialToken;
-       if (jjnewLexState[jjmatchedKind] != -1)
-         curLexState = jjnewLexState[jjmatchedKind];
-           return matchedToken;
-        }
-        else if ((jjtoSkip[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
-        {
-           if ((jjtoSpecial[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
-           {
-              matchedToken = jjFillToken();
-              if (specialToken == null)
-                 specialToken = matchedToken;
-              else
-              {
-                 matchedToken.specialToken = specialToken;
-                 specialToken = (specialToken.next = matchedToken);
-              }
-              SkipLexicalActions(matchedToken);
-           }
-           else 
-              SkipLexicalActions(null);
-         if (jjnewLexState[jjmatchedKind] != -1)
-           curLexState = jjnewLexState[jjmatchedKind];
-           continue EOFLoop;
-        }
-        jjimageLen += jjmatchedPos + 1;
-      if (jjnewLexState[jjmatchedKind] != -1)
-        curLexState = jjnewLexState[jjmatchedKind];
-        curPos = 0;
-        jjmatchedKind = 0x7fffffff;
-        try {
-           curChar = input_stream.readChar();
-           continue;
-        }
-        catch (java.io.IOException e1) { }
-     }
-     int error_line = input_stream.getEndLine();
-     int error_column = input_stream.getEndColumn();
-     String error_after = null;
-     boolean EOFSeen = false;
-     try { input_stream.readChar(); input_stream.backup(1); }
-     catch (java.io.IOException e1) {
-        EOFSeen = true;
-        error_after = curPos <= 1 ? "" : input_stream.GetImage();
-        if (curChar == '\n' || curChar == '\r') {
-           error_line++;
-           error_column = 0;
-        }
-        else
-           error_column++;
-     }
-     if (!EOFSeen) {
-        input_stream.backup(1);
-        error_after = curPos <= 1 ? "" : input_stream.GetImage();
-     }
-     throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);
-   }
-  }
-}
-
-void SkipLexicalActions(Token matchedToken)
-{
-   switch(jjmatchedKind)
-   {
-      default :
-         break;
-   }
-}
-}
+/* VerilogParserCoreTokenManager.java */
+/* Generated By:JavaCC: Do not edit this line. VerilogParserCoreTokenManager.java */
+package com.elphel.vdt.veditor.parser.verilog;
+
+/** Token Manager. */
+@SuppressWarnings("unused")public class VerilogParserCoreTokenManager implements VerilogParserCoreConstants {
+
+  /** Debug output. */
+  public  java.io.PrintStream debugStream = System.out;
+  /** Set debug output. */
+  public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }
+private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1, long active2){
+   switch (pos)
+   {
+      case 0:
+         if ((active0 & 0x1000002000020000L) != 0L)
+         {
+            jjmatchedKind = 123;
+            return 194;
+         }
+         if ((active0 & 0x2L) != 0L || (active1 & 0x80000000000L) != 0L)
+            return 3;
+         if ((active0 & 0x100000000000000L) != 0L || (active1 & 0x2L) != 0L)
+         {
+            jjmatchedKind = 123;
+            return 62;
+         }
+         if ((active0 & 0x2802200040000000L) != 0L)
+         {
+            jjmatchedKind = 123;
+            return 149;
+         }
+         if ((active1 & 0x2000L) != 0L)
+            return 0;
+         if ((active0 & 0x400088000000L) != 0L)
+         {
+            jjmatchedKind = 123;
+            return 242;
+         }
+         if ((active0 & 0x10000000800000L) != 0L)
+         {
+            jjmatchedKind = 123;
+            return 223;
+         }
+         if ((active0 & 0x80000L) != 0L)
+         {
+            jjmatchedKind = 123;
+            return 137;
+         }
+         if ((active1 & 0x400000L) != 0L)
+            return 12;
+         if ((active0 & 0x24000000008000L) != 0L)
+         {
+            jjmatchedKind = 123;
+            return 90;
+         }
+         if ((active0 & 0xc6499fde37756000L) != 0L || (active1 & 0x5L) != 0L)
+         {
+            jjmatchedKind = 123;
+            return 8;
+         }
+         return -1;
+      case 1:
+         if ((active0 & 0x100000000000000L) != 0L)
+         {
+            if (jjmatchedPos != 1)
+            {
+               jjmatchedKind = 123;
+               jjmatchedPos = 1;
+            }
+            return 61;
+         }
+         if ((active0 & 0x8000000002000000L) != 0L)
+            return 8;
+         if ((active0 & 0x80000000L) != 0L)
+         {
+            if (jjmatchedPos != 1)
+            {
+               jjmatchedKind = 123;
+               jjmatchedPos = 1;
+            }
+            return 241;
+         }
+         if ((active0 & 0x7e7ffffe7dffe000L) != 0L || (active1 & 0x7L) != 0L)
+         {
+            if (jjmatchedPos != 1)
+            {
+               jjmatchedKind = 123;
+               jjmatchedPos = 1;
+            }
+            return 8;
+         }
+         return -1;
+      case 2:
+         if ((active0 & 0x7a3fdeaacccaa000L) != 0L || (active1 & 0x7L) != 0L)
+         {
+            if (jjmatchedPos != 2)
+            {
+               jjmatchedKind = 123;
+               jjmatchedPos = 2;
+            }
+            return 8;
+         }
+         if ((active0 & 0x100000000000000L) != 0L)
+         {
+            if (jjmatchedPos != 2)
+            {
+               jjmatchedKind = 123;
+               jjmatchedPos = 2;
+            }
+            return 60;
+         }
+         if ((active0 & 0x440215431354000L) != 0L)
+            return 8;
+         return -1;
+      case 3:
+         if ((active0 & 0x4f7d9fde698fe000L) != 0L || (active1 & 0x7L) != 0L)
+         {
+            if (jjmatchedPos != 3)
+            {
+               jjmatchedKind = 123;
+               jjmatchedPos = 3;
+            }
+            return 8;
+         }
+         if ((active0 & 0x3002402084600000L) != 0L)
+            return 8;
+         return -1;
+      case 4:
+         if ((active0 & 0x6b7d15de6185e000L) != 0L || (active1 & 0x7L) != 0L)
+         {
+            jjmatchedKind = 123;
+            jjmatchedPos = 4;
+            return 8;
+         }
+         if ((active0 & 0x4008a00080a0000L) != 0L)
+            return 8;
+         return -1;
+      case 5:
+         if ((active0 & 0x6a6c11de2185c000L) != 0L || (active1 & 0x5L) != 0L)
+         {
+            jjmatchedKind = 123;
+            jjmatchedPos = 5;
+            return 8;
+         }
+         if ((active0 & 0x111040040002000L) != 0L || (active1 & 0x2L) != 0L)
+            return 8;
+         return -1;
+      case 6:
+         if ((active0 & 0x626c01980105c000L) != 0L)
+         {
+            jjmatchedKind = 123;
+            jjmatchedPos = 6;
+            return 8;
+         }
+         if ((active0 & 0x800104620800000L) != 0L || (active1 & 0x5L) != 0L)
+            return 8;
+         return -1;
+      case 7:
+         if ((active0 & 0x4c01100101c000L) != 0L)
+         {
+            jjmatchedKind = 123;
+            jjmatchedPos = 7;
+            return 8;
+         }
+         if ((active0 & 0x6220008800040000L) != 0L)
+            return 8;
+         return -1;
+      case 8:
+         if ((active0 & 0x48011001010000L) != 0L)
+         {
+            jjmatchedKind = 123;
+            jjmatchedPos = 8;
+            return 8;
+         }
+         if ((active0 & 0x400000000c000L) != 0L)
+            return 8;
+         return -1;
+      case 9:
+         if ((active0 & 0x8000001000000L) != 0L)
+            return 8;
+         if ((active0 & 0x40011000010000L) != 0L)
+         {
+            jjmatchedKind = 123;
+            jjmatchedPos = 9;
+            return 8;
+         }
+         return -1;
+      case 10:
+         if ((active0 & 0x10000L) != 0L)
+         {
+            jjmatchedKind = 123;
+            jjmatchedPos = 10;
+            return 8;
+         }
+         if ((active0 & 0x40011000000000L) != 0L)
+            return 8;
+         return -1;
+      default :
+         return -1;
+   }
+}
+private final int jjStartNfa_0(int pos, long active0, long active1, long active2){
+   return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0, active1, active2), pos + 1);
+}
+private int jjStopAtPos(int pos, int kind)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   return pos + 1;
+}
+private int jjMoveStringLiteralDfa0_0(){
+   switch(curChar)
+   {
+      case 33:
+         jjmatchedKind = 92;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x80002000000000L, 0x0L);
+      case 35:
+         return jjStopAtPos(0, 84);
+      case 36:
+         return jjStartNfaWithStates_0(0, 86, 12);
+      case 37:
+         return jjStopAtPos(0, 111);
+      case 38:
+         jjmatchedKind = 108;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x8000000000L, 0x0L);
+      case 40:
+         return jjStartNfaWithStates_0(0, 77, 0);
+      case 41:
+         return jjStopAtPos(0, 78);
+      case 42:
+         jjmatchedKind = 106;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x100000000000000L, 0x0L);
+      case 43:
+         jjmatchedKind = 104;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x100000000L, 0x0L);
+      case 44:
+         return jjStopAtPos(0, 87);
+      case 45:
+         jjmatchedKind = 105;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x200000000L, 0x80L);
+      case 46:
+         return jjStopAtPos(0, 88);
+      case 47:
+         jjmatchedKind = 107;
+         return jjMoveStringLiteralDfa1_0(0x2L, 0x0L, 0x0L);
+      case 58:
+         return jjStopAtPos(0, 95);
+      case 59:
+         return jjStopAtPos(0, 83);
+      case 60:
+         jjmatchedKind = 91;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x201000800000000L, 0x0L);
+      case 61:
+         jjmatchedKind = 89;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x40000400000000L, 0x0L);
+      case 62:
+         jjmatchedKind = 90;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x402001000000000L, 0x0L);
+      case 63:
+         return jjStopAtPos(0, 94);
+      case 64:
+         return jjStopAtPos(0, 85);
+      case 91:
+         return jjStopAtPos(0, 81);
+      case 93:
+         return jjStopAtPos(0, 82);
+      case 94:
+         jjmatchedKind = 110;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x20000000000000L, 0x0L);
+      case 97:
+         return jjMoveStringLiteralDfa1_0(0x100000000000000L, 0x2L, 0x0L);
+      case 98:
+         return jjMoveStringLiteralDfa1_0(0x80000L, 0x0L, 0x0L);
+      case 100:
+         return jjMoveStringLiteralDfa1_0(0x4200000200000000L, 0x1L, 0x0L);
+      case 101:
+         return jjMoveStringLiteralDfa1_0(0x40815405154000L, 0x0L, 0x0L);
+      case 102:
+         return jjMoveStringLiteralDfa1_0(0x400000830200000L, 0x0L, 0x0L);
+      case 103:
+         return jjMoveStringLiteralDfa1_0(0x1008000000000L, 0x0L, 0x0L);
+      case 105:
+         return jjMoveStringLiteralDfa1_0(0x1a0002000000L, 0x4L, 0x0L);
+      case 106:
+         return jjMoveStringLiteralDfa1_0(0x400000L, 0x0L, 0x0L);
+      case 108:
+         return jjMoveStringLiteralDfa1_0(0x8000000000000L, 0x0L, 0x0L);
+      case 109:
+         return jjMoveStringLiteralDfa1_0(0x2000L, 0x0L, 0x0L);
+      case 111:
+         return jjMoveStringLiteralDfa1_0(0x8000040000000000L, 0x0L, 0x0L);
+      case 112:
+         return jjMoveStringLiteralDfa1_0(0x24000000008000L, 0x0L, 0x0L);
+      case 114:
+         return jjMoveStringLiteralDfa1_0(0x2802200040000000L, 0x0L, 0x0L);
+      case 115:
+         return jjMoveStringLiteralDfa1_0(0x10000000800000L, 0x0L, 0x0L);
+      case 116:
+         return jjMoveStringLiteralDfa1_0(0x1000002000020000L, 0x0L, 0x0L);
+      case 119:
+         return jjMoveStringLiteralDfa1_0(0x400088000000L, 0x0L, 0x0L);
+      case 123:
+         return jjStopAtPos(0, 79);
+      case 124:
+         jjmatchedKind = 109;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x4000000000L, 0x0L);
+      case 125:
+         return jjStopAtPos(0, 80);
+      case 126:
+         jjmatchedKind = 93;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x1c000000000000L, 0x0L);
+      default :
+         return jjMoveNfa_0(2, 0);
+   }
+}
+private int jjMoveStringLiteralDfa1_0(long active0, long active1, long active2){
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(0, active0, active1, active2);
+      return 1;
+   }
+   switch(curChar)
+   {
+      case 38:
+         if ((active1 & 0x8000000000L) != 0L)
+            return jjStopAtPos(1, 103);
+         else if ((active1 & 0x4000000000000L) != 0L)
+            return jjStopAtPos(1, 114);
+         break;
+      case 42:
+         if ((active0 & 0x2L) != 0L)
+            return jjStopAtPos(1, 1);
+         else if ((active1 & 0x100000000000000L) != 0L)
+            return jjStopAtPos(1, 120);
+         break;
+      case 58:
+         if ((active1 & 0x100000000L) != 0L)
+            return jjStopAtPos(1, 96);
+         else if ((active1 & 0x200000000L) != 0L)
+            return jjStopAtPos(1, 97);
+         break;
+      case 60:
+         if ((active1 & 0x1000000000000L) != 0L)
+         {
+            jjmatchedKind = 112;
+            jjmatchedPos = 1;
+         }
+         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x200000000000000L, active2, 0L);
+      case 61:
+         if ((active1 & 0x400000000L) != 0L)
+         {
+            jjmatchedKind = 98;
+            jjmatchedPos = 1;
+         }
+         else if ((active1 & 0x800000000L) != 0L)
+            return jjStopAtPos(1, 99);
+         else if ((active1 & 0x1000000000L) != 0L)
+            return jjStopAtPos(1, 100);
+         else if ((active1 & 0x2000000000L) != 0L)
+         {
+            jjmatchedKind = 101;
+            jjmatchedPos = 1;
+         }
+         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0xc0000000000000L, active2, 0L);
+      case 62:
+         if ((active1 & 0x2000000000000L) != 0L)
+         {
+            jjmatchedKind = 113;
+            jjmatchedPos = 1;
+         }
+         else if ((active2 & 0x80L) != 0L)
+            return jjStopAtPos(1, 135);
+         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x400000000000000L, active2, 0L);
+      case 94:
+         if ((active1 & 0x10000000000000L) != 0L)
+            return jjStopAtPos(1, 116);
+         break;
+      case 97:
+         return jjMoveStringLiteralDfa2_0(active0, 0x4002080020000L, active1, 0L, active2, 0L);
+      case 101:
+         return jjMoveStringLiteralDfa2_0(active0, 0x6a03208240080000L, active1, 0L, active2, 0L);
+      case 102:
+         if ((active0 & 0x2000000L) != 0L)
+            return jjStartNfaWithStates_0(1, 25, 8);
+         break;
+      case 104:
+         return jjMoveStringLiteralDfa2_0(active0, 0x8000000L, active1, 0L, active2, 0L);
+      case 105:
+         return jjMoveStringLiteralDfa2_0(active0, 0x1010400000000000L, active1, 0x1L, active2, 0L);
+      case 108:
+         return jjMoveStringLiteralDfa2_0(active0, 0x4000000L, active1, 0x2L, active2, 0L);
+      case 110:
+         return jjMoveStringLiteralDfa2_0(active0, 0x401b5401154000L, active1, 0x4L, active2, 0L);
+      case 111:
+         return jjMoveStringLiteralDfa2_0(active0, 0x408000030602000L, active1, 0L, active2, 0L);
+      case 112:
+         return jjMoveStringLiteralDfa2_0(active0, 0x800000L, active1, 0L, active2, 0L);
+      case 114:
+         if ((active0 & 0x8000000000000000L) != 0L)
+            return jjStartNfaWithStates_0(1, 63, 8);
+         return jjMoveStringLiteralDfa2_0(active0, 0x20000000008000L, active1, 0L, active2, 0L);
+      case 115:
+         return jjMoveStringLiteralDfa2_0(active0, 0x100000000000000L, active1, 0L, active2, 0L);
+      case 117:
+         return jjMoveStringLiteralDfa2_0(active0, 0x40800000000L, active1, 0L, active2, 0L);
+      case 118:
+         return jjMoveStringLiteralDfa2_0(active0, 0x800000000000L, active1, 0L, active2, 0L);
+      case 124:
+         if ((active1 & 0x4000000000L) != 0L)
+            return jjStopAtPos(1, 102);
+         else if ((active1 & 0x8000000000000L) != 0L)
+            return jjStopAtPos(1, 115);
+         break;
+      case 126:
+         if ((active1 & 0x20000000000000L) != 0L)
+            return jjStopAtPos(1, 117);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(0, active0, active1, active2);
+}
+private int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1, long old2, long active2){
+   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)
+      return jjStartNfa_0(0, old0, old1, old2);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(1, active0, active1, 0L);
+      return 2;
+   }
+   switch(curChar)
+   {
+      case 60:
+         if ((active1 & 0x200000000000000L) != 0L)
+            return jjStopAtPos(2, 121);
+         break;
+      case 61:
+         if ((active1 & 0x40000000000000L) != 0L)
+            return jjStopAtPos(2, 118);
+         else if ((active1 & 0x80000000000000L) != 0L)
+            return jjStopAtPos(2, 119);
+         break;
+      case 62:
+         if ((active1 & 0x400000000000000L) != 0L)
+            return jjStopAtPos(2, 122);
+         break;
+      case 97:
+         return jjMoveStringLiteralDfa3_0(active0, 0x2202000000000000L, active1, 0L);
+      case 98:
+         return jjMoveStringLiteralDfa3_0(active0, 0x20000L, active1, 0L);
+      case 99:
+         return jjMoveStringLiteralDfa3_0(active0, 0x8000000000000L, active1, 0L);
+      case 100:
+         if ((active0 & 0x100000L) != 0L)
+         {
+            jjmatchedKind = 20;
+            jjmatchedPos = 2;
+         }
+         return jjMoveStringLiteralDfa3_0(active0, 0x40015401056000L, active1, 0L);
+      case 101:
+         return jjMoveStringLiteralDfa3_0(active0, 0x800000800000L, active1, 0L);
+      case 102:
+         return jjMoveStringLiteralDfa3_0(active0, 0x4000000200000000L, active1, 0L);
+      case 103:
+         if ((active0 & 0x200000000000L) != 0L)
+            return jjStartNfaWithStates_0(2, 45, 8);
+         return jjMoveStringLiteralDfa3_0(active0, 0x10000000080000L, active1, 0L);
+      case 105:
+         return jjMoveStringLiteralDfa3_0(active0, 0x88408000L, active1, 0x4L);
+      case 108:
+         return jjMoveStringLiteralDfa3_0(active0, 0x800000000000000L, active1, 0L);
+      case 109:
+         return jjMoveStringLiteralDfa3_0(active0, 0x1000000000000000L, active1, 0L);
+      case 110:
+         return jjMoveStringLiteralDfa3_0(active0, 0x1008800000000L, active1, 0L);
+      case 111:
+         return jjMoveStringLiteralDfa3_0(active0, 0x20080000000000L, active1, 0L);
+      case 112:
+         return jjMoveStringLiteralDfa3_0(active0, 0x20040000000L, active1, 0L);
+      case 114:
+         if ((active0 & 0x10000000L) != 0L)
+         {
+            jjmatchedKind = 28;
+            jjmatchedPos = 2;
+         }
+         return jjMoveStringLiteralDfa3_0(active0, 0x404400020200000L, active1, 0L);
+      case 115:
+         return jjMoveStringLiteralDfa3_0(active0, 0x100002004000000L, active1, 0x1L);
+      case 116:
+         return jjMoveStringLiteralDfa3_0(active0, 0x140000000000L, active1, 0L);
+      case 119:
+         return jjMoveStringLiteralDfa3_0(active0, 0L, active1, 0x2L);
+      default :
+         break;
+   }
+   return jjStartNfa_0(1, active0, active1, 0L);
+}
+private int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1){
+   if (((active0 &= old0) | (active1 &= old1)) == 0L)
+      return jjStartNfa_0(1, old0, old1, 0L);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(2, active0, active1, 0L);
+      return 3;
+   }
+   switch(curChar)
+   {
+      case 97:
+         return jjMoveStringLiteralDfa4_0(active0, 0xc000200000000L, active1, 0x3L);
+      case 99:
+         return jjMoveStringLiteralDfa4_0(active0, 0x400000c00800000L, active1, 0L);
+      case 101:
+         if ((active0 & 0x4000000L) != 0L)
+            return jjStartNfaWithStates_0(3, 26, 8);
+         else if ((active0 & 0x400000000000L) != 0L)
+            return jjStartNfaWithStates_0(3, 46, 8);
+         else if ((active0 & 0x1000000000000000L) != 0L)
+            return jjStartNfaWithStates_0(3, 60, 8);
+         return jjMoveStringLiteralDfa4_0(active0, 0x800108060000000L, active1, 0L);
+      case 102:
+         return jjMoveStringLiteralDfa4_0(active0, 0x1000000000L, active1, 0L);
+      case 103:
+         return jjMoveStringLiteralDfa4_0(active0, 0x10000000000L, active1, 0L);
+      case 105:
+         return jjMoveStringLiteralDfa4_0(active0, 0x100000000080000L, active1, 0L);
+      case 107:
+         if ((active0 & 0x200000L) != 0L)
+            return jjStartNfaWithStates_0(3, 21, 8);
+         else if ((active0 & 0x2000000000L) != 0L)
+            return jjStartNfaWithStates_0(3, 37, 8);
+         break;
+      case 108:
+         if ((active0 & 0x2000000000000L) != 0L)
+         {
+            jjmatchedKind = 49;
+            jjmatchedPos = 3;
+         }
+         return jjMoveStringLiteralDfa4_0(active0, 0x2000000008020000L, active1, 0L);
+      case 109:
+         return jjMoveStringLiteralDfa4_0(active0, 0xc000L, active1, 0L);
+      case 110:
+         if ((active0 & 0x400000L) != 0L)
+            return jjStartNfaWithStates_0(3, 22, 8);
+         return jjMoveStringLiteralDfa4_0(active0, 0x10800000000000L, active1, 0L);
+      case 112:
+         return jjMoveStringLiteralDfa4_0(active0, 0x4060040000010000L, active1, 0L);
+      case 115:
+         return jjMoveStringLiteralDfa4_0(active0, 0x200000001000000L, active1, 0L);
+      case 116:
+         if ((active0 & 0x80000000L) != 0L)
+            return jjStartNfaWithStates_0(3, 31, 8);
+         return jjMoveStringLiteralDfa4_0(active0, 0x4000040000L, active1, 0x4L);
+      case 117:
+         return jjMoveStringLiteralDfa4_0(active0, 0xa0000002000L, active1, 0L);
+      case 118:
+         return jjMoveStringLiteralDfa4_0(active0, 0x1000000000000L, active1, 0L);
+      default :
+         break;
+   }
+   return jjStartNfa_0(2, active0, active1, 0L);
+}
+private int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1){
+   if (((active0 &= old0) | (active1 &= old1)) == 0L)
+      return jjStartNfa_0(2, old0, old1, 0L);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(3, active0, active1, 0L);
+      return 4;
+   }
+   switch(curChar)
+   {
+      case 97:
+         return jjMoveStringLiteralDfa5_0(active0, 0x4801004440040000L, active1, 0L);
+      case 98:
+         return jjMoveStringLiteralDfa5_0(active0, 0L, active1, 0x1L);
+      case 101:
+         if ((active0 & 0x20000L) != 0L)
+            return jjStartNfaWithStates_0(4, 17, 8);
+         else if ((active0 & 0x8000000L) != 0L)
+            return jjStartNfaWithStates_0(4, 27, 8);
+         else if ((active0 & 0x400000000000000L) != 0L)
+            return jjStartNfaWithStates_0(4, 58, 8);
+         return jjMoveStringLiteralDfa5_0(active0, 0x30010000000000L, active1, 0L);
+      case 103:
+         return jjMoveStringLiteralDfa5_0(active0, 0x100100000000000L, active1, 0L);
+      case 105:
+         return jjMoveStringLiteralDfa5_0(active0, 0x808000L, active1, 0x4L);
+      case 108:
+         return jjMoveStringLiteralDfa5_0(active0, 0x8000000002000L, active1, 0L);
+      case 109:
+         return jjMoveStringLiteralDfa5_0(active0, 0x4000000000000L, active1, 0L);
+      case 110:
+         if ((active0 & 0x80000L) != 0L)
+            return jjStartNfaWithStates_0(4, 19, 8);
+         break;
+      case 111:
+         return jjMoveStringLiteralDfa5_0(active0, 0x4000L, active1, 0L);
+      case 112:
+         return jjMoveStringLiteralDfa5_0(active0, 0x1000000L, active1, 0L);
+      case 114:
+         return jjMoveStringLiteralDfa5_0(active0, 0x40008000010000L, active1, 0L);
+      case 115:
+         return jjMoveStringLiteralDfa5_0(active0, 0x200000000000000L, active1, 0L);
+      case 116:
+         if ((active0 & 0x20000000000L) != 0L)
+            return jjStartNfaWithStates_0(4, 41, 8);
+         else if ((active0 & 0x80000000000L) != 0L)
+            return jjStartNfaWithStates_0(4, 43, 8);
+         else if ((active0 & 0x800000000000L) != 0L)
+            return jjStartNfaWithStates_0(4, 47, 8);
+         return jjMoveStringLiteralDfa5_0(active0, 0x2000000800000000L, active1, 0L);
+      case 117:
+         return jjMoveStringLiteralDfa5_0(active0, 0x41200000000L, active1, 0L);
+      case 118:
+         return jjMoveStringLiteralDfa5_0(active0, 0x20000000L, active1, 0L);
+      case 121:
+         return jjMoveStringLiteralDfa5_0(active0, 0L, active1, 0x2L);
+      default :
+         break;
+   }
+   return jjStartNfa_0(3, active0, active1, 0L);
+}
+private int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1){
+   if (((active0 &= old0) | (active1 &= old1)) == 0L)
+      return jjStartNfa_0(3, old0, old1, 0L);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(4, active0, active1, 0L);
+      return 5;
+   }
+   switch(curChar)
+   {
+      case 97:
+         return jjMoveStringLiteralDfa6_0(active0, 0x8000000000L, active1, 0x4L);
+      case 98:
+         return jjMoveStringLiteralDfa6_0(active0, 0x40000L, active1, 0L);
+      case 100:
+         if ((active0 & 0x10000000000000L) != 0L)
+            return jjStartNfaWithStates_0(5, 52, 8);
+         return jjMoveStringLiteralDfa6_0(active0, 0x4000L, active1, 0L);
+      case 101:
+         if ((active0 & 0x2000L) != 0L)
+            return jjStartNfaWithStates_0(5, 13, 8);
+         return jjMoveStringLiteralDfa6_0(active0, 0x4100021000000L, active1, 0L);
+      case 102:
+         return jjMoveStringLiteralDfa6_0(active0, 0x800000L, active1, 0L);
+      case 105:
+         return jjMoveStringLiteralDfa6_0(active0, 0x2200000800010000L, active1, 0L);
+      case 108:
+         return jjMoveStringLiteralDfa6_0(active0, 0x200000000L, active1, 0x1L);
+      case 110:
+         if ((active0 & 0x100000000000000L) != 0L)
+            return jjStartNfaWithStates_0(5, 56, 8);
+         return jjMoveStringLiteralDfa6_0(active0, 0x11000000000L, active1, 0L);
+      case 111:
+         return jjMoveStringLiteralDfa6_0(active0, 0x40000000000000L, active1, 0L);
+      case 112:
+         return jjMoveStringLiteralDfa6_0(active0, 0x8000000000000L, active1, 0L);
+      case 114:
+         if ((active0 & 0x1000000000000L) != 0L)
+            return jjStartNfaWithStates_0(5, 48, 8);
+         return jjMoveStringLiteralDfa6_0(active0, 0x4020000000000000L, active1, 0L);
+      case 115:
+         if ((active1 & 0x2L) != 0L)
+            return jjStartNfaWithStates_0(5, 65, 8);
+         return jjMoveStringLiteralDfa6_0(active0, 0x800004400000000L, active1, 0L);
+      case 116:
+         if ((active0 & 0x40000000L) != 0L)
+            return jjStartNfaWithStates_0(5, 30, 8);
+         else if ((active0 & 0x40000000000L) != 0L)
+            return jjStartNfaWithStates_0(5, 42, 8);
+         return jjMoveStringLiteralDfa6_0(active0, 0x8000L, active1, 0L);
+      default :
+         break;
+   }
+   return jjStartNfa_0(4, active0, active1, 0L);
+}
+private int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1){
+   if (((active0 &= old0) | (active1 &= old1)) == 0L)
+      return jjStartNfa_0(4, old0, old1, 0L);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(5, active0, active1, 0L);
+      return 6;
+   }
+   switch(curChar)
+   {
+      case 97:
+         return jjMoveStringLiteralDfa7_0(active0, 0x4008000000000000L, active1, 0L);
+      case 99:
+         return jjMoveStringLiteralDfa7_0(active0, 0x1001000000L, active1, 0L);
+      case 101:
+         if ((active0 & 0x400000000L) != 0L)
+            return jjStartNfaWithStates_0(6, 34, 8);
+         else if ((active0 & 0x800000000000000L) != 0L)
+            return jjStartNfaWithStates_0(6, 59, 8);
+         else if ((active1 & 0x1L) != 0L)
+            return jjStartNfaWithStates_0(6, 64, 8);
+         return jjMoveStringLiteralDfa7_0(active0, 0x10000000000L, active1, 0L);
+      case 103:
+         return jjMoveStringLiteralDfa7_0(active0, 0x200000000000000L, active1, 0L);
+      case 105:
+         return jjMoveStringLiteralDfa7_0(active0, 0x8000L, active1, 0L);
+      case 107:
+         if ((active0 & 0x4000000000L) != 0L)
+            return jjStartNfaWithStates_0(6, 38, 8);
+         break;
+      case 108:
+         if ((active1 & 0x4L) != 0L)
+            return jjStartNfaWithStates_0(6, 66, 8);
+         return jjMoveStringLiteralDfa7_0(active0, 0x40000L, active1, 0L);
+      case 109:
+         return jjMoveStringLiteralDfa7_0(active0, 0x2000000000010000L, active1, 0L);
+      case 111:
+         return jjMoveStringLiteralDfa7_0(active0, 0x800000000L, active1, 0L);
+      case 112:
+         return jjMoveStringLiteralDfa7_0(active0, 0x40000000000000L, active1, 0L);
+      case 114:
+         if ((active0 & 0x20000000L) != 0L)
+            return jjStartNfaWithStates_0(6, 29, 8);
+         else if ((active0 & 0x100000000000L) != 0L)
+            return jjStartNfaWithStates_0(6, 44, 8);
+         break;
+      case 116:
+         if ((active0 & 0x200000000L) != 0L)
+            return jjStartNfaWithStates_0(6, 33, 8);
+         return jjMoveStringLiteralDfa7_0(active0, 0x24008000000000L, active1, 0L);
+      case 117:
+         return jjMoveStringLiteralDfa7_0(active0, 0x4000L, active1, 0L);
+      case 121:
+         if ((active0 & 0x800000L) != 0L)
+            return jjStartNfaWithStates_0(6, 23, 8);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(5, active0, active1, 0L);
+}
+private int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1){
+   if (((active0 &= old0) | (active1 &= old1)) == 0L)
+      return jjStartNfa_0(5, old0, old1, 0L);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(6, active0, 0L, 0L);
+      return 7;
+   }
+   switch(curChar)
+   {
+      case 101:
+         if ((active0 & 0x40000L) != 0L)
+            return jjStartNfaWithStates_0(7, 18, 8);
+         else if ((active0 & 0x8000000000L) != 0L)
+            return jjStartNfaWithStates_0(7, 39, 8);
+         else if ((active0 & 0x2000000000000000L) != 0L)
+            return jjStartNfaWithStates_0(7, 61, 8);
+         return jjMoveStringLiteralDfa8_0(active0, 0x44000000000000L);
+      case 105:
+         return jjMoveStringLiteralDfa8_0(active0, 0x1010000L);
+      case 108:
+         return jjMoveStringLiteralDfa8_0(active0, 0x4000L);
+      case 109:
+         if ((active0 & 0x4000000000000000L) != 0L)
+            return jjStartNfaWithStates_0(7, 62, 8);
+         break;
+      case 110:
+         if ((active0 & 0x800000000L) != 0L)
+            return jjStartNfaWithStates_0(7, 35, 8);
+         else if ((active0 & 0x200000000000000L) != 0L)
+            return jjStartNfaWithStates_0(7, 57, 8);
+         break;
+      case 114:
+         return jjMoveStringLiteralDfa8_0(active0, 0x8010000000000L);
+      case 116:
+         return jjMoveStringLiteralDfa8_0(active0, 0x1000000000L);
+      case 118:
+         return jjMoveStringLiteralDfa8_0(active0, 0x8000L);
+      case 121:
+         if ((active0 & 0x20000000000000L) != 0L)
+            return jjStartNfaWithStates_0(7, 53, 8);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(6, active0, 0L, 0L);
+}
+private int jjMoveStringLiteralDfa8_0(long old0, long active0){
+   if (((active0 &= old0)) == 0L)
+      return jjStartNfa_0(6, old0, 0L, 0L);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(7, active0, 0L, 0L);
+      return 8;
+   }
+   switch(curChar)
+   {
+      case 97:
+         return jjMoveStringLiteralDfa9_0(active0, 0x8010000000000L);
+      case 101:
+         if ((active0 & 0x4000L) != 0L)
+            return jjStartNfaWithStates_0(8, 14, 8);
+         else if ((active0 & 0x8000L) != 0L)
+            return jjStartNfaWithStates_0(8, 15, 8);
+         break;
+      case 102:
+         return jjMoveStringLiteralDfa9_0(active0, 0x1000000L);
+      case 105:
+         return jjMoveStringLiteralDfa9_0(active0, 0x1000000000L);
+      case 114:
+         if ((active0 & 0x4000000000000L) != 0L)
+            return jjStartNfaWithStates_0(8, 50, 8);
+         return jjMoveStringLiteralDfa9_0(active0, 0x40000000000000L);
+      case 116:
+         return jjMoveStringLiteralDfa9_0(active0, 0x10000L);
+      default :
+         break;
+   }
+   return jjStartNfa_0(7, active0, 0L, 0L);
+}
+private int jjMoveStringLiteralDfa9_0(long old0, long active0){
+   if (((active0 &= old0)) == 0L)
+      return jjStartNfa_0(7, old0, 0L, 0L);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(8, active0, 0L, 0L);
+      return 9;
+   }
+   switch(curChar)
+   {
+      case 105:
+         return jjMoveStringLiteralDfa10_0(active0, 0x10000L);
+      case 109:
+         if ((active0 & 0x8000000000000L) != 0L)
+            return jjStartNfaWithStates_0(9, 51, 8);
+         break;
+      case 111:
+         return jjMoveStringLiteralDfa10_0(active0, 0x1000000000L);
+      case 116:
+         return jjMoveStringLiteralDfa10_0(active0, 0x40010000000000L);
+      case 121:
+         if ((active0 & 0x1000000L) != 0L)
+            return jjStartNfaWithStates_0(9, 24, 8);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(8, active0, 0L, 0L);
+}
+private int jjMoveStringLiteralDfa10_0(long old0, long active0){
+   if (((active0 &= old0)) == 0L)
+      return jjStartNfa_0(8, old0, 0L, 0L);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(9, active0, 0L, 0L);
+      return 10;
+   }
+   switch(curChar)
+   {
+      case 101:
+         if ((active0 & 0x10000000000L) != 0L)
+            return jjStartNfaWithStates_0(10, 40, 8);
+         break;
+      case 110:
+         if ((active0 & 0x1000000000L) != 0L)
+            return jjStartNfaWithStates_0(10, 36, 8);
+         break;
+      case 118:
+         return jjMoveStringLiteralDfa11_0(active0, 0x10000L);
+      case 121:
+         if ((active0 & 0x40000000000000L) != 0L)
+            return jjStartNfaWithStates_0(10, 54, 8);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(9, active0, 0L, 0L);
+}
+private int jjMoveStringLiteralDfa11_0(long old0, long active0){
+   if (((active0 &= old0)) == 0L)
+      return jjStartNfa_0(9, old0, 0L, 0L);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_0(10, active0, 0L, 0L);
+      return 11;
+   }
+   switch(curChar)
+   {
+      case 101:
+         if ((active0 & 0x10000L) != 0L)
+            return jjStartNfaWithStates_0(11, 16, 8);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_0(10, active0, 0L, 0L);
+}
+private int jjStartNfaWithStates_0(int pos, int kind, int state)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) { return pos + 1; }
+   return jjMoveNfa_0(state, pos + 1);
+}
+static final long[] jjbitVec0 = {
+   0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL
+};
+static final long[] jjbitVec2 = {
+   0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL
+};
+private int jjMoveNfa_0(int startState, int curPos)
+{
+   int startsAt = 0;
+   jjnewStateCnt = 250;
+   int i = 1;
+   jjstateSet[0] = startState;
+   int kind = 0x7fffffff;
+   for (;;)
+   {
+      if (++jjround == 0x7fffffff)
+         ReInitRounds();
+      if (curChar < 64)
+      {
+         long l = 1L << curChar;
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 194:
+               case 8:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 123)
+                     kind = 123;
+                  { jjCheckNAdd(8); }
+                  break;
+               case 62:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 123)
+                     kind = 123;
+                  { jjCheckNAdd(8); }
+                  break;
+               case 2:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     { jjCheckNAddStates(0, 12); }
+                  else if (curChar == 39)
+                     { jjCheckNAddStates(13, 20); }
+                  else if (curChar == 34)
+                     { jjCheckNAddStates(21, 23); }
+                  else if (curChar == 36)
+                     jjstateSet[jjnewStateCnt++] = 12;
+                  else if (curChar == 47)
+                     jjstateSet[jjnewStateCnt++] = 3;
+                  else if (curChar == 40)
+                     jjstateSet[jjnewStateCnt++] = 0;
+                  if ((0x3ff000000000000L & l) != 0L)
+                  {
+                     if (kind > 127)
+                        kind = 127;
+                     { jjCheckNAdd(14); }
+                  }
+                  break;
+               case 149:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 123)
+                     kind = 123;
+                  { jjCheckNAdd(8); }
+                  break;
+               case 137:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 123)
+                     kind = 123;
+                  { jjCheckNAdd(8); }
+                  break;
+               case 242:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 123)
+                     kind = 123;
+                  { jjCheckNAdd(8); }
+                  break;
+               case 223:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 123)
+                     kind = 123;
+                  { jjCheckNAdd(8); }
+                  break;
+               case 61:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 123)
+                     kind = 123;
+                  { jjCheckNAdd(8); }
+                  break;
+               case 241:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 123)
+                     kind = 123;
+                  { jjCheckNAdd(8); }
+                  break;
+               case 90:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 123)
+                     kind = 123;
+                  { jjCheckNAdd(8); }
+                  break;
+               case 60:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 123)
+                     kind = 123;
+                  { jjCheckNAdd(8); }
+                  break;
+               case 0:
+                  if (curChar == 42)
+                     jjstateSet[jjnewStateCnt++] = 1;
+                  break;
+               case 1:
+                  if ((0xfffffdffffffffffL & l) != 0L && kind > 4)
+                     kind = 4;
+                  break;
+               case 3:
+                  if (curChar != 47)
+                     break;
+                  if (kind > 12)
+                     kind = 12;
+                  { jjCheckNAdd(4); }
+                  break;
+               case 4:
+                  if ((0xfffffffffffffbffL & l) == 0L)
+                     break;
+                  if (kind > 12)
+                     kind = 12;
+                  { jjCheckNAdd(4); }
+                  break;
+               case 5:
+                  if (curChar == 47)
+                     jjstateSet[jjnewStateCnt++] = 3;
+                  break;
+               case 10:
+                  if ((0xfffffffeffffffffL & l) == 0L)
+                     break;
+                  if (kind > 123)
+                     kind = 123;
+                  jjstateSet[jjnewStateCnt++] = 10;
+                  break;
+               case 11:
+                  if (curChar == 36)
+                     jjstateSet[jjnewStateCnt++] = 12;
+                  break;
+               case 13:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 124)
+                     kind = 124;
+                  jjstateSet[jjnewStateCnt++] = 13;
+                  break;
+               case 14:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 127)
+                     kind = 127;
+                  { jjCheckNAdd(14); }
+                  break;
+               case 15:
+                  if (curChar == 34)
+                     { jjCheckNAddStates(21, 23); }
+                  break;
+               case 16:
+                  if ((0xfffffffbffffdbffL & l) != 0L)
+                     { jjCheckNAddStates(21, 23); }
+                  break;
+               case 18:
+                  if ((0x8400000000L & l) != 0L)
+                     { jjCheckNAddStates(21, 23); }
+                  break;
+               case 19:
+                  if (curChar == 34 && kind > 134)
+                     kind = 134;
+                  break;
+               case 20:
+                  if ((0xff000000000000L & l) != 0L)
+                     { jjCheckNAddStates(24, 27); }
+                  break;
+               case 21:
+                  if ((0xff000000000000L & l) != 0L)
+                     { jjCheckNAddStates(21, 23); }
+                  break;
+               case 22:
+                  if ((0xf000000000000L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 23;
+                  break;
+               case 23:
+                  if ((0xff000000000000L & l) != 0L)
+                     { jjCheckNAdd(21); }
+                  break;
+               case 24:
+                  if (curChar == 39)
+                     { jjCheckNAddStates(13, 20); }
+                  break;
+               case 27:
+                  if ((0x100000200L & l) == 0L)
+                     break;
+                  if (kind > 127)
+                     kind = 127;
+                  { jjCheckNAddTwoStates(27, 28); }
+                  break;
+               case 28:
+                  if ((0x83ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 127)
+                     kind = 127;
+                  { jjCheckNAdd(28); }
+                  break;
+               case 31:
+                  if ((0x100000200L & l) != 0L)
+                     { jjCheckNAddTwoStates(31, 32); }
+                  break;
+               case 32:
+                  if ((0x83ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 127)
+                     kind = 127;
+                  { jjCheckNAdd(32); }
+                  break;
+               case 35:
+                  if ((0x100000200L & l) == 0L)
+                     break;
+                  if (kind > 127)
+                     kind = 127;
+                  { jjCheckNAddTwoStates(35, 36); }
+                  break;
+               case 36:
+                  if ((0x80ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 127)
+                     kind = 127;
+                  { jjCheckNAdd(36); }
+                  break;
+               case 39:
+                  if ((0x100000200L & l) == 0L)
+                     break;
+                  if (kind > 127)
+                     kind = 127;
+                  { jjCheckNAddTwoStates(39, 40); }
+                  break;
+               case 40:
+                  if ((0x8003000000000000L & l) == 0L)
+                     break;
+                  if (kind > 127)
+                     kind = 127;
+                  { jjCheckNAdd(40); }
+                  break;
+               case 47:
+                  if (curChar == 48 && kind > 70)
+                     kind = 70;
+                  break;
+               case 52:
+                  if (curChar == 49 && kind > 70)
+                     kind = 70;
+                  break;
+               case 123:
+                  if (curChar == 48 && kind > 73)
+                     kind = 73;
+                  break;
+               case 128:
+                  if (curChar == 49 && kind > 73)
+                     kind = 73;
+                  break;
+               case 160:
+                  if (curChar == 48 && kind > 76)
+                     kind = 76;
+                  break;
+               case 167:
+                  if (curChar == 49 && kind > 76)
+                     kind = 76;
+                  break;
+               case 174:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     { jjCheckNAddStates(0, 12); }
+                  break;
+               case 175:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     { jjCheckNAddTwoStates(175, 176); }
+                  break;
+               case 176:
+                  if (curChar == 39)
+                     { jjCheckNAddTwoStates(25, 26); }
+                  break;
+               case 177:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     { jjCheckNAddTwoStates(177, 178); }
+                  break;
+               case 178:
+                  if (curChar == 39)
+                     { jjCheckNAddTwoStates(29, 30); }
+                  break;
+               case 179:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     { jjCheckNAddTwoStates(179, 180); }
+                  break;
+               case 180:
+                  if (curChar == 39)
+                     { jjCheckNAddTwoStates(33, 34); }
+                  break;
+               case 181:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     { jjCheckNAddTwoStates(181, 182); }
+                  break;
+               case 182:
+                  if (curChar == 39)
+                     { jjCheckNAddTwoStates(37, 38); }
+                  break;
+               case 183:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     { jjCheckNAddTwoStates(183, 184); }
+                  break;
+               case 184:
+                  if (curChar != 46)
+                     break;
+                  if (kind > 133)
+                     kind = 133;
+                  { jjCheckNAdd(185); }
+                  break;
+               case 185:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 133)
+                     kind = 133;
+                  { jjCheckNAdd(185); }
+                  break;
+               case 186:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     { jjCheckNAddStates(28, 30); }
+                  break;
+               case 187:
+                  if (curChar == 46)
+                     { jjCheckNAddTwoStates(188, 189); }
+                  break;
+               case 188:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     { jjCheckNAddTwoStates(188, 189); }
+                  break;
+               case 190:
+                  if ((0x280000000000L & l) != 0L)
+                     { jjCheckNAdd(191); }
+                  break;
+               case 191:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 133)
+                     kind = 133;
+                  { jjCheckNAdd(191); }
+                  break;
+               case 195:
+                  if (curChar == 49 && kind > 69)
+                     kind = 69;
+                  break;
+               case 203:
+                  if (curChar == 48 && kind > 69)
+                     kind = 69;
+                  break;
+               case 218:
+                  if (curChar == 48 && kind > 68)
+                     kind = 68;
+                  break;
+               case 224:
+                  if (curChar == 49 && kind > 68)
+                     kind = 68;
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else if (curChar < 128)
+      {
+         long l = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 194:
+                  if ((0x7fffffe87fffffeL & l) != 0L)
+                  {
+                     if (kind > 123)
+                        kind = 123;
+                     { jjCheckNAdd(8); }
+                  }
+                  if (curChar == 114)
+                     jjstateSet[jjnewStateCnt++] = 215;
+                  if (curChar == 114)
+                     jjstateSet[jjnewStateCnt++] = 210;
+                  if (curChar == 114)
+                     jjstateSet[jjnewStateCnt++] = 208;
+                  if (curChar == 114)
+                     jjstateSet[jjnewStateCnt++] = 204;
+                  if (curChar == 114)
+                     jjstateSet[jjnewStateCnt++] = 201;
+                  if (curChar == 114)
+                     jjstateSet[jjnewStateCnt++] = 196;
+                  if (curChar == 114)
+                     jjstateSet[jjnewStateCnt++] = 193;
+                  break;
+               case 62:
+                  if ((0x7fffffe87fffffeL & l) != 0L)
+                  {
+                     if (kind > 123)
+                        kind = 123;
+                     { jjCheckNAdd(8); }
+                  }
+                  if (curChar == 110)
+                     { jjCheckNAdd(63); }
+                  else if (curChar == 115)
+                     jjstateSet[jjnewStateCnt++] = 61;
+                  break;
+               case 2:
+                  if ((0x7fffffe87fffffeL & l) != 0L)
+                  {
+                     if (kind > 123)
+                        kind = 123;
+                     { jjCheckNAdd(8); }
+                  }
+                  else if (curChar == 92)
+                     { jjCheckNAdd(10); }
+                  else if (curChar == 96)
+                     jjstateSet[jjnewStateCnt++] = 7;
+                  if (curChar == 119)
+                     { jjAddStates(31, 34); }
+                  else if (curChar == 115)
+                     { jjAddStates(35, 38); }
+                  else if (curChar == 116)
+                     { jjAddStates(39, 45); }
+                  else if (curChar == 114)
+                     { jjAddStates(46, 51); }
+                  else if (curChar == 98)
+                     { jjAddStates(52, 54); }
+                  else if (curChar == 110)
+                     { jjAddStates(55, 61); }
+                  else if (curChar == 112)
+                     { jjAddStates(62, 67); }
+                  else if (curChar == 99)
+                     { jjAddStates(68, 72); }
+                  else if (curChar == 97)
+                     { jjAddStates(73, 74); }
+                  else if (curChar == 104)
+                     { jjAddStates(75, 76); }
+                  else if (curChar == 120)
+                     { jjAddStates(77, 78); }
+                  else if (curChar == 95)
+                  {
+                     if (kind > 127)
+                        kind = 127;
+                     { jjCheckNAdd(14); }
+                  }
+                  break;
+               case 149:
+                  if ((0x7fffffe87fffffeL & l) != 0L)
+                  {
+                     if (kind > 123)
+                        kind = 123;
+                     { jjCheckNAdd(8); }
+                  }
+                  if (curChar == 116)
+                     jjstateSet[jjnewStateCnt++] = 172;
+                  else if (curChar == 99)
+                     jjstateSet[jjnewStateCnt++] = 154;
+                  else if (curChar == 110)
+                     jjstateSet[jjnewStateCnt++] = 151;
+                  else if (curChar == 112)
+                     jjstateSet[jjnewStateCnt++] = 148;
+                  if (curChar == 116)
+                     jjstateSet[jjnewStateCnt++] = 165;
+                  if (curChar == 116)
+                     jjstateSet[jjnewStateCnt++] = 158;
+                  break;
+               case 137:
+                  if ((0x7fffffe87fffffeL & l) != 0L)
+                  {
+                     if (kind > 123)
+                        kind = 123;
+                     { jjCheckNAdd(8); }
+                  }
+                  if (curChar == 117)
+                     jjstateSet[jjnewStateCnt++] = 144;
+                  if (curChar == 117)
+                     jjstateSet[jjnewStateCnt++] = 140;
+                  if (curChar == 117)
+                     jjstateSet[jjnewStateCnt++] = 136;
+                  break;
+               case 242:
+                  if ((0x7fffffe87fffffeL & l) != 0L)
+                  {
+                     if (kind > 123)
+                        kind = 123;
+                     { jjCheckNAdd(8); }
+                  }
+                  if (curChar == 101)
+                     jjstateSet[jjnewStateCnt++] = 248;
+                  else if (curChar == 111)
+                     { jjCheckNAdd(206); }
+                  else if (curChar == 97)
+                     jjstateSet[jjnewStateCnt++] = 241;
+                  if (curChar == 101)
+                     jjstateSet[jjnewStateCnt++] = 245;
+                  break;
+               case 223:
+                  if ((0x7fffffe87fffffeL & l) != 0L)
+                  {
+                     if (kind > 123)
+                        kind = 123;
+                     { jjCheckNAdd(8); }
+                  }
+                  if (curChar == 116)
+                     jjstateSet[jjnewStateCnt++] = 238;
+                  else if (curChar == 117)
+                     jjstateSet[jjnewStateCnt++] = 228;
+                  if (curChar == 116)
+                     jjstateSet[jjnewStateCnt++] = 233;
+                  else if (curChar == 117)
+                     jjstateSet[jjnewStateCnt++] = 222;
+                  break;
+               case 61:
+                  if ((0x7fffffe87fffffeL & l) != 0L)
+                  {
+                     if (kind > 123)
+                        kind = 123;
+                     { jjCheckNAdd(8); }
+                  }
+                  if (curChar == 115)
+                     jjstateSet[jjnewStateCnt++] = 60;
+                  break;
+               case 241:
+                  if ((0x7fffffe87fffffeL & l) != 0L)
+                  {
+                     if (kind > 123)
+                        kind = 123;
+                     { jjCheckNAdd(8); }
+                  }
+                  if (curChar == 110)
+                     { jjCheckNAdd(198); }
+                  break;
+               case 90:
+                  if ((0x7fffffe87fffffeL & l) != 0L)
+                  {
+                     if (kind > 123)
+                        kind = 123;
+                     { jjCheckNAdd(8); }
+                  }
+                  if (curChar == 117)
+                     jjstateSet[jjnewStateCnt++] = 110;
+                  else if (curChar == 109)
+                     jjstateSet[jjnewStateCnt++] = 98;
+                  else if (curChar == 111)
+                     jjstateSet[jjnewStateCnt++] = 89;
+                  if (curChar == 117)
+                     jjstateSet[jjnewStateCnt++] = 103;
+                  if (curChar == 117)
+                     jjstateSet[jjnewStateCnt++] = 95;
+                  if (curChar == 117)
+                     jjstateSet[jjnewStateCnt++] = 92;
+                  break;
+               case 60:
+                  if ((0x7fffffe87fffffeL & l) != 0L)
+                  {
+                     if (kind > 123)
+                        kind = 123;
+                     { jjCheckNAdd(8); }
+                  }
+                  if (curChar == 101)
+                     jjstateSet[jjnewStateCnt++] = 59;
+                  break;
+               case 1:
+                  if (kind > 4)
+                     kind = 4;
+                  break;
+               case 4:
+                  if (kind > 12)
+                     kind = 12;
+                  jjstateSet[jjnewStateCnt++] = 4;
+                  break;
+               case 6:
+                  if (curChar == 96)
+                     jjstateSet[jjnewStateCnt++] = 7;
+                  break;
+               case 7:
+                  if ((0x7fffffe87fffffeL & l) == 0L)
+                     break;
+                  if (kind > 123)
+                     kind = 123;
+                  { jjCheckNAdd(8); }
+                  break;
+               case 8:
+                  if ((0x7fffffe87fffffeL & l) == 0L)
+                     break;
+                  if (kind > 123)
+                     kind = 123;
+                  { jjCheckNAdd(8); }
+                  break;
+               case 9:
+                  if (curChar == 92)
+                     { jjCheckNAdd(10); }
+                  break;
+               case 10:
+                  if (kind > 123)
+                     kind = 123;
+                  { jjCheckNAdd(10); }
+                  break;
+               case 12:
+               case 13:
+                  if ((0x7fffffe87fffffeL & l) == 0L)
+                     break;
+                  if (kind > 124)
+                     kind = 124;
+                  { jjCheckNAdd(13); }
+                  break;
+               case 14:
+                  if (curChar != 95)
+                     break;
+                  if (kind > 127)
+                     kind = 127;
+                  { jjCheckNAdd(14); }
+                  break;
+               case 16:
+                  { jjCheckNAddStates(21, 23); }
+                  break;
+               case 17:
+                  if (curChar == 92)
+                     { jjAddStates(79, 81); }
+                  break;
+               case 18:
+                  if ((0x14404410000000L & l) != 0L)
+                     { jjCheckNAddStates(21, 23); }
+                  break;
+               case 25:
+                  if ((0x8000000080000L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 26;
+                  break;
+               case 26:
+                  if ((0x1000000010L & l) == 0L)
+                     break;
+                  if (kind > 127)
+                     kind = 127;
+                  { jjCheckNAddTwoStates(27, 28); }
+                  break;
+               case 28:
+                  if ((0x500000085000000L & l) == 0L)
+                     break;
+                  if (kind > 127)
+                     kind = 127;
+                  { jjCheckNAdd(28); }
+                  break;
+               case 29:
+                  if ((0x8000000080000L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 30;
+                  break;
+               case 30:
+                  if ((0x10000000100L & l) != 0L)
+                     { jjCheckNAddTwoStates(31, 32); }
+                  break;
+               case 32:
+                  if ((0x500007e8500007eL & l) == 0L)
+                     break;
+                  if (kind > 127)
+                     kind = 127;
+                  { jjCheckNAdd(32); }
+                  break;
+               case 33:
+                  if ((0x8000000080000L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 34;
+                  break;
+               case 34:
+                  if ((0x800000008000L & l) == 0L)
+                     break;
+                  if (kind > 127)
+                     kind = 127;
+                  { jjCheckNAddTwoStates(35, 36); }
+                  break;
+               case 36:
+                  if ((0x500000085000000L & l) == 0L)
+                     break;
+                  if (kind > 127)
+                     kind = 127;
+                  { jjCheckNAdd(36); }
+                  break;
+               case 37:
+                  if ((0x8000000080000L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 38;
+                  break;
+               case 38:
+                  if ((0x400000004L & l) == 0L)
+                     break;
+                  if (kind > 127)
+                     kind = 127;
+                  { jjCheckNAddTwoStates(39, 40); }
+                  break;
+               case 40:
+                  if ((0x500000085000000L & l) == 0L)
+                     break;
+                  if (kind > 127)
+                     kind = 127;
+                  { jjCheckNAdd(40); }
+                  break;
+               case 41:
+                  if (curChar == 120)
+                     { jjAddStates(77, 78); }
+                  break;
+               case 42:
+                  if (curChar == 114 && kind > 71)
+                     kind = 71;
+                  break;
+               case 43:
+               case 44:
+               case 120:
+                  if (curChar == 111)
+                     { jjCheckNAdd(42); }
+                  break;
+               case 45:
+                  if (curChar == 110)
+                     jjstateSet[jjnewStateCnt++] = 44;
+                  break;
+               case 46:
+                  if (curChar == 104)
+                     { jjAddStates(75, 76); }
+                  break;
+               case 48:
+                  if (curChar == 122)
+                     { jjCheckNAdd(47); }
+                  break;
+               case 49:
+                  if (curChar == 104)
+                     jjstateSet[jjnewStateCnt++] = 48;
+                  break;
+               case 50:
+                  if (curChar == 103)
+                     jjstateSet[jjnewStateCnt++] = 49;
+                  break;
+               case 51:
+                  if (curChar == 105)
+                     jjstateSet[jjnewStateCnt++] = 50;
+                  break;
+               case 53:
+                  if (curChar == 122)
+                     { jjCheckNAdd(52); }
+                  break;
+               case 54:
+                  if (curChar == 104)
+                     jjstateSet[jjnewStateCnt++] = 53;
+                  break;
+               case 55:
+                  if (curChar == 103)
+                     jjstateSet[jjnewStateCnt++] = 54;
+                  break;
+               case 56:
+                  if (curChar == 105)
+                     jjstateSet[jjnewStateCnt++] = 55;
+                  break;
+               case 57:
+                  if (curChar == 97)
+                     { jjAddStates(73, 74); }
+                  break;
+               case 58:
+                  if (curChar == 116 && kind > 55)
+                     kind = 55;
+                  break;
+               case 59:
+                  if (curChar == 114)
+                     jjstateSet[jjnewStateCnt++] = 58;
+                  break;
+               case 63:
+                  if (curChar == 100 && kind > 71)
+                     kind = 71;
+                  break;
+               case 64:
+               case 118:
+                  if (curChar == 110)
+                     { jjCheckNAdd(63); }
+                  break;
+               case 65:
+                  if (curChar == 99)
+                     { jjAddStates(68, 72); }
+                  break;
+               case 66:
+                  if (curChar == 101 && kind > 32)
+                     kind = 32;
+                  break;
+               case 67:
+                  if (curChar == 115)
+                     jjstateSet[jjnewStateCnt++] = 66;
+                  break;
+               case 68:
+                  if (curChar == 97)
+                     jjstateSet[jjnewStateCnt++] = 67;
+                  break;
+               case 69:
+                  if (curChar == 120 && kind > 32)
+                     kind = 32;
+                  break;
+               case 70:
+                  if (curChar == 101)
+                     jjstateSet[jjnewStateCnt++] = 69;
+                  break;
+               case 71:
+                  if (curChar == 115)
+                     jjstateSet[jjnewStateCnt++] = 70;
+                  break;
+               case 72:
+                  if (curChar == 97)
+                     jjstateSet[jjnewStateCnt++] = 71;
+                  break;
+               case 73:
+                  if (curChar == 122 && kind > 32)
+                     kind = 32;
+                  break;
+               case 74:
+                  if (curChar == 101)
+                     jjstateSet[jjnewStateCnt++] = 73;
+                  break;
+               case 75:
+                  if (curChar == 115)
+                     jjstateSet[jjnewStateCnt++] = 74;
+                  break;
+               case 76:
+                  if (curChar == 97)
+                     jjstateSet[jjnewStateCnt++] = 75;
+                  break;
+               case 77:
+                  if (curChar == 114 && kind > 55)
+                     kind = 55;
+                  break;
+               case 78:
+                  if (curChar == 101)
+                     jjstateSet[jjnewStateCnt++] = 77;
+                  break;
+               case 79:
+                  if (curChar == 118)
+                     jjstateSet[jjnewStateCnt++] = 78;
+                  break;
+               case 80:
+                  if (curChar == 111)
+                     jjstateSet[jjnewStateCnt++] = 79;
+                  break;
+               case 81:
+                  if (curChar == 115 && kind > 75)
+                     kind = 75;
+                  break;
+               case 82:
+               case 153:
+                  if (curChar == 111)
+                     { jjCheckNAdd(81); }
+                  break;
+               case 83:
+                  if (curChar == 109)
+                     jjstateSet[jjnewStateCnt++] = 82;
+                  break;
+               case 84:
+                  if (curChar == 112)
+                     { jjAddStates(62, 67); }
+                  break;
+               case 85:
+                  if (curChar == 101 && kind > 67)
+                     kind = 67;
+                  break;
+               case 86:
+               case 113:
+                  if (curChar == 103)
+                     { jjCheckNAdd(85); }
+                  break;
+               case 87:
+                  if (curChar == 100)
+                     jjstateSet[jjnewStateCnt++] = 86;
+                  break;
+               case 88:
+                  if (curChar == 101)
+                     jjstateSet[jjnewStateCnt++] = 87;
+                  break;
+               case 89:
+                  if (curChar == 115)
+                     jjstateSet[jjnewStateCnt++] = 88;
+                  break;
+               case 91:
+                  if (curChar == 108)
+                     { jjCheckNAdd(47); }
+                  break;
+               case 92:
+                  if (curChar == 108)
+                     jjstateSet[jjnewStateCnt++] = 91;
+                  break;
+               case 93:
+                  if (curChar == 117)
+                     jjstateSet[jjnewStateCnt++] = 92;
+                  break;
+               case 94:
+                  if (curChar == 108)
+                     { jjCheckNAdd(52); }
+                  break;
+               case 95:
+                  if (curChar == 108)
+                     jjstateSet[jjnewStateCnt++] = 94;
+                  break;
+               case 96:
+                  if (curChar == 117)
+                     jjstateSet[jjnewStateCnt++] = 95;
+                  break;
+               case 97:
+                  if (curChar == 115 && kind > 73)
+                     kind = 73;
+                  break;
+               case 98:
+               case 133:
+               case 147:
+               case 150:
+                  if (curChar == 111)
+                     { jjCheckNAdd(97); }
+                  break;
+               case 99:
+                  if (curChar == 109)
+                     jjstateSet[jjnewStateCnt++] = 98;
+                  break;
+               case 100:
+                  if (curChar == 112 && kind > 74)
+                     kind = 74;
+                  break;
+               case 101:
+                  if (curChar == 117)
+                     jjstateSet[jjnewStateCnt++] = 100;
+                  break;
+               case 102:
+                  if (curChar == 108)
+                     jjstateSet[jjnewStateCnt++] = 101;
+                  break;
+               case 103:
+                  if (curChar == 108)
+                     jjstateSet[jjnewStateCnt++] = 102;
+                  break;
+               case 104:
+                  if (curChar == 117)
+                     jjstateSet[jjnewStateCnt++] = 103;
+                  break;
+               case 105:
+                  if (curChar == 110 && kind > 74)
+                     kind = 74;
+                  break;
+               case 106:
+                  if (curChar == 119)
+                     jjstateSet[jjnewStateCnt++] = 105;
+                  break;
+               case 107:
+                  if (curChar == 111)
+                     jjstateSet[jjnewStateCnt++] = 106;
+                  break;
+               case 108:
+                  if (curChar == 100)
+                     jjstateSet[jjnewStateCnt++] = 107;
+                  break;
+               case 109:
+                  if (curChar == 108)
+                     jjstateSet[jjnewStateCnt++] = 108;
+                  break;
+               case 110:
+                  if (curChar == 108)
+                     jjstateSet[jjnewStateCnt++] = 109;
+                  break;
+               case 111:
+                  if (curChar == 117)
+                     jjstateSet[jjnewStateCnt++] = 110;
+                  break;
+               case 112:
+                  if (curChar == 110)
+                     { jjAddStates(55, 61); }
+                  break;
+               case 114:
+                  if (curChar == 100)
+                     jjstateSet[jjnewStateCnt++] = 113;
+                  break;
+               case 115:
+                  if (curChar == 101)
+                     jjstateSet[jjnewStateCnt++] = 114;
+                  break;
+               case 116:
+                  if (curChar == 103)
+                     jjstateSet[jjnewStateCnt++] = 115;
+                  break;
+               case 117:
+                  if (curChar == 101)
+                     jjstateSet[jjnewStateCnt++] = 116;
+                  break;
+               case 119:
+                  if (curChar == 97)
+                     jjstateSet[jjnewStateCnt++] = 118;
+                  break;
+               case 121:
+                  if (curChar == 116 && kind > 72)
+                     kind = 72;
+                  break;
+               case 122:
+                  if (curChar == 111)
+                     jjstateSet[jjnewStateCnt++] = 121;
+                  break;
+               case 124:
+               case 138:
+                  if (curChar == 102)
+                     { jjCheckNAdd(123); }
+                  break;
+               case 125:
+                  if (curChar == 105)
+                     jjstateSet[jjnewStateCnt++] = 124;
+                  break;
+               case 126:
+                  if (curChar == 116)
+                     jjstateSet[jjnewStateCnt++] = 125;
+                  break;
+               case 127:
+                  if (curChar == 111)
+                     jjstateSet[jjnewStateCnt++] = 126;
+                  break;
+               case 129:
+               case 142:
+                  if (curChar == 102)
+                     { jjCheckNAdd(128); }
+                  break;
+               case 130:
+                  if (curChar == 105)
+                     jjstateSet[jjnewStateCnt++] = 129;
+                  break;
+               case 131:
+                  if (curChar == 116)
+                     jjstateSet[jjnewStateCnt++] = 130;
+                  break;
+               case 132:
+                  if (curChar == 111)
+                     jjstateSet[jjnewStateCnt++] = 131;
+                  break;
+               case 134:
+                  if (curChar == 109)
+                     jjstateSet[jjnewStateCnt++] = 133;
+                  break;
+               case 135:
+                  if (curChar == 98)
+                     { jjAddStates(52, 54); }
+                  break;
+               case 136:
+                  if (curChar == 102 && kind > 72)
+                     kind = 72;
+                  break;
+               case 139:
+                  if (curChar == 105)
+                     jjstateSet[jjnewStateCnt++] = 138;
+                  break;
+               case 140:
+                  if (curChar == 102)
+                     jjstateSet[jjnewStateCnt++] = 139;
+                  break;
+               case 141:
+                  if (curChar == 117)
+                     jjstateSet[jjnewStateCnt++] = 140;
+                  break;
+               case 143:
+                  if (curChar == 105)
+                     jjstateSet[jjnewStateCnt++] = 142;
+                  break;
+               case 144:
+                  if (curChar == 102)
+                     jjstateSet[jjnewStateCnt++] = 143;
+                  break;
+               case 145:
+                  if (curChar == 117)
+                     jjstateSet[jjnewStateCnt++] = 144;
+                  break;
+               case 146:
+                  if (curChar == 114)
+                     { jjAddStates(46, 51); }
+                  break;
+               case 148:
+                  if (curChar == 109)
+                     jjstateSet[jjnewStateCnt++] = 147;
+                  break;
+               case 151:
+                  if (curChar == 109)
+                     jjstateSet[jjnewStateCnt++] = 150;
+                  break;
+               case 152:
+                  if (curChar == 110)
+                     jjstateSet[jjnewStateCnt++] = 151;
+                  break;
+               case 154:
+                  if (curChar == 109)
+                     jjstateSet[jjnewStateCnt++] = 153;
+                  break;
+               case 155:
+                  if (curChar == 99)
+                     jjstateSet[jjnewStateCnt++] = 154;
+                  break;
+               case 156:
+                  if (curChar == 110 && kind > 76)
+                     kind = 76;
+                  break;
+               case 157:
+               case 210:
+                  if (curChar == 97)
+                     { jjCheckNAdd(156); }
+                  break;
+               case 158:
+                  if (curChar == 114)
+                     jjstateSet[jjnewStateCnt++] = 157;
+                  break;
+               case 159:
+                  if (curChar == 116)
+                     jjstateSet[jjnewStateCnt++] = 158;
+                  break;
+               case 161:
+               case 212:
+                  if (curChar == 102)
+                     { jjCheckNAdd(160); }
+                  break;
+               case 162:
+                  if (curChar == 105)
+                     jjstateSet[jjnewStateCnt++] = 161;
+                  break;
+               case 163:
+                  if (curChar == 110)
+                     jjstateSet[jjnewStateCnt++] = 162;
+                  break;
+               case 164:
+                  if (curChar == 97)
+                     jjstateSet[jjnewStateCnt++] = 163;
+                  break;
+               case 165:
+                  if (curChar == 114)
+                     jjstateSet[jjnewStateCnt++] = 164;
+                  break;
+               case 166:
+                  if (curChar == 116)
+                     jjstateSet[jjnewStateCnt++] = 165;
+                  break;
+               case 168:
+                  if (curChar == 102)
+                     jjstateSet[jjnewStateCnt++] = 167;
+                  break;
+               case 169:
+                  if (curChar == 105)
+                     jjstateSet[jjnewStateCnt++] = 168;
+                  break;
+               case 170:
+                  if (curChar == 110)
+                     jjstateSet[jjnewStateCnt++] = 169;
+                  break;
+               case 171:
+                  if (curChar == 97)
+                     jjstateSet[jjnewStateCnt++] = 170;
+                  break;
+               case 172:
+                  if (curChar == 114)
+                     jjstateSet[jjnewStateCnt++] = 171;
+                  break;
+               case 173:
+                  if (curChar == 116)
+                     jjstateSet[jjnewStateCnt++] = 172;
+                  break;
+               case 189:
+                  if ((0x2000000020L & l) != 0L)
+                     { jjAddStates(82, 83); }
+                  break;
+               case 192:
+                  if (curChar == 116)
+                     { jjAddStates(39, 45); }
+                  break;
+               case 193:
+                  if (curChar == 105 && kind > 69)
+                     kind = 69;
+                  break;
+               case 196:
+                  if (curChar == 105)
+                     jjstateSet[jjnewStateCnt++] = 195;
+                  break;
+               case 197:
+                  if (curChar == 114)
+                     jjstateSet[jjnewStateCnt++] = 196;
+                  break;
+               case 198:
+                  if (curChar == 100 && kind > 69)
+                     kind = 69;
+                  break;
+               case 199:
+                  if (curChar == 110)
+                     { jjCheckNAdd(198); }
+                  break;
+               case 200:
+                  if (curChar == 97)
+                     jjstateSet[jjnewStateCnt++] = 199;
+                  break;
+               case 201:
+                  if (curChar == 105)
+                     jjstateSet[jjnewStateCnt++] = 200;
+                  break;
+               case 202:
+                  if (curChar == 114)
+                     jjstateSet[jjnewStateCnt++] = 201;
+                  break;
+               case 204:
+                  if (curChar == 105)
+                     jjstateSet[jjnewStateCnt++] = 203;
+                  break;
+               case 205:
+                  if (curChar == 114)
+                     jjstateSet[jjnewStateCnt++] = 204;
+                  break;
+               case 206:
+                  if (curChar == 114 && kind > 69)
+                     kind = 69;
+                  break;
+               case 207:
+                  if (curChar == 111)
+                     { jjCheckNAdd(206); }
+                  break;
+               case 208:
+                  if (curChar == 105)
+                     jjstateSet[jjnewStateCnt++] = 207;
+                  break;
+               case 209:
+                  if (curChar == 114)
+                     jjstateSet[jjnewStateCnt++] = 208;
+                  break;
+               case 211:
+                  if (curChar == 114)
+                     jjstateSet[jjnewStateCnt++] = 210;
+                  break;
+               case 213:
+                  if (curChar == 105)
+                     jjstateSet[jjnewStateCnt++] = 212;
+                  break;
+               case 214:
+                  if (curChar == 110)
+                     jjstateSet[jjnewStateCnt++] = 213;
+                  break;
+               case 215:
+                  if (curChar == 97)
+                     jjstateSet[jjnewStateCnt++] = 214;
+                  break;
+               case 216:
+                  if (curChar == 114)
+                     jjstateSet[jjnewStateCnt++] = 215;
+                  break;
+               case 217:
+                  if (curChar == 115)
+                     { jjAddStates(35, 38); }
+                  break;
+               case 219:
+                  if (curChar == 121)
+                     jjstateSet[jjnewStateCnt++] = 218;
+                  break;
+               case 220:
+                  if (curChar == 108)
+                     jjstateSet[jjnewStateCnt++] = 219;
+                  break;
+               case 221:
+                  if (curChar == 112)
+                     jjstateSet[jjnewStateCnt++] = 220;
+                  break;
+               case 222:
+                  if (curChar == 112)
+                     jjstateSet[jjnewStateCnt++] = 221;
+                  break;
+               case 225:
+                  if (curChar == 121)
+                     jjstateSet[jjnewStateCnt++] = 224;
+                  break;
+               case 226:
+                  if (curChar == 108)
+                     jjstateSet[jjnewStateCnt++] = 225;
+                  break;
+               case 227:
+                  if (curChar == 112)
+                     jjstateSet[jjnewStateCnt++] = 226;
+                  break;
+               case 228:
+                  if (curChar == 112)
+                     jjstateSet[jjnewStateCnt++] = 227;
+                  break;
+               case 229:
+                  if (curChar == 117)
+                     jjstateSet[jjnewStateCnt++] = 228;
+                  break;
+               case 230:
+                  if (curChar == 103)
+                     { jjCheckNAdd(47); }
+                  break;
+               case 231:
+                  if (curChar == 110)
+                     jjstateSet[jjnewStateCnt++] = 230;
+                  break;
+               case 232:
+                  if (curChar == 111)
+                     jjstateSet[jjnewStateCnt++] = 231;
+                  break;
+               case 233:
+                  if (curChar == 114)
+                     jjstateSet[jjnewStateCnt++] = 232;
+                  break;
+               case 234:
+                  if (curChar == 116)
+                     jjstateSet[jjnewStateCnt++] = 233;
+                  break;
+               case 235:
+                  if (curChar == 103)
+                     { jjCheckNAdd(52); }
+                  break;
+               case 236:
+                  if (curChar == 110)
+                     jjstateSet[jjnewStateCnt++] = 235;
+                  break;
+               case 237:
+                  if (curChar == 111)
+                     jjstateSet[jjnewStateCnt++] = 236;
+                  break;
+               case 238:
+                  if (curChar == 114)
+                     jjstateSet[jjnewStateCnt++] = 237;
+                  break;
+               case 239:
+                  if (curChar == 116)
+                     jjstateSet[jjnewStateCnt++] = 238;
+                  break;
+               case 240:
+                  if (curChar == 119)
+                     { jjAddStates(31, 34); }
+                  break;
+               case 243:
+                  if (curChar == 111)
+                     { jjCheckNAdd(206); }
+                  break;
+               case 244:
+                  if (curChar == 107)
+                     { jjCheckNAdd(47); }
+                  break;
+               case 245:
+                  if (curChar == 97)
+                     jjstateSet[jjnewStateCnt++] = 244;
+                  break;
+               case 246:
+                  if (curChar == 101)
+                     jjstateSet[jjnewStateCnt++] = 245;
+                  break;
+               case 247:
+                  if (curChar == 107)
+                     { jjCheckNAdd(52); }
+                  break;
+               case 248:
+                  if (curChar == 97)
+                     jjstateSet[jjnewStateCnt++] = 247;
+                  break;
+               case 249:
+                  if (curChar == 101)
+                     jjstateSet[jjnewStateCnt++] = 248;
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else
+      {
+         int hiByte = (curChar >> 8);
+         int i1 = hiByte >> 6;
+         long l1 = 1L << (hiByte & 077);
+         int i2 = (curChar & 0xff) >> 6;
+         long l2 = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 1:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 4)
+                     kind = 4;
+                  break;
+               case 4:
+                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 12)
+                     kind = 12;
+                  jjstateSet[jjnewStateCnt++] = 4;
+                  break;
+               case 10:
+                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 123)
+                     kind = 123;
+                  jjstateSet[jjnewStateCnt++] = 10;
+                  break;
+               case 16:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     { jjAddStates(21, 23); }
+                  break;
+               default : if (i1 == 0 || l1 == 0 || i2 == 0 ||  l2 == 0) break; else break;
+            }
+         } while(i != startsAt);
+      }
+      if (kind != 0x7fffffff)
+      {
+         jjmatchedKind = kind;
+         jjmatchedPos = curPos;
+         kind = 0x7fffffff;
+      }
+      ++curPos;
+      if ((i = jjnewStateCnt) == (startsAt = 250 - (jjnewStateCnt = startsAt)))
+         return curPos;
+      try { curChar = input_stream.readChar(); }
+      catch(java.io.IOException e) { return curPos; }
+   }
+}
+private int jjMoveStringLiteralDfa0_1(){
+   switch(curChar)
+   {
+      case 42:
+         return jjMoveStringLiteralDfa1_1(0x4L);
+      default :
+         return 1;
+   }
+}
+private int jjMoveStringLiteralDfa1_1(long active0){
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      return 1;
+   }
+   switch(curChar)
+   {
+      case 47:
+         if ((active0 & 0x4L) != 0L)
+            return jjStopAtPos(1, 2);
+         break;
+      default :
+         return 2;
+   }
+   return 2;
+}
+private int jjMoveStringLiteralDfa0_2(){
+   switch(curChar)
+   {
+      case 42:
+         return jjMoveStringLiteralDfa1_2(0x20L);
+      default :
+         return 1;
+   }
+}
+private int jjMoveStringLiteralDfa1_2(long active0){
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      return 1;
+   }
+   switch(curChar)
+   {
+      case 41:
+         if ((active0 & 0x20L) != 0L)
+            return jjStopAtPos(1, 5);
+         break;
+      default :
+         return 2;
+   }
+   return 2;
+}
+static final int[] jjnextStates = {
+   175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 186, 187, 189, 25, 26, 29, 
+   30, 33, 34, 37, 38, 16, 17, 19, 16, 17, 21, 19, 186, 187, 189, 242, 
+   243, 246, 249, 223, 229, 234, 239, 194, 197, 202, 205, 209, 211, 216, 149, 152, 
+   155, 159, 166, 173, 137, 141, 145, 117, 119, 120, 122, 127, 132, 134, 90, 93, 
+   96, 99, 104, 111, 68, 72, 76, 80, 83, 62, 64, 51, 56, 43, 45, 18, 
+   20, 22, 190, 191, 
+};
+private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2)
+{
+   switch(hiByte)
+   {
+      case 0:
+         return ((jjbitVec2[i2] & l2) != 0L);
+      default :
+         if ((jjbitVec0[i1] & l1) != 0L)
+            return true;
+         return false;
+   }
+}
+
+/** Token literal values. */
+public static final String[] jjstrLiteralImages = {
+"", null, null, null, null, null, null, null, null, null, null, null, null, 
+"\155\157\144\165\154\145", "\145\156\144\155\157\144\165\154\145", 
+"\160\162\151\155\151\164\151\166\145", "\145\156\144\160\162\151\155\151\164\151\166\145", "\164\141\142\154\145", 
+"\145\156\144\164\141\142\154\145", "\142\145\147\151\156", "\145\156\144", "\146\157\162\153", 
+"\152\157\151\156", "\163\160\145\143\151\146\171", "\145\156\144\163\160\145\143\151\146\171", 
+"\151\146", "\145\154\163\145", "\167\150\151\154\145", "\146\157\162", 
+"\146\157\162\145\166\145\162", "\162\145\160\145\141\164", "\167\141\151\164", null, 
+"\144\145\146\141\165\154\164", "\145\156\144\143\141\163\145", "\146\165\156\143\164\151\157\156", 
+"\145\156\144\146\165\156\143\164\151\157\156", "\164\141\163\153", "\145\156\144\164\141\163\153", 
+"\147\145\156\145\162\141\164\145", "\145\156\144\147\145\156\145\162\141\164\145", "\151\156\160\165\164", 
+"\157\165\164\160\165\164", "\151\156\157\165\164", "\151\156\164\145\147\145\162", "\162\145\147", 
+"\167\151\162\145", "\145\166\145\156\164", "\147\145\156\166\141\162", "\162\145\141\154", 
+"\160\141\162\141\155\145\164\145\162", "\154\157\143\141\154\160\141\162\141\155", "\163\151\147\156\145\144", 
+"\160\162\157\160\145\162\164\171", "\145\156\144\160\162\157\160\145\162\164\171", null, 
+"\141\163\163\151\147\156", "\144\145\141\163\163\151\147\156", "\146\157\162\143\145", 
+"\162\145\154\145\141\163\145", "\164\151\155\145", "\162\145\141\154\164\151\155\145", 
+"\144\145\146\160\141\162\141\155", "\157\162", "\144\151\163\141\142\154\145", "\141\154\167\141\171\163", 
+"\151\156\151\164\151\141\154", null, null, null, null, null, null, null, null, null, null, "\50", "\51", 
+"\173", "\175", "\133", "\135", "\73", "\43", "\100", "\44", "\54", "\56", "\75", 
+"\76", "\74", "\41", "\176", "\77", "\72", "\53\72", "\55\72", "\75\75", "\74\75", 
+"\76\75", "\41\75", "\174\174", "\46\46", "\53", "\55", "\52", "\57", "\46", "\174", 
+"\136", "\45", "\74\74", "\76\76", "\176\46", "\176\174", "\176\136", "\136\176", 
+"\75\75\75", "\41\75\75", "\52\52", "\74\74\74", "\76\76\76", null, null, null, null, null, 
+null, null, null, null, null, null, null, "\55\76", };
+protected Token jjFillToken()
+{
+   final Token t;
+   final String curTokenImage;
+   final int beginLine;
+   final int endLine;
+   final int beginColumn;
+   final int endColumn;
+   String im = jjstrLiteralImages[jjmatchedKind];
+   curTokenImage = (im == null) ? input_stream.GetImage() : im;
+   beginLine = input_stream.getBeginLine();
+   beginColumn = input_stream.getBeginColumn();
+   endLine = input_stream.getEndLine();
+   endColumn = input_stream.getEndColumn();
+   t = Token.newToken(jjmatchedKind, curTokenImage);
+
+   t.beginLine = beginLine;
+   t.endLine = endLine;
+   t.beginColumn = beginColumn;
+   t.endColumn = endColumn;
+
+   return t;
+}
+
+int curLexState = 0;
+int defaultLexState = 0;
+int jjnewStateCnt;
+int jjround;
+int jjmatchedPos;
+int jjmatchedKind;
+
+/** Get the next Token. */
+public Token getNextToken() 
+{
+  Token specialToken = null;
+  Token matchedToken;
+  int curPos = 0;
+
+  EOFLoop :
+  for (;;)
+  {
+   try
+   {
+      curChar = input_stream.BeginToken();
+   }
+   catch(java.io.IOException e)
+   {
+      jjmatchedKind = 0;
+      jjmatchedPos = -1;
+      matchedToken = jjFillToken();
+      matchedToken.specialToken = specialToken;
+      return matchedToken;
+   }
+
+   for (;;)
+   {
+     switch(curLexState)
+     {
+       case 0:
+         try { input_stream.backup(0);
+            while (curChar <= 32 && (0x100003600L & (1L << curChar)) != 0L)
+               curChar = input_stream.BeginToken();
+         }
+         catch (java.io.IOException e1) { continue EOFLoop; }
+         jjmatchedKind = 0x7fffffff;
+         jjmatchedPos = 0;
+         curPos = jjMoveStringLiteralDfa0_0();
+         break;
+       case 1:
+         jjmatchedKind = 0x7fffffff;
+         jjmatchedPos = 0;
+         curPos = jjMoveStringLiteralDfa0_1();
+         if (jjmatchedPos == 0 && jjmatchedKind > 3)
+         {
+            jjmatchedKind = 3;
+         }
+         break;
+       case 2:
+         jjmatchedKind = 0x7fffffff;
+         jjmatchedPos = 0;
+         curPos = jjMoveStringLiteralDfa0_2();
+         if (jjmatchedPos == 0 && jjmatchedKind > 6)
+         {
+            jjmatchedKind = 6;
+         }
+         break;
+     }
+     if (jjmatchedKind != 0x7fffffff)
+     {
+        if (jjmatchedPos + 1 < curPos)
+           input_stream.backup(curPos - jjmatchedPos - 1);
+        if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
+        {
+           matchedToken = jjFillToken();
+           matchedToken.specialToken = specialToken;
+       if (jjnewLexState[jjmatchedKind] != -1)
+         curLexState = jjnewLexState[jjmatchedKind];
+           return matchedToken;
+        }
+        else if ((jjtoSkip[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
+        {
+           if ((jjtoSpecial[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
+           {
+              matchedToken = jjFillToken();
+              if (specialToken == null)
+                 specialToken = matchedToken;
+              else
+              {
+                 matchedToken.specialToken = specialToken;
+                 specialToken = (specialToken.next = matchedToken);
+              }
+           }
+         if (jjnewLexState[jjmatchedKind] != -1)
+           curLexState = jjnewLexState[jjmatchedKind];
+           continue EOFLoop;
+        }
+      if (jjnewLexState[jjmatchedKind] != -1)
+        curLexState = jjnewLexState[jjmatchedKind];
+        curPos = 0;
+        jjmatchedKind = 0x7fffffff;
+        try {
+           curChar = input_stream.readChar();
+           continue;
+        }
+        catch (java.io.IOException e1) { }
+     }
+     int error_line = input_stream.getEndLine();
+     int error_column = input_stream.getEndColumn();
+     String error_after = null;
+     boolean EOFSeen = false;
+     try { input_stream.readChar(); input_stream.backup(1); }
+     catch (java.io.IOException e1) {
+        EOFSeen = true;
+        error_after = curPos <= 1 ? "" : input_stream.GetImage();
+        if (curChar == '\n' || curChar == '\r') {
+           error_line++;
+           error_column = 0;
+        }
+        else
+           error_column++;
+     }
+     if (!EOFSeen) {
+        input_stream.backup(1);
+        error_after = curPos <= 1 ? "" : input_stream.GetImage();
+     }
+     throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);
+   }
+  }
+}
+
+private void jjCheckNAdd(int state)
+{
+   if (jjrounds[state] != jjround)
+   {
+      jjstateSet[jjnewStateCnt++] = state;
+      jjrounds[state] = jjround;
+   }
+}
+private void jjAddStates(int start, int end)
+{
+   do {
+      jjstateSet[jjnewStateCnt++] = jjnextStates[start];
+   } while (start++ != end);
+}
+private void jjCheckNAddTwoStates(int state1, int state2)
+{
+   jjCheckNAdd(state1);
+   jjCheckNAdd(state2);
+}
+
+private void jjCheckNAddStates(int start, int end)
+{
+   do {
+      jjCheckNAdd(jjnextStates[start]);
+   } while (start++ != end);
+}
+
+    /** Constructor. */
+    public VerilogParserCoreTokenManager(JavaCharStream stream){
+
+      if (JavaCharStream.staticFlag)
+            throw new Error("ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.");
+
+    input_stream = stream;
+  }
+
+  /** Constructor. */
+  public VerilogParserCoreTokenManager (JavaCharStream stream, int lexState){
+    ReInit(stream);
+    SwitchTo(lexState);
+  }
+
+  /** Reinitialise parser. */
+  public void ReInit(JavaCharStream stream)
+  {
+    jjmatchedPos = jjnewStateCnt = 0;
+    curLexState = defaultLexState;
+    input_stream = stream;
+    ReInitRounds();
+  }
+
+  private void ReInitRounds()
+  {
+    int i;
+    jjround = 0x80000001;
+    for (i = 250; i-- > 0;)
+      jjrounds[i] = 0x80000000;
+  }
+
+  /** Reinitialise parser. */
+  public void ReInit(JavaCharStream stream, int lexState)
+  {
+    ReInit(stream);
+    SwitchTo(lexState);
+  }
+
+  /** Switch to specified lex state. */
+  public void SwitchTo(int lexState)
+  {
+    if (lexState >= 3 || lexState < 0)
+      throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", TokenMgrError.INVALID_LEXICAL_STATE);
+    else
+      curLexState = lexState;
+  }
+
+/** Lexer state names. */
+public static final String[] lexStateNames = {
+   "DEFAULT",
+   "IN_MULTI_LINE_COMMENT",
+   "IN_PROPERTY",
+};
+
+/** Lex State array. */
+public static final int[] jjnewLexState = {
+   -1, 1, 0, -1, 2, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
+   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
+   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
+   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
+   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
+   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
+};
+static final long[] jjtoToken = {
+   0xffffffffffffe001L, 0x9fffffffffffffffL, 0xe0L, 
+};
+static final long[] jjtoSkip = {
+   0x1fa4L, 0x0L, 0x0L, 
+};
+static final long[] jjtoSpecial = {
+   0x1000L, 0x0L, 0x0L, 
+};
+static final long[] jjtoMore = {
+   0x5aL, 0x0L, 0x0L, 
+};
+    protected JavaCharStream  input_stream;
+
+    private final int[] jjrounds = new int[250];
+    private final int[] jjstateSet = new int[2 * 250];
+
+    
+    protected char curChar;
+}
diff -U 3 -dHrN -- vdt-veditor/_generated/com/elphel/vdt/veditor/parser/vhdl/ParseException.java vdt/_generated/com/elphel/vdt/veditor/parser/vhdl/ParseException.java
--- vdt-veditor/_generated/com/elphel/vdt/veditor/parser/vhdl/ParseException.java	2016-06-24 10:29:40.832496184 -0600
+++ vdt/_generated/com/elphel/vdt/veditor/parser/vhdl/ParseException.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,197 +1,187 @@
-/* Generated By:JavaCC: Do not edit this line. ParseException.java Version 3.0 */
-package net.sourceforge.veditor.parser;
-
-/**
- * This exception is thrown when parse errors are encountered.
- * You can explicitly create objects of this exception type by
- * calling the method generateParseException in the generated
- * parser.
- *
- * You can modify this class to customize your error reporting
- * mechanisms so long as you retain the public fields.
- */
-public class ParseException extends Exception {
-
-  /**
-     * 
-     */
-    private static final long serialVersionUID = 7811742812760162144L;
-
-/**
-   * This constructor is used by the method "generateParseException"
-   * in the generated parser.  Calling this constructor generates
-   * a new object of this type with the fields "currentToken",
-   * "expectedTokenSequences", and "tokenImage" set.  The boolean
-   * flag "specialConstructor" is also set to true to indicate that
-   * this constructor was used to create this object.
-   * This constructor calls its super class with the empty string
-   * to force the "toString" method of parent class "Throwable" to
-   * print the error message in the form:
-   *     ParseException: <result of getMessage>
-   */
-  public ParseException(Token currentTokenVal,
-                        int[][] expectedTokenSequencesVal,
-                        String[] tokenImageVal
-                       )
-  {
-    super("");
-    specialConstructor = true;
-    currentToken = currentTokenVal;
-    expectedTokenSequences = expectedTokenSequencesVal;
-    tokenImage = tokenImageVal;
-  }
-
-  /**
-   * The following constructors are for use by you for whatever
-   * purpose you can think of.  Constructing the exception in this
-   * manner makes the exception behave in the normal way - i.e., as
-   * documented in the class "Throwable".  The fields "errorToken",
-   * "expectedTokenSequences", and "tokenImage" do not contain
-   * relevant information.  The JavaCC generated code does not use
-   * these constructors.
-   */
-
-  public ParseException() {
-    super();
-    specialConstructor = false;
-  }
-
-  public ParseException(String message) {
-    super(message);
-    specialConstructor = false;
-  }
-
-  /**
-   * This variable determines which constructor was used to create
-   * this object and thereby affects the semantics of the
-   * "getMessage" method (see below).
-   */
-  protected boolean specialConstructor;
-
-  /**
-   * This is the last token that has been consumed successfully.  If
-   * this object has been created due to a parse error, the token
-   * followng this token will (therefore) be the first error token.
-   */
-  public Token currentToken;
-
-  /**
-   * Each entry in this array is an array of integers.  Each array
-   * of integers represents a sequence of tokens (by their ordinal
-   * values) that is expected at this point of the parse.
-   */
-  public int[][] expectedTokenSequences;
-
-  /**
-   * This is a reference to the "tokenImage" array of the generated
-   * parser within which the parse error occurred.  This array is
-   * defined in the generated ...Constants interface.
-   */
-  public String[] tokenImage;
-
-  /**
-   * This method has the standard behavior when this object has been
-   * created using the standard constructors.  Otherwise, it uses
-   * "currentToken" and "expectedTokenSequences" to generate a parse
-   * error message and returns it.  If this object has been created
-   * due to a parse error, and you do not catch it (it gets thrown
-   * from the parser), then this method is called during the printing
-   * of the final stack trace, and hence the correct error message
-   * gets displayed.
-   */
-  public String getMessage() {
-    if (!specialConstructor) {
-      return super.getMessage();
-    }
-    StringBuffer expected = new StringBuffer();
-    int maxSize = 0;
-    for (int i = 0; i < expectedTokenSequences.length; i++) {
-      if (maxSize < expectedTokenSequences[i].length) {
-        maxSize = expectedTokenSequences[i].length;
-      }
-      for (int j = 0; j < expectedTokenSequences[i].length; j++) {
-        expected.append(tokenImage[expectedTokenSequences[i][j]]).append(" ");
-      }
-      if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0) {
-        expected.append("...");
-      }
-      expected.append(eol).append("    ");
-    }
-    String retval = "Encountered \"";
-    Token tok = currentToken.next;
-    for (int i = 0; i < maxSize; i++) {
-      if (i != 0) retval += " ";
-      if (tok.kind == 0) {
-        retval += tokenImage[0];
-        break;
-      }
-      retval += add_escapes(tok.image);
-      tok = tok.next; 
-    }
-    retval += "\" at line " + currentToken.next.beginLine + ", column " + currentToken.next.beginColumn;
-    retval += "." + eol;
-    if (expectedTokenSequences.length == 1) {
-      retval += "Was expecting:" + eol + "    ";
-    } else {
-      retval += "Was expecting one of:" + eol + "    ";
-    }
-    retval += expected.toString();
-    return retval;
-  }
-
-  /**
-   * The end of line string for this machine.
-   */
-  protected String eol = System.getProperty("line.separator", "\n");
- 
-  /**
-   * Used to convert raw characters to their escaped version
-   * when these raw version cannot be used as part of an ASCII
-   * string literal.
-   */
-  protected String add_escapes(String str) {
-      StringBuffer retval = new StringBuffer();
-      char ch;
-      for (int i = 0; i < str.length(); i++) {
-        switch (str.charAt(i))
-        {
-           case 0 :
-              continue;
-           case '\b':
-              retval.append("\\b");
-              continue;
-           case '\t':
-              retval.append("\\t");
-              continue;
-           case '\n':
-              retval.append("\\n");
-              continue;
-           case '\f':
-              retval.append("\\f");
-              continue;
-           case '\r':
-              retval.append("\\r");
-              continue;
-           case '\"':
-              retval.append("\\\"");
-              continue;
-           case '\'':
-              retval.append("\\\'");
-              continue;
-           case '\\':
-              retval.append("\\\\");
-              continue;
-           default:
-              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
-                 String s = "0000" + Integer.toString(ch, 16);
-                 retval.append("\\u" + s.substring(s.length() - 4, s.length()));
-              } else {
-                 retval.append(ch);
-              }
-              continue;
-        }
-      }
-      return retval.toString();
-   }
-
-}
+/* Generated By:JavaCC: Do not edit this line. ParseException.java Version 6.0 */
+/* JavaCCOptions:KEEP_LINE_COL=null */
+package com.elphel.vdt.veditor.parser.vhdl;
+
+/**
+ * This exception is thrown when parse errors are encountered.
+ * You can explicitly create objects of this exception type by
+ * calling the method generateParseException in the generated
+ * parser.
+ *
+ * You can modify this class to customize your error reporting
+ * mechanisms so long as you retain the public fields.
+ */
+public class ParseException extends Exception {
+
+  /**
+   * The version identifier for this Serializable class.
+   * Increment only if the <i>serialized</i> form of the
+   * class changes.
+   */
+  private static final long serialVersionUID = 1L;
+
+  /**
+   * This constructor is used by the method "generateParseException"
+   * in the generated parser.  Calling this constructor generates
+   * a new object of this type with the fields "currentToken",
+   * "expectedTokenSequences", and "tokenImage" set.
+   */
+  public ParseException(Token currentTokenVal,
+                        int[][] expectedTokenSequencesVal,
+                        String[] tokenImageVal
+                       )
+  {
+    super(initialise(currentTokenVal, expectedTokenSequencesVal, tokenImageVal));
+    currentToken = currentTokenVal;
+    expectedTokenSequences = expectedTokenSequencesVal;
+    tokenImage = tokenImageVal;
+  }
+
+  /**
+   * The following constructors are for use by you for whatever
+   * purpose you can think of.  Constructing the exception in this
+   * manner makes the exception behave in the normal way - i.e., as
+   * documented in the class "Throwable".  The fields "errorToken",
+   * "expectedTokenSequences", and "tokenImage" do not contain
+   * relevant information.  The JavaCC generated code does not use
+   * these constructors.
+   */
+
+  public ParseException() {
+    super();
+  }
+
+  /** Constructor with message. */
+  public ParseException(String message) {
+    super(message);
+  }
+
+
+  /**
+   * This is the last token that has been consumed successfully.  If
+   * this object has been created due to a parse error, the token
+   * followng this token will (therefore) be the first error token.
+   */
+  public Token currentToken;
+
+  /**
+   * Each entry in this array is an array of integers.  Each array
+   * of integers represents a sequence of tokens (by their ordinal
+   * values) that is expected at this point of the parse.
+   */
+  public int[][] expectedTokenSequences;
+
+  /**
+   * This is a reference to the "tokenImage" array of the generated
+   * parser within which the parse error occurred.  This array is
+   * defined in the generated ...Constants interface.
+   */
+  public String[] tokenImage;
+
+  /**
+   * It uses "currentToken" and "expectedTokenSequences" to generate a parse
+   * error message and returns it.  If this object has been created
+   * due to a parse error, and you do not catch it (it gets thrown
+   * from the parser) the correct error message
+   * gets displayed.
+   */
+  private static String initialise(Token currentToken,
+                           int[][] expectedTokenSequences,
+                           String[] tokenImage) {
+    String eol = System.getProperty("line.separator", "\n");
+    StringBuffer expected = new StringBuffer();
+    int maxSize = 0;
+    for (int i = 0; i < expectedTokenSequences.length; i++) {
+      if (maxSize < expectedTokenSequences[i].length) {
+        maxSize = expectedTokenSequences[i].length;
+      }
+      for (int j = 0; j < expectedTokenSequences[i].length; j++) {
+        expected.append(tokenImage[expectedTokenSequences[i][j]]).append(' ');
+      }
+      if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0) {
+        expected.append("...");
+      }
+      expected.append(eol).append("    ");
+    }
+    String retval = "Encountered \"";
+    Token tok = currentToken.next;
+    for (int i = 0; i < maxSize; i++) {
+      if (i != 0) retval += " ";
+      if (tok.kind == 0) {
+        retval += tokenImage[0];
+        break;
+      }
+      retval += " " + tokenImage[tok.kind];
+      retval += " \"";
+      retval += add_escapes(tok.image);
+      retval += " \"";
+      tok = tok.next;
+    }
+    retval += "\" at line " + currentToken.next.beginLine + ", column " + currentToken.next.beginColumn;
+    retval += "." + eol;
+    if (expectedTokenSequences.length == 1) {
+      retval += "Was expecting:" + eol + "    ";
+    } else {
+      retval += "Was expecting one of:" + eol + "    ";
+    }
+    retval += expected.toString();
+    return retval;
+  }
+
+  /**
+   * The end of line string for this machine.
+   */
+  protected String eol = System.getProperty("line.separator", "\n");
+
+  /**
+   * Used to convert raw characters to their escaped version
+   * when these raw version cannot be used as part of an ASCII
+   * string literal.
+   */
+  static String add_escapes(String str) {
+      StringBuffer retval = new StringBuffer();
+      char ch;
+      for (int i = 0; i < str.length(); i++) {
+        switch (str.charAt(i))
+        {
+           case 0 :
+              continue;
+           case '\b':
+              retval.append("\\b");
+              continue;
+           case '\t':
+              retval.append("\\t");
+              continue;
+           case '\n':
+              retval.append("\\n");
+              continue;
+           case '\f':
+              retval.append("\\f");
+              continue;
+           case '\r':
+              retval.append("\\r");
+              continue;
+           case '\"':
+              retval.append("\\\"");
+              continue;
+           case '\'':
+              retval.append("\\\'");
+              continue;
+           case '\\':
+              retval.append("\\\\");
+              continue;
+           default:
+              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
+                 String s = "0000" + Integer.toString(ch, 16);
+                 retval.append("\\u" + s.substring(s.length() - 4, s.length()));
+              } else {
+                 retval.append(ch);
+              }
+              continue;
+        }
+      }
+      return retval.toString();
+   }
+
+}
+/* JavaCC - OriginalChecksum=705a163ceaf6e6e23a4a787f3ceeadfd (do not edit this line) */
diff -U 3 -dHrN -- vdt-veditor/_generated/com/elphel/vdt/veditor/parser/vhdl/SimpleCharStream.java vdt/_generated/com/elphel/vdt/veditor/parser/vhdl/SimpleCharStream.java
--- vdt-veditor/_generated/com/elphel/vdt/veditor/parser/vhdl/SimpleCharStream.java	1969-12-31 17:00:00.000000000 -0700
+++ vdt/_generated/com/elphel/vdt/veditor/parser/vhdl/SimpleCharStream.java	2016-06-24 10:29:40.824496406 -0600
@@ -0,0 +1,474 @@
+/* Generated By:JavaCC: Do not edit this line. SimpleCharStream.java Version 6.0 */
+/* JavaCCOptions:STATIC=false,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
+package com.elphel.vdt.veditor.parser.vhdl;
+
+/**
+ * An implementation of interface CharStream, where the stream is assumed to
+ * contain only ASCII characters (without unicode processing).
+ */
+
+public class SimpleCharStream
+{
+/** Whether parser is static. */
+  public static final boolean staticFlag = false;
+  int bufsize;
+  int available;
+  int tokenBegin;
+/** Position in buffer. */
+  public int bufpos = -1;
+  protected int bufline[];
+  protected int bufcolumn[];
+
+  protected int column = 0;
+  protected int line = 1;
+
+  protected boolean prevCharIsCR = false;
+  protected boolean prevCharIsLF = false;
+
+  protected java.io.Reader inputStream;
+
+  protected char[] buffer;
+  protected int maxNextCharInd = 0;
+  protected int inBuf = 0;
+  protected int tabSize = 8;
+  protected boolean trackLineColumn = true;
+
+  public void setTabSize(int i) { tabSize = i; }
+  public int getTabSize() { return tabSize; }
+
+
+  protected void ExpandBuff(boolean wrapAround)
+  {
+    char[] newbuffer = new char[bufsize + 2048];
+    int newbufline[] = new int[bufsize + 2048];
+    int newbufcolumn[] = new int[bufsize + 2048];
+
+    try
+    {
+      if (wrapAround)
+      {
+        System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
+        System.arraycopy(buffer, 0, newbuffer, bufsize - tokenBegin, bufpos);
+        buffer = newbuffer;
+
+        System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
+        System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
+        bufline = newbufline;
+
+        System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
+        System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
+        bufcolumn = newbufcolumn;
+
+        maxNextCharInd = (bufpos += (bufsize - tokenBegin));
+      }
+      else
+      {
+        System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
+        buffer = newbuffer;
+
+        System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
+        bufline = newbufline;
+
+        System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
+        bufcolumn = newbufcolumn;
+
+        maxNextCharInd = (bufpos -= tokenBegin);
+      }
+    }
+    catch (Throwable t)
+    {
+      throw new Error(t.getMessage());
+    }
+
+
+    bufsize += 2048;
+    available = bufsize;
+    tokenBegin = 0;
+  }
+
+  protected void FillBuff() throws java.io.IOException
+  {
+    if (maxNextCharInd == available)
+    {
+      if (available == bufsize)
+      {
+        if (tokenBegin > 2048)
+        {
+          bufpos = maxNextCharInd = 0;
+          available = tokenBegin;
+        }
+        else if (tokenBegin < 0)
+          bufpos = maxNextCharInd = 0;
+        else
+          ExpandBuff(false);
+      }
+      else if (available > tokenBegin)
+        available = bufsize;
+      else if ((tokenBegin - available) < 2048)
+        ExpandBuff(true);
+      else
+        available = tokenBegin;
+    }
+
+    int i;
+    try {
+      if ((i = inputStream.read(buffer, maxNextCharInd, available - maxNextCharInd)) == -1)
+      {
+        inputStream.close();
+        throw new java.io.IOException();
+      }
+      else
+        maxNextCharInd += i;
+      return;
+    }
+    catch(java.io.IOException e) {
+      --bufpos;
+      backup(0);
+      if (tokenBegin == -1)
+        tokenBegin = bufpos;
+      throw e;
+    }
+  }
+
+/** Start. */
+  public char BeginToken() throws java.io.IOException
+  {
+    tokenBegin = -1;
+    char c = readChar();
+    tokenBegin = bufpos;
+
+    return c;
+  }
+
+  protected void UpdateLineColumn(char c)
+  {
+    column++;
+
+    if (prevCharIsLF)
+    {
+      prevCharIsLF = false;
+      line += (column = 1);
+    }
+    else if (prevCharIsCR)
+    {
+      prevCharIsCR = false;
+      if (c == '\n')
+      {
+        prevCharIsLF = true;
+      }
+      else
+        line += (column = 1);
+    }
+
+    switch (c)
+    {
+      case '\r' :
+        prevCharIsCR = true;
+        break;
+      case '\n' :
+        prevCharIsLF = true;
+        break;
+      case '\t' :
+        column--;
+        column += (tabSize - (column % tabSize));
+        break;
+      default :
+        break;
+    }
+
+    bufline[bufpos] = line;
+    bufcolumn[bufpos] = column;
+  }
+
+/** Read a character. */
+  public char readChar() throws java.io.IOException
+  {
+    if (inBuf > 0)
+    {
+      --inBuf;
+
+      if (++bufpos == bufsize)
+        bufpos = 0;
+
+      return buffer[bufpos];
+    }
+
+    if (++bufpos >= maxNextCharInd)
+      FillBuff();
+
+    char c = buffer[bufpos];
+
+    UpdateLineColumn(c);
+    return c;
+  }
+
+  @Deprecated
+  /**
+   * @deprecated
+   * @see #getEndColumn
+   */
+
+  public int getColumn() {
+    return bufcolumn[bufpos];
+  }
+
+  @Deprecated
+  /**
+   * @deprecated
+   * @see #getEndLine
+   */
+
+  public int getLine() {
+    return bufline[bufpos];
+  }
+
+  /** Get token end column number. */
+  public int getEndColumn() {
+    return bufcolumn[bufpos];
+  }
+
+  /** Get token end line number. */
+  public int getEndLine() {
+     return bufline[bufpos];
+  }
+
+  /** Get token beginning column number. */
+  public int getBeginColumn() {
+    return bufcolumn[tokenBegin];
+  }
+
+  /** Get token beginning line number. */
+  public int getBeginLine() {
+    return bufline[tokenBegin];
+  }
+
+/** Backup a number of characters. */
+  public void backup(int amount) {
+
+    inBuf += amount;
+    if ((bufpos -= amount) < 0)
+      bufpos += bufsize;
+  }
+
+  /** Constructor. */
+  public SimpleCharStream(java.io.Reader dstream, int startline,
+  int startcolumn, int buffersize)
+  {
+    inputStream = dstream;
+    line = startline;
+    column = startcolumn - 1;
+
+    available = bufsize = buffersize;
+    buffer = new char[buffersize];
+    bufline = new int[buffersize];
+    bufcolumn = new int[buffersize];
+  }
+
+  /** Constructor. */
+  public SimpleCharStream(java.io.Reader dstream, int startline,
+                          int startcolumn)
+  {
+    this(dstream, startline, startcolumn, 4096);
+  }
+
+  /** Constructor. */
+  public SimpleCharStream(java.io.Reader dstream)
+  {
+    this(dstream, 1, 1, 4096);
+  }
+
+  /** Reinitialise. */
+  public void ReInit(java.io.Reader dstream, int startline,
+  int startcolumn, int buffersize)
+  {
+    inputStream = dstream;
+    line = startline;
+    column = startcolumn - 1;
+
+    if (buffer == null || buffersize != buffer.length)
+    {
+      available = bufsize = buffersize;
+      buffer = new char[buffersize];
+      bufline = new int[buffersize];
+      bufcolumn = new int[buffersize];
+    }
+    prevCharIsLF = prevCharIsCR = false;
+    tokenBegin = inBuf = maxNextCharInd = 0;
+    bufpos = -1;
+  }
+
+  /** Reinitialise. */
+  public void ReInit(java.io.Reader dstream, int startline,
+                     int startcolumn)
+  {
+    ReInit(dstream, startline, startcolumn, 4096);
+  }
+
+  /** Reinitialise. */
+  public void ReInit(java.io.Reader dstream)
+  {
+    ReInit(dstream, 1, 1, 4096);
+  }
+  /** Constructor. */
+  public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline,
+  int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException
+  {
+    this(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
+  }
+
+  /** Constructor. */
+  public SimpleCharStream(java.io.InputStream dstream, int startline,
+  int startcolumn, int buffersize)
+  {
+    this(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
+  }
+
+  /** Constructor. */
+  public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline,
+                          int startcolumn) throws java.io.UnsupportedEncodingException
+  {
+    this(dstream, encoding, startline, startcolumn, 4096);
+  }
+
+  /** Constructor. */
+  public SimpleCharStream(java.io.InputStream dstream, int startline,
+                          int startcolumn)
+  {
+    this(dstream, startline, startcolumn, 4096);
+  }
+
+  /** Constructor. */
+  public SimpleCharStream(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException
+  {
+    this(dstream, encoding, 1, 1, 4096);
+  }
+
+  /** Constructor. */
+  public SimpleCharStream(java.io.InputStream dstream)
+  {
+    this(dstream, 1, 1, 4096);
+  }
+
+  /** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, String encoding, int startline,
+                          int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException
+  {
+    ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
+  }
+
+  /** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, int startline,
+                          int startcolumn, int buffersize)
+  {
+    ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
+  }
+
+  /** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException
+  {
+    ReInit(dstream, encoding, 1, 1, 4096);
+  }
+
+  /** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream)
+  {
+    ReInit(dstream, 1, 1, 4096);
+  }
+  /** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, String encoding, int startline,
+                     int startcolumn) throws java.io.UnsupportedEncodingException
+  {
+    ReInit(dstream, encoding, startline, startcolumn, 4096);
+  }
+  /** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, int startline,
+                     int startcolumn)
+  {
+    ReInit(dstream, startline, startcolumn, 4096);
+  }
+  /** Get token literal value. */
+  public String GetImage()
+  {
+    if (bufpos >= tokenBegin)
+      return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
+    else
+      return new String(buffer, tokenBegin, bufsize - tokenBegin) +
+                            new String(buffer, 0, bufpos + 1);
+  }
+
+  /** Get the suffix. */
+  public char[] GetSuffix(int len)
+  {
+    char[] ret = new char[len];
+
+    if ((bufpos + 1) >= len)
+      System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
+    else
+    {
+      System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,
+                                                        len - bufpos - 1);
+      System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
+    }
+
+    return ret;
+  }
+
+  /** Reset buffer when finished. */
+  public void Done()
+  {
+    buffer = null;
+    bufline = null;
+    bufcolumn = null;
+  }
+
+  /**
+   * Method to adjust line and column numbers for the start of a token.
+   */
+  public void adjustBeginLineColumn(int newLine, int newCol)
+  {
+    int start = tokenBegin;
+    int len;
+
+    if (bufpos >= tokenBegin)
+    {
+      len = bufpos - tokenBegin + inBuf + 1;
+    }
+    else
+    {
+      len = bufsize - tokenBegin + bufpos + 1 + inBuf;
+    }
+
+    int i = 0, j = 0, k = 0;
+    int nextColDiff = 0, columnDiff = 0;
+
+    while (i < len && bufline[j = start % bufsize] == bufline[k = ++start % bufsize])
+    {
+      bufline[j] = newLine;
+      nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];
+      bufcolumn[j] = newCol + columnDiff;
+      columnDiff = nextColDiff;
+      i++;
+    }
+
+    if (i < len)
+    {
+      bufline[j] = newLine++;
+      bufcolumn[j] = newCol + columnDiff;
+
+      while (i++ < len)
+      {
+        if (bufline[j = start % bufsize] != bufline[++start % bufsize])
+          bufline[j] = newLine++;
+        else
+          bufline[j] = newLine;
+      }
+    }
+
+    line = bufline[j];
+    column = bufcolumn[j];
+  }
+
+  boolean getTrackLineColumn() { return trackLineColumn; }
+  void setTrackLineColumn(boolean tlc) { trackLineColumn = tlc; }
+}
+/* JavaCC - OriginalChecksum=481f01d084994900d089ac6372520457 (do not edit this line) */
diff -U 3 -dHrN -- vdt-veditor/_generated/com/elphel/vdt/veditor/parser/vhdl/Token.java vdt/_generated/com/elphel/vdt/veditor/parser/vhdl/Token.java
--- vdt-veditor/_generated/com/elphel/vdt/veditor/parser/vhdl/Token.java	2016-06-24 10:29:40.832496184 -0600
+++ vdt/_generated/com/elphel/vdt/veditor/parser/vhdl/Token.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,81 +1,131 @@
-/* Generated By:JavaCC: Do not edit this line. Token.java Version 3.0 */
-package net.sourceforge.veditor.parser;
-
-/**
- * Describes the input token stream.
- */
-
-public class Token {
-
-  /**
-   * An integer that describes the kind of this token.  This numbering
-   * system is determined by JavaCCParser, and a table of these numbers is
-   * stored in the file ...Constants.java.
-   */
-  public int kind;
-
-  /**
-   * beginLine and beginColumn describe the position of the first character
-   * of this token; endLine and endColumn describe the position of the
-   * last character of this token.
-   */
-  public int beginLine, beginColumn, endLine, endColumn;
-
-  /**
-   * The string image of the token.
-   */
-  public String image;
-
-  /**
-   * A reference to the next regular (non-special) token from the input
-   * stream.  If this is the last token from the input stream, or if the
-   * token manager has not read tokens beyond this one, this field is
-   * set to null.  This is true only if this token is also a regular
-   * token.  Otherwise, see below for a description of the contents of
-   * this field.
-   */
-  public Token next;
-
-  /**
-   * This field is used to access special tokens that occur prior to this
-   * token, but after the immediately preceding regular (non-special) token.
-   * If there are no such special tokens, this field is set to null.
-   * When there are more than one such special token, this field refers
-   * to the last of these special tokens, which in turn refers to the next
-   * previous special token through its specialToken field, and so on
-   * until the first special token (whose specialToken field is null).
-   * The next fields of special tokens refer to other special tokens that
-   * immediately follow it (without an intervening regular token).  If there
-   * is no such token, this field is null.
-   */
-  public Token specialToken;
-
-  /**
-   * Returns the image.
-   */
-  public String toString()
-  {
-     return image;
-  }
-
-  /**
-   * Returns a new Token object, by default. However, if you want, you
-   * can create and return subclass objects based on the value of ofKind.
-   * Simply add the cases to the switch for all those special cases.
-   * For example, if you have a subclass of Token called IDToken that
-   * you want to create if ofKind is ID, simlpy add something like :
-   *
-   *    case MyParserConstants.ID : return new IDToken();
-   *
-   * to the following switch statement. Then you can cast matchedToken
-   * variable to the appropriate type and use it in your lexical actions.
-   */
-  public static final Token newToken(int ofKind)
-  {
-     switch(ofKind)
-     {
-       default : return new Token();
-     }
-  }
-
-}
+/* Generated By:JavaCC: Do not edit this line. Token.java Version 6.0 */
+/* JavaCCOptions:TOKEN_EXTENDS=,KEEP_LINE_COL=null,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
+package com.elphel.vdt.veditor.parser.vhdl;
+
+/**
+ * Describes the input token stream.
+ */
+
+public class Token implements java.io.Serializable {
+
+  /**
+   * The version identifier for this Serializable class.
+   * Increment only if the <i>serialized</i> form of the
+   * class changes.
+   */
+  private static final long serialVersionUID = 1L;
+
+  /**
+   * An integer that describes the kind of this token.  This numbering
+   * system is determined by JavaCCParser, and a table of these numbers is
+   * stored in the file ...Constants.java.
+   */
+  public int kind;
+
+  /** The line number of the first character of this Token. */
+  public int beginLine;
+  /** The column number of the first character of this Token. */
+  public int beginColumn;
+  /** The line number of the last character of this Token. */
+  public int endLine;
+  /** The column number of the last character of this Token. */
+  public int endColumn;
+
+  /**
+   * The string image of the token.
+   */
+  public String image;
+
+  /**
+   * A reference to the next regular (non-special) token from the input
+   * stream.  If this is the last token from the input stream, or if the
+   * token manager has not read tokens beyond this one, this field is
+   * set to null.  This is true only if this token is also a regular
+   * token.  Otherwise, see below for a description of the contents of
+   * this field.
+   */
+  public Token next;
+
+  /**
+   * This field is used to access special tokens that occur prior to this
+   * token, but after the immediately preceding regular (non-special) token.
+   * If there are no such special tokens, this field is set to null.
+   * When there are more than one such special token, this field refers
+   * to the last of these special tokens, which in turn refers to the next
+   * previous special token through its specialToken field, and so on
+   * until the first special token (whose specialToken field is null).
+   * The next fields of special tokens refer to other special tokens that
+   * immediately follow it (without an intervening regular token).  If there
+   * is no such token, this field is null.
+   */
+  public Token specialToken;
+
+  /**
+   * An optional attribute value of the Token.
+   * Tokens which are not used as syntactic sugar will often contain
+   * meaningful values that will be used later on by the compiler or
+   * interpreter. This attribute value is often different from the image.
+   * Any subclass of Token that actually wants to return a non-null value can
+   * override this method as appropriate.
+   */
+  public Object getValue() {
+    return null;
+  }
+
+  /**
+   * No-argument constructor
+   */
+  public Token() {}
+
+  /**
+   * Constructs a new token for the specified Image.
+   */
+  public Token(int kind)
+  {
+    this(kind, null);
+  }
+
+  /**
+   * Constructs a new token for the specified Image and Kind.
+   */
+  public Token(int kind, String image)
+  {
+    this.kind = kind;
+    this.image = image;
+  }
+
+  /**
+   * Returns the image.
+   */
+  public String toString()
+  {
+    return image;
+  }
+
+  /**
+   * Returns a new Token object, by default. However, if you want, you
+   * can create and return subclass objects based on the value of ofKind.
+   * Simply add the cases to the switch for all those special cases.
+   * For example, if you have a subclass of Token called IDToken that
+   * you want to create if ofKind is ID, simply add something like :
+   *
+   *    case MyParserConstants.ID : return new IDToken(ofKind, image);
+   *
+   * to the following switch statement. Then you can cast matchedToken
+   * variable to the appropriate type and use sit in your lexical actions.
+   */
+  public static Token newToken(int ofKind, String image)
+  {
+    switch(ofKind)
+    {
+      default : return new Token(ofKind, image);
+    }
+  }
+
+  public static Token newToken(int ofKind)
+  {
+    return newToken(ofKind, null);
+  }
+
+}
+/* JavaCC - OriginalChecksum=e16af3189395a5ac351db220894b5f48 (do not edit this line) */
diff -U 3 -dHrN -- vdt-veditor/_generated/com/elphel/vdt/veditor/parser/vhdl/TokenMgrError.java vdt/_generated/com/elphel/vdt/veditor/parser/vhdl/TokenMgrError.java
--- vdt-veditor/_generated/com/elphel/vdt/veditor/parser/vhdl/TokenMgrError.java	2016-06-24 10:29:40.832496184 -0600
+++ vdt/_generated/com/elphel/vdt/veditor/parser/vhdl/TokenMgrError.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,138 +1,147 @@
-/* Generated By:JavaCC: Do not edit this line. TokenMgrError.java Version 3.0 */
-package net.sourceforge.veditor.parser;
-
-public class TokenMgrError extends Error
-{
-   /*
-    * Ordinals for various reasons why an Error of this type can be thrown.
-    */
-
-   /**
-     * 
-     */
-    private static final long serialVersionUID = 8717981741131339532L;
-
-/**
-    * Lexical error occured.
-    */
-   static final int LEXICAL_ERROR = 0;
-
-   /**
-    * An attempt wass made to create a second instance of a static token manager.
-    */
-   static final int STATIC_LEXER_ERROR = 1;
-
-   /**
-    * Tried to change to an invalid lexical state.
-    */
-   static final int INVALID_LEXICAL_STATE = 2;
-
-   /**
-    * Detected (and bailed out of) an infinite loop in the token manager.
-    */
-   static final int LOOP_DETECTED = 3;
-
-   /**
-    * Indicates the reason why the exception is thrown. It will have
-    * one of the above 4 values.
-    */
-   int errorCode;
-
-   /**
-    * Replaces unprintable characters by their espaced (or unicode escaped)
-    * equivalents in the given string
-    */
-   protected static final String addEscapes(String str) {
-      StringBuffer retval = new StringBuffer();
-      char ch;
-      for (int i = 0; i < str.length(); i++) {
-        switch (str.charAt(i))
-        {
-           case 0 :
-              continue;
-           case '\b':
-              retval.append("\\b");
-              continue;
-           case '\t':
-              retval.append("\\t");
-              continue;
-           case '\n':
-              retval.append("\\n");
-              continue;
-           case '\f':
-              retval.append("\\f");
-              continue;
-           case '\r':
-              retval.append("\\r");
-              continue;
-           case '\"':
-              retval.append("\\\"");
-              continue;
-           case '\'':
-              retval.append("\\\'");
-              continue;
-           case '\\':
-              retval.append("\\\\");
-              continue;
-           default:
-              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
-                 String s = "0000" + Integer.toString(ch, 16);
-                 retval.append("\\u" + s.substring(s.length() - 4, s.length()));
-              } else {
-                 retval.append(ch);
-              }
-              continue;
-        }
-      }
-      return retval.toString();
-   }
-
-   /**
-    * Returns a detailed message for the Error when it is thrown by the
-    * token manager to indicate a lexical error.
-    * Parameters : 
-    *    EOFSeen     : indicates if EOF caused the lexicl error
-    *    curLexState : lexical state in which this error occured
-    *    errorLine   : line number when the error occured
-    *    errorColumn : column number when the error occured
-    *    errorAfter  : prefix that was seen before this error occured
-    *    curchar     : the offending character
-    * Note: You can customize the lexical error message by modifying this method.
-    */
-   protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {
-      return("Lexical error at line " +
-           errorLine + ", column " +
-           errorColumn + ".  Encountered: " +
-           (EOFSeen ? "<EOF> " : ("\"" + addEscapes(String.valueOf(curChar)) + "\"") + " (" + (int)curChar + "), ") +
-           "after : \"" + addEscapes(errorAfter) + "\"");
-   }
-
-   /**
-    * You can also modify the body of this method to customize your error messages.
-    * For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
-    * of end-users concern, so you can return something like : 
-    *
-    *     "Internal Error : Please file a bug report .... "
-    *
-    * from this method for such cases in the release version of your parser.
-    */
-   public String getMessage() {
-      return super.getMessage();
-   }
-
-   /*
-    * Constructors of various flavors follow.
-    */
-
-   public TokenMgrError() {
-   }
-
-   public TokenMgrError(String message, int reason) {
-      super(message);
-      errorCode = reason;
-   }
-
-   public TokenMgrError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar, int reason) {
-      this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason);
-   }
-}
+/* Generated By:JavaCC: Do not edit this line. TokenMgrError.java Version 6.0 */
+/* JavaCCOptions: */
+package com.elphel.vdt.veditor.parser.vhdl;
+
+/** Token Manager Error. */
+public class TokenMgrError extends Error
+{
+
+  /**
+   * The version identifier for this Serializable class.
+   * Increment only if the <i>serialized</i> form of the
+   * class changes.
+   */
+  private static final long serialVersionUID = 1L;
+
+  /*
+   * Ordinals for various reasons why an Error of this type can be thrown.
+   */
+
+  /**
+   * Lexical error occurred.
+   */
+  static final int LEXICAL_ERROR = 0;
+
+  /**
+   * An attempt was made to create a second instance of a static token manager.
+   */
+  static final int STATIC_LEXER_ERROR = 1;
+
+  /**
+   * Tried to change to an invalid lexical state.
+   */
+  static final int INVALID_LEXICAL_STATE = 2;
+
+  /**
+   * Detected (and bailed out of) an infinite loop in the token manager.
+   */
+  static final int LOOP_DETECTED = 3;
+
+  /**
+   * Indicates the reason why the exception is thrown. It will have
+   * one of the above 4 values.
+   */
+  int errorCode;
+
+  /**
+   * Replaces unprintable characters by their escaped (or unicode escaped)
+   * equivalents in the given string
+   */
+  protected static final String addEscapes(String str) {
+    StringBuffer retval = new StringBuffer();
+    char ch;
+    for (int i = 0; i < str.length(); i++) {
+      switch (str.charAt(i))
+      {
+        case 0 :
+          continue;
+        case '\b':
+          retval.append("\\b");
+          continue;
+        case '\t':
+          retval.append("\\t");
+          continue;
+        case '\n':
+          retval.append("\\n");
+          continue;
+        case '\f':
+          retval.append("\\f");
+          continue;
+        case '\r':
+          retval.append("\\r");
+          continue;
+        case '\"':
+          retval.append("\\\"");
+          continue;
+        case '\'':
+          retval.append("\\\'");
+          continue;
+        case '\\':
+          retval.append("\\\\");
+          continue;
+        default:
+          if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
+            String s = "0000" + Integer.toString(ch, 16);
+            retval.append("\\u" + s.substring(s.length() - 4, s.length()));
+          } else {
+            retval.append(ch);
+          }
+          continue;
+      }
+    }
+    return retval.toString();
+  }
+
+  /**
+   * Returns a detailed message for the Error when it is thrown by the
+   * token manager to indicate a lexical error.
+   * Parameters :
+   *    EOFSeen     : indicates if EOF caused the lexical error
+   *    curLexState : lexical state in which this error occurred
+   *    errorLine   : line number when the error occurred
+   *    errorColumn : column number when the error occurred
+   *    errorAfter  : prefix that was seen before this error occurred
+   *    curchar     : the offending character
+   * Note: You can customize the lexical error message by modifying this method.
+   */
+  protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {
+    return("Lexical error at line " +
+          errorLine + ", column " +
+          errorColumn + ".  Encountered: " +
+          (EOFSeen ? "<EOF> " : ("\"" + addEscapes(String.valueOf(curChar)) + "\"") + " (" + (int)curChar + "), ") +
+          "after : \"" + addEscapes(errorAfter) + "\"");
+  }
+
+  /**
+   * You can also modify the body of this method to customize your error messages.
+   * For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
+   * of end-users concern, so you can return something like :
+   *
+   *     "Internal Error : Please file a bug report .... "
+   *
+   * from this method for such cases in the release version of your parser.
+   */
+  public String getMessage() {
+    return super.getMessage();
+  }
+
+  /*
+   * Constructors of various flavors follow.
+   */
+
+  /** No arg constructor. */
+  public TokenMgrError() {
+  }
+
+  /** Constructor with message and reason. */
+  public TokenMgrError(String message, int reason) {
+    super(message);
+    errorCode = reason;
+  }
+
+  /** Full Constructor. */
+  public TokenMgrError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar, int reason) {
+    this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason);
+  }
+}
+/* JavaCC - OriginalChecksum=c41bdfb9ac964ae021f18dc192808dd1 (do not edit this line) */
diff -U 3 -dHrN -- vdt-veditor/_generated/com/elphel/vdt/veditor/parser/vhdl/VhdlParserCoreConstants.java vdt/_generated/com/elphel/vdt/veditor/parser/vhdl/VhdlParserCoreConstants.java
--- vdt-veditor/_generated/com/elphel/vdt/veditor/parser/vhdl/VhdlParserCoreConstants.java	2016-06-24 10:29:40.836496072 -0600
+++ vdt/_generated/com/elphel/vdt/veditor/parser/vhdl/VhdlParserCoreConstants.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,154 +1,491 @@
-/* Generated By:JavaCC: Do not edit this line. VhdlParserCoreConstants.java */
-package net.sourceforge.veditor.parser;
-
-public interface VhdlParserCoreConstants {
-
-  int EOF = 0;
-  int MULTI_LINE_COMMENT = 2;
-  int SINGLE_LINE_COMMENT = 9;
-  int LIBRARY = 10;
-  int BODY = 11;
-  int PACKAGE = 12;
-  int USE = 13;
-  int ENTITY = 14;
-  int ARCHITECTURE = 15;
-  int IS = 16;
-  int OF = 17;
-  int RECORD = 18;
-  int GENERIC = 19;
-  int PORT = 20;
-  int PROCESS = 21;
-  int BEGIN = 22;
-  int END = 23;
-  int CONSTANT = 24;
-  int PROCEDURE = 25;
-  int FUNCTION = 26;
-  int SIGNAL = 27;
-  int SHARED = 28;
-  int VARIABLE = 29;
-  int TYPE = 30;
-  int SUBTYPE = 31;
-  int FILE = 32;
-  int ALIAS = 33;
-  int ATTRIBUTE = 34;
-  int COMPONENT = 35;
-  int FOR = 36;
-  int IF = 37;
-  int CASE = 38;
-  int LOOP = 39;
-  int RETURN = 40;
-  int DISCONNECT = 41;
-  int GROUP = 42;
-  int BLOCK = 43;
-  int ASSERT = 44;
-  int GENERATE = 45;
-  int CONFIGURATION = 46;
-  int LABEL = 47;
-  int LITERAL = 48;
-  int UNITS = 49;
-  int TO = 50;
-  int RANGE = 51;
-  int WITH = 52;
-  int OTHERS = 53;
-  int ALL = 54;
-  int MODE = 55;
-  int LPAREN = 56;
-  int RPAREN = 57;
-  int LBRACE = 58;
-  int RBRACE = 59;
-  int LBRACKET = 60;
-  int RBRACKET = 61;
-  int EOS = 62;
-  int PARA = 63;
-  int AT = 64;
-  int BQ = 65;
-  int DOLLAR = 66;
-  int COMMA = 67;
-  int COLON = 68;
-  int ASSIGN = 69;
-  int EQUAL = 70;
-  int IDENT = 71;
-  int SPC_CHAR = 72;
-  int OTHER = 73;
-
-  int DEFAULT = 0;
-  int IN_MULTI_LINE_COMMENT = 1;
-
-  String[] tokenImage = {
-    "<EOF>",
-    "\"/*\"",
-    "\"*/\"",
-    "<token of kind 3>",
-    "\" \"",
-    "\"\\t\"",
-    "\"\\r\"",
-    "\"\\n\"",
-    "\"\\f\"",
-    "<SINGLE_LINE_COMMENT>",
-    "\"library\"",
-    "\"body\"",
-    "\"package\"",
-    "\"use\"",
-    "\"entity\"",
-    "\"architecture\"",
-    "\"is\"",
-    "\"of\"",
-    "\"record\"",
-    "\"generic\"",
-    "\"port\"",
-    "\"process\"",
-    "\"begin\"",
-    "\"end\"",
-    "\"constant\"",
-    "\"procedure\"",
-    "\"function\"",
-    "\"signal\"",
-    "\"shared\"",
-    "\"variable\"",
-    "\"type\"",
-    "\"subtype\"",
-    "\"file\"",
-    "\"alias\"",
-    "\"attribute\"",
-    "\"component\"",
-    "\"for\"",
-    "\"if\"",
-    "\"case\"",
-    "\"loop\"",
-    "\"return\"",
-    "\"disconnect\"",
-    "\"group\"",
-    "\"block\"",
-    "\"assert\"",
-    "\"generate\"",
-    "\"configuration\"",
-    "\"lable\"",
-    "\"literal\"",
-    "\"units\"",
-    "\"to\"",
-    "\"range\"",
-    "\"with\"",
-    "\"others\"",
-    "\"all\"",
-    "<MODE>",
-    "\"(\"",
-    "\")\"",
-    "\"{\"",
-    "\"}\"",
-    "\"[\"",
-    "\"]\"",
-    "\";\"",
-    "\"#\"",
-    "\"@\"",
-    "\"`\"",
-    "\"$\"",
-    "\",\"",
-    "\":\"",
-    "\"<=\"",
-    "\"=\"",
-    "<IDENT>",
-    "<SPC_CHAR>",
-    "\"[.]\"",
-  };
-
-}
+/* Generated By:JJTree&JavaCC: Do not edit this line. VhdlParserCoreConstants.java */
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+/**
+ * Token literal values and constants.
+ * Generated by org.javacc.parser.OtherFilesGen#start()
+ */
+public interface VhdlParserCoreConstants {
+
+  /** End of File. */
+  int EOF = 0;
+  /** RegularExpression Id. */
+  int COMMENT = 6;
+  /** RegularExpression Id. */
+  int ABS = 7;
+  /** RegularExpression Id. */
+  int ACCESS = 8;
+  /** RegularExpression Id. */
+  int ACROSS = 9;
+  /** RegularExpression Id. */
+  int AFTER = 10;
+  /** RegularExpression Id. */
+  int ALIAS = 11;
+  /** RegularExpression Id. */
+  int ALL = 12;
+  /** RegularExpression Id. */
+  int AND = 13;
+  /** RegularExpression Id. */
+  int ARCHITECTURE = 14;
+  /** RegularExpression Id. */
+  int ARRAY = 15;
+  /** RegularExpression Id. */
+  int ASSERT = 16;
+  /** RegularExpression Id. */
+  int ATTRIBUTE = 17;
+  /** RegularExpression Id. */
+  int BEGIN = 18;
+  /** RegularExpression Id. */
+  int BLOCK = 19;
+  /** RegularExpression Id. */
+  int BODY = 20;
+  /** RegularExpression Id. */
+  int BREAK = 21;
+  /** RegularExpression Id. */
+  int BUFFER = 22;
+  /** RegularExpression Id. */
+  int BUS = 23;
+  /** RegularExpression Id. */
+  int CASE = 24;
+  /** RegularExpression Id. */
+  int COMPONENT = 25;
+  /** RegularExpression Id. */
+  int CONFIGURATION = 26;
+  /** RegularExpression Id. */
+  int CONSTANT = 27;
+  /** RegularExpression Id. */
+  int DISCONNECT = 28;
+  /** RegularExpression Id. */
+  int DOWNTO = 29;
+  /** RegularExpression Id. */
+  int ELSE = 30;
+  /** RegularExpression Id. */
+  int ELSIF = 31;
+  /** RegularExpression Id. */
+  int END = 32;
+  /** RegularExpression Id. */
+  int ENTITY = 33;
+  /** RegularExpression Id. */
+  int EXIT = 34;
+  /** RegularExpression Id. */
+  int FILE = 35;
+  /** RegularExpression Id. */
+  int FOR = 36;
+  /** RegularExpression Id. */
+  int FUNCTION = 37;
+  /** RegularExpression Id. */
+  int GENERATE = 38;
+  /** RegularExpression Id. */
+  int GENERIC = 39;
+  /** RegularExpression Id. */
+  int GROUP = 40;
+  /** RegularExpression Id. */
+  int GUARDED = 41;
+  /** RegularExpression Id. */
+  int IF = 42;
+  /** RegularExpression Id. */
+  int IMPURE = 43;
+  /** RegularExpression Id. */
+  int IN = 44;
+  /** RegularExpression Id. */
+  int INERTIAL = 45;
+  /** RegularExpression Id. */
+  int INOUT = 46;
+  /** RegularExpression Id. */
+  int IS = 47;
+  /** RegularExpression Id. */
+  int LABEL = 48;
+  /** RegularExpression Id. */
+  int LIBRARY = 49;
+  /** RegularExpression Id. */
+  int LINKAGE = 50;
+  /** RegularExpression Id. */
+  int LITERAL = 51;
+  /** RegularExpression Id. */
+  int LOOP = 52;
+  /** RegularExpression Id. */
+  int MAP = 53;
+  /** RegularExpression Id. */
+  int MOD = 54;
+  /** RegularExpression Id. */
+  int NAND = 55;
+  /** RegularExpression Id. */
+  int NATURE = 56;
+  /** RegularExpression Id. */
+  int NEW = 57;
+  /** RegularExpression Id. */
+  int NEXT = 58;
+  /** RegularExpression Id. */
+  int NOISE = 59;
+  /** RegularExpression Id. */
+  int NOR = 60;
+  /** RegularExpression Id. */
+  int NOT = 61;
+  /** RegularExpression Id. */
+  int NULL = 62;
+  /** RegularExpression Id. */
+  int OF = 63;
+  /** RegularExpression Id. */
+  int ON = 64;
+  /** RegularExpression Id. */
+  int OPEN = 65;
+  /** RegularExpression Id. */
+  int OR = 66;
+  /** RegularExpression Id. */
+  int OTHERS = 67;
+  /** RegularExpression Id. */
+  int OUT = 68;
+  /** RegularExpression Id. */
+  int PACKAGE = 69;
+  /** RegularExpression Id. */
+  int PORT = 70;
+  /** RegularExpression Id. */
+  int POSTPONED = 71;
+  /** RegularExpression Id. */
+  int PROCEDURAL = 72;
+  /** RegularExpression Id. */
+  int PROCEDURE = 73;
+  /** RegularExpression Id. */
+  int PROCESS = 74;
+  /** RegularExpression Id. */
+  int PROTECTED = 75;
+  /** RegularExpression Id. */
+  int PURE = 76;
+  /** RegularExpression Id. */
+  int QUANTITY = 77;
+  /** RegularExpression Id. */
+  int RANGE = 78;
+  /** RegularExpression Id. */
+  int RECORD = 79;
+  /** RegularExpression Id. */
+  int REGISTER = 80;
+  /** RegularExpression Id. */
+  int REJECT = 81;
+  /** RegularExpression Id. */
+  int REM = 82;
+  /** RegularExpression Id. */
+  int REPORT = 83;
+  /** RegularExpression Id. */
+  int RETURN = 84;
+  /** RegularExpression Id. */
+  int ROL = 85;
+  /** RegularExpression Id. */
+  int ROR = 86;
+  /** RegularExpression Id. */
+  int SELECT = 87;
+  /** RegularExpression Id. */
+  int SEVERITY = 88;
+  /** RegularExpression Id. */
+  int SIGNAL = 89;
+  /** RegularExpression Id. */
+  int SHARED = 90;
+  /** RegularExpression Id. */
+  int SLA = 91;
+  /** RegularExpression Id. */
+  int SLL = 92;
+  /** RegularExpression Id. */
+  int SPECTRUM = 93;
+  /** RegularExpression Id. */
+  int SRA = 94;
+  /** RegularExpression Id. */
+  int SRL = 95;
+  /** RegularExpression Id. */
+  int SUBNATURE = 96;
+  /** RegularExpression Id. */
+  int SUBTYPE = 97;
+  /** RegularExpression Id. */
+  int TERMINAL = 98;
+  /** RegularExpression Id. */
+  int THEN = 99;
+  /** RegularExpression Id. */
+  int THROUGH = 100;
+  /** RegularExpression Id. */
+  int TO = 101;
+  /** RegularExpression Id. */
+  int TOLERANCE = 102;
+  /** RegularExpression Id. */
+  int TRANSPORT = 103;
+  /** RegularExpression Id. */
+  int TYPE = 104;
+  /** RegularExpression Id. */
+  int UNAFFECTED = 105;
+  /** RegularExpression Id. */
+  int UNITS = 106;
+  /** RegularExpression Id. */
+  int UNTIL = 107;
+  /** RegularExpression Id. */
+  int USE = 108;
+  /** RegularExpression Id. */
+  int VARIABLE = 109;
+  /** RegularExpression Id. */
+  int WAIT = 110;
+  /** RegularExpression Id. */
+  int WHEN = 111;
+  /** RegularExpression Id. */
+  int WHILE = 112;
+  /** RegularExpression Id. */
+  int WITH = 113;
+  /** RegularExpression Id. */
+  int XNOR = 114;
+  /** RegularExpression Id. */
+  int XOR = 115;
+  /** RegularExpression Id. */
+  int upper_case_letter = 116;
+  /** RegularExpression Id. */
+  int lower_case_letter = 117;
+  /** RegularExpression Id. */
+  int digit = 118;
+  /** RegularExpression Id. */
+  int extended_digit = 119;
+  /** RegularExpression Id. */
+  int special_character = 120;
+  /** RegularExpression Id. */
+  int other_special_character = 121;
+  /** RegularExpression Id. */
+  int format_effector = 122;
+  /** RegularExpression Id. */
+  int base_specifier = 123;
+  /** RegularExpression Id. */
+  int underline = 124;
+  /** RegularExpression Id. */
+  int letter = 125;
+  /** RegularExpression Id. */
+  int letter_or_digit = 126;
+  /** RegularExpression Id. */
+  int integer = 127;
+  /** RegularExpression Id. */
+  int base = 128;
+  /** RegularExpression Id. */
+  int based_integer = 129;
+  /** RegularExpression Id. */
+  int based_literal = 130;
+  /** RegularExpression Id. */
+  int basic_character = 131;
+  /** RegularExpression Id. */
+  int basic_graphic_character = 132;
+  /** RegularExpression Id. */
+  int basic_identifier = 133;
+  /** RegularExpression Id. */
+  int bit_string_literal = 134;
+  /** RegularExpression Id. */
+  int bit_value = 135;
+  /** RegularExpression Id. */
+  int character_literal = 136;
+  /** RegularExpression Id. */
+  int decimal_literal = 137;
+  /** RegularExpression Id. */
+  int exponent = 138;
+  /** RegularExpression Id. */
+  int extended_identifier = 139;
+  /** RegularExpression Id. */
+  int graphic_character = 140;
+  /** RegularExpression Id. */
+  int string_literal = 141;
+  /** RegularExpression Id. */
+  int EXP = 142;
+  /** RegularExpression Id. */
+  int MUL = 143;
+  /** RegularExpression Id. */
+  int DIV = 144;
+  /** RegularExpression Id. */
+  int ADD = 145;
+  /** RegularExpression Id. */
+  int SUB = 146;
+  /** RegularExpression Id. */
+  int CONCAT = 147;
+  /** RegularExpression Id. */
+  int EQ = 148;
+  /** RegularExpression Id. */
+  int NEQ = 149;
+  /** RegularExpression Id. */
+  int GE = 150;
+  /** RegularExpression Id. */
+  int LE = 151;
+  /** RegularExpression Id. */
+  int GT = 152;
+  /** RegularExpression Id. */
+  int LO = 153;
+  /** RegularExpression Id. */
+  int SEMICOLON = 154;
+  /** RegularExpression Id. */
+  int COLON = 155;
+  /** RegularExpression Id. */
+  int ASSIGN = 156;
+  /** RegularExpression Id. */
+  int RARROW = 157;
+
+  /** Lexical state. */
+  int DEFAULT = 0;
+
+  /** Literal token values. */
+  String[] tokenImage = {
+    "<EOF>",
+    "\" \"",
+    "\"\\n\"",
+    "\"\\r\"",
+    "\"\\t\"",
+    "\"\\f\"",
+    "<COMMENT>",
+    "\"abs\"",
+    "\"access\"",
+    "\"across\"",
+    "\"after\"",
+    "\"alias\"",
+    "\"all\"",
+    "\"and\"",
+    "\"architecture\"",
+    "\"array\"",
+    "\"assert\"",
+    "\"attribute\"",
+    "\"begin\"",
+    "\"block\"",
+    "\"body\"",
+    "\"break\"",
+    "\"buffer\"",
+    "\"bus\"",
+    "\"case\"",
+    "\"component\"",
+    "\"configuration\"",
+    "\"constant\"",
+    "\"disconnect\"",
+    "\"downto\"",
+    "\"else\"",
+    "\"elsif\"",
+    "\"end\"",
+    "\"entity\"",
+    "\"exit\"",
+    "\"file\"",
+    "\"for\"",
+    "\"function\"",
+    "\"generate\"",
+    "\"generic\"",
+    "\"group\"",
+    "\"guarded\"",
+    "\"if\"",
+    "\"impure\"",
+    "\"in\"",
+    "\"inertial\"",
+    "\"inout\"",
+    "\"is\"",
+    "\"label\"",
+    "\"library\"",
+    "\"linkage\"",
+    "\"literal\"",
+    "\"loop\"",
+    "\"map\"",
+    "\"mod\"",
+    "\"nand\"",
+    "\"nature\"",
+    "\"new\"",
+    "\"next\"",
+    "\"noise\"",
+    "\"nor\"",
+    "\"not\"",
+    "\"null\"",
+    "\"of\"",
+    "\"on\"",
+    "\"open\"",
+    "\"or\"",
+    "\"others\"",
+    "\"out\"",
+    "\"package\"",
+    "\"port\"",
+    "\"postponed\"",
+    "\"procedural\"",
+    "\"procedure\"",
+    "\"process\"",
+    "\"protected\"",
+    "\"pure\"",
+    "\"quantity\"",
+    "\"range\"",
+    "\"record\"",
+    "\"register\"",
+    "\"reject\"",
+    "\"rem\"",
+    "\"report\"",
+    "\"return\"",
+    "\"rol\"",
+    "\"ror\"",
+    "\"select\"",
+    "\"severity\"",
+    "\"signal\"",
+    "\"shared\"",
+    "\"sla\"",
+    "\"sll\"",
+    "\"spectrum\"",
+    "\"sra\"",
+    "\"srl\"",
+    "\"subnature\"",
+    "\"subtype\"",
+    "\"terminal\"",
+    "\"then\"",
+    "\"through\"",
+    "\"to\"",
+    "\"tolerance\"",
+    "\"transport\"",
+    "\"type\"",
+    "\"unaffected\"",
+    "\"units\"",
+    "\"until\"",
+    "\"use\"",
+    "\"variable\"",
+    "\"wait\"",
+    "\"when\"",
+    "\"while\"",
+    "\"with\"",
+    "\"xnor\"",
+    "\"xor\"",
+    "<upper_case_letter>",
+    "<lower_case_letter>",
+    "<digit>",
+    "<extended_digit>",
+    "<special_character>",
+    "<other_special_character>",
+    "<format_effector>",
+    "<base_specifier>",
+    "\"_\"",
+    "<letter>",
+    "<letter_or_digit>",
+    "<integer>",
+    "<base>",
+    "<based_integer>",
+    "<based_literal>",
+    "<basic_character>",
+    "<basic_graphic_character>",
+    "<basic_identifier>",
+    "<bit_string_literal>",
+    "<bit_value>",
+    "<character_literal>",
+    "<decimal_literal>",
+    "<exponent>",
+    "<extended_identifier>",
+    "<graphic_character>",
+    "<string_literal>",
+    "\"**\"",
+    "\"*\"",
+    "\"/\"",
+    "\"+\"",
+    "\"-\"",
+    "\"&\"",
+    "\"=\"",
+    "\"/=\"",
+    "\">=\"",
+    "\"<=\"",
+    "\">\"",
+    "\"<\"",
+    "\";\"",
+    "\":\"",
+    "\":=\"",
+    "\"=>\"",
+    "\"(\"",
+    "\")\"",
+    "\",\"",
+    "\"\\\'\"",
+    "\"|\"",
+    "\"<>\"",
+    "\".\"",
+    "\"==\"",
+  };
+
+}
diff -U 3 -dHrN -- vdt-veditor/_generated/com/elphel/vdt/veditor/parser/vhdl/VhdlParserCore.java vdt/_generated/com/elphel/vdt/veditor/parser/vhdl/VhdlParserCore.java
--- vdt-veditor/_generated/com/elphel/vdt/veditor/parser/vhdl/VhdlParserCore.java	2016-06-24 10:29:40.836496072 -0600
+++ vdt/_generated/com/elphel/vdt/veditor/parser/vhdl/VhdlParserCore.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,1311 +1,21173 @@
-/* Generated By:JavaCC: Do not edit this line. VhdlParserCore.java */
-package net.sourceforge.veditor.parser;
-
-public abstract class VhdlParserCore implements VhdlParserCoreConstants {
-        protected abstract void addModule(int begin, String name);
-        protected abstract void endModule(int line);
-        protected abstract void addPort(int line, String portName);
-        protected abstract void addVariable(int line, String varName);
-        protected abstract void addParameter(int line, String name);
-        protected abstract void addElement(int begin, int end, String type, String name);
-        protected abstract void addInstance(int begin, int end, String module, String inst);
-        protected abstract void beginStatement();
-        protected abstract void endStatement();
-        protected abstract void setPrefix(String fix);
-        protected abstract void setPostfix(String fix);
-
-        public void parse() throws ParseException
-        {
-                modules();
-        }
-
-  final public void modules() throws ParseException {
-    label_1:
-    while (true) {
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case LIBRARY:
-        jj_consume_token(LIBRARY);
-        skipTo(EOS);
-        break;
-      case USE:
-        jj_consume_token(USE);
-        skipTo(EOS);
-        break;
-      case ENTITY:
-        entity();
-        break;
-      case ARCHITECTURE:
-        architecture();
-        break;
-      case PACKAGE:
-        packageDef();
-        break;
-      default:
-        jj_la1[0] = jj_gen;
-        jj_consume_token(-1);
-        throw new ParseException();
-      }
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case LIBRARY:
-      case PACKAGE:
-      case USE:
-      case ENTITY:
-      case ARCHITECTURE:
-        ;
-        break;
-      default:
-        jj_la1[1] = jj_gen;
-        break label_1;
-      }
-    }
-  }
-
-  final public void entity() throws ParseException {
-        Token name ;
-        Token end ;
-    jj_consume_token(ENTITY);
-    name = identifier();
-    jj_consume_token(IS);
-                addModule( name.beginLine, name.image );
-    label_2:
-    while (true) {
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case GENERIC:
-      case PORT:
-        ;
-        break;
-      default:
-        jj_la1[2] = jj_gen;
-        break label_2;
-      }
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case GENERIC:
-        genericList();
-        break;
-      case PORT:
-        portList();
-        break;
-      default:
-        jj_la1[3] = jj_gen;
-        jj_consume_token(-1);
-        throw new ParseException();
-      }
-    }
-    label_3:
-    while (true) {
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case ATTRIBUTE:
-        ;
-        break;
-      default:
-        jj_la1[4] = jj_gen;
-        break label_3;
-      }
-      attributeList();
-    }
-    jj_consume_token(END);
-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case ENTITY:
-      jj_consume_token(ENTITY);
-      break;
-    default:
-      jj_la1[5] = jj_gen;
-      ;
-    }
-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case IDENT:
-      identifier();
-      break;
-    default:
-      jj_la1[6] = jj_gen;
-      ;
-    }
-    end = jj_consume_token(EOS);
-                endModule( end.beginLine );
-  }
-
-  final public void architecture() throws ParseException {
-        Token end;
-    jj_consume_token(ARCHITECTURE);
-    identifier();
-    jj_consume_token(OF);
-    identifier();
-    jj_consume_token(IS);
-    moduleBody();
-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case ARCHITECTURE:
-      jj_consume_token(ARCHITECTURE);
-      break;
-    default:
-      jj_la1[7] = jj_gen;
-      ;
-    }
-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case IDENT:
-      identifier();
-      break;
-    default:
-      jj_la1[8] = jj_gen;
-      ;
-    }
-    end = jj_consume_token(EOS);
-                endModule( end.beginLine );
-  }
-
-  final public void packageDef() throws ParseException {
-        Token name ;
-        Token end ;
-    jj_consume_token(PACKAGE);
-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case BODY:
-      jj_consume_token(BODY);
-      break;
-    default:
-      jj_la1[9] = jj_gen;
-      ;
-    }
-    identifier();
-    jj_consume_token(IS);
-    label_4:
-    while (true) {
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case CONSTANT:
-      case PROCEDURE:
-      case FUNCTION:
-      case SIGNAL:
-      case SHARED:
-      case VARIABLE:
-      case TYPE:
-      case SUBTYPE:
-      case FILE:
-      case ALIAS:
-      case ATTRIBUTE:
-      case FOR:
-      case DISCONNECT:
-      case GROUP:
-        packageDeclaration();
-        break;
-      case COMPONENT:
-        jj_consume_token(COMPONENT);
-        name = identifier();
-        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-        case IS:
-          jj_consume_token(IS);
-          break;
-        default:
-          jj_la1[10] = jj_gen;
-          ;
-        }
-                        addModule( name.beginLine, name.image );
-        label_5:
-        while (true) {
-          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-          case GENERIC:
-          case PORT:
-            ;
-            break;
-          default:
-            jj_la1[11] = jj_gen;
-            break label_5;
-          }
-          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-          case GENERIC:
-            genericList();
-            break;
-          case PORT:
-            portList();
-            break;
-          default:
-            jj_la1[12] = jj_gen;
-            jj_consume_token(-1);
-            throw new ParseException();
-          }
-        }
-        end = jj_consume_token(END);
-        jj_consume_token(COMPONENT);
-        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-        case IDENT:
-          identifier();
-          break;
-        default:
-          jj_la1[13] = jj_gen;
-          ;
-        }
-        jj_consume_token(EOS);
-                        endModule( end.beginLine );
-        break;
-      default:
-        jj_la1[14] = jj_gen;
-        jj_consume_token(-1);
-        throw new ParseException();
-      }
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case CONSTANT:
-      case PROCEDURE:
-      case FUNCTION:
-      case SIGNAL:
-      case SHARED:
-      case VARIABLE:
-      case TYPE:
-      case SUBTYPE:
-      case FILE:
-      case ALIAS:
-      case ATTRIBUTE:
-      case COMPONENT:
-      case FOR:
-      case DISCONNECT:
-      case GROUP:
-        ;
-        break;
-      default:
-        jj_la1[15] = jj_gen;
-        break label_4;
-      }
-    }
-    jj_consume_token(END);
-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case PACKAGE:
-      jj_consume_token(PACKAGE);
-      break;
-    default:
-      jj_la1[16] = jj_gen;
-      ;
-    }
-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case BODY:
-      jj_consume_token(BODY);
-      break;
-    default:
-      jj_la1[17] = jj_gen;
-      ;
-    }
-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case IDENT:
-      identifier();
-      break;
-    default:
-      jj_la1[18] = jj_gen;
-      ;
-    }
-    jj_consume_token(EOS);
-  }
-
-  final public void genericList() throws ParseException {
-    jj_consume_token(GENERIC);
-    jj_consume_token(LPAREN);
-    genericElement();
-    label_6:
-    while (true) {
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case EOS:
-        ;
-        break;
-      default:
-        jj_la1[19] = jj_gen;
-        break label_6;
-      }
-      jj_consume_token(EOS);
-      genericElement();
-    }
-    jj_consume_token(RPAREN);
-    jj_consume_token(EOS);
-  }
-
-  final public void genericElement() throws ParseException {
-        Token port;
-        Token postfix;
-                setPrefix("port ");
-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case CONSTANT:
-    case SIGNAL:
-    case VARIABLE:
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case CONSTANT:
-        jj_consume_token(CONSTANT);
-        break;
-      case SIGNAL:
-        jj_consume_token(SIGNAL);
-        break;
-      case VARIABLE:
-        jj_consume_token(VARIABLE);
-        break;
-      default:
-        jj_la1[20] = jj_gen;
-        jj_consume_token(-1);
-        throw new ParseException();
-      }
-      break;
-    default:
-      jj_la1[21] = jj_gen;
-      ;
-    }
-    port = identifier();
-                addParameter(port.beginLine, port.image);
-    label_7:
-    while (true) {
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case COMMA:
-        ;
-        break;
-      default:
-        jj_la1[22] = jj_gen;
-        break label_7;
-      }
-      jj_consume_token(COMMA);
-      port = identifier();
-                        addParameter(port.beginLine, port.image);
-    }
-    jj_consume_token(COLON);
-    postfix = interfaceElementIndication();
-                setPostfix(postfix.image);
-  }
-
-  final public void portList() throws ParseException {
-    jj_consume_token(PORT);
-    jj_consume_token(LPAREN);
-    portElement();
-    label_8:
-    while (true) {
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case EOS:
-        ;
-        break;
-      default:
-        jj_la1[23] = jj_gen;
-        break label_8;
-      }
-      jj_consume_token(EOS);
-      portElement();
-    }
-    jj_consume_token(RPAREN);
-    jj_consume_token(EOS);
-  }
-
-  final public void attributeList() throws ParseException {
-    jj_consume_token(ATTRIBUTE);
-    identifier();
-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case OF:
-      jj_consume_token(OF);
-      entityNameList();
-      jj_consume_token(COLON);
-      entityClass();
-      jj_consume_token(IS);
-      break;
-    case COLON:
-      jj_consume_token(COLON);
-      identifier();
-      break;
-    default:
-      jj_la1[24] = jj_gen;
-      jj_consume_token(-1);
-      throw new ParseException();
-    }
-    skipTo(EOS);
-  }
-
-  final public void entityClass() throws ParseException {
-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case ENTITY:
-      jj_consume_token(ENTITY);
-      break;
-    case ARCHITECTURE:
-      jj_consume_token(ARCHITECTURE);
-      break;
-    case CONFIGURATION:
-      jj_consume_token(CONFIGURATION);
-      break;
-    case PACKAGE:
-      jj_consume_token(PACKAGE);
-      break;
-    case PROCEDURE:
-      jj_consume_token(PROCEDURE);
-      break;
-    case FUNCTION:
-      jj_consume_token(FUNCTION);
-      break;
-    case TYPE:
-      jj_consume_token(TYPE);
-      break;
-    case SUBTYPE:
-      jj_consume_token(SUBTYPE);
-      break;
-    case CONSTANT:
-      jj_consume_token(CONSTANT);
-      break;
-    case SIGNAL:
-      jj_consume_token(SIGNAL);
-      break;
-    case VARIABLE:
-      jj_consume_token(VARIABLE);
-      break;
-    case FILE:
-      jj_consume_token(FILE);
-      break;
-    case COMPONENT:
-      jj_consume_token(COMPONENT);
-      break;
-    case LABEL:
-      jj_consume_token(LABEL);
-      break;
-    case LITERAL:
-      jj_consume_token(LITERAL);
-      break;
-    case UNITS:
-      jj_consume_token(UNITS);
-      break;
-    case GROUP:
-      jj_consume_token(GROUP);
-      break;
-    default:
-      jj_la1[25] = jj_gen;
-      jj_consume_token(-1);
-      throw new ParseException();
-    }
-  }
-
-  final public void entityNameList() throws ParseException {
-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case IDENT:
-      identifier();
-      break;
-    case OTHERS:
-      jj_consume_token(OTHERS);
-      break;
-    case ALL:
-      jj_consume_token(ALL);
-      break;
-    default:
-      jj_la1[26] = jj_gen;
-      jj_consume_token(-1);
-      throw new ParseException();
-    }
-  }
-
-  final public void portElement() throws ParseException {
-        Token port;
-        Token postfix;
-                setPrefix("port ");
-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case CONSTANT:
-    case SIGNAL:
-    case VARIABLE:
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case CONSTANT:
-        jj_consume_token(CONSTANT);
-        break;
-      case SIGNAL:
-        jj_consume_token(SIGNAL);
-        break;
-      case VARIABLE:
-        jj_consume_token(VARIABLE);
-        break;
-      default:
-        jj_la1[27] = jj_gen;
-        jj_consume_token(-1);
-        throw new ParseException();
-      }
-      break;
-    default:
-      jj_la1[28] = jj_gen;
-      ;
-    }
-    port = identifier();
-                addPort(port.beginLine, port.image);
-    label_9:
-    while (true) {
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case COMMA:
-        ;
-        break;
-      default:
-        jj_la1[29] = jj_gen;
-        break label_9;
-      }
-      jj_consume_token(COMMA);
-      port = identifier();
-                        addPort(port.beginLine, port.image);
-    }
-    jj_consume_token(COLON);
-    postfix = interfaceElementIndication();
-                setPostfix(" : " + postfix.image);
-  }
-
-  final public void moduleBody() throws ParseException {
-        Token   module, inst, iend ;
-    label_10:
-    while (true) {
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case CONSTANT:
-      case PROCEDURE:
-      case FUNCTION:
-      case SIGNAL:
-      case SHARED:
-      case VARIABLE:
-      case TYPE:
-      case SUBTYPE:
-      case FILE:
-      case ALIAS:
-      case ATTRIBUTE:
-      case COMPONENT:
-      case FOR:
-      case DISCONNECT:
-      case GROUP:
-        ;
-        break;
-      default:
-        jj_la1[30] = jj_gen;
-        break label_10;
-      }
-      declaration();
-    }
-    jj_consume_token(BEGIN);
-    label_11:
-    while (true) {
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case PROCESS:
-      case BLOCK:
-      case ASSERT:
-      case WITH:
-      case IDENT:
-        ;
-        break;
-      default:
-        jj_la1[31] = jj_gen;
-        break label_11;
-      }
-      statement();
-    }
-    jj_consume_token(END);
-  }
-
-  final public Token identifier() throws ParseException {
-        Token token ;
-    token = jj_consume_token(IDENT);
-                {if (true) return token ;}
-    throw new Error("Missing return statement in function");
-  }
-
-  final public void packageDeclaration() throws ParseException {
-        Token variable;
-        Token postfix;
-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case CONSTANT:
-    case SIGNAL:
-    case SHARED:
-    case VARIABLE:
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case CONSTANT:
-        jj_consume_token(CONSTANT);
-        break;
-      case SIGNAL:
-        jj_consume_token(SIGNAL);
-        break;
-      case SHARED:
-      case VARIABLE:
-        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-        case SHARED:
-          jj_consume_token(SHARED);
-          break;
-        default:
-          jj_la1[32] = jj_gen;
-          ;
-        }
-        jj_consume_token(VARIABLE);
-        break;
-      default:
-        jj_la1[33] = jj_gen;
-        jj_consume_token(-1);
-        throw new ParseException();
-      }
-                        setPrefix(token.image + " ");
-      variable = identifier();
-                        addVariable(variable.beginLine, variable.image);
-      label_12:
-      while (true) {
-        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-        case COMMA:
-          ;
-          break;
-        default:
-          jj_la1[34] = jj_gen;
-          break label_12;
-        }
-        jj_consume_token(COMMA);
-        variable = identifier();
-                                addVariable(variable.beginLine, variable.image);
-      }
-      jj_consume_token(COLON);
-      postfix = interfaceElementIndication();
-                        setPostfix(" : " + postfix.image);
-      jj_consume_token(EOS);
-      break;
-    case TYPE:
-    case SUBTYPE:
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case TYPE:
-        jj_consume_token(TYPE);
-        break;
-      case SUBTYPE:
-        jj_consume_token(SUBTYPE);
-        break;
-      default:
-        jj_la1[35] = jj_gen;
-        jj_consume_token(-1);
-        throw new ParseException();
-      }
-      identifier();
-      jj_consume_token(IS);
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case RECORD:
-        jj_consume_token(RECORD);
-        skipEnd();
-        jj_consume_token(END);
-        jj_consume_token(RECORD);
-        jj_consume_token(EOS);
-        break;
-      default:
-        jj_la1[36] = jj_gen;
-        skipTo(EOS);
-      }
-      break;
-    case FILE:
-    case ALIAS:
-    case ATTRIBUTE:
-    case FOR:
-    case DISCONNECT:
-    case GROUP:
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case FILE:
-        jj_consume_token(FILE);
-        break;
-      case ALIAS:
-        jj_consume_token(ALIAS);
-        break;
-      case ATTRIBUTE:
-        jj_consume_token(ATTRIBUTE);
-        break;
-      case FOR:
-        jj_consume_token(FOR);
-        break;
-      case DISCONNECT:
-        jj_consume_token(DISCONNECT);
-        break;
-      case GROUP:
-        jj_consume_token(GROUP);
-        break;
-      default:
-        jj_la1[37] = jj_gen;
-        jj_consume_token(-1);
-        throw new ParseException();
-      }
-      skipTo(EOS);
-      break;
-    case PROCEDURE:
-      jj_consume_token(PROCEDURE);
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case EOS:
-        jj_consume_token(EOS);
-        break;
-      default:
-        jj_la1[40] = jj_gen;
-        skipTo(BEGIN);
-        skipEnd();
-        jj_consume_token(END);
-        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-        case PROCEDURE:
-          jj_consume_token(PROCEDURE);
-          break;
-        default:
-          jj_la1[38] = jj_gen;
-          ;
-        }
-        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-        case IDENT:
-          identifier();
-          break;
-        default:
-          jj_la1[39] = jj_gen;
-          ;
-        }
-        jj_consume_token(EOS);
-      }
-      break;
-    case FUNCTION:
-      jj_consume_token(FUNCTION);
-      skipTo(RETURN);
-      identifier();
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case EOS:
-        jj_consume_token(EOS);
-        break;
-      default:
-        jj_la1[43] = jj_gen;
-        skipTo(BEGIN);
-        skipEnd();
-        jj_consume_token(END);
-        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-        case FUNCTION:
-          jj_consume_token(FUNCTION);
-          break;
-        default:
-          jj_la1[41] = jj_gen;
-          ;
-        }
-        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-        case IDENT:
-          identifier();
-          break;
-        default:
-          jj_la1[42] = jj_gen;
-          ;
-        }
-        jj_consume_token(EOS);
-      }
-      break;
-    default:
-      jj_la1[44] = jj_gen;
-      jj_consume_token(-1);
-      throw new ParseException();
-    }
-  }
-
-  final public void declaration() throws ParseException {
-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case CONSTANT:
-    case PROCEDURE:
-    case FUNCTION:
-    case SIGNAL:
-    case SHARED:
-    case VARIABLE:
-    case TYPE:
-    case SUBTYPE:
-    case FILE:
-    case ALIAS:
-    case ATTRIBUTE:
-    case FOR:
-    case DISCONNECT:
-    case GROUP:
-      packageDeclaration();
-      break;
-    case COMPONENT:
-      jj_consume_token(COMPONENT);
-      skipTo2(END, COMPONENT);
-      skipTo(EOS);
-      break;
-    default:
-      jj_la1[45] = jj_gen;
-      jj_consume_token(-1);
-      throw new ParseException();
-    }
-  }
-
-  final public void statement() throws ParseException {
-        Token ident, module, iend;
-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case IDENT:
-      ident = identifier();
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case COLON:
-        jj_consume_token(COLON);
-                             beginStatement();
-        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-        case ENTITY:
-        case IDENT:
-          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-          case ENTITY:
-            jj_consume_token(ENTITY);
-            break;
-          default:
-            jj_la1[46] = jj_gen;
-            ;
-          }
-          module = identifier();
-          iend = skipTo(EOS);
-                                        addInstance( ident.beginLine, iend.endLine, module.image, ident.image );
-          break;
-        case COMPONENT:
-          jj_consume_token(COMPONENT);
-          module = identifier();
-          iend = skipTo(EOS);
-                                        addInstance( ident.beginLine, iend.endLine, module.image, ident.image );
-          break;
-        case FOR:
-        case IF:
-          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-          case IF:
-            jj_consume_token(IF);
-            break;
-          case FOR:
-            jj_consume_token(FOR);
-            break;
-          default:
-            jj_la1[47] = jj_gen;
-            jj_consume_token(-1);
-            throw new ParseException();
-          }
-          skipTo(GENERATE);
-          label_13:
-          while (true) {
-            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-            case CONSTANT:
-            case PROCEDURE:
-            case FUNCTION:
-            case SIGNAL:
-            case SHARED:
-            case VARIABLE:
-            case TYPE:
-            case SUBTYPE:
-            case FILE:
-            case ALIAS:
-            case ATTRIBUTE:
-            case COMPONENT:
-            case FOR:
-            case DISCONNECT:
-            case GROUP:
-              ;
-              break;
-            default:
-              jj_la1[48] = jj_gen;
-              break label_13;
-            }
-            declaration();
-          }
-          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-          case BEGIN:
-            jj_consume_token(BEGIN);
-            label_14:
-            while (true) {
-              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-              case PROCESS:
-              case BLOCK:
-              case ASSERT:
-              case WITH:
-              case IDENT:
-                ;
-                break;
-              default:
-                jj_la1[49] = jj_gen;
-                break label_14;
-              }
-              statement();
-            }
-            break;
-          case PROCESS:
-          case BLOCK:
-          case ASSERT:
-          case WITH:
-          case IDENT:
-            label_15:
-            while (true) {
-              statement();
-              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-              case PROCESS:
-              case BLOCK:
-              case ASSERT:
-              case WITH:
-              case IDENT:
-                ;
-                break;
-              default:
-                jj_la1[50] = jj_gen;
-                break label_15;
-              }
-            }
-            break;
-          default:
-            jj_la1[51] = jj_gen;
-            jj_consume_token(-1);
-            throw new ParseException();
-          }
-          jj_consume_token(END);
-          jj_consume_token(GENERATE);
-          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-          case IDENT:
-            identifier();
-            break;
-          default:
-            jj_la1[52] = jj_gen;
-            ;
-          }
-          jj_consume_token(EOS);
-          break;
-        case PROCESS:
-          jj_consume_token(PROCESS);
-          process();
-          break;
-        default:
-          jj_la1[53] = jj_gen;
-          jj_consume_token(-1);
-          throw new ParseException();
-        }
-                         endStatement();
-        break;
-      default:
-        jj_la1[55] = jj_gen;
-                         beginStatement();
-        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-        case LPAREN:
-          jj_consume_token(LPAREN);
-          skipParen();
-          jj_consume_token(RPAREN);
-          break;
-        default:
-          jj_la1[54] = jj_gen;
-          ;
-        }
-        skipTo(EOS);
-                         endStatement();
-      }
-      break;
-    case WITH:
-      jj_consume_token(WITH);
-                        beginStatement();
-      skipTo(EOS);
-                                                          endStatement();
-      break;
-    case PROCESS:
-      jj_consume_token(PROCESS);
-                           beginStatement();
-      process();
-                                                         endStatement();
-      break;
-    case BLOCK:
-      jj_consume_token(BLOCK);
-                         beginStatement();
-      skipTo2(END, BLOCK);
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case IDENT:
-        identifier();
-        break;
-      default:
-        jj_la1[56] = jj_gen;
-        ;
-      }
-      jj_consume_token(EOS);
-                                                                      endStatement();
-      break;
-    case ASSERT:
-      jj_consume_token(ASSERT);
-                          beginStatement();
-      skipTo(EOS);
-                                                            endStatement();
-      break;
-    default:
-      jj_la1[57] = jj_gen;
-      jj_consume_token(-1);
-      throw new ParseException();
-    }
-  }
-
-  final public void process() throws ParseException {
-    skipTo2(END, PROCESS);
-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case IDENT:
-      identifier();
-      break;
-    default:
-      jj_la1[58] = jj_gen;
-      ;
-    }
-    jj_consume_token(EOS);
-  }
-
-  void unexpectedEof(Token token) throws ParseException {
-        ParseException ex = new ParseException("unexpected EOF");
-        ex.currentToken = token;
-        throw ex;
-  }
-
-  Token skipTo(int skip) throws ParseException {
-        Token current = token;
-        Token token;
-        StringBuffer image = new StringBuffer();
-
-        for(;;)
-        {
-                token = getToken(1);
-                if ( token.kind == EOF )
-                        unexpectedEof(current);
-                if (token.kind == skip)
-                {
-                        getNextToken();
-                        break;
-                }
-
-                image.append(token.image);
-                getNextToken();
-        }
-        token.image = image.toString();
-        return token;
-  }
-
-  void skipTo2(int skip1, int skip2) throws ParseException {
-        Token current = token;
-        Token token;
-
-        for(;;)
-        {
-                token = getToken(1);
-                if (token.kind == EOF)
-                        unexpectedEof(current);
-                if (token.kind == skip1)
-                {
-                        getNextToken();
-                        token = getToken(1);
-                        if (token.kind == skip2)
-                        {
-                                getNextToken();
-                                break ;
-                        }
-                }
-                else
-                        getNextToken();
-        }
-  }
-
-  void skipParen() throws ParseException {
-        Token current = token;
-        Token token ;
-        int nesting = 1 ;
-        for(;;)
-        {
-                token = getToken(1);
-                if (token.kind == EOF)
-                        unexpectedEof(current);
-                if (token.kind == LPAREN)
-                        nesting++;
-                if (token.kind == RPAREN)
-                {
-                        nesting--;
-                        if (nesting == 0)
-                                break;
-                }
-                getNextToken();
-        }
-  }
-
-  void skipEnd() throws ParseException {
-        Token current = token;
-        Token token;
-        int nesting = 1;
-        for(;;)
-        {
-                token = getToken(1);
-                if (token.kind == EOF)
-                        unexpectedEof(current);
-                if (token.kind == BEGIN || token.kind == IF || token.kind == CASE || token.kind == LOOP)
-                        nesting++;
-                if (token.kind == END)
-                {
-                        nesting--;
-                        if (nesting == 0)
-                                break;
-                        else
-                                getNextToken(); // if or case
-                }
-                getNextToken();
-        }
-  }
-
-  Token interfaceElementIndication() throws ParseException {
-        Token current = token;
-        Token token ;
-        StringBuffer image = new StringBuffer();
-        int nesting = 1;
-
-        for(;;)
-        {
-                token = getToken(1);
-                if (token.kind == EOF)
-                        unexpectedEof(current);
-                if (token.kind == LPAREN)
-                        nesting++;
-                if (token.kind == RPAREN)
-                {
-                        nesting--;
-                        if (nesting == 0)
-                                break;
-                }
-                if (token.kind == EOS)
-                {
-                        break ;
-                }
-
-                image.append(token.image + " ");
-                getNextToken();
-        }
-        token.image = image.toString();
-        return token ;
-  }
-
-  public VhdlParserCoreTokenManager token_source;
-  JavaCharStream jj_input_stream;
-  public Token token, jj_nt;
-  private int jj_ntk;
-  private int jj_gen;
-  final private int[] jj_la1 = new int[59];
-  static private int[] jj_la1_0;
-  static private int[] jj_la1_1;
-  static private int[] jj_la1_2;
-  static {
-      jj_la1_0();
-      jj_la1_1();
-      jj_la1_2();
-   }
-   private static void jj_la1_0() {
-      jj_la1_0 = new int[] {0xf400,0xf400,0x180000,0x180000,0x0,0x4000,0x0,0x8000,0x0,0x800,0x10000,0x180000,0x180000,0x0,0xff000000,0xff000000,0x1000,0x800,0x0,0x0,0x29000000,0x29000000,0x0,0x0,0x20000,0xef00d000,0x0,0x29000000,0x29000000,0x0,0xff000000,0x200000,0x10000000,0x39000000,0x0,0xc0000000,0x40000,0x0,0x2000000,0x0,0x0,0x4000000,0x0,0x0,0xff000000,0xff000000,0x4000,0x0,0xff000000,0x200000,0x200000,0x600000,0x0,0x204000,0x0,0x0,0x0,0x200000,0x0,};
-   }
-   private static void jj_la1_1() {
-      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x61f,0x61f,0x0,0x0,0x0,0x40000000,0x0,0x0,0x0,0x40000000,0x0,0x3c409,0x600000,0x0,0x0,0x0,0x61f,0x101800,0x0,0x0,0x0,0x0,0x0,0x617,0x0,0x0,0x40000000,0x0,0x0,0x40000000,0x617,0x61f,0x0,0x30,0x61f,0x101800,0x101800,0x101800,0x0,0x38,0x1000000,0x0,0x0,0x101800,0x0,};
-   }
-   private static void jj_la1_2() {
-      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x0,0x80,0x0,0x0,0x0,0x0,0x80,0x0,0x0,0x0,0x0,0x80,0x0,0x0,0x0,0x8,0x0,0x10,0x0,0x80,0x0,0x0,0x8,0x0,0x80,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x80,0x0,0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x80,0x80,0x80,0x80,0x0,0x10,0x80,0x80,0x80,};
-   }
-
-  public VhdlParserCore(java.io.InputStream stream) {
-     this(stream, null);
-  }
-  public VhdlParserCore(java.io.InputStream stream, String encoding) {
-    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
-    token_source = new VhdlParserCoreTokenManager(jj_input_stream);
-    token = new Token();
-    jj_ntk = -1;
-    jj_gen = 0;
-    for (int i = 0; i < 59; i++) jj_la1[i] = -1;
-  }
-
-  public void ReInit(java.io.InputStream stream) {
-     ReInit(stream, null);
-  }
-  public void ReInit(java.io.InputStream stream, String encoding) {
-    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
-    token_source.ReInit(jj_input_stream);
-    token = new Token();
-    jj_ntk = -1;
-    jj_gen = 0;
-    for (int i = 0; i < 59; i++) jj_la1[i] = -1;
-  }
-
-  public VhdlParserCore(java.io.Reader stream) {
-    jj_input_stream = new JavaCharStream(stream, 1, 1);
-    token_source = new VhdlParserCoreTokenManager(jj_input_stream);
-    token = new Token();
-    jj_ntk = -1;
-    jj_gen = 0;
-    for (int i = 0; i < 59; i++) jj_la1[i] = -1;
-  }
-
-  public void ReInit(java.io.Reader stream) {
-    jj_input_stream.ReInit(stream, 1, 1);
-    token_source.ReInit(jj_input_stream);
-    token = new Token();
-    jj_ntk = -1;
-    jj_gen = 0;
-    for (int i = 0; i < 59; i++) jj_la1[i] = -1;
-  }
-
-  public VhdlParserCore(VhdlParserCoreTokenManager tm) {
-    token_source = tm;
-    token = new Token();
-    jj_ntk = -1;
-    jj_gen = 0;
-    for (int i = 0; i < 59; i++) jj_la1[i] = -1;
-  }
-
-  public void ReInit(VhdlParserCoreTokenManager tm) {
-    token_source = tm;
-    token = new Token();
-    jj_ntk = -1;
-    jj_gen = 0;
-    for (int i = 0; i < 59; i++) jj_la1[i] = -1;
-  }
-
-  final private Token jj_consume_token(int kind) throws ParseException {
-    Token oldToken;
-    if ((oldToken = token).next != null) token = token.next;
-    else token = token.next = token_source.getNextToken();
-    jj_ntk = -1;
-    if (token.kind == kind) {
-      jj_gen++;
-      return token;
-    }
-    token = oldToken;
-    jj_kind = kind;
-    throw generateParseException();
-  }
-
-  final public Token getNextToken() {
-    if (token.next != null) token = token.next;
-    else token = token.next = token_source.getNextToken();
-    jj_ntk = -1;
-    jj_gen++;
-    return token;
-  }
-
-  final public Token getToken(int index) {
-    Token t = token;
-    for (int i = 0; i < index; i++) {
-      if (t.next != null) t = t.next;
-      else t = t.next = token_source.getNextToken();
-    }
-    return t;
-  }
-
-  final private int jj_ntk() {
-    if ((jj_nt=token.next) == null)
-      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
-    else
-      return (jj_ntk = jj_nt.kind);
-  }
-
-  private java.util.Vector jj_expentries = new java.util.Vector();
-  private int[] jj_expentry;
-  private int jj_kind = -1;
-
-  public ParseException generateParseException() {
-    jj_expentries.removeAllElements();
-    boolean[] la1tokens = new boolean[74];
-    for (int i = 0; i < 74; i++) {
-      la1tokens[i] = false;
-    }
-    if (jj_kind >= 0) {
-      la1tokens[jj_kind] = true;
-      jj_kind = -1;
-    }
-    for (int i = 0; i < 59; i++) {
-      if (jj_la1[i] == jj_gen) {
-        for (int j = 0; j < 32; j++) {
-          if ((jj_la1_0[i] & (1<<j)) != 0) {
-            la1tokens[j] = true;
-          }
-          if ((jj_la1_1[i] & (1<<j)) != 0) {
-            la1tokens[32+j] = true;
-          }
-          if ((jj_la1_2[i] & (1<<j)) != 0) {
-            la1tokens[64+j] = true;
-          }
-        }
-      }
-    }
-    for (int i = 0; i < 74; i++) {
-      if (la1tokens[i]) {
-        jj_expentry = new int[1];
-        jj_expentry[0] = i;
-        jj_expentries.addElement(jj_expentry);
-      }
-    }
-    int[][] exptokseq = new int[jj_expentries.size()][];
-    for (int i = 0; i < jj_expentries.size(); i++) {
-      exptokseq[i] = (int[])jj_expentries.elementAt(i);
-    }
-    return new ParseException(token, exptokseq, tokenImage);
-  }
-
-  final public void enable_tracing() {
-  }
-
-  final public void disable_tracing() {
-  }
-
-}
+/* VhdlParserCore.java */
+/* Generated By:JJTree&JavaCC: Do not edit this line. VhdlParserCore.java */
+package com.elphel.vdt.veditor.parser.vhdl;
+
+@SuppressWarnings("all")
+
+public class VhdlParserCore/*@bgen(jjtree)*/implements VhdlParserCoreTreeConstants, VhdlParserCoreConstants {/*@bgen(jjtree)*/
+  protected JJTVhdlParserCoreState jjtree = new JJTVhdlParserCoreState();/**
+   * Called, whenever a new node in jjtree is generated.
+   * - store first token of the production.
+   * - check, if production is supported in subsets that are to be
+   *   checked.
+   */
+   void jjtreeOpenNodeScope(Node n)
+  {
+
+    ((SimpleNode) n).setFirstToken(getToken(1));
+    ((SimpleNode) n).setParser(this);
+  }
+
+  /**
+   * Called, whenever a node in jjtree is closed.
+   */
+   void jjtreeCloseNodeScope(Node n)
+  {
+    ((SimpleNode) n).setLastToken(getToken(0));
+  }
+
+  public ErrorHandler getErrorHandler(){
+        return errs;
+  }
+
+  public SymbolTable getSymbolTable(){
+        return m_SymbolTable;
+  }
+
+  public void setSymbolTable(SymbolTable symbolTable){
+    m_SymbolTable=symbolTable;
+  }
+
+  ErrorHandler errs = new ErrorHandler(this);
+  SymbolTable m_SymbolTable=null;
+
+  final public void abstract_literal() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case decimal_literal:{
+      jj_consume_token(decimal_literal);
+      break;
+      }
+    case based_literal:{
+      jj_consume_token(based_literal);
+      break;
+      }
+    default:
+      jj_la1[0] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void access_type_definition() throws ParseException {
+    jj_consume_token(ACCESS);
+    subtype_indication();
+  }
+
+  final public void actual_designator() throws ParseException {
+    if (jj_2_1(2147483647)) {
+      expression();
+    } else if (jj_2_2(2147483647)) {
+      signal_name();
+    } else if (jj_2_3(2147483647)) {
+      variable_name();
+    } else if (jj_2_4(2147483647)) {
+      file_name();
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case OPEN:{
+        jj_consume_token(OPEN);
+        break;
+        }
+      default:
+        jj_la1[1] = jj_gen;
+        if (jj_2_5(2147483647)) {
+          terminal_name();
+        } else {
+          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+          case basic_identifier:
+          case extended_identifier:
+          case string_literal:{
+            quantity_name();
+            break;
+            }
+          default:
+            jj_la1[2] = jj_gen;
+            jj_consume_token(-1);
+            throw new ParseException();
+          }
+        }
+      }
+    }
+  }
+
+  final public void actual_parameter_part() throws ParseException {
+    parameter_association_list();
+  }
+
+  final public void actual_part() throws ParseException {/*@bgen(jjtree) actual_part */
+  ASTactual_part jjtn000 = new ASTactual_part(JJTACTUAL_PART);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      if (jj_2_6(2147483647)) {
+        function_name();
+        jj_consume_token(158);
+        actual_designator();
+        jj_consume_token(159);
+      } else if (jj_2_7(2147483647)) {
+        type_mark();
+        jj_consume_token(158);
+        actual_designator();
+        jj_consume_token(159);
+      } else {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case ABS:
+        case NEW:
+        case NOT:
+        case NULL:
+        case OPEN:
+        case based_literal:
+        case basic_identifier:
+        case bit_string_literal:
+        case character_literal:
+        case decimal_literal:
+        case extended_identifier:
+        case string_literal:
+        case ADD:
+        case SUB:
+        case 158:{
+          actual_designator();
+          break;
+          }
+        default:
+          jj_la1[3] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        {if (true) throw (RuntimeException)jjte000;}
+      }
+      if (jjte000 instanceof ParseException) {
+        {if (true) throw (ParseException)jjte000;}
+      }
+      {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+  }
+
+  final public int adding_operator() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case ADD:{
+      jj_consume_token(ADD);
+{if ("" != null) return ADD;}
+      break;
+      }
+    case SUB:{
+      jj_consume_token(SUB);
+{if ("" != null) return SUB;}
+      break;
+      }
+    case CONCAT:{
+      jj_consume_token(CONCAT);
+{if ("" != null) return CONCAT;}
+      break;
+      }
+    default:
+      jj_la1[4] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    throw new Error("Missing return statement in function");
+  }
+
+  final public void aggregate() throws ParseException {/*@bgen(jjtree) aggregate */
+  ASTaggregate jjtn000 = new ASTaggregate(JJTAGGREGATE);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(158);
+      element_association();
+      label_1:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case 160:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[5] = jj_gen;
+          break label_1;
+        }
+        jj_consume_token(160);
+        element_association();
+      }
+      jj_consume_token(159);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void alias_declaration() throws ParseException {/*@bgen(jjtree) alias_declaration */
+  ASTalias_declaration jjtn000 = new ASTalias_declaration(JJTALIAS_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(ALIAS);
+      alias_designator();
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case COLON:{
+        jj_consume_token(COLON);
+        subtype_indication();
+        break;
+        }
+      default:
+        jj_la1[6] = jj_gen;
+        ;
+      }
+      jj_consume_token(IS);
+      name();
+      signature();
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void alias_designator() throws ParseException {/*@bgen(jjtree) alias_designator */
+  ASTalias_designator jjtn000 = new ASTalias_designator(JJTALIAS_DESIGNATOR);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:{
+        identifier();
+        break;
+        }
+      case character_literal:{
+        jj_consume_token(character_literal);
+        break;
+        }
+      case string_literal:{
+        operator_symbol();
+        break;
+        }
+      default:
+        jj_la1[7] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        {if (true) throw (RuntimeException)jjte000;}
+      }
+      if (jjte000 instanceof ParseException) {
+        {if (true) throw (ParseException)jjte000;}
+      }
+      {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+  }
+
+  final public void allocator() throws ParseException {/*@bgen(jjtree) allocator */
+  ASTallocator jjtn000 = new ASTallocator(JJTALLOCATOR);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(NEW);
+      if (jj_2_8(2147483647)) {
+        qualified_expression();
+      } else {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case basic_identifier:
+        case extended_identifier:
+        case string_literal:{
+          subtype_indication();
+          break;
+          }
+        default:
+          jj_la1[8] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void architecture_body() throws ParseException {/*@bgen(jjtree) architecture_body */
+  ASTarchitecture_body jjtn000 = new ASTarchitecture_body(JJTARCHITECTURE_BODY);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(ARCHITECTURE);
+      identifier();
+      jj_consume_token(OF);
+      entity_name();
+      jj_consume_token(IS);
+jjtn000.newBlock();
+      architecture_declarative_part();
+      jj_consume_token(BEGIN);
+      architecture_statement_part();
+      jj_consume_token(END);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case ARCHITECTURE:{
+        jj_consume_token(ARCHITECTURE);
+        break;
+        }
+      default:
+        jj_la1[9] = jj_gen;
+        ;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:{
+        architecture_simple_name();
+        break;
+        }
+      default:
+        jj_la1[10] = jj_gen;
+        ;
+      }
+      jj_consume_token(SEMICOLON);
+jjtree.closeNodeScope(jjtn000, true);
+    jjtc000 = false;
+    if (jjtree.nodeCreated()) {
+     jjtreeCloseNodeScope(jjtn000);
+    }
+jjtn000.endBlock();
+    jjtn000.Check();
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void architecture_declarative_part() throws ParseException {/*@bgen(jjtree) architecture_declarative_part */
+  ASTarchitecture_declarative_part jjtn000 = new ASTarchitecture_declarative_part(JJTARCHITECTURE_DECLARATIVE_PART);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      label_2:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case ALIAS:
+        case ATTRIBUTE:
+        case COMPONENT:
+        case CONSTANT:
+        case DISCONNECT:
+        case FILE:
+        case FOR:
+        case FUNCTION:
+        case GROUP:
+        case IMPURE:
+        case NATURE:
+        case PROCEDURE:
+        case PURE:
+        case QUANTITY:
+        case SIGNAL:
+        case SHARED:
+        case SUBNATURE:
+        case SUBTYPE:
+        case TERMINAL:
+        case TYPE:
+        case USE:
+        case VARIABLE:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[11] = jj_gen;
+          break label_2;
+        }
+        block_declarative_item();
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void architecture_statement_part() throws ParseException {/*@bgen(jjtree) architecture_statement_part */
+  ASTarchitecture_statement_part jjtn000 = new ASTarchitecture_statement_part(JJTARCHITECTURE_STATEMENT_PART);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      label_3:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case ABS:
+        case ASSERT:
+        case BREAK:
+        case CASE:
+        case IF:
+        case IMPURE:
+        case NEW:
+        case NOT:
+        case NULL:
+        case POSTPONED:
+        case PROCEDURAL:
+        case PROCESS:
+        case PURE:
+        case WITH:
+        case based_literal:
+        case basic_identifier:
+        case bit_string_literal:
+        case character_literal:
+        case decimal_literal:
+        case extended_identifier:
+        case string_literal:
+        case ADD:
+        case SUB:
+        case 158:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[12] = jj_gen;
+          break label_3;
+        }
+        architecture_statement();
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+/**
+ *  This rule also contains the concurrent statements.
+ */
+  final public void architecture_statement() throws ParseException {
+    try {
+      if (jj_2_9(2147483647)) {
+        block_statement();
+      } else if (jj_2_10(2147483647)) {
+        process_statement();
+      } else if (jj_2_11(2147483647)) {
+        concurrent_procedure_call_statement();
+      } else if (jj_2_12(2147483647)) {
+        concurrent_assertion_statement();
+      } else if (jj_2_13(2147483647)) {
+        concurrent_signal_assignment_statement();
+      } else if (jj_2_14(2147483647)) {
+        component_instantiation_statement();
+      } else if (jj_2_15(2147483647)) {
+        generate_statement();
+      } else if (jj_2_16(2147483647)) {
+        concurrent_break_statement();
+      } else {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case ABS:
+        case CASE:
+        case IF:
+        case IMPURE:
+        case NEW:
+        case NOT:
+        case NULL:
+        case PROCEDURAL:
+        case PURE:
+        case based_literal:
+        case basic_identifier:
+        case bit_string_literal:
+        case character_literal:
+        case decimal_literal:
+        case extended_identifier:
+        case string_literal:
+        case ADD:
+        case SUB:
+        case 158:{
+          simultaneous_statement();
+          break;
+          }
+        default:
+          jj_la1[13] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+      }
+    } catch (ParseException e) {
+error_skipto(SEMICOLON, "syntax error in statement");
+    }
+  }
+
+/**
+ * 1076.1 extension:
+ */
+  final public void array_nature_definition() throws ParseException {
+    if (jj_2_17(2147483647)) {
+      unconstrained_nature_definition();
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case ARRAY:{
+        constrained_nature_definition();
+        break;
+        }
+      default:
+        jj_la1[14] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+  }
+
+/**
+  * 1076.1 extension:
+  */
+  final public void unconstrained_nature_definition() throws ParseException {/*@bgen(jjtree) unconstrained_nature_definition */
+  ASTunconstrained_nature_definition jjtn000 = new ASTunconstrained_nature_definition(JJTUNCONSTRAINED_NATURE_DEFINITION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(ARRAY);
+      jj_consume_token(158);
+      index_subtype_definition();
+      label_4:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case 160:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[15] = jj_gen;
+          break label_4;
+        }
+        jj_consume_token(160);
+        index_subtype_definition();
+      }
+      jj_consume_token(159);
+      jj_consume_token(OF);
+      subnature_indication();
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+/**
+  * 1076.1 extension:
+  */
+  final public void constrained_nature_definition() throws ParseException {/*@bgen(jjtree) constrained_nature_definition */
+  ASTconstrained_nature_definition jjtn000 = new ASTconstrained_nature_definition(JJTCONSTRAINED_NATURE_DEFINITION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(ARRAY);
+      index_constraint();
+      jj_consume_token(OF);
+      subnature_indication();
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void array_type_definition() throws ParseException {
+    if (jj_2_18(2147483647)) {
+      unconstrained_array_definition();
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case ARRAY:{
+        constrained_array_definition();
+        break;
+        }
+      default:
+        jj_la1[16] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+  }
+
+  final public void assertion() throws ParseException {/*@bgen(jjtree) assertion */
+  ASTassertion jjtn000 = new ASTassertion(JJTASSERTION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(ASSERT);
+      condition();
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case REPORT:{
+        jj_consume_token(REPORT);
+        expression();
+        break;
+        }
+      default:
+        jj_la1[17] = jj_gen;
+        ;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case SEVERITY:{
+        jj_consume_token(SEVERITY);
+        expression();
+        break;
+        }
+      default:
+        jj_la1[18] = jj_gen;
+        ;
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void assertion_statement() throws ParseException {/*@bgen(jjtree) assertion_statement */
+  ASTassertion_statement jjtn000 = new ASTassertion_statement(JJTASSERTION_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:{
+        label();
+        jj_consume_token(COLON);
+        break;
+        }
+      default:
+        jj_la1[19] = jj_gen;
+        ;
+      }
+      assertion();
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void association_element() throws ParseException {/*@bgen(jjtree) association_element */
+  ASTassociation_element jjtn000 = new ASTassociation_element(JJTASSOCIATION_ELEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      if (jj_2_19(2147483647)) {
+        formal_part();
+        jj_consume_token(RARROW);
+      } else {
+        ;
+      }
+      actual_part();
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void association_list() throws ParseException {/*@bgen(jjtree) association_list */
+  ASTassociation_list jjtn000 = new ASTassociation_list(JJTASSOCIATION_LIST);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      association_element();
+      label_5:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case 160:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[20] = jj_gen;
+          break label_5;
+        }
+        jj_consume_token(160);
+        association_element();
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void attribute_declaration() throws ParseException {/*@bgen(jjtree) attribute_declaration */
+  ASTattribute_declaration jjtn000 = new ASTattribute_declaration(JJTATTRIBUTE_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(ATTRIBUTE);
+      identifier();
+      jj_consume_token(COLON);
+      type_mark();
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void attribute_designator() throws ParseException {
+    attribute_simple_name();
+  }
+
+  final public void attribute_name() throws ParseException {/*@bgen(jjtree) attribute_name */
+  ASTattribute_name jjtn000 = new ASTattribute_name(JJTATTRIBUTE_NAME);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      prefix();
+      signature();
+      jj_consume_token(161);
+      attribute_designator();
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case 158:{
+        jj_consume_token(158);
+        expression();
+        label_6:
+        while (true) {
+          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+          case 160:{
+            ;
+            break;
+            }
+          default:
+            jj_la1[21] = jj_gen;
+            break label_6;
+          }
+          jj_consume_token(160);
+          expression();
+        }
+        jj_consume_token(159);
+        break;
+        }
+      default:
+        jj_la1[22] = jj_gen;
+        ;
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void attribute_specification() throws ParseException {/*@bgen(jjtree) attribute_specification */
+  ASTattribute_specification jjtn000 = new ASTattribute_specification(JJTATTRIBUTE_SPECIFICATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(ATTRIBUTE);
+      attribute_designator();
+      jj_consume_token(OF);
+      entity_specification();
+      jj_consume_token(IS);
+      expression();
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void base_unit_declaration() throws ParseException {
+    identifier();
+    jj_consume_token(SEMICOLON);
+  }
+
+  final public void binding_indication() throws ParseException {/*@bgen(jjtree) binding_indication */
+  ASTbinding_indication jjtn000 = new ASTbinding_indication(JJTBINDING_INDICATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case USE:{
+        jj_consume_token(USE);
+        entity_aspect();
+        break;
+        }
+      default:
+        jj_la1[23] = jj_gen;
+        ;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case GENERIC:{
+        generic_map_aspect();
+        break;
+        }
+      default:
+        jj_la1[24] = jj_gen;
+        ;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case PORT:{
+        port_map_aspect();
+        break;
+        }
+      default:
+        jj_la1[25] = jj_gen;
+        ;
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void block_configuration() throws ParseException {/*@bgen(jjtree) block_configuration */
+  ASTblock_configuration jjtn000 = new ASTblock_configuration(JJTBLOCK_CONFIGURATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(FOR);
+      block_specification();
+      label_7:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case USE:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[26] = jj_gen;
+          break label_7;
+        }
+        use_clause();
+      }
+      label_8:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case FOR:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[27] = jj_gen;
+          break label_8;
+        }
+        configuration_item();
+      }
+      jj_consume_token(END);
+      jj_consume_token(FOR);
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void block_declarative_item() throws ParseException {
+    try {
+      if (jj_2_20(2147483647)) {
+        subprogram_declaration();
+      } else {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case FUNCTION:
+        case IMPURE:
+        case PROCEDURE:
+        case PURE:{
+          subprogram_body();
+          break;
+          }
+        case TYPE:{
+          type_declaration();
+          break;
+          }
+        case SUBTYPE:{
+          subtype_declaration();
+          break;
+          }
+        case CONSTANT:{
+          constant_declaration();
+          break;
+          }
+        case SIGNAL:{
+          signal_declaration();
+          break;
+          }
+        case SHARED:
+        case VARIABLE:{
+          shared_variable_declaration();
+          break;
+          }
+        case FILE:{
+          file_declaration();
+          break;
+          }
+        case ALIAS:{
+          alias_declaration();
+          break;
+          }
+        case COMPONENT:{
+          component_declaration();
+          break;
+          }
+        default:
+          jj_la1[28] = jj_gen;
+          if (jj_2_21(2147483647)) {
+            attribute_declaration();
+          } else {
+            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+            case ATTRIBUTE:{
+              attribute_specification();
+              break;
+              }
+            case FOR:{
+              configuration_specification();
+              break;
+              }
+            case DISCONNECT:{
+              disconnection_specification();
+              break;
+              }
+            case USE:{
+              use_clause();
+              break;
+              }
+            default:
+              jj_la1[29] = jj_gen;
+              if (jj_2_22(2147483647)) {
+                group_template_declaration();
+              } else {
+                switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+                case GROUP:{
+                  group_declaration();
+                  break;
+                  }
+                case NATURE:{
+                  nature_declaration();
+                  break;
+                  }
+                case SUBNATURE:{
+                  subnature_declaration();
+                  break;
+                  }
+                case QUANTITY:{
+                  quantity_declaration();
+                  break;
+                  }
+                case TERMINAL:{
+                  terminal_declaration();
+                  break;
+                  }
+                default:
+                  jj_la1[30] = jj_gen;
+                  jj_consume_token(-1);
+                  throw new ParseException();
+                }
+              }
+            }
+          }
+        }
+      }
+    } catch (ParseException e) {
+error_skipto(SEMICOLON, "syntax error in declarative item");
+    }
+  }
+
+  final public void block_declarative_part() throws ParseException {/*@bgen(jjtree) block_declarative_part */
+  ASTblock_declarative_part jjtn000 = new ASTblock_declarative_part(JJTBLOCK_DECLARATIVE_PART);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      label_9:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case ALIAS:
+        case ATTRIBUTE:
+        case COMPONENT:
+        case CONSTANT:
+        case DISCONNECT:
+        case FILE:
+        case FOR:
+        case FUNCTION:
+        case GROUP:
+        case IMPURE:
+        case NATURE:
+        case PROCEDURE:
+        case PURE:
+        case QUANTITY:
+        case SIGNAL:
+        case SHARED:
+        case SUBNATURE:
+        case SUBTYPE:
+        case TERMINAL:
+        case TYPE:
+        case USE:
+        case VARIABLE:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[31] = jj_gen;
+          break label_9;
+        }
+        block_declarative_item();
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void block_header() throws ParseException {/*@bgen(jjtree) block_header */
+  ASTblock_header jjtn000 = new ASTblock_header(JJTBLOCK_HEADER);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case GENERIC:{
+        generic_clause();
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case GENERIC:{
+          generic_map_aspect();
+          jj_consume_token(SEMICOLON);
+          break;
+          }
+        default:
+          jj_la1[32] = jj_gen;
+          ;
+        }
+        break;
+        }
+      default:
+        jj_la1[33] = jj_gen;
+        ;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case PORT:{
+        port_clause();
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case PORT:{
+          port_map_aspect();
+          jj_consume_token(SEMICOLON);
+          break;
+          }
+        default:
+          jj_la1[34] = jj_gen;
+          ;
+        }
+        break;
+        }
+      default:
+        jj_la1[35] = jj_gen;
+        ;
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void block_specification() throws ParseException {/*@bgen(jjtree) block_specification */
+  ASTblock_specification jjtn000 = new ASTblock_specification(JJTBLOCK_SPECIFICATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      if (jj_2_23(2147483647)) {
+        architecture_name();
+      } else if (jj_2_24(2147483647)) {
+        block_statement_label();
+      } else if (jj_2_25(2147483647)) {
+        generate_statement_label();
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case 158:{
+          jj_consume_token(158);
+          index_specification();
+          jj_consume_token(159);
+          break;
+          }
+        default:
+          jj_la1[36] = jj_gen;
+          ;
+        }
+      } else {
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        {if (true) throw (RuntimeException)jjte000;}
+      }
+      if (jjte000 instanceof ParseException) {
+        {if (true) throw (ParseException)jjte000;}
+      }
+      {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+  }
+
+  final public void block_statement() throws ParseException {/*@bgen(jjtree) block_statement */
+  ASTblock_statement jjtn000 = new ASTblock_statement(JJTBLOCK_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      block_label();
+      jj_consume_token(COLON);
+      jj_consume_token(BLOCK);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case 158:{
+        jj_consume_token(158);
+        guard_expression();
+        jj_consume_token(159);
+        break;
+        }
+      default:
+        jj_la1[37] = jj_gen;
+        ;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case IS:{
+        jj_consume_token(IS);
+        break;
+        }
+      default:
+        jj_la1[38] = jj_gen;
+        ;
+      }
+      block_header();
+      block_declarative_part();
+      jj_consume_token(BEGIN);
+      block_statement_part();
+      jj_consume_token(END);
+      jj_consume_token(BLOCK);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:{
+        block_label();
+        break;
+        }
+      default:
+        jj_la1[39] = jj_gen;
+        ;
+      }
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void block_statement_part() throws ParseException {/*@bgen(jjtree) block_statement_part */
+  ASTblock_statement_part jjtn000 = new ASTblock_statement_part(JJTBLOCK_STATEMENT_PART);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      label_10:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case ABS:
+        case ASSERT:
+        case BREAK:
+        case CASE:
+        case IF:
+        case IMPURE:
+        case NEW:
+        case NOT:
+        case NULL:
+        case POSTPONED:
+        case PROCEDURAL:
+        case PROCESS:
+        case PURE:
+        case WITH:
+        case based_literal:
+        case basic_identifier:
+        case bit_string_literal:
+        case character_literal:
+        case decimal_literal:
+        case extended_identifier:
+        case string_literal:
+        case ADD:
+        case SUB:
+        case 158:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[40] = jj_gen;
+          break label_10;
+        }
+        architecture_statement();
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+/**
+ * Section 8.14: Break statement
+ * 1076.1 extension:
+ */
+  final public void break_statement() throws ParseException {/*@bgen(jjtree) break_statement */
+  ASTbreak_statement jjtn000 = new ASTbreak_statement(JJTBREAK_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:{
+        label();
+        jj_consume_token(COLON);
+        break;
+        }
+      default:
+        jj_la1[41] = jj_gen;
+        ;
+      }
+      jj_consume_token(BREAK);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case FOR:
+      case basic_identifier:
+      case extended_identifier:
+      case string_literal:{
+        break_list();
+        break;
+        }
+      default:
+        jj_la1[42] = jj_gen;
+        ;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case WHEN:{
+        jj_consume_token(WHEN);
+        condition();
+        break;
+        }
+      default:
+        jj_la1[43] = jj_gen;
+        ;
+      }
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+/**
+ * 1076.1 extension:
+ */
+  final public void break_list() throws ParseException {/*@bgen(jjtree) break_list */
+  ASTbreak_list jjtn000 = new ASTbreak_list(JJTBREAK_LIST);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      break_element();
+      label_11:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case 160:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[44] = jj_gen;
+          break label_11;
+        }
+        jj_consume_token(160);
+        break_element();
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+/**
+ * 1076.1 extension:
+ */
+  final public void break_element() throws ParseException {/*@bgen(jjtree) break_element */
+  ASTbreak_element jjtn000 = new ASTbreak_element(JJTBREAK_ELEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case FOR:{
+        selector_clause();
+        break;
+        }
+      default:
+        jj_la1[45] = jj_gen;
+        ;
+      }
+      quantity_name();
+      jj_consume_token(RARROW);
+      expression();
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+/**
+ * 1076.1 extension:
+ */
+  final public void selector_clause() throws ParseException {
+    jj_consume_token(FOR);
+    quantity_name();
+    jj_consume_token(USE);
+  }
+
+  final public void case_statement() throws ParseException {/*@bgen(jjtree) case_statement */
+  ASTcase_statement jjtn000 = new ASTcase_statement(JJTCASE_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:{
+        case_label();
+        jj_consume_token(COLON);
+        break;
+        }
+      default:
+        jj_la1[46] = jj_gen;
+        ;
+      }
+      jj_consume_token(CASE);
+      expression();
+      jj_consume_token(IS);
+      case_statement_alternative();
+      label_12:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case WHEN:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[47] = jj_gen;
+          break label_12;
+        }
+        case_statement_alternative();
+      }
+      jj_consume_token(END);
+      jj_consume_token(CASE);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:{
+        case_label();
+        break;
+        }
+      default:
+        jj_la1[48] = jj_gen;
+        ;
+      }
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void case_statement_alternative() throws ParseException {/*@bgen(jjtree) case_statement_alternative */
+  ASTcase_statement_alternative jjtn000 = new ASTcase_statement_alternative(JJTCASE_STATEMENT_ALTERNATIVE);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(WHEN);
+      choices();
+      jj_consume_token(RARROW);
+      sequence_of_statements();
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void choice() throws ParseException {/*@bgen(jjtree) choice */
+  ASTchoice jjtn000 = new ASTchoice(JJTCHOICE);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      if (jj_2_26(2147483647)) {
+        discrete_range();
+      } else if (jj_2_27(2147483647)) {
+        simple_expression();
+      } else {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case basic_identifier:
+        case extended_identifier:{
+          element_simple_name();
+          break;
+          }
+        case OTHERS:{
+          jj_consume_token(OTHERS);
+          break;
+          }
+        default:
+          jj_la1[49] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        {if (true) throw (RuntimeException)jjte000;}
+      }
+      if (jjte000 instanceof ParseException) {
+        {if (true) throw (ParseException)jjte000;}
+      }
+      {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+  }
+
+  final public void choices() throws ParseException {/*@bgen(jjtree) choices */
+  ASTchoices jjtn000 = new ASTchoices(JJTCHOICES);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      choice();
+      label_13:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case 162:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[50] = jj_gen;
+          break label_13;
+        }
+        jj_consume_token(162);
+        choice();
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void component_configuration() throws ParseException {/*@bgen(jjtree) component_configuration */
+  ASTcomponent_configuration jjtn000 = new ASTcomponent_configuration(JJTCOMPONENT_CONFIGURATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(FOR);
+      component_specification();
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case GENERIC:
+      case PORT:
+      case USE:
+      case SEMICOLON:{
+        binding_indication();
+        jj_consume_token(SEMICOLON);
+        break;
+        }
+      default:
+        jj_la1[51] = jj_gen;
+        ;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case FOR:{
+        block_configuration();
+        break;
+        }
+      default:
+        jj_la1[52] = jj_gen;
+        ;
+      }
+      jj_consume_token(END);
+      jj_consume_token(FOR);
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void component_declaration() throws ParseException {/*@bgen(jjtree) component_declaration */
+  ASTcomponent_declaration jjtn000 = new ASTcomponent_declaration(JJTCOMPONENT_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(COMPONENT);
+      identifier();
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case IS:{
+        jj_consume_token(IS);
+        break;
+        }
+      default:
+        jj_la1[53] = jj_gen;
+        ;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case GENERIC:{
+        local_generic_clause();
+        break;
+        }
+      default:
+        jj_la1[54] = jj_gen;
+        ;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case PORT:{
+        local_port_clause();
+        break;
+        }
+      default:
+        jj_la1[55] = jj_gen;
+        ;
+      }
+      jj_consume_token(END);
+      jj_consume_token(COMPONENT);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:{
+        component_simple_name();
+        break;
+        }
+      default:
+        jj_la1[56] = jj_gen;
+        ;
+      }
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void component_instantiation_statement() throws ParseException {/*@bgen(jjtree) component_instantiation_statement */
+  ASTcomponent_instantiation_statement jjtn000 = new ASTcomponent_instantiation_statement(JJTCOMPONENT_INSTANTIATION_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      instantiation_label();
+      jj_consume_token(COLON);
+      instantiated_unit();
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case GENERIC:{
+        generic_map_aspect();
+        break;
+        }
+      default:
+        jj_la1[57] = jj_gen;
+        ;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case PORT:{
+        port_map_aspect();
+        break;
+        }
+      default:
+        jj_la1[58] = jj_gen;
+        ;
+      }
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+// 1076.1 - extension:
+  final public void composite_nature_definition() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case ARRAY:{
+      array_nature_definition();
+      break;
+      }
+    case RECORD:{
+      record_nature_definition();
+      break;
+      }
+    default:
+      jj_la1[59] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void component_specification() throws ParseException {/*@bgen(jjtree) component_specification */
+  ASTcomponent_specification jjtn000 = new ASTcomponent_specification(JJTCOMPONENT_SPECIFICATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      instantiation_list();
+      jj_consume_token(COLON);
+      component_name();
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void composite_type_definition() throws ParseException {/*@bgen(jjtree) composite_type_definition */
+  ASTcomposite_type_definition jjtn000 = new ASTcomposite_type_definition(JJTCOMPOSITE_TYPE_DEFINITION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case ARRAY:{
+        array_type_definition();
+        break;
+        }
+      case RECORD:{
+        record_type_definition();
+        break;
+        }
+      default:
+        jj_la1[60] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        {if (true) throw (RuntimeException)jjte000;}
+      }
+      if (jjte000 instanceof ParseException) {
+        {if (true) throw (ParseException)jjte000;}
+      }
+      {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+  }
+
+  final public void concurrent_assertion_statement() throws ParseException {/*@bgen(jjtree) concurrent_assertion_statement */
+  ASTconcurrent_assertion_statement jjtn000 = new ASTconcurrent_assertion_statement(JJTCONCURRENT_ASSERTION_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:{
+        label();
+        jj_consume_token(COLON);
+        break;
+        }
+      default:
+        jj_la1[61] = jj_gen;
+        ;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case POSTPONED:{
+        jj_consume_token(POSTPONED);
+        break;
+        }
+      default:
+        jj_la1[62] = jj_gen;
+        ;
+      }
+      assertion();
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void concurrent_procedure_call_statement() throws ParseException {/*@bgen(jjtree) concurrent_procedure_call_statement */
+  ASTconcurrent_procedure_call_statement jjtn000 = new ASTconcurrent_procedure_call_statement(JJTCONCURRENT_PROCEDURE_CALL_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      if (jj_2_28(2147483647)) {
+        label();
+        jj_consume_token(COLON);
+      } else {
+        ;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case POSTPONED:{
+        jj_consume_token(POSTPONED);
+        break;
+        }
+      default:
+        jj_la1[63] = jj_gen;
+        ;
+      }
+      procedure_call();
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void concurrent_signal_assignment_statement() throws ParseException {/*@bgen(jjtree) concurrent_signal_assignment_statement */
+  ASTconcurrent_signal_assignment_statement jjtn000 = new ASTconcurrent_signal_assignment_statement(JJTCONCURRENT_SIGNAL_ASSIGNMENT_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      if (jj_2_29(2147483647)) {
+        label();
+        jj_consume_token(COLON);
+      } else {
+        ;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case POSTPONED:{
+        jj_consume_token(POSTPONED);
+        break;
+        }
+      default:
+        jj_la1[64] = jj_gen;
+        ;
+      }
+      if (jj_2_30(2147483647)) {
+        conditional_signal_assignment();
+      } else {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case WITH:{
+          selected_signal_assignment();
+          break;
+          }
+        default:
+          jj_la1[65] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        {if (true) throw (RuntimeException)jjte000;}
+      }
+      if (jjte000 instanceof ParseException) {
+        {if (true) throw (ParseException)jjte000;}
+      }
+      {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+  }
+
+  final public void condition() throws ParseException {
+    boolean_expression();
+  }
+
+  final public void condition_clause() throws ParseException {
+    jj_consume_token(UNTIL);
+    condition();
+  }
+
+  final public void conditional_signal_assignment() throws ParseException {/*@bgen(jjtree) conditional_signal_assignment */
+  ASTconditional_signal_assignment jjtn000 = new ASTconditional_signal_assignment(JJTCONDITIONAL_SIGNAL_ASSIGNMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      target();
+      jj_consume_token(LE);
+      options_();
+      conditional_waveforms();
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void conditional_waveforms() throws ParseException {/*@bgen(jjtree) conditional_waveforms */
+  ASTconditional_waveforms jjtn000 = new ASTconditional_waveforms(JJTCONDITIONAL_WAVEFORMS);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      waveform();
+      label_14:
+      while (true) {
+        if (jj_2_31(2147483647)) {
+          ;
+        } else {
+          break label_14;
+        }
+        jj_consume_token(WHEN);
+        condition();
+        jj_consume_token(ELSE);
+        waveform();
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case WHEN:{
+        jj_consume_token(WHEN);
+        condition();
+        break;
+        }
+      default:
+        jj_la1[66] = jj_gen;
+        ;
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void configuration_declaration() throws ParseException {/*@bgen(jjtree) configuration_declaration */
+  ASTconfiguration_declaration jjtn000 = new ASTconfiguration_declaration(JJTCONFIGURATION_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(CONFIGURATION);
+      identifier();
+      jj_consume_token(OF);
+      entity_name();
+      jj_consume_token(IS);
+      configuration_declarative_part();
+      block_configuration();
+      jj_consume_token(END);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case CONFIGURATION:{
+        jj_consume_token(CONFIGURATION);
+        break;
+        }
+      default:
+        jj_la1[67] = jj_gen;
+        ;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:{
+        configuration_simple_name();
+        break;
+        }
+      default:
+        jj_la1[68] = jj_gen;
+        ;
+      }
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void configuration_declarative_item() throws ParseException {
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case USE:{
+        use_clause();
+        break;
+        }
+      case ATTRIBUTE:{
+        attribute_specification();
+        break;
+        }
+      case GROUP:{
+        group_declaration();
+        break;
+        }
+      default:
+        jj_la1[69] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    } catch (ParseException e) {
+error_skipto(SEMICOLON, "syntax error in declarative item");
+    }
+  }
+
+  final public void configuration_declarative_part() throws ParseException {/*@bgen(jjtree) configuration_declarative_part */
+  ASTconfiguration_declarative_part jjtn000 = new ASTconfiguration_declarative_part(JJTCONFIGURATION_DECLARATIVE_PART);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      label_15:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case ATTRIBUTE:
+        case GROUP:
+        case USE:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[70] = jj_gen;
+          break label_15;
+        }
+        configuration_declarative_item();
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void configuration_item() throws ParseException {
+    if (jj_2_32(2147483647)) {
+      block_configuration();
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case FOR:{
+        component_configuration();
+        break;
+        }
+      default:
+        jj_la1[71] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+  }
+
+  final public void configuration_specification() throws ParseException {/*@bgen(jjtree) configuration_specification */
+  ASTconfiguration_specification jjtn000 = new ASTconfiguration_specification(JJTCONFIGURATION_SPECIFICATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(FOR);
+      component_specification();
+      binding_indication();
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void constant_declaration() throws ParseException {/*@bgen(jjtree) constant_declaration */
+  ASTconstant_declaration jjtn000 = new ASTconstant_declaration(JJTCONSTANT_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(CONSTANT);
+      identifier_list();
+      jj_consume_token(COLON);
+      subtype_indication();
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case ASSIGN:{
+        jj_consume_token(ASSIGN);
+        expression();
+        break;
+        }
+      default:
+        jj_la1[72] = jj_gen;
+        ;
+      }
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void constrained_array_definition() throws ParseException {/*@bgen(jjtree) constrained_array_definition */
+  ASTconstrained_array_definition jjtn000 = new ASTconstrained_array_definition(JJTCONSTRAINED_ARRAY_DEFINITION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(ARRAY);
+      index_constraint();
+      jj_consume_token(OF);
+      element_subtype_indication();
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void constraint() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case RANGE:{
+      range_constraint();
+      break;
+      }
+    case 158:{
+      index_constraint();
+      break;
+      }
+    default:
+      jj_la1[73] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void context_clause() throws ParseException {/*@bgen(jjtree) context_clause */
+  ASTcontext_clause jjtn000 = new ASTcontext_clause(JJTCONTEXT_CLAUSE);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      label_16:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case LIBRARY:
+        case USE:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[74] = jj_gen;
+          break label_16;
+        }
+        context_item();
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void context_item() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case LIBRARY:{
+      library_clause();
+      break;
+      }
+    case USE:{
+      use_clause();
+      break;
+      }
+    default:
+      jj_la1[75] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+/** 
+ * Section 4:
+ * Declarations
+ */
+
+
+/**
+ * 1076.1 extension:
+ */
+  final public void terminal_declaration() throws ParseException {/*@bgen(jjtree) terminal_declaration */
+  ASTterminal_declaration jjtn000 = new ASTterminal_declaration(JJTTERMINAL_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(TERMINAL);
+      identifier_list();
+      jj_consume_token(COLON);
+      subnature_indication();
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void terminal_aspect() throws ParseException {/*@bgen(jjtree) terminal_aspect */
+  ASTterminal_aspect jjtn000 = new ASTterminal_aspect(JJTTERMINAL_ASPECT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      plus_terminal_name();
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case TO:{
+        jj_consume_token(TO);
+        minus_terminal_name();
+        break;
+        }
+      default:
+        jj_la1[76] = jj_gen;
+        ;
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void delay_mechanism() throws ParseException {/*@bgen(jjtree) delay_mechanism */
+  ASTdelay_mechanism jjtn000 = new ASTdelay_mechanism(JJTDELAY_MECHANISM);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case TRANSPORT:{
+        jj_consume_token(TRANSPORT);
+        break;
+        }
+      case INERTIAL:
+      case REJECT:{
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case REJECT:{
+          jj_consume_token(REJECT);
+          time_expression();
+          break;
+          }
+        default:
+          jj_la1[77] = jj_gen;
+          ;
+        }
+        jj_consume_token(INERTIAL);
+        break;
+        }
+      default:
+        jj_la1[78] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        {if (true) throw (RuntimeException)jjte000;}
+      }
+      if (jjte000 instanceof ParseException) {
+        {if (true) throw (ParseException)jjte000;}
+      }
+      {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+  }
+
+  final public ASTdesign_file design_file() throws ParseException {/*@bgen(jjtree) design_file */
+  ASTdesign_file jjtn000 = new ASTdesign_file(JJTDESIGN_FILE);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      label_17:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case ARCHITECTURE:
+        case CONFIGURATION:
+        case ENTITY:
+        case LIBRARY:
+        case PACKAGE:
+        case USE:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[79] = jj_gen;
+          break label_17;
+        }
+        design_unit();
+      }
+jjtree.closeNodeScope(jjtn000, true);
+    jjtc000 = false;
+    if (jjtree.nodeCreated()) {
+     jjtreeCloseNodeScope(jjtn000);
+    }
+{if ("" != null) return jjtn000;}
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+    throw new Error("Missing return statement in function");
+  }
+
+  final public void design_unit() throws ParseException {/*@bgen(jjtree) design_unit */
+  ASTdesign_unit jjtn000 = new ASTdesign_unit(JJTDESIGN_UNIT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      context_clause();
+      library_unit();
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void designator() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case basic_identifier:
+    case extended_identifier:{
+      identifier();
+      break;
+      }
+    case string_literal:{
+      operator_symbol();
+      break;
+      }
+    default:
+      jj_la1[80] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void direction() throws ParseException {/*@bgen(jjtree) direction */
+  ASTdirection jjtn000 = new ASTdirection(JJTDIRECTION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case TO:{
+        jj_consume_token(TO);
+        break;
+        }
+      case DOWNTO:{
+        jj_consume_token(DOWNTO);
+        break;
+        }
+      default:
+        jj_la1[81] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void disconnection_specification() throws ParseException {/*@bgen(jjtree) disconnection_specification */
+  ASTdisconnection_specification jjtn000 = new ASTdisconnection_specification(JJTDISCONNECTION_SPECIFICATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(DISCONNECT);
+      guarded_signal_specification();
+      jj_consume_token(AFTER);
+      time_expression();
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void discrete_range() throws ParseException {
+    if (jj_2_33(2147483647)) {
+      range();
+    } else if (jj_2_34(2147483647)) {
+      discrete_subtype_indication();
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case ABS:
+      case NEW:
+      case NOT:
+      case NULL:
+      case based_literal:
+      case basic_identifier:
+      case bit_string_literal:
+      case character_literal:
+      case decimal_literal:
+      case extended_identifier:
+      case string_literal:
+      case ADD:
+      case SUB:
+      case 158:{
+        range();
+        break;
+        }
+      default:
+        jj_la1[82] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+  }
+
+  final public void element_association() throws ParseException {
+    if (jj_2_35(2147483647)) {
+      choices();
+      jj_consume_token(RARROW);
+    } else {
+      ;
+    }
+    expression();
+  }
+
+  final public void element_declaration() throws ParseException {/*@bgen(jjtree) element_declaration */
+  ASTelement_declaration jjtn000 = new ASTelement_declaration(JJTELEMENT_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      identifier_list();
+      jj_consume_token(COLON);
+      element_subtype_definition();
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void element_subtype_definition() throws ParseException {
+    subtype_indication();
+  }
+
+  final public void entity_aspect() throws ParseException {/*@bgen(jjtree) entity_aspect */
+  ASTentity_aspect jjtn000 = new ASTentity_aspect(JJTENTITY_ASPECT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case ENTITY:{
+        jj_consume_token(ENTITY);
+        entity_name();
+        if (jj_2_36(2147483647)) {
+          jj_consume_token(158);
+          architecture_identifier();
+          jj_consume_token(159);
+        } else {
+          ;
+        }
+        break;
+        }
+      case CONFIGURATION:{
+        jj_consume_token(CONFIGURATION);
+        configuration_name();
+        break;
+        }
+      case OPEN:{
+        jj_consume_token(OPEN);
+        break;
+        }
+      default:
+        jj_la1[83] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        {if (true) throw (RuntimeException)jjte000;}
+      }
+      if (jjte000 instanceof ParseException) {
+        {if (true) throw (ParseException)jjte000;}
+      }
+      {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+  }
+
+/**
+ * Section 5: Specifications
+ */
+  final public int entity_class() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case ENTITY:{
+      jj_consume_token(ENTITY);
+{if ("" != null) return ENTITY;}
+      break;
+      }
+    case ARCHITECTURE:{
+      jj_consume_token(ARCHITECTURE);
+{if ("" != null) return ARCHITECTURE;}
+      break;
+      }
+    case CONFIGURATION:{
+      jj_consume_token(CONFIGURATION);
+{if ("" != null) return CONFIGURATION;}
+      break;
+      }
+    case PROCEDURE:{
+      jj_consume_token(PROCEDURE);
+{if ("" != null) return PROCEDURE;}
+      break;
+      }
+    case FUNCTION:{
+      jj_consume_token(FUNCTION);
+{if ("" != null) return FUNCTION;}
+      break;
+      }
+    case PACKAGE:{
+      jj_consume_token(PACKAGE);
+{if ("" != null) return PACKAGE;}
+      break;
+      }
+    case TYPE:{
+      jj_consume_token(TYPE);
+{if ("" != null) return TYPE;}
+      break;
+      }
+    case SUBTYPE:{
+      jj_consume_token(SUBTYPE);
+{if ("" != null) return SUBTYPE;}
+      break;
+      }
+    case CONSTANT:{
+      jj_consume_token(CONSTANT);
+{if ("" != null) return CONSTANT;}
+      break;
+      }
+    case SIGNAL:{
+      jj_consume_token(SIGNAL);
+{if ("" != null) return SIGNAL;}
+      break;
+      }
+    case VARIABLE:{
+      jj_consume_token(VARIABLE);
+{if ("" != null) return VARIABLE;}
+      break;
+      }
+    case COMPONENT:{
+      jj_consume_token(COMPONENT);
+{if ("" != null) return COMPONENT;}
+      break;
+      }
+    case LABEL:{
+      jj_consume_token(LABEL);
+{if ("" != null) return LABEL;}
+      break;
+      }
+    case LITERAL:{
+      jj_consume_token(LITERAL);
+{if ("" != null) return LITERAL;}
+      break;
+      }
+    case UNITS:{
+      jj_consume_token(UNITS);
+{if ("" != null) return UNITS;}
+      break;
+      }
+    case GROUP:{
+      jj_consume_token(GROUP);
+{if ("" != null) return GROUP;}
+      break;
+      }
+    case FILE:{
+      jj_consume_token(FILE);
+{if ("" != null) return FILE;}
+      break;
+      }
+    case SUBNATURE:{
+      jj_consume_token(SUBNATURE);
+{if ("" != null) return SUBNATURE;}
+      break;
+      }
+    case NATURE:{
+      jj_consume_token(NATURE);
+{if ("" != null) return NATURE;}
+      break;
+      }
+    case TERMINAL:{
+      jj_consume_token(TERMINAL);
+{if ("" != null) return TERMINAL;}
+      break;
+      }
+    default:
+      jj_la1[84] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    throw new Error("Missing return statement in function");
+  }
+
+  final public void entity_class_entry() throws ParseException {/*@bgen(jjtree) entity_class_entry */
+  ASTentity_class_entry jjtn000 = new ASTentity_class_entry(JJTENTITY_CLASS_ENTRY);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      entity_class();
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case 163:{
+        jj_consume_token(163);
+        break;
+        }
+      default:
+        jj_la1[85] = jj_gen;
+        ;
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void entity_class_entry_list() throws ParseException {/*@bgen(jjtree) entity_class_entry_list */
+  ASTentity_class_entry_list jjtn000 = new ASTentity_class_entry_list(JJTENTITY_CLASS_ENTRY_LIST);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      entity_class_entry();
+      label_18:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case 160:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[86] = jj_gen;
+          break label_18;
+        }
+        jj_consume_token(160);
+        entity_class_entry();
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void entity_declaration() throws ParseException {/*@bgen(jjtree) entity_declaration */
+  ASTentity_declaration jjtn000 = new ASTentity_declaration(JJTENTITY_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(ENTITY);
+      identifier();
+      jj_consume_token(IS);
+jjtn000.newBlock();
+      entity_header();
+      entity_declarative_part();
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case BEGIN:{
+        jj_consume_token(BEGIN);
+        entity_statement_part();
+        break;
+        }
+      default:
+        jj_la1[87] = jj_gen;
+        ;
+      }
+      jj_consume_token(END);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case ENTITY:{
+        jj_consume_token(ENTITY);
+        break;
+        }
+      default:
+        jj_la1[88] = jj_gen;
+        ;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:{
+        entity_simple_name();
+        break;
+        }
+      default:
+        jj_la1[89] = jj_gen;
+        ;
+      }
+      jj_consume_token(SEMICOLON);
+jjtree.closeNodeScope(jjtn000, true);
+    jjtc000 = false;
+    if (jjtree.nodeCreated()) {
+     jjtreeCloseNodeScope(jjtn000);
+    }
+jjtn000.Check();
+    jjtn000.endBlock();
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void entity_declarative_item() throws ParseException {
+    try {
+      if (jj_2_37(2147483647)) {
+        subprogram_declaration();
+      } else {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case FUNCTION:
+        case IMPURE:
+        case PROCEDURE:
+        case PURE:{
+          subprogram_body();
+          break;
+          }
+        case TYPE:{
+          type_declaration();
+          break;
+          }
+        case SUBTYPE:{
+          subtype_declaration();
+          break;
+          }
+        case CONSTANT:{
+          constant_declaration();
+          break;
+          }
+        case SIGNAL:{
+          signal_declaration();
+          break;
+          }
+        case SHARED:
+        case VARIABLE:{
+          shared_variable_declaration();
+          break;
+          }
+        case FILE:{
+          file_declaration();
+          break;
+          }
+        case ALIAS:{
+          alias_declaration();
+          break;
+          }
+        default:
+          jj_la1[90] = jj_gen;
+          if (jj_2_38(2147483647)) {
+            attribute_declaration();
+          } else {
+            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+            case ATTRIBUTE:{
+              attribute_specification();
+              break;
+              }
+            case DISCONNECT:{
+              disconnection_specification();
+              break;
+              }
+            case USE:{
+              use_clause();
+              break;
+              }
+            default:
+              jj_la1[91] = jj_gen;
+              if (jj_2_39(2147483647)) {
+                group_template_declaration();
+              } else {
+                switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+                case GROUP:{
+                  group_declaration();
+                  break;
+                  }
+                case NATURE:{
+                  nature_declaration();
+                  break;
+                  }
+                case SUBNATURE:{
+                  subnature_declaration();
+                  break;
+                  }
+                case TERMINAL:{
+                  terminal_declaration();
+                  break;
+                  }
+                default:
+                  jj_la1[92] = jj_gen;
+                  jj_consume_token(-1);
+                  throw new ParseException();
+                }
+              }
+            }
+          }
+        }
+      }
+    } catch (ParseException e) {
+error_skipto(SEMICOLON, "syntax error in declarative item");
+    }
+  }
+
+/**
+ * 4.8: Nature Declaration
+ * 1076.1 extension
+ */
+  final public void nature_declaration() throws ParseException {/*@bgen(jjtree) nature_declaration */
+  ASTnature_declaration jjtn000 = new ASTnature_declaration(JJTNATURE_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(NATURE);
+      identifier();
+      jj_consume_token(IS);
+      nature_definition();
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+/**
+ * 1076.1 extension
+ */
+  final public void nature_definition() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case basic_identifier:
+    case extended_identifier:
+    case string_literal:{
+      scalar_nature_definition();
+      break;
+      }
+    case ARRAY:
+    case RECORD:{
+      composite_nature_definition();
+      break;
+      }
+    default:
+      jj_la1[93] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void subnature_declaration() throws ParseException {/*@bgen(jjtree) subnature_declaration */
+  ASTsubnature_declaration jjtn000 = new ASTsubnature_declaration(JJTSUBNATURE_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(SUBNATURE);
+      identifier();
+      jj_consume_token(IS);
+      subnature_indication();
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void subnature_indication() throws ParseException {/*@bgen(jjtree) subnature_indication */
+  ASTsubnature_indication jjtn000 = new ASTsubnature_indication(JJTSUBNATURE_INDICATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      nature_mark();
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case 158:{
+        index_constraint();
+        break;
+        }
+      default:
+        jj_la1[94] = jj_gen;
+        ;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case TOLERANCE:{
+        jj_consume_token(TOLERANCE);
+        string_expression();
+        jj_consume_token(ACROSS);
+        string_expression();
+        jj_consume_token(THROUGH);
+        break;
+        }
+      default:
+        jj_la1[95] = jj_gen;
+        ;
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void nature_mark() throws ParseException {
+    if (jj_2_40(2147483647)) {
+      nature_name();
+    } else if (jj_2_41(2147483647)) {
+      subnature_name();
+    } else {
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void entity_declarative_part() throws ParseException {/*@bgen(jjtree) entity_declarative_part */
+  ASTentity_declarative_part jjtn000 = new ASTentity_declarative_part(JJTENTITY_DECLARATIVE_PART);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      label_19:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case ALIAS:
+        case ATTRIBUTE:
+        case CONSTANT:
+        case DISCONNECT:
+        case FILE:
+        case FUNCTION:
+        case GROUP:
+        case IMPURE:
+        case NATURE:
+        case PROCEDURE:
+        case PURE:
+        case SIGNAL:
+        case SHARED:
+        case SUBNATURE:
+        case SUBTYPE:
+        case TERMINAL:
+        case TYPE:
+        case USE:
+        case VARIABLE:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[96] = jj_gen;
+          break label_19;
+        }
+        entity_declarative_item();
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void entity_designator() throws ParseException {/*@bgen(jjtree) entity_designator */
+  ASTentity_designator jjtn000 = new ASTentity_designator(JJTENTITY_DESIGNATOR);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      entity_tag();
+      signature();
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void entity_header() throws ParseException {/*@bgen(jjtree) entity_header */
+  ASTentity_header jjtn000 = new ASTentity_header(JJTENTITY_HEADER);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case GENERIC:{
+        formal_generic_clause();
+        break;
+        }
+      default:
+        jj_la1[97] = jj_gen;
+        ;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case PORT:{
+        formal_port_clause();
+        break;
+        }
+      default:
+        jj_la1[98] = jj_gen;
+        ;
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void entity_name_list() throws ParseException {/*@bgen(jjtree) entity_name_list */
+  ASTentity_name_list jjtn000 = new ASTentity_name_list(JJTENTITY_NAME_LIST);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case character_literal:
+      case extended_identifier:
+      case string_literal:{
+        entity_designator();
+        label_20:
+        while (true) {
+          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+          case 160:{
+            ;
+            break;
+            }
+          default:
+            jj_la1[99] = jj_gen;
+            break label_20;
+          }
+          jj_consume_token(160);
+          entity_designator();
+        }
+        break;
+        }
+      case OTHERS:{
+        jj_consume_token(OTHERS);
+        break;
+        }
+      case ALL:{
+        jj_consume_token(ALL);
+        break;
+        }
+      default:
+        jj_la1[100] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void entity_specification() throws ParseException {/*@bgen(jjtree) entity_specification */
+  ASTentity_specification jjtn000 = new ASTentity_specification(JJTENTITY_SPECIFICATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      entity_name_list();
+      jj_consume_token(COLON);
+      entity_class();
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+            jjtree.clearNodeScope(jjtn000);
+            jjtc000 = false;
+          } else {
+            jjtree.popNode();
+          }
+          if (jjte000 instanceof RuntimeException) {
+            {if (true) throw (RuntimeException)jjte000;}
+          }
+          if (jjte000 instanceof ParseException) {
+            {if (true) throw (ParseException)jjte000;}
+          }
+          {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+            jjtree.closeNodeScope(jjtn000, true);
+            if (jjtree.nodeCreated()) {
+             jjtreeCloseNodeScope(jjtn000);
+            }
+          }
+    }
+  }
+
+  final public void entity_statement() throws ParseException {
+    if (jj_2_42(2147483647)) {
+      concurrent_assertion_statement();
+    } else if (jj_2_43(2147483647)) {
+      passive_process_statement();
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case POSTPONED:
+      case basic_identifier:
+      case extended_identifier:
+      case string_literal:{
+        passive_concurrent_procedure_call_statement();
+        break;
+        }
+      default:
+        jj_la1[101] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+  }
+
+  final public void entity_statement_part() throws ParseException {/*@bgen(jjtree) entity_statement_part */
+  ASTentity_statement_part jjtn000 = new ASTentity_statement_part(JJTENTITY_STATEMENT_PART);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      label_21:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case ASSERT:
+        case POSTPONED:
+        case PROCESS:
+        case basic_identifier:
+        case extended_identifier:
+        case string_literal:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[102] = jj_gen;
+          break label_21;
+        }
+        entity_statement();
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void entity_tag() throws ParseException {/*@bgen(jjtree) entity_tag */
+  ASTentity_tag jjtn000 = new ASTentity_tag(JJTENTITY_TAG);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:{
+        simple_name();
+        break;
+        }
+      case character_literal:{
+        jj_consume_token(character_literal);
+        break;
+        }
+      case string_literal:{
+        operator_symbol();
+        break;
+        }
+      default:
+        jj_la1[103] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        {if (true) throw (RuntimeException)jjte000;}
+      }
+      if (jjte000 instanceof ParseException) {
+        {if (true) throw (ParseException)jjte000;}
+      }
+      {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+  }
+
+  final public void enumeration_literal() throws ParseException {/*@bgen(jjtree) enumeration_literal */
+  ASTenumeration_literal jjtn000 = new ASTenumeration_literal(JJTENUMERATION_LITERAL);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case character_literal:{
+        jj_consume_token(character_literal);
+        break;
+        }
+      case basic_identifier:
+      case extended_identifier:{
+        identifier();
+        break;
+        }
+      default:
+        jj_la1[104] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void enumeration_type_definition() throws ParseException {/*@bgen(jjtree) enumeration_type_definition */
+  ASTenumeration_type_definition jjtn000 = new ASTenumeration_type_definition(JJTENUMERATION_TYPE_DEFINITION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(158);
+      enumeration_literal();
+      label_22:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case 160:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[105] = jj_gen;
+          break label_22;
+        }
+        jj_consume_token(160);
+        enumeration_literal();
+      }
+      jj_consume_token(159);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void exit_statement() throws ParseException {/*@bgen(jjtree) exit_statement */
+  ASTexit_statement jjtn000 = new ASTexit_statement(JJTEXIT_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:{
+        label();
+        jj_consume_token(COLON);
+        break;
+        }
+      default:
+        jj_la1[106] = jj_gen;
+        ;
+      }
+      jj_consume_token(EXIT);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:{
+        loop_label();
+        break;
+        }
+      default:
+        jj_la1[107] = jj_gen;
+        ;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case WHEN:{
+        jj_consume_token(WHEN);
+        condition();
+        break;
+        }
+      default:
+        jj_la1[108] = jj_gen;
+        ;
+      }
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void expression() throws ParseException {int op;
+    relation();
+    label_23:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case AND:
+      case NAND:
+      case NOR:
+      case OR:
+      case XNOR:
+      case XOR:{
+        ;
+        break;
+        }
+      default:
+        jj_la1[109] = jj_gen;
+        break label_23;
+      }
+      op = logical_operator();
+ASTrelation jjtn001 = new ASTrelation(JJTRELATION);
+                                         boolean jjtc001 = true;
+                                         jjtree.openNodeScope(jjtn001);
+                                         jjtreeOpenNodeScope(jjtn001);
+      try {
+        relation();
+      } catch (Throwable jjte001) {
+if (jjtc001) {
+                                           jjtree.clearNodeScope(jjtn001);
+                                           jjtc001 = false;
+                                         } else {
+                                           jjtree.popNode();
+                                         }
+                                         if (jjte001 instanceof RuntimeException) {
+                                           {if (true) throw (RuntimeException)jjte001;}
+                                         }
+                                         if (jjte001 instanceof ParseException) {
+                                           {if (true) throw (ParseException)jjte001;}
+                                         }
+                                         {if (true) throw (Error)jjte001;}
+      } finally {
+if (jjtc001) {
+                                           jjtree.closeNodeScope(jjtn001,  2);
+                                           if (jjtree.nodeCreated()) {
+                                            jjtreeCloseNodeScope(jjtn001);
+                                           }
+                                         }
+      }
+    }
+  }
+
+  final public void factor() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case ABS:{
+      jj_consume_token(ABS);
+      primary();
+      break;
+      }
+    case NOT:{
+      jj_consume_token(NOT);
+      primary();
+      break;
+      }
+    case NEW:
+    case NULL:
+    case based_literal:
+    case basic_identifier:
+    case bit_string_literal:
+    case character_literal:
+    case decimal_literal:
+    case extended_identifier:
+    case string_literal:
+    case 158:{
+      primary();
+      if (jj_2_44(2147483647)) {
+        jj_consume_token(EXP);
+ASTfactor jjtn001 = new ASTfactor(JJTFACTOR);
+                                                   boolean jjtc001 = true;
+                                                   jjtree.openNodeScope(jjtn001);
+                                                   jjtreeOpenNodeScope(jjtn001);
+        try {
+          primary();
+        } catch (Throwable jjte001) {
+if (jjtc001) {
+                                                     jjtree.clearNodeScope(jjtn001);
+                                                     jjtc001 = false;
+                                                   } else {
+                                                     jjtree.popNode();
+                                                   }
+                                                   if (jjte001 instanceof RuntimeException) {
+                                                     {if (true) throw (RuntimeException)jjte001;}
+                                                   }
+                                                   if (jjte001 instanceof ParseException) {
+                                                     {if (true) throw (ParseException)jjte001;}
+                                                   }
+                                                   {if (true) throw (Error)jjte001;}
+        } finally {
+if (jjtc001) {
+                                                     jjtree.closeNodeScope(jjtn001,  2);
+                                                     if (jjtree.nodeCreated()) {
+                                                      jjtreeCloseNodeScope(jjtn001);
+                                                     }
+                                                   }
+        }
+      } else {
+        ;
+      }
+      break;
+      }
+    default:
+      jj_la1[110] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void file_declaration() throws ParseException {/*@bgen(jjtree) file_declaration */
+  ASTfile_declaration jjtn000 = new ASTfile_declaration(JJTFILE_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(FILE);
+      identifier_list();
+      jj_consume_token(COLON);
+      subtype_indication();
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case IS:
+      case OPEN:{
+        file_open_information();
+        break;
+        }
+      default:
+        jj_la1[111] = jj_gen;
+        ;
+      }
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void file_logical_name() throws ParseException {
+    string_expression();
+  }
+
+  final public void file_open_information() throws ParseException {/*@bgen(jjtree) file_open_information */
+  ASTfile_open_information jjtn000 = new ASTfile_open_information(JJTFILE_OPEN_INFORMATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case OPEN:{
+        jj_consume_token(OPEN);
+        file_open_kind_expression();
+        jj_consume_token(IS);
+        file_logical_name();
+        break;
+        }
+      case IS:{
+        jj_consume_token(IS);
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case IN:
+        case OUT:{
+          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+          case IN:{
+            jj_consume_token(IN);
+            break;
+            }
+          case OUT:{
+            jj_consume_token(OUT);
+            break;
+            }
+          default:
+            jj_la1[112] = jj_gen;
+            jj_consume_token(-1);
+            throw new ParseException();
+          }
+          break;
+          }
+        default:
+          jj_la1[113] = jj_gen;
+          ;
+        }
+        file_logical_name();
+        break;
+        }
+      default:
+        jj_la1[114] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void file_type_definition() throws ParseException {
+    jj_consume_token(FILE);
+    jj_consume_token(OF);
+    type_mark();
+  }
+
+  final public void floating_type_definition() throws ParseException {
+    range_constraint();
+  }
+
+  final public void formal_designator() throws ParseException {
+    if (jj_2_45(2147483647)) {
+      generic_name();
+    } else if (jj_2_46(2147483647)) {
+      port_name();
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:
+      case string_literal:{
+        parameter_name();
+        break;
+        }
+      default:
+        jj_la1[115] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+  }
+
+  final public void formal_parameter_list() throws ParseException {/*@bgen(jjtree) formal_parameter_list */
+  ASTformal_parameter_list jjtn000 = new ASTformal_parameter_list(JJTFORMAL_PARAMETER_LIST);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      parameter_interface_list();
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void formal_part() throws ParseException {
+    if (jj_2_47(2147483647)) {
+      function_name();
+      jj_consume_token(158);
+      formal_designator();
+      jj_consume_token(159);
+    } else if (jj_2_48(2147483647)) {
+      type_mark();
+      jj_consume_token(158);
+      formal_designator();
+      jj_consume_token(159);
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:
+      case string_literal:{
+        formal_designator();
+        break;
+        }
+      default:
+        jj_la1[116] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+  }
+
+  final public void full_type_declaration() throws ParseException {/*@bgen(jjtree) full_type_declaration */
+  ASTfull_type_declaration jjtn000 = new ASTfull_type_declaration(JJTFULL_TYPE_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(TYPE);
+      identifier();
+      jj_consume_token(IS);
+      type_definition();
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void function_call() throws ParseException {/*@bgen(jjtree) function_call */
+  ASTfunction_call jjtn000 = new ASTfunction_call(JJTFUNCTION_CALL);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      function_name();
+      if (jj_2_49(2147483647)) {
+        jj_consume_token(158);
+        actual_parameter_part();
+        jj_consume_token(159);
+      } else {
+        ;
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+/**
+ * Section 9.7
+ */
+  final public void generate_statement() throws ParseException {/*@bgen(jjtree) generate_statement */
+  ASTgenerate_statement jjtn000 = new ASTgenerate_statement(JJTGENERATE_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      generate_label();
+      jj_consume_token(COLON);
+      generation_scheme();
+      jj_consume_token(GENERATE);
+      if (jj_2_50(2)) {
+        label_24:
+        while (true) {
+          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+          case ALIAS:
+          case ATTRIBUTE:
+          case COMPONENT:
+          case CONSTANT:
+          case DISCONNECT:
+          case FILE:
+          case FOR:
+          case FUNCTION:
+          case GROUP:
+          case IMPURE:
+          case NATURE:
+          case PROCEDURE:
+          case PURE:
+          case QUANTITY:
+          case SIGNAL:
+          case SHARED:
+          case SUBNATURE:
+          case SUBTYPE:
+          case TERMINAL:
+          case TYPE:
+          case USE:
+          case VARIABLE:{
+            ;
+            break;
+            }
+          default:
+            jj_la1[117] = jj_gen;
+            break label_24;
+          }
+          block_declarative_item();
+        }
+        jj_consume_token(BEGIN);
+      } else {
+        ;
+      }
+      label_25:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case ABS:
+        case ASSERT:
+        case BREAK:
+        case CASE:
+        case IF:
+        case IMPURE:
+        case NEW:
+        case NOT:
+        case NULL:
+        case POSTPONED:
+        case PROCEDURAL:
+        case PROCESS:
+        case PURE:
+        case WITH:
+        case based_literal:
+        case basic_identifier:
+        case bit_string_literal:
+        case character_literal:
+        case decimal_literal:
+        case extended_identifier:
+        case string_literal:
+        case ADD:
+        case SUB:
+        case 158:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[118] = jj_gen;
+          break label_25;
+        }
+        architecture_statement();
+      }
+      jj_consume_token(END);
+      jj_consume_token(GENERATE);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:{
+        generate_label();
+        break;
+        }
+      default:
+        jj_la1[119] = jj_gen;
+        ;
+      }
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+/** 1076.1 extension: */
+  final public void concurrent_break_statement() throws ParseException {/*@bgen(jjtree) concurrent_break_statement */
+  ASTconcurrent_break_statement jjtn000 = new ASTconcurrent_break_statement(JJTCONCURRENT_BREAK_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:{
+        label();
+        jj_consume_token(COLON);
+        break;
+        }
+      default:
+        jj_la1[120] = jj_gen;
+        ;
+      }
+      jj_consume_token(BREAK);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case FOR:
+      case basic_identifier:
+      case extended_identifier:
+      case string_literal:{
+        break_list();
+        break;
+        }
+      default:
+        jj_la1[121] = jj_gen;
+        ;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case ON:{
+        sensitivity_clause();
+        break;
+        }
+      default:
+        jj_la1[122] = jj_gen;
+        ;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case WHEN:{
+        jj_consume_token(WHEN);
+        condition();
+        break;
+        }
+      default:
+        jj_la1[123] = jj_gen;
+        ;
+      }
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void generation_scheme() throws ParseException {/*@bgen(jjtree) generation_scheme */
+  ASTgeneration_scheme jjtn000 = new ASTgeneration_scheme(JJTGENERATION_SCHEME);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case FOR:{
+        jj_consume_token(FOR);
+        generate_parameter_specification();
+        break;
+        }
+      case IF:{
+        jj_consume_token(IF);
+        condition();
+        break;
+        }
+      default:
+        jj_la1[124] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        {if (true) throw (RuntimeException)jjte000;}
+      }
+      if (jjte000 instanceof ParseException) {
+        {if (true) throw (ParseException)jjte000;}
+      }
+      {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+  }
+
+  final public void generic_clause() throws ParseException {/*@bgen(jjtree) generic_clause */
+  ASTgeneric_clause jjtn000 = new ASTgeneric_clause(JJTGENERIC_CLAUSE);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(GENERIC);
+      jj_consume_token(158);
+      generic_list();
+      jj_consume_token(159);
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void generic_list() throws ParseException {
+    generic_interface_list();
+  }
+
+  final public void generic_map_aspect() throws ParseException {
+    jj_consume_token(GENERIC);
+    jj_consume_token(MAP);
+    jj_consume_token(158);
+    generic_association_list();
+    jj_consume_token(159);
+  }
+
+  final public void group_constituent() throws ParseException {/*@bgen(jjtree) group_constituent */
+  ASTgroup_constituent jjtn000 = new ASTgroup_constituent(JJTGROUP_CONSTITUENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:
+      case string_literal:{
+        name();
+        break;
+        }
+      case character_literal:{
+        jj_consume_token(character_literal);
+        break;
+        }
+      default:
+        jj_la1[125] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        {if (true) throw (RuntimeException)jjte000;}
+      }
+      if (jjte000 instanceof ParseException) {
+        {if (true) throw (ParseException)jjte000;}
+      }
+      {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+  }
+
+  final public void group_constituent_list() throws ParseException {/*@bgen(jjtree) group_constituent_list */
+  ASTgroup_constituent_list jjtn000 = new ASTgroup_constituent_list(JJTGROUP_CONSTITUENT_LIST);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      group_constituent();
+      label_26:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case 160:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[126] = jj_gen;
+          break label_26;
+        }
+        jj_consume_token(160);
+        group_constituent();
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void group_template_declaration() throws ParseException {/*@bgen(jjtree) group_template_declaration */
+  ASTgroup_template_declaration jjtn000 = new ASTgroup_template_declaration(JJTGROUP_TEMPLATE_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(GROUP);
+      identifier();
+      jj_consume_token(IS);
+      jj_consume_token(158);
+      entity_class_entry_list();
+      jj_consume_token(159);
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void group_declaration() throws ParseException {/*@bgen(jjtree) group_declaration */
+  ASTgroup_declaration jjtn000 = new ASTgroup_declaration(JJTGROUP_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(GROUP);
+      identifier();
+      jj_consume_token(COLON);
+      group_template_name();
+      jj_consume_token(158);
+      group_constituent_list();
+      jj_consume_token(159);
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void guarded_signal_specification() throws ParseException {/*@bgen(jjtree) guarded_signal_specification */
+  ASTguarded_signal_specification jjtn000 = new ASTguarded_signal_specification(JJTGUARDED_SIGNAL_SPECIFICATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      guarded_signal_list();
+      jj_consume_token(COLON);
+      type_mark();
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void identifier() throws ParseException {/*@bgen(jjtree) identifier */
+  ASTidentifier jjtn000 = new ASTidentifier(JJTIDENTIFIER);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);Token t;
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:{
+        t = jj_consume_token(basic_identifier);
+jjtree.closeNodeScope(jjtn000, true);
+                               jjtc000 = false;
+                               if (jjtree.nodeCreated()) {
+                                jjtreeCloseNodeScope(jjtn000);
+                               }
+jjtn000.name = t.image;
+        break;
+        }
+      case extended_identifier:{
+        t = jj_consume_token(extended_identifier);
+jjtree.closeNodeScope(jjtn000, true);
+                               jjtc000 = false;
+                               if (jjtree.nodeCreated()) {
+                                jjtreeCloseNodeScope(jjtn000);
+                               }
+jjtn000.name = t.image;
+        break;
+        }
+      default:
+        jj_la1[127] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    } finally {
+if (jjtc000) {
+         jjtree.closeNodeScope(jjtn000, true);
+         if (jjtree.nodeCreated()) {
+          jjtreeCloseNodeScope(jjtn000);
+         }
+       }
+    }
+  }
+
+  final public void identifier_list() throws ParseException {/*@bgen(jjtree) identifier_list */
+  ASTidentifier_list jjtn000 = new ASTidentifier_list(JJTIDENTIFIER_LIST);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      identifier();
+      label_27:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case 160:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[128] = jj_gen;
+          break label_27;
+        }
+        jj_consume_token(160);
+        identifier();
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void if_statement() throws ParseException {/*@bgen(jjtree) if_statement */
+  ASTif_statement jjtn000 = new ASTif_statement(JJTIF_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:{
+        if_label();
+        jj_consume_token(COLON);
+        break;
+        }
+      default:
+        jj_la1[129] = jj_gen;
+        ;
+      }
+      jj_consume_token(IF);
+      condition();
+      jj_consume_token(THEN);
+      sequence_of_statements();
+      label_28:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case ELSIF:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[130] = jj_gen;
+          break label_28;
+        }
+        jj_consume_token(ELSIF);
+        condition();
+        jj_consume_token(THEN);
+        sequence_of_statements();
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case ELSE:{
+        jj_consume_token(ELSE);
+        sequence_of_statements();
+        break;
+        }
+      default:
+        jj_la1[131] = jj_gen;
+        ;
+      }
+      jj_consume_token(END);
+      jj_consume_token(IF);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:{
+        if_label();
+        break;
+        }
+      default:
+        jj_la1[132] = jj_gen;
+        ;
+      }
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void incomplete_type_declaration() throws ParseException {/*@bgen(jjtree) incomplete_type_declaration */
+  ASTincomplete_type_declaration jjtn000 = new ASTincomplete_type_declaration(JJTINCOMPLETE_TYPE_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(TYPE);
+      identifier();
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void index_constraint() throws ParseException {/*@bgen(jjtree) index_constraint */
+  ASTindex_constraint jjtn000 = new ASTindex_constraint(JJTINDEX_CONSTRAINT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(158);
+      discrete_range();
+      label_29:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case 160:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[133] = jj_gen;
+          break label_29;
+        }
+        jj_consume_token(160);
+        discrete_range();
+      }
+      jj_consume_token(159);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void index_specification() throws ParseException {/*@bgen(jjtree) index_specification */
+  ASTindex_specification jjtn000 = new ASTindex_specification(JJTINDEX_SPECIFICATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      if (jj_2_51(2147483647)) {
+        discrete_range();
+      } else {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case ABS:
+        case NEW:
+        case NOT:
+        case NULL:
+        case based_literal:
+        case basic_identifier:
+        case bit_string_literal:
+        case character_literal:
+        case decimal_literal:
+        case extended_identifier:
+        case string_literal:
+        case ADD:
+        case SUB:
+        case 158:{
+          static_expression();
+          break;
+          }
+        default:
+          jj_la1[134] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        {if (true) throw (RuntimeException)jjte000;}
+      }
+      if (jjte000 instanceof ParseException) {
+        {if (true) throw (ParseException)jjte000;}
+      }
+      {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+  }
+
+  final public void index_subtype_definition() throws ParseException {/*@bgen(jjtree) index_subtype_definition */
+  ASTindex_subtype_definition jjtn000 = new ASTindex_subtype_definition(JJTINDEX_SUBTYPE_DEFINITION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      type_mark();
+      jj_consume_token(RANGE);
+      jj_consume_token(163);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void indexed_name() throws ParseException {/*@bgen(jjtree) indexed_name */
+  ASTindexed_name jjtn000 = new ASTindexed_name(JJTINDEXED_NAME);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      prefix();
+      jj_consume_token(158);
+      expression();
+      label_30:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case 160:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[135] = jj_gen;
+          break label_30;
+        }
+        jj_consume_token(160);
+        expression();
+      }
+      jj_consume_token(159);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void instantiated_unit() throws ParseException {/*@bgen(jjtree) instantiated_unit */
+  ASTinstantiated_unit jjtn000 = new ASTinstantiated_unit(JJTINSTANTIATED_UNIT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case COMPONENT:
+      case basic_identifier:
+      case extended_identifier:
+      case string_literal:{
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case COMPONENT:{
+          jj_consume_token(COMPONENT);
+          break;
+          }
+        default:
+          jj_la1[136] = jj_gen;
+          ;
+        }
+        component_name();
+        break;
+        }
+      case ENTITY:{
+        jj_consume_token(ENTITY);
+        entity_name();
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case 158:{
+          jj_consume_token(158);
+          architecture_identifier();
+          jj_consume_token(159);
+          break;
+          }
+        default:
+          jj_la1[137] = jj_gen;
+          ;
+        }
+        break;
+        }
+      case CONFIGURATION:{
+        jj_consume_token(CONFIGURATION);
+        configuration_name();
+        break;
+        }
+      default:
+        jj_la1[138] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        {if (true) throw (RuntimeException)jjte000;}
+      }
+      if (jjte000 instanceof ParseException) {
+        {if (true) throw (ParseException)jjte000;}
+      }
+      {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+  }
+
+  final public void instantiation_list() throws ParseException {/*@bgen(jjtree) instantiation_list */
+  ASTinstantiation_list jjtn000 = new ASTinstantiation_list(JJTINSTANTIATION_LIST);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:{
+        instantiation_label();
+        label_31:
+        while (true) {
+          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+          case 160:{
+            ;
+            break;
+            }
+          default:
+            jj_la1[139] = jj_gen;
+            break label_31;
+          }
+          jj_consume_token(160);
+          instantiation_label();
+        }
+        break;
+        }
+      case OTHERS:{
+        jj_consume_token(OTHERS);
+        break;
+        }
+      case ALL:{
+        jj_consume_token(ALL);
+        break;
+        }
+      default:
+        jj_la1[140] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        {if (true) throw (RuntimeException)jjte000;}
+      }
+      if (jjte000 instanceof ParseException) {
+        {if (true) throw (ParseException)jjte000;}
+      }
+      {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+  }
+
+  final public void integer_type_definition() throws ParseException {
+    range_constraint();
+  }
+
+  final public void interface_constant_declaration() throws ParseException {/*@bgen(jjtree) interface_constant_declaration */
+  ASTinterface_constant_declaration jjtn000 = new ASTinterface_constant_declaration(JJTINTERFACE_CONSTANT_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case CONSTANT:{
+        jj_consume_token(CONSTANT);
+        break;
+        }
+      default:
+        jj_la1[141] = jj_gen;
+        ;
+      }
+      identifier_list();
+      jj_consume_token(COLON);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case IN:{
+        jj_consume_token(IN);
+        break;
+        }
+      default:
+        jj_la1[142] = jj_gen;
+        ;
+      }
+      subtype_indication();
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case ASSIGN:{
+        jj_consume_token(ASSIGN);
+        static_expression();
+        break;
+        }
+      default:
+        jj_la1[143] = jj_gen;
+        ;
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+/**
+ * Section 4.3.2:
+ */
+  final public void interface_declaration() throws ParseException {
+    if (jj_2_52(2147483647)) {
+      interface_constant_declaration();
+    } else if (jj_2_53(2147483647)) {
+      interface_signal_declaration();
+    } else if (jj_2_54(2147483647)) {
+      interface_variable_declaration();
+    } else if (jj_2_55(2147483647)) {
+      interface_file_declaration();
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case TERMINAL:{
+        interface_terminal_declaration();
+        break;
+        }
+      case QUANTITY:{
+        interface_quantity_declaration();
+        break;
+        }
+      default:
+        jj_la1[144] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+  }
+
+/**
+ * 1076.1 extension:
+ */
+  final public void interface_terminal_declaration() throws ParseException {/*@bgen(jjtree) interface_terminal_declaration */
+  ASTinterface_terminal_declaration jjtn000 = new ASTinterface_terminal_declaration(JJTINTERFACE_TERMINAL_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(TERMINAL);
+      identifier_list();
+      jj_consume_token(COLON);
+      subnature_indication();
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+/**
+ * 1076.1 extension:
+ */
+  final public void interface_quantity_declaration() throws ParseException {/*@bgen(jjtree) interface_quantity_declaration */
+  ASTinterface_quantity_declaration jjtn000 = new ASTinterface_quantity_declaration(JJTINTERFACE_QUANTITY_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(QUANTITY);
+      identifier_list();
+      jj_consume_token(COLON);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case IN:
+      case OUT:{
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case IN:{
+          jj_consume_token(IN);
+          break;
+          }
+        case OUT:{
+          jj_consume_token(OUT);
+          break;
+          }
+        default:
+          jj_la1[145] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+        break;
+        }
+      default:
+        jj_la1[146] = jj_gen;
+        ;
+      }
+      subtype_indication();
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case ASSIGN:{
+        jj_consume_token(ASSIGN);
+        static_expression();
+        break;
+        }
+      default:
+        jj_la1[147] = jj_gen;
+        ;
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void interface_element() throws ParseException {
+    interface_declaration();
+  }
+
+  final public void interface_file_declaration() throws ParseException {/*@bgen(jjtree) interface_file_declaration */
+  ASTinterface_file_declaration jjtn000 = new ASTinterface_file_declaration(JJTINTERFACE_FILE_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(FILE);
+      identifier_list();
+      jj_consume_token(COLON);
+      subtype_indication();
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void interface_list() throws ParseException {/*@bgen(jjtree) interface_list */
+  ASTinterface_list jjtn000 = new ASTinterface_list(JJTINTERFACE_LIST);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      interface_element();
+      label_32:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case SEMICOLON:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[148] = jj_gen;
+          break label_32;
+        }
+        jj_consume_token(SEMICOLON);
+        interface_element();
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void interface_signal_declaration() throws ParseException {/*@bgen(jjtree) interface_signal_declaration */
+  ASTinterface_signal_declaration jjtn000 = new ASTinterface_signal_declaration(JJTINTERFACE_SIGNAL_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case SIGNAL:{
+        jj_consume_token(SIGNAL);
+        break;
+        }
+      default:
+        jj_la1[149] = jj_gen;
+        ;
+      }
+      identifier_list();
+      jj_consume_token(COLON);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case BUFFER:
+      case IN:
+      case INOUT:
+      case LINKAGE:
+      case OUT:{
+        mode();
+        break;
+        }
+      default:
+        jj_la1[150] = jj_gen;
+        ;
+      }
+      subtype_indication();
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case BUS:{
+        jj_consume_token(BUS);
+        break;
+        }
+      default:
+        jj_la1[151] = jj_gen;
+        ;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case ASSIGN:{
+        jj_consume_token(ASSIGN);
+        static_expression();
+        break;
+        }
+      default:
+        jj_la1[152] = jj_gen;
+        ;
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void interface_variable_declaration() throws ParseException {/*@bgen(jjtree) interface_variable_declaration */
+  ASTinterface_variable_declaration jjtn000 = new ASTinterface_variable_declaration(JJTINTERFACE_VARIABLE_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case VARIABLE:{
+        jj_consume_token(VARIABLE);
+        break;
+        }
+      default:
+        jj_la1[153] = jj_gen;
+        ;
+      }
+      identifier_list();
+      jj_consume_token(COLON);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case BUFFER:
+      case IN:
+      case INOUT:
+      case LINKAGE:
+      case OUT:{
+        mode();
+        break;
+        }
+      default:
+        jj_la1[154] = jj_gen;
+        ;
+      }
+      subtype_indication();
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case ASSIGN:{
+        jj_consume_token(ASSIGN);
+        static_expression();
+        break;
+        }
+      default:
+        jj_la1[155] = jj_gen;
+        ;
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void iteration_scheme() throws ParseException {/*@bgen(jjtree) iteration_scheme */
+  ASTiteration_scheme jjtn000 = new ASTiteration_scheme(JJTITERATION_SCHEME);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case WHILE:{
+        jj_consume_token(WHILE);
+        condition();
+        break;
+        }
+      case FOR:{
+        jj_consume_token(FOR);
+        loop_parameter_specification();
+        break;
+        }
+      default:
+        jj_la1[156] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        {if (true) throw (RuntimeException)jjte000;}
+      }
+      if (jjte000 instanceof ParseException) {
+        {if (true) throw (ParseException)jjte000;}
+      }
+      {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+  }
+
+  final public void label() throws ParseException {
+    identifier();
+  }
+
+  final public void library_clause() throws ParseException {
+    jj_consume_token(LIBRARY);
+    logical_name_list();
+    jj_consume_token(SEMICOLON);
+  }
+
+  final public void library_unit() throws ParseException {
+    if (jj_2_56(2147483647)) {
+      primary_unit();
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case ARCHITECTURE:
+      case PACKAGE:{
+        secondary_unit();
+        break;
+        }
+      default:
+        jj_la1[157] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+  }
+
+  final public void literal() throws ParseException {/*@bgen(jjtree) literal */
+  ASTliteral jjtn000 = new ASTliteral(JJTLITERAL);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      if (jj_2_57(2147483647)) {
+        numeric_literal();
+      } else {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case basic_identifier:
+        case character_literal:
+        case extended_identifier:{
+          enumeration_literal();
+          break;
+          }
+        case string_literal:{
+          jj_consume_token(string_literal);
+          break;
+          }
+        case bit_string_literal:{
+          jj_consume_token(bit_string_literal);
+          break;
+          }
+        case NULL:{
+          jj_consume_token(NULL);
+          break;
+          }
+        default:
+          jj_la1[158] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        {if (true) throw (RuntimeException)jjte000;}
+      }
+      if (jjte000 instanceof ParseException) {
+        {if (true) throw (ParseException)jjte000;}
+      }
+      {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+  }
+
+  final public void logical_name() throws ParseException {
+    identifier();
+  }
+
+  final public void logical_name_list() throws ParseException {/*@bgen(jjtree) logical_name_list */
+  ASTlogical_name_list jjtn000 = new ASTlogical_name_list(JJTLOGICAL_NAME_LIST);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      logical_name();
+      label_33:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case 160:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[159] = jj_gen;
+          break label_33;
+        }
+        jj_consume_token(160);
+        logical_name();
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public int logical_operator() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case AND:{
+      jj_consume_token(AND);
+{if ("" != null) return AND;}
+      break;
+      }
+    case OR:{
+      jj_consume_token(OR);
+{if ("" != null) return OR;}
+      break;
+      }
+    case NAND:{
+      jj_consume_token(NAND);
+{if ("" != null) return NAND;}
+      break;
+      }
+    case NOR:{
+      jj_consume_token(NOR);
+{if ("" != null) return NOR;}
+      break;
+      }
+    case XOR:{
+      jj_consume_token(XOR);
+{if ("" != null) return XOR;}
+      break;
+      }
+    case XNOR:{
+      jj_consume_token(XNOR);
+{if ("" != null) return XNOR;}
+      break;
+      }
+    default:
+      jj_la1[160] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    throw new Error("Missing return statement in function");
+  }
+
+  final public void loop_statement() throws ParseException {/*@bgen(jjtree) loop_statement */
+  ASTloop_statement jjtn000 = new ASTloop_statement(JJTLOOP_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:{
+        loop_label();
+        jj_consume_token(COLON);
+        break;
+        }
+      default:
+        jj_la1[161] = jj_gen;
+        ;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case FOR:
+      case WHILE:{
+        iteration_scheme();
+        break;
+        }
+      default:
+        jj_la1[162] = jj_gen;
+        ;
+      }
+      jj_consume_token(LOOP);
+      sequence_of_statements();
+      jj_consume_token(END);
+      jj_consume_token(LOOP);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:{
+        loop_label();
+        break;
+        }
+      default:
+        jj_la1[163] = jj_gen;
+        ;
+      }
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public int miscellaneous_operator() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case EXP:{
+      jj_consume_token(EXP);
+{if ("" != null) return EXP;}
+      break;
+      }
+    case ABS:{
+      jj_consume_token(ABS);
+{if ("" != null) return ABS;}
+      break;
+      }
+    case NOT:{
+      jj_consume_token(NOT);
+{if ("" != null) return NOT;}
+      break;
+      }
+    default:
+      jj_la1[164] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    throw new Error("Missing return statement in function");
+  }
+
+  final public void mode() throws ParseException {/*@bgen(jjtree) mode */
+  ASTmode jjtn000 = new ASTmode(JJTMODE);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case IN:{
+        jj_consume_token(IN);
+        break;
+        }
+      case OUT:{
+        jj_consume_token(OUT);
+        break;
+        }
+      case INOUT:{
+        jj_consume_token(INOUT);
+        break;
+        }
+      case BUFFER:{
+        jj_consume_token(BUFFER);
+        break;
+        }
+      case LINKAGE:{
+        jj_consume_token(LINKAGE);
+        break;
+        }
+      default:
+        jj_la1[165] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    } finally {
+if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+  }
+
+  final public int multiplying_operator() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case MUL:{
+      jj_consume_token(MUL);
+{if ("" != null) return MUL;}
+      break;
+      }
+    case DIV:{
+      jj_consume_token(DIV);
+{if ("" != null) return DIV;}
+      break;
+      }
+    case MOD:{
+      jj_consume_token(MOD);
+{if ("" != null) return MOD;}
+      break;
+      }
+    case REM:{
+      jj_consume_token(REM);
+{if ("" != null) return REM;}
+      break;
+      }
+    default:
+      jj_la1[166] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    throw new Error("Missing return statement in function");
+  }
+
+  final public void name() throws ParseException {/*@bgen(jjtree) name */
+  ASTname jjtn000 = new ASTname(JJTNAME);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:{
+        simple_name();
+        break;
+        }
+      case string_literal:{
+        operator_symbol();
+        break;
+        }
+      default:
+        jj_la1[167] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      if (jj_2_58(2147483647)) {
+        name_extension();
+      } else {
+        ;
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void name_extension() throws ParseException {
+    if (jj_2_60(2147483647)) {
+      signature();
+      jj_consume_token(161);
+      attribute_designator();
+      if (jj_2_59(2147483647)) {
+        jj_consume_token(158);
+        expression();
+        jj_consume_token(159);
+      } else {
+        ;
+      }
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case 164:{
+        jj_consume_token(164);
+        suffix();
+        break;
+        }
+      default:
+        jj_la1[169] = jj_gen;
+        if (jj_2_61(2147483647)) {
+          jj_consume_token(158);
+          discrete_range();
+          jj_consume_token(159);
+        } else if (jj_2_62(2147483647)) {
+          jj_consume_token(158);
+          expression();
+          label_34:
+          while (true) {
+            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+            case 160:{
+              ;
+              break;
+              }
+            default:
+              jj_la1[168] = jj_gen;
+              break label_34;
+            }
+            jj_consume_token(160);
+            expression();
+          }
+          jj_consume_token(159);
+        } else {
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+      }
+    }
+    if (jj_2_63(2147483647)) {
+      name_extension();
+    } else {
+      ;
+    }
+  }
+
+/**
+ * 1076.1 extension:
+ */
+  final public void nature_element_declaration() throws ParseException {/*@bgen(jjtree) nature_element_declaration */
+  ASTnature_element_declaration jjtn000 = new ASTnature_element_declaration(JJTNATURE_ELEMENT_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      identifier_list();
+      jj_consume_token(COLON);
+      element_subnature_definition();
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+/**
+ * 1076.1 extension:
+ */
+  final public void element_subnature_definition() throws ParseException {
+    subnature_indication();
+  }
+
+  final public void next_statement() throws ParseException {/*@bgen(jjtree) next_statement */
+  ASTnext_statement jjtn000 = new ASTnext_statement(JJTNEXT_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:{
+        label();
+        jj_consume_token(COLON);
+        break;
+        }
+      default:
+        jj_la1[170] = jj_gen;
+        ;
+      }
+      jj_consume_token(NEXT);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:{
+        loop_label();
+        break;
+        }
+      default:
+        jj_la1[171] = jj_gen;
+        ;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case WHEN:{
+        jj_consume_token(WHEN);
+        condition();
+        break;
+        }
+      default:
+        jj_la1[172] = jj_gen;
+        ;
+      }
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void null_statement() throws ParseException {/*@bgen(jjtree) null_statement */
+  ASTnull_statement jjtn000 = new ASTnull_statement(JJTNULL_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:{
+        label();
+        jj_consume_token(COLON);
+        break;
+        }
+      default:
+        jj_la1[173] = jj_gen;
+        ;
+      }
+      jj_consume_token(NULL);
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void numeric_literal() throws ParseException {
+    if (jj_2_64(2147483647)) {
+      physical_literal();
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case based_literal:
+      case decimal_literal:{
+        abstract_literal();
+        break;
+        }
+      default:
+        jj_la1[174] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+  }
+
+  final public void object_declaration() throws ParseException {
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case CONSTANT:{
+        constant_declaration();
+        break;
+        }
+      case SIGNAL:{
+        signal_declaration();
+        break;
+        }
+      case SHARED:
+      case VARIABLE:{
+        variable_declaration();
+        break;
+        }
+      case FILE:{
+        file_declaration();
+        break;
+        }
+      case TERMINAL:{
+        terminal_declaration();
+        break;
+        }
+      case QUANTITY:{
+        quantity_declaration();
+        break;
+        }
+      default:
+        jj_la1[175] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    } catch (ParseException e) {
+error_skipto(SEMICOLON, "syntax error in declaration");
+    }
+  }
+
+  final public void operator_symbol() throws ParseException {/*@bgen(jjtree) operator_symbol */
+  ASToperator_symbol jjtn000 = new ASToperator_symbol(JJTOPERATOR_SYMBOL);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(string_literal);
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void options_() throws ParseException {/*@bgen(jjtree) options_ */
+  ASToptions_ jjtn000 = new ASToptions_(JJTOPTIONS_);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case GUARDED:{
+        jj_consume_token(GUARDED);
+        break;
+        }
+      default:
+        jj_la1[176] = jj_gen;
+        ;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case INERTIAL:
+      case REJECT:
+      case TRANSPORT:{
+        delay_mechanism();
+        break;
+        }
+      default:
+        jj_la1[177] = jj_gen;
+        ;
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void package_body() throws ParseException {/*@bgen(jjtree) package_body */
+  ASTpackage_body jjtn000 = new ASTpackage_body(JJTPACKAGE_BODY);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(PACKAGE);
+      jj_consume_token(BODY);
+      package_simple_name();
+      jj_consume_token(IS);
+      package_body_declarative_part();
+      jj_consume_token(END);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case PACKAGE:{
+        jj_consume_token(PACKAGE);
+        jj_consume_token(BODY);
+        break;
+        }
+      default:
+        jj_la1[178] = jj_gen;
+        ;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:{
+        package_simple_name();
+        break;
+        }
+      default:
+        jj_la1[179] = jj_gen;
+        ;
+      }
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void package_body_declarative_item() throws ParseException {
+    try {
+      if (jj_2_65(2147483647)) {
+        subprogram_declaration();
+      } else {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case FUNCTION:
+        case IMPURE:
+        case PROCEDURE:
+        case PURE:{
+          subprogram_body();
+          break;
+          }
+        case TYPE:{
+          type_declaration();
+          break;
+          }
+        case SUBTYPE:{
+          subtype_declaration();
+          break;
+          }
+        case CONSTANT:{
+          constant_declaration();
+          break;
+          }
+        case SHARED:
+        case VARIABLE:{
+          shared_variable_declaration();
+          break;
+          }
+        case FILE:{
+          file_declaration();
+          break;
+          }
+        case ALIAS:{
+          alias_declaration();
+          break;
+          }
+        case USE:{
+          use_clause();
+          break;
+          }
+        default:
+          jj_la1[180] = jj_gen;
+          if (jj_2_66(2147483647)) {
+            group_template_declaration();
+          } else {
+            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+            case GROUP:{
+              group_declaration();
+              break;
+              }
+            default:
+              jj_la1[181] = jj_gen;
+              jj_consume_token(-1);
+              throw new ParseException();
+            }
+          }
+        }
+      }
+    } catch (ParseException e) {
+error_skipto(SEMICOLON, "syntax error in declarative item");
+    }
+  }
+
+  final public void package_body_declarative_part() throws ParseException {/*@bgen(jjtree) package_body_declarative_part */
+  ASTpackage_body_declarative_part jjtn000 = new ASTpackage_body_declarative_part(JJTPACKAGE_BODY_DECLARATIVE_PART);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      label_35:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case ALIAS:
+        case CONSTANT:
+        case FILE:
+        case FUNCTION:
+        case GROUP:
+        case IMPURE:
+        case PROCEDURE:
+        case PURE:
+        case SHARED:
+        case SUBTYPE:
+        case TYPE:
+        case USE:
+        case VARIABLE:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[182] = jj_gen;
+          break label_35;
+        }
+        package_body_declarative_item();
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void package_declaration() throws ParseException {/*@bgen(jjtree) package_declaration */
+  ASTpackage_declaration jjtn000 = new ASTpackage_declaration(JJTPACKAGE_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(PACKAGE);
+      identifier();
+      jj_consume_token(IS);
+      package_declarative_part();
+      jj_consume_token(END);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case PACKAGE:{
+        jj_consume_token(PACKAGE);
+        break;
+        }
+      default:
+        jj_la1[183] = jj_gen;
+        ;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:{
+        package_simple_name();
+        break;
+        }
+      default:
+        jj_la1[184] = jj_gen;
+        ;
+      }
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void package_declarative_item() throws ParseException {
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case FUNCTION:
+      case IMPURE:
+      case PROCEDURE:
+      case PURE:{
+        subprogram_declaration();
+        break;
+        }
+      case TYPE:{
+        type_declaration();
+        break;
+        }
+      case SUBTYPE:{
+        subtype_declaration();
+        break;
+        }
+      case CONSTANT:{
+        constant_declaration();
+        break;
+        }
+      case SIGNAL:{
+        signal_declaration();
+        break;
+        }
+      case SHARED:
+      case VARIABLE:{
+        shared_variable_declaration();
+        break;
+        }
+      case FILE:{
+        file_declaration();
+        break;
+        }
+      case ALIAS:{
+        alias_declaration();
+        break;
+        }
+      case COMPONENT:{
+        component_declaration();
+        break;
+        }
+      default:
+        jj_la1[185] = jj_gen;
+        if (jj_2_67(2147483647)) {
+          attribute_declaration();
+        } else {
+          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+          case ATTRIBUTE:{
+            attribute_specification();
+            break;
+            }
+          case DISCONNECT:{
+            disconnection_specification();
+            break;
+            }
+          case USE:{
+            use_clause();
+            break;
+            }
+          default:
+            jj_la1[186] = jj_gen;
+            if (jj_2_68(2147483647)) {
+              group_template_declaration();
+            } else {
+              switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+              case GROUP:{
+                group_declaration();
+                break;
+                }
+              case NATURE:{
+                nature_declaration();
+                break;
+                }
+              case SUBNATURE:{
+                subnature_declaration();
+                break;
+                }
+              case TERMINAL:{
+                terminal_declaration();
+                break;
+                }
+              default:
+                jj_la1[187] = jj_gen;
+                jj_consume_token(-1);
+                throw new ParseException();
+              }
+            }
+          }
+        }
+      }
+    } catch (ParseException e) {
+error_skipto(SEMICOLON, "syntax error in declaration");
+    }
+  }
+
+  final public void package_declarative_part() throws ParseException {/*@bgen(jjtree) package_declarative_part */
+  ASTpackage_declarative_part jjtn000 = new ASTpackage_declarative_part(JJTPACKAGE_DECLARATIVE_PART);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      label_36:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case ALIAS:
+        case ATTRIBUTE:
+        case COMPONENT:
+        case CONSTANT:
+        case DISCONNECT:
+        case FILE:
+        case FUNCTION:
+        case GROUP:
+        case IMPURE:
+        case NATURE:
+        case PROCEDURE:
+        case PURE:
+        case SIGNAL:
+        case SHARED:
+        case SUBNATURE:
+        case SUBTYPE:
+        case TERMINAL:
+        case TYPE:
+        case USE:
+        case VARIABLE:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[188] = jj_gen;
+          break label_36;
+        }
+        package_declarative_item();
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void parameter_specification() throws ParseException {/*@bgen(jjtree) parameter_specification */
+  ASTparameter_specification jjtn000 = new ASTparameter_specification(JJTPARAMETER_SPECIFICATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      identifier();
+      jj_consume_token(IN);
+      discrete_range();
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void physical_literal() throws ParseException {/*@bgen(jjtree) physical_literal */
+  ASTphysical_literal jjtn000 = new ASTphysical_literal(JJTPHYSICAL_LITERAL);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      if (jj_2_69(2147483647)) {
+        abstract_literal();
+      } else {
+        ;
+      }
+      unit_name();
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void physical_type_definition() throws ParseException {/*@bgen(jjtree) physical_type_definition */
+  ASTphysical_type_definition jjtn000 = new ASTphysical_type_definition(JJTPHYSICAL_TYPE_DEFINITION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      range_constraint();
+      jj_consume_token(UNITS);
+      base_unit_declaration();
+      label_37:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case basic_identifier:
+        case extended_identifier:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[189] = jj_gen;
+          break label_37;
+        }
+        secondary_unit_declaration();
+      }
+      jj_consume_token(END);
+      jj_consume_token(UNITS);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:{
+        physical_type_simple_name();
+        break;
+        }
+      default:
+        jj_la1[190] = jj_gen;
+        ;
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void port_clause() throws ParseException {/*@bgen(jjtree) port_clause */
+  ASTport_clause jjtn000 = new ASTport_clause(JJTPORT_CLAUSE);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(PORT);
+      jj_consume_token(158);
+      port_list();
+      jj_consume_token(159);
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void port_list() throws ParseException {
+    port_interface_list();
+  }
+
+  final public void port_map_aspect() throws ParseException {/*@bgen(jjtree) port_map_aspect */
+  ASTport_map_aspect jjtn000 = new ASTport_map_aspect(JJTPORT_MAP_ASPECT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(PORT);
+      jj_consume_token(MAP);
+      jj_consume_token(158);
+      port_association_list();
+      jj_consume_token(159);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void prefix() throws ParseException {/*@bgen(jjtree) prefix */
+  ASTprefix jjtn000 = new ASTprefix(JJTPREFIX);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      if (jj_2_70(2147483647)) {
+        function_call();
+      } else {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case basic_identifier:
+        case extended_identifier:
+        case string_literal:{
+          name();
+          break;
+          }
+        default:
+          jj_la1[191] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        {if (true) throw (RuntimeException)jjte000;}
+      }
+      if (jjte000 instanceof ParseException) {
+        {if (true) throw (ParseException)jjte000;}
+      }
+      {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+  }
+
+  final public void primary() throws ParseException {
+    if (jj_2_71(2147483647)) {
+      qualified_expression();
+    } else if (jj_2_72(2147483647)) {
+      function_call();
+    } else if (jj_2_73(2147483647)) {
+      name();
+    } else if (jj_2_74(2147483647)) {
+      literal();
+    } else if (jj_2_75(2147483647)) {
+      aggregate();
+    } else if (jj_2_76(2147483647)) {
+      jj_consume_token(158);
+      expression();
+      jj_consume_token(159);
+    } else if (jj_2_77(2147483647)) {
+      type_conversion();
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case NEW:{
+        allocator();
+        break;
+        }
+      default:
+        jj_la1[192] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+  }
+
+  final public void primary_unit() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case ENTITY:{
+      entity_declaration();
+      break;
+      }
+    case CONFIGURATION:{
+      configuration_declaration();
+      break;
+      }
+    default:
+      jj_la1[193] = jj_gen;
+      if (jj_2_78(2147483647)) {
+        package_declaration();
+      } else {
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+  }
+
+  final public void procedure_call() throws ParseException {/*@bgen(jjtree) procedure_call */
+  ASTprocedure_call jjtn000 = new ASTprocedure_call(JJTPROCEDURE_CALL);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      procedure_name();
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case 158:{
+        jj_consume_token(158);
+        actual_parameter_part();
+        jj_consume_token(159);
+        break;
+        }
+      default:
+        jj_la1[194] = jj_gen;
+        ;
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void procedure_call_statement() throws ParseException {/*@bgen(jjtree) procedure_call_statement */
+  ASTprocedure_call_statement jjtn000 = new ASTprocedure_call_statement(JJTPROCEDURE_CALL_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      if (jj_2_79(2147483647)) {
+        label();
+        jj_consume_token(COLON);
+      } else {
+        ;
+      }
+      procedure_call();
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+       jjtree.clearNodeScope(jjtn000);
+       jjtc000 = false;
+     } else {
+       jjtree.popNode();
+     }
+     if (jjte000 instanceof RuntimeException) {
+       {if (true) throw (RuntimeException)jjte000;}
+     }
+     if (jjte000 instanceof ParseException) {
+       {if (true) throw (ParseException)jjte000;}
+     }
+     {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+       jjtree.closeNodeScope(jjtn000, true);
+       if (jjtree.nodeCreated()) {
+        jjtreeCloseNodeScope(jjtn000);
+       }
+     }
+    }
+  }
+
+  final public void process_declarative_item() throws ParseException {
+    if (jj_2_80(2147483647)) {
+      subprogram_declaration();
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case FUNCTION:
+      case IMPURE:
+      case PROCEDURE:
+      case PURE:{
+        subprogram_body();
+        break;
+        }
+      case TYPE:{
+        type_declaration();
+        break;
+        }
+      case SUBTYPE:{
+        subtype_declaration();
+        break;
+        }
+      case CONSTANT:{
+        constant_declaration();
+        break;
+        }
+      case SHARED:
+      case VARIABLE:{
+        variable_declaration();
+        break;
+        }
+      case FILE:{
+        file_declaration();
+        break;
+        }
+      case ALIAS:{
+        alias_declaration();
+        break;
+        }
+      default:
+        jj_la1[195] = jj_gen;
+        if (jj_2_81(2147483647)) {
+          attribute_declaration();
+        } else {
+          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+          case ATTRIBUTE:{
+            attribute_specification();
+            break;
+            }
+          case USE:{
+            use_clause();
+            break;
+            }
+          default:
+            jj_la1[196] = jj_gen;
+            if (jj_2_82(2147483647)) {
+              group_template_declaration();
+            } else {
+              switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+              case GROUP:{
+                group_declaration();
+                break;
+                }
+              default:
+                jj_la1[197] = jj_gen;
+                jj_consume_token(-1);
+                throw new ParseException();
+              }
+            }
+          }
+        }
+      }
+    }
+  }
+
+  final public void process_declarative_part() throws ParseException {/*@bgen(jjtree) process_declarative_part */
+  ASTprocess_declarative_part jjtn000 = new ASTprocess_declarative_part(JJTPROCESS_DECLARATIVE_PART);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      label_38:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case ALIAS:
+        case ATTRIBUTE:
+        case CONSTANT:
+        case FILE:
+        case FUNCTION:
+        case GROUP:
+        case IMPURE:
+        case PROCEDURE:
+        case PURE:
+        case SHARED:
+        case SUBTYPE:
+        case TYPE:
+        case USE:
+        case VARIABLE:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[198] = jj_gen;
+          break label_38;
+        }
+        process_declarative_item();
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void process_statement() throws ParseException {/*@bgen(jjtree) process_statement */
+  ASTprocess_statement jjtn000 = new ASTprocess_statement(JJTPROCESS_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:{
+        process_label();
+        jj_consume_token(COLON);
+        break;
+        }
+      default:
+        jj_la1[199] = jj_gen;
+        ;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case POSTPONED:{
+        jj_consume_token(POSTPONED);
+        break;
+        }
+      default:
+        jj_la1[200] = jj_gen;
+        ;
+      }
+      jj_consume_token(PROCESS);
+jjtn000.newBlock();
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case 158:{
+        jj_consume_token(158);
+        sensitivity_list();
+        jj_consume_token(159);
+        break;
+        }
+      default:
+        jj_la1[201] = jj_gen;
+        ;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case IS:{
+        jj_consume_token(IS);
+        break;
+        }
+      default:
+        jj_la1[202] = jj_gen;
+        ;
+      }
+      process_declarative_part();
+      jj_consume_token(BEGIN);
+      process_statement_part();
+      jj_consume_token(END);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case POSTPONED:{
+        jj_consume_token(POSTPONED);
+        break;
+        }
+      default:
+        jj_la1[203] = jj_gen;
+        ;
+      }
+      jj_consume_token(PROCESS);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:{
+        process_label();
+        break;
+        }
+      default:
+        jj_la1[204] = jj_gen;
+        ;
+      }
+      jj_consume_token(SEMICOLON);
+jjtree.closeNodeScope(jjtn000, true);
+     jjtc000 = false;
+     if (jjtree.nodeCreated()) {
+      jjtreeCloseNodeScope(jjtn000);
+     }
+jjtn000.Check();
+     jjtn000.endBlock();
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+       jjtree.clearNodeScope(jjtn000);
+       jjtc000 = false;
+     } else {
+       jjtree.popNode();
+     }
+     if (jjte000 instanceof RuntimeException) {
+       {if (true) throw (RuntimeException)jjte000;}
+     }
+     if (jjte000 instanceof ParseException) {
+       {if (true) throw (ParseException)jjte000;}
+     }
+     {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+       jjtree.closeNodeScope(jjtn000, true);
+       if (jjtree.nodeCreated()) {
+        jjtreeCloseNodeScope(jjtn000);
+       }
+     }
+    }
+  }
+
+  final public void process_statement_part() throws ParseException {/*@bgen(jjtree) process_statement_part */
+  ASTprocess_statement_part jjtn000 = new ASTprocess_statement_part(JJTPROCESS_STATEMENT_PART);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      label_39:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case ASSERT:
+        case BREAK:
+        case CASE:
+        case EXIT:
+        case FOR:
+        case IF:
+        case LOOP:
+        case NEXT:
+        case NULL:
+        case REPORT:
+        case RETURN:
+        case WAIT:
+        case WHILE:
+        case basic_identifier:
+        case extended_identifier:
+        case string_literal:
+        case COLON:
+        case 158:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[205] = jj_gen;
+          break label_39;
+        }
+        sequential_statement();
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+/*
+    VHDL 2002: protected types:
+*/
+  final public 
+void protected_type_body() throws ParseException {
+    jj_consume_token(PROTECTED);
+    jj_consume_token(BODY);
+    protected_type_body_declarative_part();
+    jj_consume_token(END);
+    jj_consume_token(PROTECTED);
+    jj_consume_token(BODY);
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case basic_identifier:
+    case extended_identifier:{
+      simple_name();
+      break;
+      }
+    default:
+      jj_la1[206] = jj_gen;
+      ;
+    }
+  }
+
+  final public void protected_type_body_declarative_item() throws ParseException {
+    if (jj_2_83(2147483647)) {
+      subprogram_declaration();
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case FUNCTION:
+      case IMPURE:
+      case PROCEDURE:
+      case PURE:{
+        subprogram_body();
+        break;
+        }
+      case TYPE:{
+        type_declaration();
+        break;
+        }
+      case SUBTYPE:{
+        subtype_declaration();
+        break;
+        }
+      case CONSTANT:{
+        constant_declaration();
+        break;
+        }
+      case SHARED:
+      case VARIABLE:{
+        variable_declaration();
+        break;
+        }
+      case FILE:{
+        file_declaration();
+        break;
+        }
+      case ALIAS:{
+        alias_declaration();
+        break;
+        }
+      default:
+        jj_la1[207] = jj_gen;
+        if (jj_2_84(2147483647)) {
+          attribute_declaration();
+        } else {
+          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+          case ATTRIBUTE:{
+            attribute_specification();
+            break;
+            }
+          case USE:{
+            use_clause();
+            break;
+            }
+          default:
+            jj_la1[208] = jj_gen;
+            if (jj_2_85(2147483647)) {
+              group_template_declaration();
+            } else {
+              switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+              case GROUP:{
+                group_declaration();
+                break;
+                }
+              default:
+                jj_la1[209] = jj_gen;
+                jj_consume_token(-1);
+                throw new ParseException();
+              }
+            }
+          }
+        }
+      }
+    }
+  }
+
+  final public void protected_type_body_declarative_part() throws ParseException {
+    label_40:
+    while (true) {
+      protected_type_body_declarative_item();
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case ALIAS:
+      case ATTRIBUTE:
+      case CONSTANT:
+      case FILE:
+      case FUNCTION:
+      case GROUP:
+      case IMPURE:
+      case PROCEDURE:
+      case PURE:
+      case SHARED:
+      case SUBTYPE:
+      case TYPE:
+      case USE:
+      case VARIABLE:{
+        ;
+        break;
+        }
+      default:
+        jj_la1[210] = jj_gen;
+        break label_40;
+      }
+    }
+  }
+
+  final public void protected_type_declaration() throws ParseException {
+    jj_consume_token(PROTECTED);
+    protected_type_declarative_part();
+    jj_consume_token(END);
+    jj_consume_token(PROTECTED);
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case basic_identifier:
+    case extended_identifier:{
+      simple_name();
+      break;
+      }
+    default:
+      jj_la1[211] = jj_gen;
+      ;
+    }
+  }
+
+  final public void protected_type_declarative_item() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case FUNCTION:
+    case IMPURE:
+    case PROCEDURE:
+    case PURE:{
+      subprogram_declaration();
+      break;
+      }
+    case ATTRIBUTE:{
+      attribute_declaration();
+      break;
+      }
+    case USE:{
+      use_clause();
+      break;
+      }
+    default:
+      jj_la1[212] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void protected_type_declarative_part() throws ParseException {
+    label_41:
+    while (true) {
+      protected_type_declarative_item();
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case ATTRIBUTE:
+      case FUNCTION:
+      case IMPURE:
+      case PROCEDURE:
+      case PURE:
+      case USE:{
+        ;
+        break;
+        }
+      default:
+        jj_la1[213] = jj_gen;
+        break label_41;
+      }
+    }
+  }
+
+  final public void protected_type_definition() throws ParseException {
+    if (jj_2_86(2147483647)) {
+      protected_type_body();
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case PROTECTED:{
+        protected_type_declaration();
+        break;
+        }
+      default:
+        jj_la1[214] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+  }
+
+  final public void qualified_expression() throws ParseException {/*@bgen(jjtree) qualified_expression */
+  ASTqualified_expression jjtn000 = new ASTqualified_expression(JJTQUALIFIED_EXPRESSION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      type_mark();
+      jj_consume_token(161);
+      if (jj_2_87(2147483647)) {
+        aggregate();
+      } else {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case 158:{
+          jj_consume_token(158);
+          expression();
+          jj_consume_token(159);
+          break;
+          }
+        default:
+          jj_la1[215] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void range() throws ParseException {/*@bgen(jjtree) range */
+  ASTrange jjtn000 = new ASTrange(JJTRANGE);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      if (jj_2_88(2147483647)) {
+        simple_expression();
+        direction();
+        simple_expression();
+      } else {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case basic_identifier:
+        case extended_identifier:
+        case string_literal:{
+          range_attribute_name();
+          break;
+          }
+        default:
+          jj_la1[216] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        {if (true) throw (RuntimeException)jjte000;}
+      }
+      if (jjte000 instanceof ParseException) {
+        {if (true) throw (ParseException)jjte000;}
+      }
+      {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+  }
+
+  final public void range_constraint() throws ParseException {
+    jj_consume_token(RANGE);
+    range();
+  }
+
+  final public void record_nature_definition() throws ParseException {/*@bgen(jjtree) record_nature_definition */
+  ASTrecord_nature_definition jjtn000 = new ASTrecord_nature_definition(JJTRECORD_NATURE_DEFINITION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(RECORD);
+      label_42:
+      while (true) {
+        nature_element_declaration();
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case basic_identifier:
+        case extended_identifier:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[217] = jj_gen;
+          break label_42;
+        }
+      }
+      jj_consume_token(END);
+      jj_consume_token(RECORD);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:{
+        record_nature_simple_name();
+        break;
+        }
+      default:
+        jj_la1[218] = jj_gen;
+        ;
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void record_type_definition() throws ParseException {/*@bgen(jjtree) record_type_definition */
+  ASTrecord_type_definition jjtn000 = new ASTrecord_type_definition(JJTRECORD_TYPE_DEFINITION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(RECORD);
+      label_43:
+      while (true) {
+        element_declaration();
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case basic_identifier:
+        case extended_identifier:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[219] = jj_gen;
+          break label_43;
+        }
+      }
+      jj_consume_token(END);
+      jj_consume_token(RECORD);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:{
+        record_type_simple_name();
+        break;
+        }
+      default:
+        jj_la1[220] = jj_gen;
+        ;
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void relation() throws ParseException {int op;
+    shift_expression();
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case EQ:
+    case NEQ:
+    case GE:
+    case LE:
+    case GT:
+    case LO:{
+      op = relational_operator();
+ASTshift_expression jjtn001 = new ASTshift_expression(JJTSHIFT_EXPRESSION);
+    boolean jjtc001 = true;
+    jjtree.openNodeScope(jjtn001);
+    jjtreeOpenNodeScope(jjtn001);
+      try {
+        shift_expression();
+      } catch (Throwable jjte001) {
+if (jjtc001) {
+      jjtree.clearNodeScope(jjtn001);
+      jjtc001 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte001 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte001;}
+    }
+    if (jjte001 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte001;}
+    }
+    {if (true) throw (Error)jjte001;}
+      } finally {
+if (jjtc001) {
+      jjtree.closeNodeScope(jjtn001,  2);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn001);
+      }
+    }
+      }
+      break;
+      }
+    default:
+      jj_la1[221] = jj_gen;
+      ;
+    }
+  }
+
+  final public int relational_operator() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case EQ:{
+      jj_consume_token(EQ);
+{if ("" != null) return EQ;}
+      break;
+      }
+    case NEQ:{
+      jj_consume_token(NEQ);
+{if ("" != null) return NEQ;}
+      break;
+      }
+    case LO:{
+      jj_consume_token(LO);
+{if ("" != null) return LO;}
+      break;
+      }
+    case LE:{
+      jj_consume_token(LE);
+{if ("" != null) return LE;}
+      break;
+      }
+    case GT:{
+      jj_consume_token(GT);
+{if ("" != null) return GT;}
+      break;
+      }
+    case GE:{
+      jj_consume_token(GE);
+{if ("" != null) return GE;}
+      break;
+      }
+    default:
+      jj_la1[222] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    throw new Error("Missing return statement in function");
+  }
+
+  final public void report_statement() throws ParseException {/*@bgen(jjtree) report_statement */
+  ASTreport_statement jjtn000 = new ASTreport_statement(JJTREPORT_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:{
+        label();
+        jj_consume_token(COLON);
+        break;
+        }
+      default:
+        jj_la1[223] = jj_gen;
+        ;
+      }
+      jj_consume_token(REPORT);
+      expression();
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case SEVERITY:{
+        jj_consume_token(SEVERITY);
+        expression();
+        break;
+        }
+      default:
+        jj_la1[224] = jj_gen;
+        ;
+      }
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void return_statement() throws ParseException {/*@bgen(jjtree) return_statement */
+  ASTreturn_statement jjtn000 = new ASTreturn_statement(JJTRETURN_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:{
+        label();
+        jj_consume_token(COLON);
+        break;
+        }
+      default:
+        jj_la1[225] = jj_gen;
+        ;
+      }
+      jj_consume_token(RETURN);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case ABS:
+      case NEW:
+      case NOT:
+      case NULL:
+      case based_literal:
+      case basic_identifier:
+      case bit_string_literal:
+      case character_literal:
+      case decimal_literal:
+      case extended_identifier:
+      case string_literal:
+      case ADD:
+      case SUB:
+      case 158:{
+        expression();
+        break;
+        }
+      default:
+        jj_la1[226] = jj_gen;
+        ;
+      }
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+// 1076.1 - extension:
+  final public void scalar_nature_definition() throws ParseException {/*@bgen(jjtree) scalar_nature_definition */
+  ASTscalar_nature_definition jjtn000 = new ASTscalar_nature_definition(JJTSCALAR_NATURE_DEFINITION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      type_mark();
+      jj_consume_token(ACROSS);
+      type_mark();
+      jj_consume_token(THROUGH);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void scalar_type_definition() throws ParseException {
+    if (jj_2_89(2147483647)) {
+      physical_type_definition();
+    } else if (jj_2_90(2147483647)) {
+      enumeration_type_definition();
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case RANGE:{
+        range_constraint();
+        break;
+        }
+      default:
+        jj_la1[227] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+  }
+
+  final public void secondary_unit() throws ParseException {
+    if (jj_2_91(2147483647)) {
+      architecture_body();
+    } else if (jj_2_92(2147483647)) {
+      package_body();
+    } else {
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void secondary_unit_declaration() throws ParseException {/*@bgen(jjtree) secondary_unit_declaration */
+  ASTsecondary_unit_declaration jjtn000 = new ASTsecondary_unit_declaration(JJTSECONDARY_UNIT_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      identifier();
+      jj_consume_token(EQ);
+      physical_literal();
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void selected_name() throws ParseException {/*@bgen(jjtree) selected_name */
+  ASTselected_name jjtn000 = new ASTselected_name(JJTSELECTED_NAME);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:{
+        simple_name();
+        break;
+        }
+      case string_literal:{
+        operator_symbol();
+        break;
+        }
+      default:
+        jj_la1[228] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      if (jj_2_93(2147483647)) {
+        name_extension();
+      } else {
+        ;
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void selected_signal_assignment() throws ParseException {/*@bgen(jjtree) selected_signal_assignment */
+  ASTselected_signal_assignment jjtn000 = new ASTselected_signal_assignment(JJTSELECTED_SIGNAL_ASSIGNMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(WITH);
+      expression();
+      jj_consume_token(SELECT);
+      target();
+      jj_consume_token(LE);
+      options_();
+      selected_waveforms();
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void selected_waveforms() throws ParseException {/*@bgen(jjtree) selected_waveforms */
+  ASTselected_waveforms jjtn000 = new ASTselected_waveforms(JJTSELECTED_WAVEFORMS);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      waveform();
+      jj_consume_token(WHEN);
+      choices();
+      label_44:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case 160:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[229] = jj_gen;
+          break label_44;
+        }
+        jj_consume_token(160);
+        waveform();
+        jj_consume_token(WHEN);
+        choices();
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void sensitivity_clause() throws ParseException {
+    jj_consume_token(ON);
+    sensitivity_list();
+  }
+
+  final public void sensitivity_list() throws ParseException {/*@bgen(jjtree) sensitivity_list */
+  ASTsensitivity_list jjtn000 = new ASTsensitivity_list(JJTSENSITIVITY_LIST);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      signal_name();
+      label_45:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case 160:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[230] = jj_gen;
+          break label_45;
+        }
+        jj_consume_token(160);
+        signal_name();
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void sequence_of_statements() throws ParseException {/*@bgen(jjtree) sequence_of_statements */
+  ASTsequence_of_statements jjtn000 = new ASTsequence_of_statements(JJTSEQUENCE_OF_STATEMENTS);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      label_46:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case ASSERT:
+        case BREAK:
+        case CASE:
+        case EXIT:
+        case FOR:
+        case IF:
+        case LOOP:
+        case NEXT:
+        case NULL:
+        case REPORT:
+        case RETURN:
+        case WAIT:
+        case WHILE:
+        case basic_identifier:
+        case extended_identifier:
+        case string_literal:
+        case COLON:
+        case 158:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[231] = jj_gen;
+          break label_46;
+        }
+        sequential_statement();
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void sequential_statement() throws ParseException {
+    try {
+      if (jj_2_94(3)) {
+        wait_statement();
+      } else if (jj_2_95(3)) {
+        assertion_statement();
+      } else if (jj_2_96(3)) {
+        report_statement();
+      } else if (jj_2_97(2147483647)) {
+        signal_assignment_statement();
+      } else if (jj_2_98(2147483647)) {
+        variable_assignment_statement();
+      } else if (jj_2_99(3)) {
+        procedure_call_statement();
+      } else if (jj_2_100(3)) {
+        if_statement();
+      } else if (jj_2_101(3)) {
+        case_statement();
+      } else if (jj_2_102(3)) {
+        loop_statement();
+      } else if (jj_2_103(3)) {
+        next_statement();
+      } else if (jj_2_104(3)) {
+        exit_statement();
+      } else if (jj_2_105(3)) {
+        return_statement();
+      } else if (jj_2_106(3)) {
+        null_statement();
+      } else {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case BREAK:
+        case basic_identifier:
+        case extended_identifier:{
+          break_statement();
+          break;
+          }
+        default:
+          jj_la1[232] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+      }
+    } catch (ParseException e) {
+error_skipto(SEMICOLON, "syntax error in sequential statement");
+    }
+  }
+
+  final public void shift_expression() throws ParseException {int op;
+    simple_expression();
+    if (jj_2_107(2)) {
+      op = shift_operator();
+ASTsimple_expression jjtn001 = new ASTsimple_expression(JJTSIMPLE_EXPRESSION);
+    boolean jjtc001 = true;
+    jjtree.openNodeScope(jjtn001);
+    jjtreeOpenNodeScope(jjtn001);
+      try {
+        simple_expression();
+      } catch (Throwable jjte001) {
+if (jjtc001) {
+      jjtree.clearNodeScope(jjtn001);
+      jjtc001 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte001 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte001;}
+    }
+    if (jjte001 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte001;}
+    }
+    {if (true) throw (Error)jjte001;}
+      } finally {
+if (jjtc001) {
+      jjtree.closeNodeScope(jjtn001,  2);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn001);
+      }
+    }
+      }
+    } else {
+      ;
+    }
+  }
+
+  final public int shift_operator() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case SLL:{
+      jj_consume_token(SLL);
+{if ("" != null) return SLL;}
+      break;
+      }
+    case SRL:{
+      jj_consume_token(SRL);
+{if ("" != null) return SRL;}
+      break;
+      }
+    case SLA:{
+      jj_consume_token(SLA);
+{if ("" != null) return SLA;}
+      break;
+      }
+    case SRA:{
+      jj_consume_token(SRA);
+{if ("" != null) return SRA;}
+      break;
+      }
+    case ROL:{
+      jj_consume_token(ROL);
+{if ("" != null) return ROL;}
+      break;
+      }
+    case ROR:{
+      jj_consume_token(ROR);
+{if ("" != null) return ROR;}
+      break;
+      }
+    default:
+      jj_la1[233] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    throw new Error("Missing return statement in function");
+  }
+
+  final public void sign() throws ParseException {/*@bgen(jjtree) sign */
+  ASTsign jjtn000 = new ASTsign(JJTSIGN);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case ADD:{
+        jj_consume_token(ADD);
+        break;
+        }
+      case SUB:{
+        jj_consume_token(SUB);
+        break;
+        }
+      default:
+        jj_la1[234] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    } finally {
+if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+  }
+
+  final public void signal_assignment_statement() throws ParseException {/*@bgen(jjtree) signal_assignment_statement */
+  ASTsignal_assignment_statement jjtn000 = new ASTsignal_assignment_statement(JJTSIGNAL_ASSIGNMENT_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      if (jj_2_108(2147483647)) {
+        label();
+        jj_consume_token(COLON);
+      } else {
+        ;
+      }
+      target();
+      jj_consume_token(LE);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case INERTIAL:
+      case REJECT:
+      case TRANSPORT:{
+        delay_mechanism();
+        break;
+        }
+      default:
+        jj_la1[235] = jj_gen;
+        ;
+      }
+      waveform();
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void signal_declaration() throws ParseException {/*@bgen(jjtree) signal_declaration */
+  ASTsignal_declaration jjtn000 = new ASTsignal_declaration(JJTSIGNAL_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(SIGNAL);
+      identifier_list();
+      jj_consume_token(COLON);
+      subtype_indication();
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case BUS:
+      case REGISTER:{
+        signal_kind();
+        break;
+        }
+      default:
+        jj_la1[236] = jj_gen;
+        ;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case ASSIGN:{
+        jj_consume_token(ASSIGN);
+        expression();
+        break;
+        }
+      default:
+        jj_la1[237] = jj_gen;
+        ;
+      }
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        {if (true) throw (RuntimeException)jjte000;}
+      }
+      if (jjte000 instanceof ParseException) {
+        {if (true) throw (ParseException)jjte000;}
+      }
+      {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+  }
+
+  final public void signal_kind() throws ParseException {/*@bgen(jjtree) signal_kind */
+  ASTsignal_kind jjtn000 = new ASTsignal_kind(JJTSIGNAL_KIND);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case REGISTER:{
+        jj_consume_token(REGISTER);
+        break;
+        }
+      case BUS:{
+        jj_consume_token(BUS);
+        break;
+        }
+      default:
+        jj_la1[238] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    } finally {
+if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+  }
+
+  final public void signal_list() throws ParseException {/*@bgen(jjtree) signal_list */
+  ASTsignal_list jjtn000 = new ASTsignal_list(JJTSIGNAL_LIST);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:
+      case string_literal:{
+        signal_name();
+        label_47:
+        while (true) {
+          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+          case 160:{
+            ;
+            break;
+            }
+          default:
+            jj_la1[239] = jj_gen;
+            break label_47;
+          }
+          jj_consume_token(160);
+          signal_name();
+        }
+        break;
+        }
+      case OTHERS:{
+        jj_consume_token(OTHERS);
+        break;
+        }
+      case ALL:{
+        jj_consume_token(ALL);
+        break;
+        }
+      default:
+        jj_la1[240] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        {if (true) throw (RuntimeException)jjte000;}
+      }
+      if (jjte000 instanceof ParseException) {
+        {if (true) throw (ParseException)jjte000;}
+      }
+      {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+  }
+
+  final public void signature() throws ParseException {/*@bgen(jjtree) signature */
+  ASTsignature jjtn000 = new ASTsignature(JJTSIGNATURE);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:
+      case string_literal:{
+        type_mark();
+        label_48:
+        while (true) {
+          if (jj_2_109(2147483647)) {
+            ;
+          } else {
+            break label_48;
+          }
+          jj_consume_token(160);
+          type_mark();
+        }
+        break;
+        }
+      default:
+        jj_la1[241] = jj_gen;
+        ;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case RETURN:{
+        jj_consume_token(RETURN);
+        type_mark();
+        break;
+        }
+      default:
+        jj_la1[242] = jj_gen;
+        ;
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void simple_expression() throws ParseException {int op;
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case ADD:
+    case SUB:{
+      sign();
+      break;
+      }
+    default:
+      jj_la1[243] = jj_gen;
+      ;
+    }
+    term();
+    label_49:
+    while (true) {
+      if (jj_2_110(2)) {
+        ;
+      } else {
+        break label_49;
+      }
+      op = adding_operator();
+ASTterm jjtn001 = new ASTterm(JJTTERM);
+                                         boolean jjtc001 = true;
+                                         jjtree.openNodeScope(jjtn001);
+                                         jjtreeOpenNodeScope(jjtn001);
+      try {
+        term();
+      } catch (Throwable jjte001) {
+if (jjtc001) {
+                                           jjtree.clearNodeScope(jjtn001);
+                                           jjtc001 = false;
+                                         } else {
+                                           jjtree.popNode();
+                                         }
+                                         if (jjte001 instanceof RuntimeException) {
+                                           {if (true) throw (RuntimeException)jjte001;}
+                                         }
+                                         if (jjte001 instanceof ParseException) {
+                                           {if (true) throw (ParseException)jjte001;}
+                                         }
+                                         {if (true) throw (Error)jjte001;}
+      } finally {
+if (jjtc001) {
+                                           jjtree.closeNodeScope(jjtn001,  2);
+                                           if (jjtree.nodeCreated()) {
+                                            jjtreeCloseNodeScope(jjtn001);
+                                           }
+                                         }
+      }
+    }
+  }
+
+  final public void simple_name() throws ParseException {
+    identifier();
+  }
+
+  final public void slice_name() throws ParseException {/*@bgen(jjtree) slice_name */
+  ASTslice_name jjtn000 = new ASTslice_name(JJTSLICE_NAME);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      prefix();
+      jj_consume_token(158);
+      discrete_range();
+      jj_consume_token(159);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void subprogram_body() throws ParseException {/*@bgen(jjtree) subprogram_body */
+  ASTsubprogram_body jjtn000 = new ASTsubprogram_body(JJTSUBPROGRAM_BODY);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      subprogram_specification();
+      jj_consume_token(IS);
+      subprogram_declarative_part();
+      jj_consume_token(BEGIN);
+      subprogram_statement_part();
+      jj_consume_token(END);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case FUNCTION:
+      case PROCEDURE:{
+        subprogram_kind();
+        break;
+        }
+      default:
+        jj_la1[244] = jj_gen;
+        ;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:
+      case string_literal:{
+        designator();
+        break;
+        }
+      default:
+        jj_la1[245] = jj_gen;
+        ;
+      }
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void subprogram_declaration() throws ParseException {
+    subprogram_specification();
+    jj_consume_token(SEMICOLON);
+  }
+
+  final public void subprogram_declarative_item() throws ParseException {
+    if (jj_2_111(2147483647)) {
+      subprogram_declaration();
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case FUNCTION:
+      case IMPURE:
+      case PROCEDURE:
+      case PURE:{
+        subprogram_body();
+        break;
+        }
+      case TYPE:{
+        type_declaration();
+        break;
+        }
+      case SUBTYPE:{
+        subtype_declaration();
+        break;
+        }
+      case CONSTANT:{
+        constant_declaration();
+        break;
+        }
+      case SHARED:
+      case VARIABLE:{
+        variable_declaration();
+        break;
+        }
+      case FILE:{
+        file_declaration();
+        break;
+        }
+      case ALIAS:{
+        alias_declaration();
+        break;
+        }
+      default:
+        jj_la1[246] = jj_gen;
+        if (jj_2_112(2147483647)) {
+          attribute_declaration();
+        } else {
+          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+          case ATTRIBUTE:{
+            attribute_specification();
+            break;
+            }
+          case USE:{
+            use_clause();
+            break;
+            }
+          default:
+            jj_la1[247] = jj_gen;
+            if (jj_2_113(2147483647)) {
+              group_template_declaration();
+            } else {
+              switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+              case GROUP:{
+                group_declaration();
+                break;
+                }
+              default:
+                jj_la1[248] = jj_gen;
+                jj_consume_token(-1);
+                throw new ParseException();
+              }
+            }
+          }
+        }
+      }
+    }
+  }
+
+  final public void subprogram_declarative_part() throws ParseException {/*@bgen(jjtree) subprogram_declarative_part */
+  ASTsubprogram_declarative_part jjtn000 = new ASTsubprogram_declarative_part(JJTSUBPROGRAM_DECLARATIVE_PART);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      label_50:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case ALIAS:
+        case ATTRIBUTE:
+        case CONSTANT:
+        case FILE:
+        case FUNCTION:
+        case GROUP:
+        case IMPURE:
+        case PROCEDURE:
+        case PURE:
+        case SHARED:
+        case SUBTYPE:
+        case TYPE:
+        case USE:
+        case VARIABLE:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[249] = jj_gen;
+          break label_50;
+        }
+        subprogram_declarative_item();
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public int subprogram_kind() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case PROCEDURE:{
+      jj_consume_token(PROCEDURE);
+{if ("" != null) return PROCEDURE;}
+      break;
+      }
+    case FUNCTION:{
+      jj_consume_token(FUNCTION);
+{if ("" != null) return FUNCTION;}
+      break;
+      }
+    default:
+      jj_la1[250] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    throw new Error("Missing return statement in function");
+  }
+
+  final public void subprogram_specification() throws ParseException {/*@bgen(jjtree) subprogram_specification */
+  ASTsubprogram_specification jjtn000 = new ASTsubprogram_specification(JJTSUBPROGRAM_SPECIFICATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case PROCEDURE:{
+        jj_consume_token(PROCEDURE);
+        designator();
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case 158:{
+          jj_consume_token(158);
+          formal_parameter_list();
+          jj_consume_token(159);
+          break;
+          }
+        default:
+          jj_la1[251] = jj_gen;
+          ;
+        }
+        break;
+        }
+      case FUNCTION:
+      case IMPURE:
+      case PURE:{
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case IMPURE:
+        case PURE:{
+          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+          case PURE:{
+            jj_consume_token(PURE);
+            break;
+            }
+          case IMPURE:{
+            jj_consume_token(IMPURE);
+            break;
+            }
+          default:
+            jj_la1[252] = jj_gen;
+            jj_consume_token(-1);
+            throw new ParseException();
+          }
+          break;
+          }
+        default:
+          jj_la1[253] = jj_gen;
+          ;
+        }
+        jj_consume_token(FUNCTION);
+        designator();
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case 158:{
+          jj_consume_token(158);
+          formal_parameter_list();
+          jj_consume_token(159);
+          break;
+          }
+        default:
+          jj_la1[254] = jj_gen;
+          ;
+        }
+        jj_consume_token(RETURN);
+        type_mark();
+        break;
+        }
+      default:
+        jj_la1[255] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void subprogram_statement_part() throws ParseException {/*@bgen(jjtree) subprogram_statement_part */
+  ASTsubprogram_statement_part jjtn000 = new ASTsubprogram_statement_part(JJTSUBPROGRAM_STATEMENT_PART);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      label_51:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case ASSERT:
+        case BREAK:
+        case CASE:
+        case EXIT:
+        case FOR:
+        case IF:
+        case LOOP:
+        case NEXT:
+        case NULL:
+        case REPORT:
+        case RETURN:
+        case WAIT:
+        case WHILE:
+        case basic_identifier:
+        case extended_identifier:
+        case string_literal:
+        case COLON:
+        case 158:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[256] = jj_gen;
+          break label_51;
+        }
+        sequential_statement();
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void subtype_declaration() throws ParseException {/*@bgen(jjtree) subtype_declaration */
+  ASTsubtype_declaration jjtn000 = new ASTsubtype_declaration(JJTSUBTYPE_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(SUBTYPE);
+      identifier();
+      jj_consume_token(IS);
+      subtype_indication();
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+/**
+ * Section 4.1:
+ */
+  final public void subtype_indication() throws ParseException {/*@bgen(jjtree) subtype_indication */
+  ASTsubtype_indication jjtn000 = new ASTsubtype_indication(JJTSUBTYPE_INDICATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      if (jj_2_118(2147483647)) {
+        resolution_function_name();
+        type_mark();
+        constraint();
+        if (jj_2_114(2147483647)) {
+          tolerance_aspect();
+        } else {
+          ;
+        }
+      } else if (jj_2_119(2147483647)) {
+        type_mark();
+        constraint();
+        if (jj_2_115(2147483647)) {
+          tolerance_aspect();
+        } else {
+          ;
+        }
+      } else if (jj_2_120(2147483647)) {
+        resolution_function_name();
+        type_mark();
+        if (jj_2_116(2147483647)) {
+          tolerance_aspect();
+        } else {
+          ;
+        }
+      } else if (jj_2_121(2147483647)) {
+        type_mark();
+        if (jj_2_117(2147483647)) {
+          tolerance_aspect();
+        } else {
+          ;
+        }
+      } else {
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        {if (true) throw (RuntimeException)jjte000;}
+      }
+      if (jjte000 instanceof ParseException) {
+        {if (true) throw (ParseException)jjte000;}
+      }
+      {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+  }
+
+/**
+ * 1076.1 extension:
+ */
+  final public void tolerance_aspect() throws ParseException {
+    jj_consume_token(TOLERANCE);
+    string_expression();
+  }
+
+/**
+ * Section 4.3.1.6: Quantity declaration
+ * 1076.1 extension:
+ */
+  final public void quantity_declaration() throws ParseException {
+    if (jj_2_122(2147483647)) {
+      free_quantity_declaration();
+    } else if (jj_2_123(2147483647)) {
+      branch_quantity_declaration();
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case QUANTITY:{
+        source_quantity_declaration();
+        break;
+        }
+      default:
+        jj_la1[257] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+  }
+
+/**
+ * 1076.1 extension:
+ */
+  final public void free_quantity_declaration() throws ParseException {/*@bgen(jjtree) free_quantity_declaration */
+  ASTfree_quantity_declaration jjtn000 = new ASTfree_quantity_declaration(JJTFREE_QUANTITY_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(QUANTITY);
+      identifier_list();
+      jj_consume_token(COLON);
+      subtype_indication();
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case ASSIGN:{
+        jj_consume_token(ASSIGN);
+        expression();
+        break;
+        }
+      default:
+        jj_la1[258] = jj_gen;
+        ;
+      }
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+/**
+ * 1076.1 extension:
+ */
+  final public void branch_quantity_declaration() throws ParseException {/*@bgen(jjtree) branch_quantity_declaration */
+  ASTbranch_quantity_declaration jjtn000 = new ASTbranch_quantity_declaration(JJTBRANCH_QUANTITY_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(QUANTITY);
+      if (jj_2_124(2147483647)) {
+        across_aspect();
+      } else {
+        ;
+      }
+      if (jj_2_125(2147483647)) {
+        through_aspect();
+      } else {
+        ;
+      }
+      terminal_aspect();
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+/**
+ * 1076.1 extension:
+ */
+  final public void source_quantity_declaration() throws ParseException {/*@bgen(jjtree) source_quantity_declaration */
+  ASTsource_quantity_declaration jjtn000 = new ASTsource_quantity_declaration(JJTSOURCE_QUANTITY_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(QUANTITY);
+      identifier_list();
+      jj_consume_token(COLON);
+      subtype_indication();
+      source_aspect();
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+/**
+ * 1076.1 extension:
+ */
+  final public void across_aspect() throws ParseException {/*@bgen(jjtree) across_aspect */
+  ASTacross_aspect jjtn000 = new ASTacross_aspect(JJTACROSS_ASPECT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      identifier_list();
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case TOLERANCE:{
+        tolerance_aspect();
+        break;
+        }
+      default:
+        jj_la1[259] = jj_gen;
+        ;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case ASSIGN:{
+        jj_consume_token(ASSIGN);
+        expression();
+        break;
+        }
+      default:
+        jj_la1[260] = jj_gen;
+        ;
+      }
+      jj_consume_token(ACROSS);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+/**
+ * 1076.1 extension:
+ */
+  final public void through_aspect() throws ParseException {/*@bgen(jjtree) through_aspect */
+  ASTthrough_aspect jjtn000 = new ASTthrough_aspect(JJTTHROUGH_ASPECT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      identifier_list();
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case TOLERANCE:{
+        tolerance_aspect();
+        break;
+        }
+      default:
+        jj_la1[261] = jj_gen;
+        ;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case ASSIGN:{
+        jj_consume_token(ASSIGN);
+        expression();
+        break;
+        }
+      default:
+        jj_la1[262] = jj_gen;
+        ;
+      }
+      jj_consume_token(THROUGH);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+/**
+ * 1076.1 extension:
+ */
+  final public void source_aspect() throws ParseException {/*@bgen(jjtree) source_aspect */
+  ASTsource_aspect jjtn000 = new ASTsource_aspect(JJTSOURCE_ASPECT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case SPECTRUM:{
+        jj_consume_token(SPECTRUM);
+        magnitude_simple_expression();
+        jj_consume_token(160);
+        phase_simple_expression();
+        break;
+        }
+      case NOISE:{
+        jj_consume_token(NOISE);
+        magnitude_simple_expression();
+        break;
+        }
+      default:
+        jj_la1[263] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        {if (true) throw (RuntimeException)jjte000;}
+      }
+      if (jjte000 instanceof ParseException) {
+        {if (true) throw (ParseException)jjte000;}
+      }
+      {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+  }
+
+  final public void suffix() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case basic_identifier:
+    case extended_identifier:{
+      simple_name();
+      break;
+      }
+    case character_literal:{
+      jj_consume_token(character_literal);
+      break;
+      }
+    case string_literal:{
+      operator_symbol();
+      break;
+      }
+    case ALL:{
+      jj_consume_token(ALL);
+      break;
+      }
+    default:
+      jj_la1[264] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void target() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case basic_identifier:
+    case extended_identifier:
+    case string_literal:{
+      name();
+      break;
+      }
+    case 158:{
+      aggregate();
+      break;
+      }
+    default:
+      jj_la1[265] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void term() throws ParseException {int op;
+    factor();
+    label_52:
+    while (true) {
+      if (jj_2_126(2)) {
+        ;
+      } else {
+        break label_52;
+      }
+      op = multiplying_operator();
+ASTfactor jjtn001 = new ASTfactor(JJTFACTOR);
+                                                        boolean jjtc001 = true;
+                                                        jjtree.openNodeScope(jjtn001);
+                                                        jjtreeOpenNodeScope(jjtn001);
+      try {
+        factor();
+      } catch (Throwable jjte001) {
+if (jjtc001) {
+                                                          jjtree.clearNodeScope(jjtn001);
+                                                          jjtc001 = false;
+                                                        } else {
+                                                          jjtree.popNode();
+                                                        }
+                                                        if (jjte001 instanceof RuntimeException) {
+                                                          {if (true) throw (RuntimeException)jjte001;}
+                                                        }
+                                                        if (jjte001 instanceof ParseException) {
+                                                          {if (true) throw (ParseException)jjte001;}
+                                                        }
+                                                        {if (true) throw (Error)jjte001;}
+      } finally {
+if (jjtc001) {
+                                                          jjtree.closeNodeScope(jjtn001,  2);
+                                                          if (jjtree.nodeCreated()) {
+                                                           jjtreeCloseNodeScope(jjtn001);
+                                                          }
+                                                        }
+      }
+    }
+  }
+
+  final public void timeout_clause() throws ParseException {
+    jj_consume_token(FOR);
+    time_or_real_expression();
+  }
+
+  final public void type_conversion() throws ParseException {/*@bgen(jjtree) type_conversion */
+  ASTtype_conversion jjtn000 = new ASTtype_conversion(JJTTYPE_CONVERSION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      type_mark();
+      jj_consume_token(158);
+      expression();
+      jj_consume_token(159);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void type_declaration() throws ParseException {
+    if (jj_2_127(2147483647)) {
+      full_type_declaration();
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case TYPE:{
+        incomplete_type_declaration();
+        break;
+        }
+      default:
+        jj_la1[266] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+  }
+
+  final public void type_definition() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case RANGE:
+    case 158:{
+      scalar_type_definition();
+      break;
+      }
+    case ARRAY:
+    case RECORD:{
+      composite_type_definition();
+      break;
+      }
+    case ACCESS:{
+      access_type_definition();
+      break;
+      }
+    case FILE:{
+      file_type_definition();
+      break;
+      }
+    case PROTECTED:{
+      protected_type_definition();
+      break;
+      }
+    default:
+      jj_la1[267] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void type_mark() throws ParseException {
+    if (jj_2_128(2147483647)) {
+      type_name();
+    } else if (jj_2_129(2147483647)) {
+      subtype_name();
+    } else {
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void unconstrained_array_definition() throws ParseException {/*@bgen(jjtree) unconstrained_array_definition */
+  ASTunconstrained_array_definition jjtn000 = new ASTunconstrained_array_definition(JJTUNCONSTRAINED_ARRAY_DEFINITION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(ARRAY);
+      jj_consume_token(158);
+      index_subtype_definition();
+      label_53:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case 160:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[268] = jj_gen;
+          break label_53;
+        }
+        jj_consume_token(160);
+        index_subtype_definition();
+      }
+      jj_consume_token(159);
+      jj_consume_token(OF);
+      element_subtype_indication();
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void use_clause() throws ParseException {/*@bgen(jjtree) use_clause */
+  ASTuse_clause jjtn000 = new ASTuse_clause(JJTUSE_CLAUSE);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(USE);
+      selected_name();
+      label_54:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case 160:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[269] = jj_gen;
+          break label_54;
+        }
+        jj_consume_token(160);
+        selected_name();
+      }
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+       jjtree.clearNodeScope(jjtn000);
+       jjtc000 = false;
+     } else {
+       jjtree.popNode();
+     }
+     if (jjte000 instanceof RuntimeException) {
+       {if (true) throw (RuntimeException)jjte000;}
+     }
+     if (jjte000 instanceof ParseException) {
+       {if (true) throw (ParseException)jjte000;}
+     }
+     {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+       jjtree.closeNodeScope(jjtn000, true);
+       if (jjtree.nodeCreated()) {
+        jjtreeCloseNodeScope(jjtn000);
+       }
+     }
+    }
+  }
+
+  final public void variable_assignment_statement() throws ParseException {/*@bgen(jjtree) variable_assignment_statement */
+  ASTvariable_assignment_statement jjtn000 = new ASTvariable_assignment_statement(JJTVARIABLE_ASSIGNMENT_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      if (jj_2_130(2147483647)) {
+        label();
+        jj_consume_token(COLON);
+      } else {
+        ;
+      }
+      target();
+      jj_consume_token(ASSIGN);
+      expression();
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void variable_declaration() throws ParseException {/*@bgen(jjtree) variable_declaration */
+  ASTvariable_declaration jjtn000 = new ASTvariable_declaration(JJTVARIABLE_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case SHARED:{
+        jj_consume_token(SHARED);
+        break;
+        }
+      default:
+        jj_la1[270] = jj_gen;
+        ;
+      }
+      jj_consume_token(VARIABLE);
+      identifier_list();
+      jj_consume_token(COLON);
+      subtype_indication();
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case ASSIGN:{
+        jj_consume_token(ASSIGN);
+        expression();
+        break;
+        }
+      default:
+        jj_la1[271] = jj_gen;
+        ;
+      }
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void wait_statement() throws ParseException {/*@bgen(jjtree) wait_statement */
+  ASTwait_statement jjtn000 = new ASTwait_statement(JJTWAIT_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      if (jj_2_131(2147483647)) {
+        jj_consume_token(COLON);
+        label();
+        jj_consume_token(COLON);
+      } else {
+        ;
+      }
+      jj_consume_token(WAIT);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case ON:{
+        sensitivity_clause();
+        break;
+        }
+      default:
+        jj_la1[272] = jj_gen;
+        ;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case UNTIL:{
+        condition_clause();
+        break;
+        }
+      default:
+        jj_la1[273] = jj_gen;
+        ;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case FOR:{
+        timeout_clause();
+        break;
+        }
+      default:
+        jj_la1[274] = jj_gen;
+        ;
+      }
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+       jjtree.clearNodeScope(jjtn000);
+       jjtc000 = false;
+     } else {
+       jjtree.popNode();
+     }
+     if (jjte000 instanceof RuntimeException) {
+       {if (true) throw (RuntimeException)jjte000;}
+     }
+     if (jjte000 instanceof ParseException) {
+       {if (true) throw (ParseException)jjte000;}
+     }
+     {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+       jjtree.closeNodeScope(jjtn000, true);
+       if (jjtree.nodeCreated()) {
+        jjtreeCloseNodeScope(jjtn000);
+       }
+     }
+    }
+  }
+
+  final public void waveform() throws ParseException {/*@bgen(jjtree) waveform */
+  ASTwaveform jjtn000 = new ASTwaveform(JJTWAVEFORM);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case ABS:
+      case NEW:
+      case NOT:
+      case NULL:
+      case based_literal:
+      case basic_identifier:
+      case bit_string_literal:
+      case character_literal:
+      case decimal_literal:
+      case extended_identifier:
+      case string_literal:
+      case ADD:
+      case SUB:
+      case 158:{
+        waveform_element();
+        label_55:
+        while (true) {
+          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+          case 160:{
+            ;
+            break;
+            }
+          default:
+            jj_la1[275] = jj_gen;
+            break label_55;
+          }
+          jj_consume_token(160);
+          waveform_element();
+        }
+        break;
+        }
+      case UNAFFECTED:{
+        jj_consume_token(UNAFFECTED);
+        break;
+        }
+      default:
+        jj_la1[276] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  final public void waveform_element() throws ParseException {/*@bgen(jjtree) waveform_element */
+  ASTwaveform_element jjtn000 = new ASTwaveform_element(JJTWAVEFORM_ELEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      if (jj_2_132(2147483647)) {
+        jj_consume_token(NULL);
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case AFTER:{
+          jj_consume_token(AFTER);
+          time_expression();
+          break;
+          }
+        default:
+          jj_la1[277] = jj_gen;
+          ;
+        }
+      } else {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case ABS:
+        case NEW:
+        case NOT:
+        case NULL:
+        case based_literal:
+        case basic_identifier:
+        case bit_string_literal:
+        case character_literal:
+        case decimal_literal:
+        case extended_identifier:
+        case string_literal:
+        case ADD:
+        case SUB:
+        case 158:{
+          value_expression();
+          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+          case AFTER:{
+            jj_consume_token(AFTER);
+            time_expression();
+            break;
+            }
+          default:
+            jj_la1[278] = jj_gen;
+            ;
+          }
+          break;
+          }
+        default:
+          jj_la1[279] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+         jjtree.clearNodeScope(jjtn000);
+         jjtc000 = false;
+       } else {
+         jjtree.popNode();
+       }
+       if (jjte000 instanceof RuntimeException) {
+         {if (true) throw (RuntimeException)jjte000;}
+       }
+       if (jjte000 instanceof ParseException) {
+         {if (true) throw (ParseException)jjte000;}
+       }
+       {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+         jjtree.closeNodeScope(jjtn000, true);
+         if (jjtree.nodeCreated()) {
+          jjtreeCloseNodeScope(jjtn000);
+         }
+       }
+    }
+  }
+
+/** 
+ *Section 15: Simultaneous statements
+ * 1076.1 extension
+ */
+  final public void simultaneous_statement_part() throws ParseException {/*@bgen(jjtree) simultaneous_statement_part */
+  ASTsimultaneous_statement_part jjtn000 = new ASTsimultaneous_statement_part(JJTSIMULTANEOUS_STATEMENT_PART);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      label_56:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case ABS:
+        case CASE:
+        case IF:
+        case IMPURE:
+        case NEW:
+        case NOT:
+        case NULL:
+        case PROCEDURAL:
+        case PURE:
+        case based_literal:
+        case basic_identifier:
+        case bit_string_literal:
+        case character_literal:
+        case decimal_literal:
+        case extended_identifier:
+        case string_literal:
+        case ADD:
+        case SUB:
+        case 158:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[280] = jj_gen;
+          break label_56;
+        }
+        simultaneous_statement();
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+/**
+ * 1076.1 extension:
+ */
+  final public void simultaneous_statement() throws ParseException {
+    if (jj_2_133(2147483647)) {
+      simple_simultaneous_statement();
+    } else if (jj_2_134(2147483647)) {
+      simultaneous_if_statement();
+    } else if (jj_2_135(2147483647)) {
+      simultaneous_case_statement();
+    } else if (jj_2_136(4)) {
+      simultaneous_procedural_statement();
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case NULL:
+      case basic_identifier:
+      case extended_identifier:{
+        simultaneous_null_statement();
+        break;
+        }
+      default:
+        jj_la1[281] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+  }
+
+/**
+ * 1076.1 extension:
+ */
+  final public void simple_simultaneous_statement() throws ParseException {/*@bgen(jjtree) simple_simultaneous_statement */
+  ASTsimple_simultaneous_statement jjtn000 = new ASTsimple_simultaneous_statement(JJTSIMPLE_SIMULTANEOUS_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      if (jj_2_137(2147483647)) {
+        label();
+        jj_consume_token(COLON);
+      } else {
+        ;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case IMPURE:
+      case PURE:{
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case PURE:{
+          jj_consume_token(PURE);
+          break;
+          }
+        case IMPURE:{
+          jj_consume_token(IMPURE);
+          break;
+          }
+        default:
+          jj_la1[282] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+        break;
+        }
+      default:
+        jj_la1[283] = jj_gen;
+        ;
+      }
+      simple_expression();
+      jj_consume_token(165);
+      simple_expression();
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case TOLERANCE:{
+        tolerance_aspect();
+        break;
+        }
+      default:
+        jj_la1[284] = jj_gen;
+        ;
+      }
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+/**
+ * 1076.1 extension:
+ */
+  final public void simultaneous_if_statement() throws ParseException {/*@bgen(jjtree) simultaneous_if_statement */
+  ASTsimultaneous_if_statement jjtn000 = new ASTsimultaneous_if_statement(JJTSIMULTANEOUS_IF_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:{
+        if_label();
+        jj_consume_token(COLON);
+        break;
+        }
+      default:
+        jj_la1[285] = jj_gen;
+        ;
+      }
+      jj_consume_token(IF);
+      condition();
+      jj_consume_token(USE);
+      simultaneous_statement_part();
+      label_57:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case ELSIF:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[286] = jj_gen;
+          break label_57;
+        }
+        jj_consume_token(ELSIF);
+        condition();
+        jj_consume_token(USE);
+        simultaneous_statement_part();
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case ELSE:{
+        jj_consume_token(ELSE);
+        simultaneous_statement_part();
+        break;
+        }
+      default:
+        jj_la1[287] = jj_gen;
+        ;
+      }
+      jj_consume_token(END);
+      jj_consume_token(USE);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:{
+        if_label();
+        break;
+        }
+      default:
+        jj_la1[288] = jj_gen;
+        ;
+      }
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+/**
+ * 1076.1 extension:
+ */
+  final public void simultaneous_case_statement() throws ParseException {/*@bgen(jjtree) simultaneous_case_statement */
+  ASTsimultaneous_case_statement jjtn000 = new ASTsimultaneous_case_statement(JJTSIMULTANEOUS_CASE_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:{
+        case_label();
+        jj_consume_token(COLON);
+        break;
+        }
+      default:
+        jj_la1[289] = jj_gen;
+        ;
+      }
+      jj_consume_token(CASE);
+      expression();
+      jj_consume_token(USE);
+      label_58:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case WHEN:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[290] = jj_gen;
+          break label_58;
+        }
+        simultaneous_alternative();
+      }
+      jj_consume_token(END);
+      jj_consume_token(CASE);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:{
+        case_label();
+        break;
+        }
+      default:
+        jj_la1[291] = jj_gen;
+        ;
+      }
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+/**
+ * 1076.1 extension:
+ */
+  final public void simultaneous_alternative() throws ParseException {/*@bgen(jjtree) simultaneous_alternative */
+  ASTsimultaneous_alternative jjtn000 = new ASTsimultaneous_alternative(JJTSIMULTANEOUS_ALTERNATIVE);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      jj_consume_token(WHEN);
+      choices();
+      jj_consume_token(USE);
+      simultaneous_statement_part();
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+/**
+ * 1076.1 extension:
+ */
+  final public void simultaneous_procedural_statement() throws ParseException {/*@bgen(jjtree) simultaneous_procedural_statement */
+  ASTsimultaneous_procedural_statement jjtn000 = new ASTsimultaneous_procedural_statement(JJTSIMULTANEOUS_PROCEDURAL_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:{
+        procedural_label();
+        jj_consume_token(COLON);
+        break;
+        }
+      default:
+        jj_la1[292] = jj_gen;
+        ;
+      }
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case IMPURE:
+      case PURE:{
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case PURE:{
+          jj_consume_token(PURE);
+          break;
+          }
+        case IMPURE:{
+          jj_consume_token(IMPURE);
+          break;
+          }
+        default:
+          jj_la1[293] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
+        break;
+        }
+      default:
+        jj_la1[294] = jj_gen;
+        ;
+      }
+      jj_consume_token(PROCEDURAL);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case IS:{
+        jj_consume_token(IS);
+        break;
+        }
+      default:
+        jj_la1[295] = jj_gen;
+        ;
+      }
+      procedural_declarative_part();
+      jj_consume_token(BEGIN);
+      procedural_statement_part();
+      jj_consume_token(END);
+      jj_consume_token(PROCEDURAL);
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:{
+        procedural_label();
+        break;
+        }
+      default:
+        jj_la1[296] = jj_gen;
+        ;
+      }
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+// 1076.1 extension:
+  final public void procedural_label() throws ParseException {
+    label();
+  }
+
+// 1076.1 extension:
+  final public void procedural_declarative_part() throws ParseException {/*@bgen(jjtree) procedural_declarative_part */
+  ASTprocedural_declarative_part jjtn000 = new ASTprocedural_declarative_part(JJTPROCEDURAL_DECLARATIVE_PART);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      label_59:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case ALIAS:
+        case ATTRIBUTE:
+        case CONSTANT:
+        case FUNCTION:
+        case GROUP:
+        case IMPURE:
+        case PROCEDURE:
+        case PURE:
+        case SHARED:
+        case SUBTYPE:
+        case TYPE:
+        case USE:
+        case VARIABLE:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[297] = jj_gen;
+          break label_59;
+        }
+        procedural_declarative_item();
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+/**
+ * 1076.1 extension:
+ */
+  final public void procedural_declarative_item() throws ParseException {
+    if (jj_2_138(2147483647)) {
+      subprogram_declaration();
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case FUNCTION:
+      case IMPURE:
+      case PROCEDURE:
+      case PURE:{
+        subprogram_body();
+        break;
+        }
+      case TYPE:{
+        type_declaration();
+        break;
+        }
+      case SUBTYPE:{
+        subtype_declaration();
+        break;
+        }
+      case CONSTANT:{
+        constant_declaration();
+        break;
+        }
+      case SHARED:
+      case VARIABLE:{
+        variable_declaration();
+        break;
+        }
+      case ALIAS:{
+        alias_declaration();
+        break;
+        }
+      default:
+        jj_la1[298] = jj_gen;
+        if (jj_2_139(2147483647)) {
+          attribute_declaration();
+        } else {
+          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+          case ATTRIBUTE:{
+            attribute_specification();
+            break;
+            }
+          case USE:{
+            use_clause();
+            break;
+            }
+          default:
+            jj_la1[299] = jj_gen;
+            if (jj_2_140(2147483647)) {
+              group_template_declaration();
+            } else {
+              switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+              case GROUP:{
+                group_declaration();
+                break;
+                }
+              default:
+                jj_la1[300] = jj_gen;
+                jj_consume_token(-1);
+                throw new ParseException();
+              }
+            }
+          }
+        }
+      }
+    }
+  }
+
+/**
+ * 1076.1 extension:
+ */
+  final public void procedural_statement_part() throws ParseException {/*@bgen(jjtree) procedural_statement_part */
+  ASTprocedural_statement_part jjtn000 = new ASTprocedural_statement_part(JJTPROCEDURAL_STATEMENT_PART);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      label_60:
+      while (true) {
+        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+        case ASSERT:
+        case BREAK:
+        case CASE:
+        case EXIT:
+        case FOR:
+        case IF:
+        case LOOP:
+        case NEXT:
+        case NULL:
+        case REPORT:
+        case RETURN:
+        case WAIT:
+        case WHILE:
+        case basic_identifier:
+        case extended_identifier:
+        case string_literal:
+        case COLON:
+        case 158:{
+          ;
+          break;
+          }
+        default:
+          jj_la1[301] = jj_gen;
+          break label_60;
+        }
+        sequential_statement();
+      }
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+// 1076.1 extension:
+  final public void simultaneous_null_statement() throws ParseException {/*@bgen(jjtree) simultaneous_null_statement */
+  ASTsimultaneous_null_statement jjtn000 = new ASTsimultaneous_null_statement(JJTSIMULTANEOUS_NULL_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case basic_identifier:
+      case extended_identifier:{
+        label();
+        jj_consume_token(COLON);
+        break;
+        }
+      default:
+        jj_la1[302] = jj_gen;
+        ;
+      }
+      jj_consume_token(NULL);
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+//
+// parts of grammar, which have to be checked during semantic analysis
+// by semantic lookahead:
+//
+  final public void block_label() throws ParseException {
+    label();
+  }
+
+  final public void block_statement_label() throws ParseException {
+    label();
+  }
+
+  final public void case_label() throws ParseException {
+    label();
+  }
+
+  final public void generate_label() throws ParseException {
+    label();
+  }
+
+  final public void generate_statement_label() throws ParseException {
+    label();
+  }
+
+  final public void if_label() throws ParseException {
+    label();
+  }
+
+  final public void instantiation_label() throws ParseException {
+    label();
+  }
+
+  final public void loop_label() throws ParseException {
+    label();
+  }
+
+  final public void process_label() throws ParseException {
+    label();
+  }
+
+  final public void architecture_simple_name() throws ParseException {
+    simple_name();
+  }
+
+  final public void attribute_simple_name() throws ParseException {
+    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+    case basic_identifier:
+    case extended_identifier:{
+      simple_name();
+      break;
+      }
+    case RANGE:{
+      jj_consume_token(RANGE);
+      break;
+      }
+    default:
+      jj_la1[303] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+  }
+
+  final public void component_simple_name() throws ParseException {
+    simple_name();
+  }
+
+  final public void configuration_simple_name() throws ParseException {
+    simple_name();
+  }
+
+  final public void element_simple_name() throws ParseException {
+    simple_name();
+  }
+
+  final public void entity_simple_name() throws ParseException {
+    simple_name();
+  }
+
+  final public void package_simple_name() throws ParseException {
+    simple_name();
+  }
+
+  final public void architecture_name() throws ParseException {
+    name();
+  }
+
+  final public void entity_name() throws ParseException {
+    name();
+  }
+
+  final public void file_name() throws ParseException {
+    name();
+  }
+
+  final public void function_name() throws ParseException {
+    name();
+  }
+
+  final public void configuration_name() throws ParseException {
+    name();
+  }
+
+  final public void component_name() throws ParseException {
+    name();
+  }
+
+  final public void generic_name() throws ParseException {
+    name();
+  }
+
+  final public void group_template_name() throws ParseException {
+    name();
+  }
+
+  final public void parameter_name() throws ParseException {
+    name();
+  }
+
+  final public void physical_type_simple_name() throws ParseException {
+    simple_name();
+  }
+
+  final public void port_name() throws ParseException {
+    name();
+  }
+
+  final public void procedure_name() throws ParseException {
+    name();
+  }
+
+  final public void range_attribute_name() throws ParseException {
+    name();
+  }
+
+  final public void signal_name() throws ParseException {
+    name();
+  }
+
+//
+// Name, der einen Typen bezeichnet...
+//
+  final public void type_name() throws ParseException {
+    name();
+  }
+
+// 1076.1 extension:
+  final public void record_nature_simple_name() throws ParseException {
+    simple_name();
+  }
+
+  final public void record_type_simple_name() throws ParseException {
+    simple_name();
+  }
+
+  final public void resolution_function_name() throws ParseException {
+    name();
+  }
+
+  final public void subtype_name() throws ParseException {
+    name();
+  }
+
+  final public void unit_name() throws ParseException {
+    name();
+  }
+
+  final public void variable_name() throws ParseException {
+    name();
+  }
+
+  final public void architecture_identifier() throws ParseException {
+    identifier();
+  }
+
+  final public void static_expression() throws ParseException {
+    expression();
+  }
+
+  final public void boolean_expression() throws ParseException {
+    expression();
+  }
+
+  final public void file_open_kind_expression() throws ParseException {
+    expression();
+  }
+
+  final public void guard_expression() throws ParseException {
+    expression();
+  }
+
+  final public void time_expression() throws ParseException {
+    expression();
+  }
+
+// 1076.1 extension:
+  final public void time_or_real_expression() throws ParseException {
+    expression();
+  }
+
+  final public void value_expression() throws ParseException {
+    expression();
+  }
+
+  final public void string_expression() throws ParseException {
+    expression();
+  }
+
+  final public void guarded_signal_list() throws ParseException {
+    signal_list();
+  }
+
+  final public void parameter_association_list() throws ParseException {
+    association_list();
+  }
+
+  final public void port_association_list() throws ParseException {
+    association_list();
+  }
+
+  final public void generic_association_list() throws ParseException {
+    association_list();
+  }
+
+  final public void generic_interface_list() throws ParseException {
+    interface_list();
+  }
+
+  final public void parameter_interface_list() throws ParseException {
+    interface_list();
+  }
+
+  final public void port_interface_list() throws ParseException {
+    interface_list();
+  }
+
+//
+// fraglich:
+//
+  final public void formal_port_clause() throws ParseException {
+    port_clause();
+  }
+
+  final public void local_port_clause() throws ParseException {
+    port_clause();
+  }
+
+  final public void formal_generic_clause() throws ParseException {
+    generic_clause();
+  }
+
+  final public void local_generic_clause() throws ParseException {
+    generic_clause();
+  }
+
+  final public void element_subtype_indication() throws ParseException {
+    subtype_indication();
+  }
+
+  final public void discrete_subtype_indication() throws ParseException {
+    subtype_indication();
+  }
+
+  final public void loop_parameter_specification() throws ParseException {
+    parameter_specification();
+  }
+
+  final public void generate_parameter_specification() throws ParseException {
+    parameter_specification();
+  }
+
+  final public void passive_concurrent_procedure_call_statement() throws ParseException {
+    concurrent_procedure_call_statement();
+  }
+
+  final public void passive_process_statement() throws ParseException {
+    process_statement();
+  }
+
+  final public void magnitude_simple_expression() throws ParseException {
+    simple_expression();
+  }
+
+  final public void phase_simple_expression() throws ParseException {
+    simple_expression();
+  }
+
+  final public void nature_name() throws ParseException {
+    name();
+  }
+
+  final public void subnature_name() throws ParseException {
+    name();
+  }
+
+/**
+ * 1076.1 extension:
+ */
+  final public void terminal_name() throws ParseException {
+    name();
+  }
+
+/**
+ * 1076.1 extension:
+ */
+  final public void quantity_name() throws ParseException {
+    name();
+  }
+
+/**
+ * 1076.1 extension:
+ */
+  final public void plus_terminal_name() throws ParseException {
+    name();
+  }
+
+/**
+ * 1076.1 extension:
+ */
+  final public void minus_terminal_name() throws ParseException {
+    name();
+  }
+
+/**
+ * still missing:
+ */
+  final public void shared_variable_declaration() throws ParseException {/*@bgen(jjtree) shared_variable_declaration */
+  ASTshared_variable_declaration jjtn000 = new ASTshared_variable_declaration(JJTSHARED_VARIABLE_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+    try {
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case SHARED:{
+        jj_consume_token(SHARED);
+        break;
+        }
+      default:
+        jj_la1[304] = jj_gen;
+        ;
+      }
+      jj_consume_token(VARIABLE);
+      identifier_list();
+      jj_consume_token(COLON);
+      subtype_indication();
+      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
+      case ASSIGN:{
+        jj_consume_token(ASSIGN);
+        expression();
+        break;
+        }
+      default:
+        jj_la1[305] = jj_gen;
+        ;
+      }
+      jj_consume_token(SEMICOLON);
+    } catch (Throwable jjte000) {
+if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      {if (true) throw (RuntimeException)jjte000;}
+    }
+    if (jjte000 instanceof ParseException) {
+      {if (true) throw (ParseException)jjte000;}
+    }
+    {if (true) throw (Error)jjte000;}
+    } finally {
+if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+    }
+  }
+
+  void error_skipto(int kind, String message) throws ParseException {/*@bgen(jjtree) error_skipto */
+ASTerror_skipto jjtn000 = new ASTerror_skipto(JJTERROR_SKIPTO);
+boolean jjtc000 = true;
+jjtree.openNodeScope(jjtn000);
+jjtreeOpenNodeScope(jjtn000);
+try {errs.Error(message,null);
+  Token t;
+  do
+  {
+    t = getNextToken();
+  } while ((t.kind != kind) && t.next != null);/*@bgen(jjtree)*/
+} finally {
+  if (jjtc000) {
+    jjtree.closeNodeScope(jjtn000, true);
+    if (jjtree.nodeCreated()) {
+     jjtreeCloseNodeScope(jjtn000);
+    }
+  }
+}
+  }
+
+  private boolean jj_2_1(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_1(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(0, xla); }
+  }
+
+  private boolean jj_2_2(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_2(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(1, xla); }
+  }
+
+  private boolean jj_2_3(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_3(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(2, xla); }
+  }
+
+  private boolean jj_2_4(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_4(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(3, xla); }
+  }
+
+  private boolean jj_2_5(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_5(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(4, xla); }
+  }
+
+  private boolean jj_2_6(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_6(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(5, xla); }
+  }
+
+  private boolean jj_2_7(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_7(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(6, xla); }
+  }
+
+  private boolean jj_2_8(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_8(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(7, xla); }
+  }
+
+  private boolean jj_2_9(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_9(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(8, xla); }
+  }
+
+  private boolean jj_2_10(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_10(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(9, xla); }
+  }
+
+  private boolean jj_2_11(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_11(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(10, xla); }
+  }
+
+  private boolean jj_2_12(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_12(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(11, xla); }
+  }
+
+  private boolean jj_2_13(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_13(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(12, xla); }
+  }
+
+  private boolean jj_2_14(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_14(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(13, xla); }
+  }
+
+  private boolean jj_2_15(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_15(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(14, xla); }
+  }
+
+  private boolean jj_2_16(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_16(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(15, xla); }
+  }
+
+  private boolean jj_2_17(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_17(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(16, xla); }
+  }
+
+  private boolean jj_2_18(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_18(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(17, xla); }
+  }
+
+  private boolean jj_2_19(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_19(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(18, xla); }
+  }
+
+  private boolean jj_2_20(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_20(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(19, xla); }
+  }
+
+  private boolean jj_2_21(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_21(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(20, xla); }
+  }
+
+  private boolean jj_2_22(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_22(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(21, xla); }
+  }
+
+  private boolean jj_2_23(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_23(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(22, xla); }
+  }
+
+  private boolean jj_2_24(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_24(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(23, xla); }
+  }
+
+  private boolean jj_2_25(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_25(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(24, xla); }
+  }
+
+  private boolean jj_2_26(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_26(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(25, xla); }
+  }
+
+  private boolean jj_2_27(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_27(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(26, xla); }
+  }
+
+  private boolean jj_2_28(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_28(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(27, xla); }
+  }
+
+  private boolean jj_2_29(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_29(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(28, xla); }
+  }
+
+  private boolean jj_2_30(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_30(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(29, xla); }
+  }
+
+  private boolean jj_2_31(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_31(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(30, xla); }
+  }
+
+  private boolean jj_2_32(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_32(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(31, xla); }
+  }
+
+  private boolean jj_2_33(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_33(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(32, xla); }
+  }
+
+  private boolean jj_2_34(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_34(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(33, xla); }
+  }
+
+  private boolean jj_2_35(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_35(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(34, xla); }
+  }
+
+  private boolean jj_2_36(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_36(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(35, xla); }
+  }
+
+  private boolean jj_2_37(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_37(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(36, xla); }
+  }
+
+  private boolean jj_2_38(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_38(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(37, xla); }
+  }
+
+  private boolean jj_2_39(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_39(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(38, xla); }
+  }
+
+  private boolean jj_2_40(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_40(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(39, xla); }
+  }
+
+  private boolean jj_2_41(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_41(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(40, xla); }
+  }
+
+  private boolean jj_2_42(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_42(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(41, xla); }
+  }
+
+  private boolean jj_2_43(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_43(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(42, xla); }
+  }
+
+  private boolean jj_2_44(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_44(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(43, xla); }
+  }
+
+  private boolean jj_2_45(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_45(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(44, xla); }
+  }
+
+  private boolean jj_2_46(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_46(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(45, xla); }
+  }
+
+  private boolean jj_2_47(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_47(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(46, xla); }
+  }
+
+  private boolean jj_2_48(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_48(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(47, xla); }
+  }
+
+  private boolean jj_2_49(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_49(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(48, xla); }
+  }
+
+  private boolean jj_2_50(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_50(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(49, xla); }
+  }
+
+  private boolean jj_2_51(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_51(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(50, xla); }
+  }
+
+  private boolean jj_2_52(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_52(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(51, xla); }
+  }
+
+  private boolean jj_2_53(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_53(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(52, xla); }
+  }
+
+  private boolean jj_2_54(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_54(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(53, xla); }
+  }
+
+  private boolean jj_2_55(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_55(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(54, xla); }
+  }
+
+  private boolean jj_2_56(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_56(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(55, xla); }
+  }
+
+  private boolean jj_2_57(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_57(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(56, xla); }
+  }
+
+  private boolean jj_2_58(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_58(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(57, xla); }
+  }
+
+  private boolean jj_2_59(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_59(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(58, xla); }
+  }
+
+  private boolean jj_2_60(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_60(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(59, xla); }
+  }
+
+  private boolean jj_2_61(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_61(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(60, xla); }
+  }
+
+  private boolean jj_2_62(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_62(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(61, xla); }
+  }
+
+  private boolean jj_2_63(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_63(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(62, xla); }
+  }
+
+  private boolean jj_2_64(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_64(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(63, xla); }
+  }
+
+  private boolean jj_2_65(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_65(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(64, xla); }
+  }
+
+  private boolean jj_2_66(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_66(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(65, xla); }
+  }
+
+  private boolean jj_2_67(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_67(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(66, xla); }
+  }
+
+  private boolean jj_2_68(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_68(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(67, xla); }
+  }
+
+  private boolean jj_2_69(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_69(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(68, xla); }
+  }
+
+  private boolean jj_2_70(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_70(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(69, xla); }
+  }
+
+  private boolean jj_2_71(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_71(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(70, xla); }
+  }
+
+  private boolean jj_2_72(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_72(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(71, xla); }
+  }
+
+  private boolean jj_2_73(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_73(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(72, xla); }
+  }
+
+  private boolean jj_2_74(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_74(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(73, xla); }
+  }
+
+  private boolean jj_2_75(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_75(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(74, xla); }
+  }
+
+  private boolean jj_2_76(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_76(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(75, xla); }
+  }
+
+  private boolean jj_2_77(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_77(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(76, xla); }
+  }
+
+  private boolean jj_2_78(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_78(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(77, xla); }
+  }
+
+  private boolean jj_2_79(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_79(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(78, xla); }
+  }
+
+  private boolean jj_2_80(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_80(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(79, xla); }
+  }
+
+  private boolean jj_2_81(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_81(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(80, xla); }
+  }
+
+  private boolean jj_2_82(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_82(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(81, xla); }
+  }
+
+  private boolean jj_2_83(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_83(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(82, xla); }
+  }
+
+  private boolean jj_2_84(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_84(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(83, xla); }
+  }
+
+  private boolean jj_2_85(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_85(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(84, xla); }
+  }
+
+  private boolean jj_2_86(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_86(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(85, xla); }
+  }
+
+  private boolean jj_2_87(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_87(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(86, xla); }
+  }
+
+  private boolean jj_2_88(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_88(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(87, xla); }
+  }
+
+  private boolean jj_2_89(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_89(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(88, xla); }
+  }
+
+  private boolean jj_2_90(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_90(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(89, xla); }
+  }
+
+  private boolean jj_2_91(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_91(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(90, xla); }
+  }
+
+  private boolean jj_2_92(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_92(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(91, xla); }
+  }
+
+  private boolean jj_2_93(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_93(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(92, xla); }
+  }
+
+  private boolean jj_2_94(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_94(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(93, xla); }
+  }
+
+  private boolean jj_2_95(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_95(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(94, xla); }
+  }
+
+  private boolean jj_2_96(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_96(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(95, xla); }
+  }
+
+  private boolean jj_2_97(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_97(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(96, xla); }
+  }
+
+  private boolean jj_2_98(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_98(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(97, xla); }
+  }
+
+  private boolean jj_2_99(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_99(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(98, xla); }
+  }
+
+  private boolean jj_2_100(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_100(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(99, xla); }
+  }
+
+  private boolean jj_2_101(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_101(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(100, xla); }
+  }
+
+  private boolean jj_2_102(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_102(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(101, xla); }
+  }
+
+  private boolean jj_2_103(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_103(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(102, xla); }
+  }
+
+  private boolean jj_2_104(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_104(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(103, xla); }
+  }
+
+  private boolean jj_2_105(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_105(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(104, xla); }
+  }
+
+  private boolean jj_2_106(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_106(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(105, xla); }
+  }
+
+  private boolean jj_2_107(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_107(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(106, xla); }
+  }
+
+  private boolean jj_2_108(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_108(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(107, xla); }
+  }
+
+  private boolean jj_2_109(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_109(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(108, xla); }
+  }
+
+  private boolean jj_2_110(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_110(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(109, xla); }
+  }
+
+  private boolean jj_2_111(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_111(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(110, xla); }
+  }
+
+  private boolean jj_2_112(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_112(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(111, xla); }
+  }
+
+  private boolean jj_2_113(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_113(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(112, xla); }
+  }
+
+  private boolean jj_2_114(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_114(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(113, xla); }
+  }
+
+  private boolean jj_2_115(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_115(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(114, xla); }
+  }
+
+  private boolean jj_2_116(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_116(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(115, xla); }
+  }
+
+  private boolean jj_2_117(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_117(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(116, xla); }
+  }
+
+  private boolean jj_2_118(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_118(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(117, xla); }
+  }
+
+  private boolean jj_2_119(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_119(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(118, xla); }
+  }
+
+  private boolean jj_2_120(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_120(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(119, xla); }
+  }
+
+  private boolean jj_2_121(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_121(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(120, xla); }
+  }
+
+  private boolean jj_2_122(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_122(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(121, xla); }
+  }
+
+  private boolean jj_2_123(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_123(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(122, xla); }
+  }
+
+  private boolean jj_2_124(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_124(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(123, xla); }
+  }
+
+  private boolean jj_2_125(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_125(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(124, xla); }
+  }
+
+  private boolean jj_2_126(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_126(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(125, xla); }
+  }
+
+  private boolean jj_2_127(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_127(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(126, xla); }
+  }
+
+  private boolean jj_2_128(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_128(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(127, xla); }
+  }
+
+  private boolean jj_2_129(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_129(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(128, xla); }
+  }
+
+  private boolean jj_2_130(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_130(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(129, xla); }
+  }
+
+  private boolean jj_2_131(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_131(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(130, xla); }
+  }
+
+  private boolean jj_2_132(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_132(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(131, xla); }
+  }
+
+  private boolean jj_2_133(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_133(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(132, xla); }
+  }
+
+  private boolean jj_2_134(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_134(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(133, xla); }
+  }
+
+  private boolean jj_2_135(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_135(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(134, xla); }
+  }
+
+  private boolean jj_2_136(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_136(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(135, xla); }
+  }
+
+  private boolean jj_2_137(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_137(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(136, xla); }
+  }
+
+  private boolean jj_2_138(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_138(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(137, xla); }
+  }
+
+  private boolean jj_2_139(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_139(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(138, xla); }
+  }
+
+  private boolean jj_2_140(int xla)
+ {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_140(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(139, xla); }
+  }
+
+  private boolean jj_3R_331()
+ {
+    if (jj_3R_125()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_481()
+ {
+    if (jj_scan_token(160)) return true;
+    if (jj_3R_89()) return true;
+    return false;
+  }
+
+  private boolean jj_3_51()
+ {
+    if (jj_3R_89()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_86()
+ {
+    if (jj_3R_125()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_80()
+ {
+    if (jj_3R_68()) return true;
+    if (jj_scan_token(RANGE)) return true;
+    if (jj_scan_token(163)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_600()
+ {
+    if (jj_3R_383()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_599()
+ {
+    if (jj_3R_89()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_507()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_599()) {
+    jj_scanpos = xsp;
+    if (jj_3R_600()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_449()
+ {
+    if (jj_3R_390()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_774()
+ {
+    if (jj_3R_317()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_405()
+ {
+    if (jj_scan_token(158)) return true;
+    if (jj_3R_89()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_481()) { jj_scanpos = xsp; break; }
+    }
+    if (jj_scan_token(159)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_607()
+ {
+    if (jj_scan_token(TYPE)) return true;
+    if (jj_3R_85()) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_663()
+ {
+    if (jj_3R_390()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_382()
+ {
+    if (jj_scan_token(160)) return true;
+    if (jj_3R_85()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_773()
+ {
+    if (jj_scan_token(ELSE)) return true;
+    if (jj_3R_277()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_772()
+ {
+    if (jj_scan_token(ELSIF)) return true;
+    if (jj_3R_95()) return true;
+    if (jj_scan_token(THEN)) return true;
+    if (jj_3R_277()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_522()
+ {
+    if (jj_3R_390()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_273()
+ {
+    if (jj_3R_317()) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_471()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_522()) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(78)) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_139()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_273()) jj_scanpos = xsp;
+    if (jj_scan_token(IF)) return true;
+    if (jj_3R_95()) return true;
+    if (jj_scan_token(THEN)) return true;
+    if (jj_3R_277()) return true;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_772()) { jj_scanpos = xsp; break; }
+    }
+    xsp = jj_scanpos;
+    if (jj_3R_773()) jj_scanpos = xsp;
+    if (jj_scan_token(END)) return true;
+    if (jj_scan_token(IF)) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_774()) jj_scanpos = xsp;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_233()
+ {
+    if (jj_3R_85()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_382()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_175()
+ {
+    if (jj_3R_91()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_200()
+ {
+    if (jj_scan_token(extended_identifier)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_199()
+ {
+    if (jj_scan_token(basic_identifier)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_85()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_199()) {
+    jj_scanpos = xsp;
+    if (jj_3R_200()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_402()
+ {
+    if (jj_3R_91()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_669()
+ {
+    if (jj_scan_token(160)) return true;
+    if (jj_3R_668()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_518()
+ {
+    if (jj_3R_611()) return true;
+    if (jj_scan_token(COLON)) return true;
+    if (jj_3R_68()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_76()
+ {
+    if (jj_3R_91()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_192()
+ {
+    if (jj_scan_token(WHEN)) return true;
+    if (jj_3R_95()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_317()
+ {
+    if (jj_3R_91()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_466()
+ {
+    if (jj_scan_token(GROUP)) return true;
+    if (jj_3R_85()) return true;
+    if (jj_scan_token(COLON)) return true;
+    if (jj_3R_632()) return true;
+    if (jj_scan_token(158)) return true;
+    if (jj_3R_633()) return true;
+    if (jj_scan_token(159)) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_88()
+ {
+    if (jj_3R_91()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_129()
+ {
+    if (jj_scan_token(GROUP)) return true;
+    if (jj_3R_85()) return true;
+    if (jj_scan_token(IS)) return true;
+    if (jj_scan_token(158)) return true;
+    if (jj_3R_259()) return true;
+    if (jj_scan_token(159)) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_185()
+ {
+    if (jj_3R_91()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_633()
+ {
+    if (jj_3R_668()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_669()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_401()
+ {
+    if (jj_3R_91()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_699()
+ {
+    if (jj_3R_125()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_668()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_699()) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(136)) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_191()
+ {
+    if (jj_3R_338()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_87()
+ {
+    if (jj_3R_91()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_174()
+ {
+    if (jj_3R_91()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_643()
+ {
+    if (jj_scan_token(GENERIC)) return true;
+    if (jj_scan_token(MAP)) return true;
+    if (jj_scan_token(158)) return true;
+    if (jj_3R_680()) return true;
+    if (jj_scan_token(159)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_190()
+ {
+    if (jj_3R_337()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_705()
+ {
+    if (jj_3R_751()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_687()
+ {
+    if (jj_3R_91()) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_646()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_687()) jj_scanpos = xsp;
+    if (jj_scan_token(NULL)) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_675()
+ {
+    if (jj_scan_token(GENERIC)) return true;
+    if (jj_scan_token(158)) return true;
+    if (jj_3R_705()) return true;
+    if (jj_scan_token(159)) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_188()
+ {
+    if (jj_3R_185()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_110()
+ {
+    if (jj_3R_232()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_335()
+ {
+    if (jj_scan_token(IF)) return true;
+    if (jj_3R_95()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_411()
+ {
+    if (jj_3R_480()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_186()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_334()) {
+    jj_scanpos = xsp;
+    if (jj_3R_335()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_334()
+ {
+    if (jj_scan_token(FOR)) return true;
+    if (jj_3R_420()) return true;
+    return false;
+  }
+
+  private boolean jj_3_140()
+ {
+    if (jj_3R_129()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_324()
+ {
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_411()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3_139()
+ {
+    if (jj_3R_84()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_572()
+ {
+    if (jj_3R_466()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_189()
+ {
+    if (jj_3R_91()) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_79()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_189()) jj_scanpos = xsp;
+    if (jj_scan_token(BREAK)) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_190()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_191()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_192()) jj_scanpos = xsp;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_571()
+ {
+    if (jj_3R_129()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_570()
+ {
+    if (jj_3R_347()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_569()
+ {
+    if (jj_3R_463()) return true;
+    return false;
+  }
+
+  private boolean jj_3_138()
+ {
+    if (jj_3R_83()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_187()
+ {
+    if (jj_3R_336()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_568()
+ {
+    if (jj_3R_84()) return true;
+    return false;
+  }
+
+  private boolean jj_3_50()
+ {
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_110()) { jj_scanpos = xsp; break; }
+    }
+    if (jj_scan_token(BEGIN)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_567()
+ {
+    if (jj_3R_461()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_566()
+ {
+    if (jj_3R_613()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_565()
+ {
+    if (jj_3R_457()) return true;
+    return false;
+  }
+
+  private boolean jj_3_49()
+ {
+    if (jj_scan_token(158)) return true;
+    if (jj_3R_109()) return true;
+    if (jj_scan_token(159)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_564()
+ {
+    if (jj_3R_456()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_563()
+ {
+    if (jj_3R_455()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_562()
+ {
+    if (jj_3R_454()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_78()
+ {
+    if (jj_3R_185()) return true;
+    if (jj_scan_token(COLON)) return true;
+    if (jj_3R_186()) return true;
+    if (jj_scan_token(GENERATE)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3_50()) jj_scanpos = xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_187()) { jj_scanpos = xsp; break; }
+    }
+    if (jj_scan_token(END)) return true;
+    if (jj_scan_token(GENERATE)) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_188()) jj_scanpos = xsp;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_561()
+ {
+    if (jj_3R_83()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_484()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_561()) {
+    jj_scanpos = xsp;
+    if (jj_3R_562()) {
+    jj_scanpos = xsp;
+    if (jj_3R_563()) {
+    jj_scanpos = xsp;
+    if (jj_3R_564()) {
+    jj_scanpos = xsp;
+    if (jj_3R_565()) {
+    jj_scanpos = xsp;
+    if (jj_3R_566()) {
+    jj_scanpos = xsp;
+    if (jj_3R_567()) {
+    jj_scanpos = xsp;
+    if (jj_3R_568()) {
+    jj_scanpos = xsp;
+    if (jj_3R_569()) {
+    jj_scanpos = xsp;
+    if (jj_3R_570()) {
+    jj_scanpos = xsp;
+    if (jj_3R_571()) {
+    jj_scanpos = xsp;
+    if (jj_3R_572()) return true;
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_686()
+ {
+    if (jj_3R_409()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_322()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(76)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(43)) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_249()
+ {
+    if (jj_scan_token(158)) return true;
+    if (jj_3R_109()) return true;
+    if (jj_scan_token(159)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_123()
+ {
+    if (jj_3R_66()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_249()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_410()
+ {
+    if (jj_3R_484()) return true;
+    return false;
+  }
+
+  private boolean jj_3_48()
+ {
+    if (jj_3R_68()) return true;
+    if (jj_scan_token(158)) return true;
+    if (jj_3R_108()) return true;
+    if (jj_scan_token(159)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_323()
+ {
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_410()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3_47()
+ {
+    if (jj_3R_66()) return true;
+    if (jj_scan_token(158)) return true;
+    if (jj_3R_108()) return true;
+    if (jj_scan_token(159)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_606()
+ {
+    if (jj_scan_token(TYPE)) return true;
+    if (jj_3R_85()) return true;
+    if (jj_scan_token(IS)) return true;
+    if (jj_3R_694()) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_409()
+ {
+    if (jj_3R_91()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_197()
+ {
+    if (jj_3R_108()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_196()
+ {
+    if (jj_3R_68()) return true;
+    if (jj_scan_token(158)) return true;
+    if (jj_3R_108()) return true;
+    if (jj_scan_token(159)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_195()
+ {
+    if (jj_3R_66()) return true;
+    if (jj_scan_token(158)) return true;
+    if (jj_3R_108()) return true;
+    if (jj_scan_token(159)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_82()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_195()) {
+    jj_scanpos = xsp;
+    if (jj_3R_196()) {
+    jj_scanpos = xsp;
+    if (jj_3R_197()) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3_46()
+ {
+    if (jj_3R_107()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_321()
+ {
+    if (jj_3R_409()) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3_45()
+ {
+    if (jj_3R_106()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_163()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_321()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_322()) jj_scanpos = xsp;
+    if (jj_scan_token(PROCEDURAL)) return true;
+    xsp = jj_scanpos;
+    if (jj_scan_token(47)) jj_scanpos = xsp;
+    if (jj_3R_323()) return true;
+    if (jj_scan_token(BEGIN)) return true;
+    if (jj_3R_324()) return true;
+    if (jj_scan_token(END)) return true;
+    if (jj_scan_token(PROCEDURAL)) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_686()) jj_scanpos = xsp;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_502()
+ {
+    if (jj_3R_594()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_320()
+ {
+    if (jj_3R_401()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_230()
+ {
+    if (jj_3R_359()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_229()
+ {
+    if (jj_3R_107()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_408()
+ {
+    if (jj_scan_token(WHEN)) return true;
+    if (jj_3R_99()) return true;
+    if (jj_scan_token(USE)) return true;
+    if (jj_3R_483()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_108()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_228()) {
+    jj_scanpos = xsp;
+    if (jj_3R_229()) {
+    jj_scanpos = xsp;
+    if (jj_3R_230()) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_228()
+ {
+    if (jj_3R_106()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_685()
+ {
+    if (jj_3R_317()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_319()
+ {
+    if (jj_3R_408()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_316()
+ {
+    if (jj_3R_149()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_318()
+ {
+    if (jj_3R_401()) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_162()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_318()) jj_scanpos = xsp;
+    if (jj_scan_token(CASE)) return true;
+    if (jj_3R_61()) return true;
+    if (jj_scan_token(USE)) return true;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_319()) { jj_scanpos = xsp; break; }
+    }
+    if (jj_scan_token(END)) return true;
+    if (jj_scan_token(CASE)) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_320()) jj_scanpos = xsp;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_742()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(44)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(68)) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_762()
+ {
+    if (jj_scan_token(FILE)) return true;
+    if (jj_scan_token(OF)) return true;
+    if (jj_3R_68()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_696()
+ {
+    if (jj_scan_token(IS)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_742()) jj_scanpos = xsp;
+    if (jj_3R_741()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_684()
+ {
+    if (jj_scan_token(ELSE)) return true;
+    if (jj_3R_483()) return true;
+    return false;
+  }
+
+  private boolean jj_3_44()
+ {
+    if (jj_scan_token(EXP)) return true;
+    if (jj_3R_105()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_683()
+ {
+    if (jj_scan_token(ELSIF)) return true;
+    if (jj_3R_95()) return true;
+    if (jj_scan_token(USE)) return true;
+    if (jj_3R_483()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_695()
+ {
+    if (jj_scan_token(OPEN)) return true;
+    if (jj_3R_740()) return true;
+    if (jj_scan_token(IS)) return true;
+    if (jj_3R_741()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_660()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_695()) {
+    jj_scanpos = xsp;
+    if (jj_3R_696()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_682()
+ {
+    if (jj_3R_317()) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3_137()
+ {
+    if (jj_3R_91()) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_645()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_682()) jj_scanpos = xsp;
+    if (jj_scan_token(IF)) return true;
+    if (jj_3R_95()) return true;
+    if (jj_scan_token(USE)) return true;
+    if (jj_3R_483()) return true;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_683()) { jj_scanpos = xsp; break; }
+    }
+    xsp = jj_scanpos;
+    if (jj_3R_684()) jj_scanpos = xsp;
+    if (jj_scan_token(END)) return true;
+    if (jj_scan_token(USE)) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_685()) jj_scanpos = xsp;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_741()
+ {
+    if (jj_3R_296()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_503()
+ {
+    if (jj_scan_token(EXP)) return true;
+    if (jj_3R_105()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_625()
+ {
+    if (jj_3R_660()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_314()
+ {
+    if (jj_3R_91()) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_315()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(76)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(43)) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_460()
+ {
+    if (jj_scan_token(FILE)) return true;
+    if (jj_3R_233()) return true;
+    if (jj_scan_token(COLON)) return true;
+    if (jj_3R_215()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_625()) jj_scanpos = xsp;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_160()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_314()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_315()) jj_scanpos = xsp;
+    if (jj_3R_90()) return true;
+    if (jj_scan_token(165)) return true;
+    if (jj_3R_90()) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_316()) jj_scanpos = xsp;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_161()
+ {
+    if (jj_3R_317()) return true;
+    return false;
+  }
+
+  private boolean jj_3_135()
+ {
+    if (jj_3R_162()) return true;
+    return false;
+  }
+
+  private boolean jj_3_134()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_161()) jj_scanpos = xsp;
+    if (jj_scan_token(COLON)) return true;
+    if (jj_scan_token(IF)) return true;
+    if (jj_3R_95()) return true;
+    if (jj_scan_token(USE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_313()
+ {
+    if (jj_3R_105()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_503()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3_133()
+ {
+    if (jj_3R_160()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_312()
+ {
+    if (jj_scan_token(NOT)) return true;
+    if (jj_3R_105()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_592()
+ {
+    if (jj_3R_646()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_157()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_311()) {
+    jj_scanpos = xsp;
+    if (jj_3R_312()) {
+    jj_scanpos = xsp;
+    if (jj_3R_313()) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_311()
+ {
+    if (jj_scan_token(ABS)) return true;
+    if (jj_3R_105()) return true;
+    return false;
+  }
+
+  private boolean jj_3_136()
+ {
+    if (jj_3R_163()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_282()
+ {
+    if (jj_3R_402()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_591()
+ {
+    if (jj_3R_162()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_598()
+ {
+    if (jj_scan_token(AFTER)) return true;
+    if (jj_3R_595()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_590()
+ {
+    if (jj_3R_645()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_264()
+ {
+    if (jj_scan_token(160)) return true;
+    if (jj_3R_263()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_596()
+ {
+    if (jj_scan_token(AFTER)) return true;
+    if (jj_3R_595()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_589()
+ {
+    if (jj_3R_160()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_497()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_589()) {
+    jj_scanpos = xsp;
+    if (jj_3R_590()) {
+    jj_scanpos = xsp;
+    if (jj_3R_591()) {
+    jj_scanpos = xsp;
+    if (jj_3_136()) {
+    jj_scanpos = xsp;
+    if (jj_3R_592()) return true;
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_165()
+ {
+    if (jj_3R_327()) return true;
+    if (jj_3R_164()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_61()
+ {
+    if (jj_3R_164()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_165()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_560()
+ {
+    if (jj_3R_497()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_439()
+ {
+    if (jj_scan_token(160)) return true;
+    if (jj_3R_438()) return true;
+    return false;
+  }
+
+  private boolean jj_3_132()
+ {
+    if (jj_scan_token(NULL)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_483()
+ {
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_560()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_268()
+ {
+    if (jj_3R_400()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_283()
+ {
+    if (jj_scan_token(WHEN)) return true;
+    if (jj_3R_95()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_281()
+ {
+    if (jj_3R_91()) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_506()
+ {
+    if (jj_3R_597()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_598()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_143()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_281()) jj_scanpos = xsp;
+    if (jj_scan_token(EXIT)) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_282()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_283()) jj_scanpos = xsp;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_505()
+ {
+    if (jj_scan_token(NULL)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_596()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_438()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_505()) {
+    jj_scanpos = xsp;
+    if (jj_3R_506()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_650()
+ {
+    if (jj_scan_token(ASSIGN)) return true;
+    if (jj_3R_61()) return true;
+    return false;
+  }
+
+  private boolean jj_3_131()
+ {
+    if (jj_3R_91()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_132()
+ {
+    if (jj_scan_token(158)) return true;
+    if (jj_3R_263()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_264()) { jj_scanpos = xsp; break; }
+    }
+    if (jj_scan_token(159)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_266()
+ {
+    if (jj_3R_338()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_208()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_343()) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(105)) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_343()
+ {
+    if (jj_3R_438()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_439()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_398()
+ {
+    if (jj_3R_85()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_267()
+ {
+    if (jj_3R_399()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_263()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(136)) {
+    jj_scanpos = xsp;
+    if (jj_3R_398()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_265()
+ {
+    if (jj_scan_token(COLON)) return true;
+    if (jj_3R_91()) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_442()
+ {
+    if (jj_scan_token(160)) return true;
+    if (jj_3R_441()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_133()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_265()) jj_scanpos = xsp;
+    if (jj_scan_token(WAIT)) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_266()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_267()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_268()) jj_scanpos = xsp;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_789()
+ {
+    if (jj_3R_391()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_788()
+ {
+    if (jj_3R_390()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_764()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_788()) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(136)) {
+    jj_scanpos = xsp;
+    if (jj_3R_789()) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3_130()
+ {
+    if (jj_3R_91()) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_104()
+ {
+    if (jj_3R_175()) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_613()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(90)) jj_scanpos = xsp;
+    if (jj_scan_token(VARIABLE)) return true;
+    if (jj_3R_233()) return true;
+    if (jj_scan_token(COLON)) return true;
+    if (jj_3R_215()) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_650()) jj_scanpos = xsp;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3_43()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_104()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(71)) jj_scanpos = xsp;
+    if (jj_scan_token(PROCESS)) return true;
+    return false;
+  }
+
+  private boolean jj_3_42()
+ {
+    if (jj_3R_103()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_652()
+ {
+    if (jj_3R_91()) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_744()
+ {
+    if (jj_scan_token(160)) return true;
+    if (jj_3R_743()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_615()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_652()) jj_scanpos = xsp;
+    if (jj_3R_92()) return true;
+    if (jj_scan_token(ASSIGN)) return true;
+    if (jj_3R_61()) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_630()
+ {
+    if (jj_3R_664()) return true;
+    if (jj_scan_token(COLON)) return true;
+    if (jj_3R_474()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_347()
+ {
+    if (jj_scan_token(USE)) return true;
+    if (jj_3R_441()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_442()) { jj_scanpos = xsp; break; }
+    }
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_193()
+ {
+    if (jj_scan_token(160)) return true;
+    if (jj_3R_80()) return true;
+    return false;
+  }
+
+  private boolean jj_3_129()
+ {
+    if (jj_3R_159()) return true;
+    return false;
+  }
+
+  private boolean jj_3_128()
+ {
+    if (jj_3R_158()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_81()
+ {
+    if (jj_scan_token(ARRAY)) return true;
+    if (jj_scan_token(158)) return true;
+    if (jj_3R_80()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_193()) { jj_scanpos = xsp; break; }
+    }
+    if (jj_scan_token(159)) return true;
+    if (jj_scan_token(OF)) return true;
+    if (jj_3R_194()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_697()
+ {
+    if (jj_3R_743()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_744()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_664()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_697()) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(67)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(12)) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_173()
+ {
+    if (jj_3R_159()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_172()
+ {
+    if (jj_3R_158()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_68()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_172()) {
+    jj_scanpos = xsp;
+    if (jj_3R_173()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_739()
+ {
+    if (jj_3R_763()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_738()
+ {
+    if (jj_3R_762()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_737()
+ {
+    if (jj_3R_761()) return true;
+    return false;
+  }
+
+  private boolean jj_3_127()
+ {
+    if (jj_scan_token(TYPE)) return true;
+    if (jj_3R_85()) return true;
+    if (jj_scan_token(IS)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_736()
+ {
+    if (jj_3R_760()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_735()
+ {
+    if (jj_3R_759()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_694()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_735()) {
+    jj_scanpos = xsp;
+    if (jj_3R_736()) {
+    jj_scanpos = xsp;
+    if (jj_3R_737()) {
+    jj_scanpos = xsp;
+    if (jj_3R_738()) {
+    jj_scanpos = xsp;
+    if (jj_3R_739()) return true;
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_743()
+ {
+    if (jj_3R_764()) return true;
+    if (jj_3R_118()) return true;
+    return false;
+  }
+
+  private boolean jj_3_41()
+ {
+    if (jj_3R_102()) return true;
+    return false;
+  }
+
+  private boolean jj_3_40()
+ {
+    if (jj_3R_101()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_515()
+ {
+    if (jj_3R_607()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_673()
+ {
+    if (jj_3R_405()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_514()
+ {
+    if (jj_3R_606()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_455()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_514()) {
+    jj_scanpos = xsp;
+    if (jj_3R_515()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_703()
+ {
+    if (jj_3R_102()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_702()
+ {
+    if (jj_3R_101()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_672()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_702()) {
+    jj_scanpos = xsp;
+    if (jj_3R_703()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_128()
+ {
+    if (jj_3R_68()) return true;
+    if (jj_scan_token(158)) return true;
+    if (jj_3R_61()) return true;
+    if (jj_scan_token(159)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_674()
+ {
+    if (jj_scan_token(TOLERANCE)) return true;
+    if (jj_3R_296()) return true;
+    if (jj_scan_token(ACROSS)) return true;
+    if (jj_3R_296()) return true;
+    if (jj_scan_token(THROUGH)) return true;
+    return false;
+  }
+
+  private boolean jj_3_126()
+ {
+    if (jj_3R_156()) return true;
+    if (jj_3R_157()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_306()
+ {
+    if (jj_scan_token(ASSIGN)) return true;
+    if (jj_3R_61()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_635()
+ {
+    if (jj_3R_672()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_673()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_674()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_400()
+ {
+    if (jj_scan_token(FOR)) return true;
+    if (jj_3R_477()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_468()
+ {
+    if (jj_scan_token(SUBNATURE)) return true;
+    if (jj_3R_85()) return true;
+    if (jj_scan_token(IS)) return true;
+    if (jj_3R_635()) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_304()
+ {
+    if (jj_scan_token(ASSIGN)) return true;
+    if (jj_3R_61()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_148()
+ {
+    if (jj_3R_157()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3_126()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_671()
+ {
+    if (jj_3R_701()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_670()
+ {
+    if (jj_3R_700()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_634()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_670()) {
+    jj_scanpos = xsp;
+    if (jj_3R_671()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_206()
+ {
+    if (jj_3R_127()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_205()
+ {
+    if (jj_3R_125()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_92()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_205()) {
+    jj_scanpos = xsp;
+    if (jj_3R_206()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_305()
+ {
+    if (jj_3R_149()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_473()
+ {
+    if (jj_3R_391()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_467()
+ {
+    if (jj_scan_token(NATURE)) return true;
+    if (jj_3R_85()) return true;
+    if (jj_scan_token(IS)) return true;
+    if (jj_3R_634()) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_387()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_472()) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(136)) {
+    jj_scanpos = xsp;
+    if (jj_3R_473()) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(12)) return true;
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_472()
+ {
+    if (jj_3R_390()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_299()
+ {
+    if (jj_scan_token(ASSIGN)) return true;
+    if (jj_3R_61()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_750()
+ {
+    if (jj_scan_token(NOISE)) return true;
+    if (jj_3R_769()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_749()
+ {
+    if (jj_scan_token(SPECTRUM)) return true;
+    if (jj_3R_769()) return true;
+    if (jj_scan_token(160)) return true;
+    if (jj_3R_770()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_704()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_749()) {
+    jj_scanpos = xsp;
+    if (jj_3R_750()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_303()
+ {
+    if (jj_3R_149()) return true;
+    return false;
+  }
+
+  private boolean jj_3_39()
+ {
+    if (jj_scan_token(GROUP)) return true;
+    if (jj_3R_85()) return true;
+    if (jj_scan_token(IS)) return true;
+    return false;
+  }
+
+  private boolean jj_3_38()
+ {
+    if (jj_3R_84()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_155()
+ {
+    if (jj_3R_233()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_305()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_306()) jj_scanpos = xsp;
+    if (jj_scan_token(THROUGH)) return true;
+    return false;
+  }
+
+  private boolean jj_3_125()
+ {
+    if (jj_3R_155()) return true;
+    return false;
+  }
+
+  private boolean jj_3_37()
+ {
+    if (jj_3R_83()) return true;
+    return false;
+  }
+
+  private boolean jj_3_124()
+ {
+    if (jj_3R_154()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_154()
+ {
+    if (jj_3R_233()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_303()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_304()) jj_scanpos = xsp;
+    if (jj_scan_token(ACROSS)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_301()
+ {
+    if (jj_3R_155()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_300()
+ {
+    if (jj_3R_154()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_612()
+ {
+    if (jj_scan_token(QUANTITY)) return true;
+    if (jj_3R_233()) return true;
+    if (jj_scan_token(COLON)) return true;
+    if (jj_3R_215()) return true;
+    if (jj_3R_704()) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_394()
+ {
+    if (jj_scan_token(160)) return true;
+    if (jj_3R_393()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_153()
+ {
+    if (jj_scan_token(QUANTITY)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_300()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_301()) jj_scanpos = xsp;
+    if (jj_3R_302()) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3_123()
+ {
+    if (jj_3R_153()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_152()
+ {
+    if (jj_scan_token(QUANTITY)) return true;
+    if (jj_3R_233()) return true;
+    if (jj_scan_token(COLON)) return true;
+    if (jj_3R_215()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_299()) jj_scanpos = xsp;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3_122()
+ {
+    if (jj_3R_152()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_259()
+ {
+    if (jj_3R_393()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_394()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_521()
+ {
+    if (jj_3R_612()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_520()
+ {
+    if (jj_3R_153()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_519()
+ {
+    if (jj_3R_152()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_469()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_519()) {
+    jj_scanpos = xsp;
+    if (jj_3R_520()) {
+    jj_scanpos = xsp;
+    if (jj_3R_521()) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_393()
+ {
+    if (jj_3R_474()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(163)) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_542()
+ {
+    if (jj_scan_token(TERMINAL)) return true;
+    return false;
+  }
+
+  private boolean jj_3_117()
+ {
+    if (jj_3R_149()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_541()
+ {
+    if (jj_scan_token(NATURE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_540()
+ {
+    if (jj_scan_token(SUBNATURE)) return true;
+    return false;
+  }
+
+  private boolean jj_3_116()
+ {
+    if (jj_3R_149()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_539()
+ {
+    if (jj_scan_token(FILE)) return true;
+    return false;
+  }
+
+  private boolean jj_3_121()
+ {
+    if (jj_3R_68()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_538()
+ {
+    if (jj_scan_token(GROUP)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_149()
+ {
+    if (jj_scan_token(TOLERANCE)) return true;
+    if (jj_3R_296()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_537()
+ {
+    if (jj_scan_token(UNITS)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_536()
+ {
+    if (jj_scan_token(LITERAL)) return true;
+    return false;
+  }
+
+  private boolean jj_3_115()
+ {
+    if (jj_3R_149()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_535()
+ {
+    if (jj_scan_token(LABEL)) return true;
+    return false;
+  }
+
+  private boolean jj_3_120()
+ {
+    if (jj_3R_150()) return true;
+    if (jj_3R_68()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_534()
+ {
+    if (jj_scan_token(COMPONENT)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_448()
+ {
+    if (jj_3R_149()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_533()
+ {
+    if (jj_scan_token(VARIABLE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_532()
+ {
+    if (jj_scan_token(SIGNAL)) return true;
+    return false;
+  }
+
+  private boolean jj_3_114()
+ {
+    if (jj_3R_149()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_531()
+ {
+    if (jj_scan_token(CONSTANT)) return true;
+    return false;
+  }
+
+  private boolean jj_3_119()
+ {
+    if (jj_3R_68()) return true;
+    if (jj_3R_151()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_530()
+ {
+    if (jj_scan_token(SUBTYPE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_447()
+ {
+    if (jj_3R_149()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_529()
+ {
+    if (jj_scan_token(TYPE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_528()
+ {
+    if (jj_scan_token(PACKAGE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_352()
+ {
+    if (jj_3R_68()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_448()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_527()
+ {
+    if (jj_scan_token(FUNCTION)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_526()
+ {
+    if (jj_scan_token(PROCEDURE)) return true;
+    return false;
+  }
+
+  private boolean jj_3_118()
+ {
+    if (jj_3R_150()) return true;
+    if (jj_3R_68()) return true;
+    if (jj_3R_151()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_446()
+ {
+    if (jj_3R_149()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_525()
+ {
+    if (jj_scan_token(CONFIGURATION)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_524()
+ {
+    if (jj_scan_token(ARCHITECTURE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_351()
+ {
+    if (jj_3R_150()) return true;
+    if (jj_3R_68()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_447()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_523()
+ {
+    if (jj_scan_token(ENTITY)) return true;
+    return false;
+  }
+
+  private boolean jj_3_36()
+ {
+    if (jj_scan_token(158)) return true;
+    if (jj_3R_100()) return true;
+    if (jj_scan_token(159)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_474()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_523()) {
+    jj_scanpos = xsp;
+    if (jj_3R_524()) {
+    jj_scanpos = xsp;
+    if (jj_3R_525()) {
+    jj_scanpos = xsp;
+    if (jj_3R_526()) {
+    jj_scanpos = xsp;
+    if (jj_3R_527()) {
+    jj_scanpos = xsp;
+    if (jj_3R_528()) {
+    jj_scanpos = xsp;
+    if (jj_3R_529()) {
+    jj_scanpos = xsp;
+    if (jj_3R_530()) {
+    jj_scanpos = xsp;
+    if (jj_3R_531()) {
+    jj_scanpos = xsp;
+    if (jj_3R_532()) {
+    jj_scanpos = xsp;
+    if (jj_3R_533()) {
+    jj_scanpos = xsp;
+    if (jj_3R_534()) {
+    jj_scanpos = xsp;
+    if (jj_3R_535()) {
+    jj_scanpos = xsp;
+    if (jj_3R_536()) {
+    jj_scanpos = xsp;
+    if (jj_3R_537()) {
+    jj_scanpos = xsp;
+    if (jj_3R_538()) {
+    jj_scanpos = xsp;
+    if (jj_3R_539()) {
+    jj_scanpos = xsp;
+    if (jj_3R_540()) {
+    jj_scanpos = xsp;
+    if (jj_3R_541()) {
+    jj_scanpos = xsp;
+    if (jj_3R_542()) return true;
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_445()
+ {
+    if (jj_3R_149()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_350()
+ {
+    if (jj_3R_68()) return true;
+    if (jj_3R_151()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_446()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_349()
+ {
+    if (jj_3R_150()) return true;
+    if (jj_3R_68()) return true;
+    if (jj_3R_151()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_445()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_765()
+ {
+    if (jj_scan_token(158)) return true;
+    if (jj_3R_100()) return true;
+    if (jj_scan_token(159)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_746()
+ {
+    if (jj_scan_token(CONFIGURATION)) return true;
+    if (jj_3R_333()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_215()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_349()) {
+    jj_scanpos = xsp;
+    if (jj_3R_350()) {
+    jj_scanpos = xsp;
+    if (jj_3R_351()) {
+    jj_scanpos = xsp;
+    if (jj_3R_352()) return true;
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_745()
+ {
+    if (jj_scan_token(ENTITY)) return true;
+    if (jj_3R_331()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_765()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_698()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_745()) {
+    jj_scanpos = xsp;
+    if (jj_3R_746()) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(65)) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_434()
+ {
+    if (jj_scan_token(158)) return true;
+    if (jj_3R_502()) return true;
+    if (jj_scan_token(159)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_821()
+ {
+    if (jj_3R_215()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_456()
+ {
+    if (jj_scan_token(SUBTYPE)) return true;
+    if (jj_3R_85()) return true;
+    if (jj_scan_token(IS)) return true;
+    if (jj_3R_215()) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3_35()
+ {
+    if (jj_3R_99()) return true;
+    if (jj_scan_token(RARROW)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_657()
+ {
+    if (jj_3R_480()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_818()
+ {
+    if (jj_3R_233()) return true;
+    if (jj_scan_token(COLON)) return true;
+    if (jj_3R_821()) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_618()
+ {
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_657()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3_34()
+ {
+    if (jj_3R_98()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_436()
+ {
+    if (jj_scan_token(158)) return true;
+    if (jj_3R_502()) return true;
+    if (jj_scan_token(159)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_392()
+ {
+    if (jj_3R_99()) return true;
+    if (jj_scan_token(RARROW)) return true;
+    return false;
+  }
+
+  private boolean jj_3_33()
+ {
+    if (jj_3R_90()) return true;
+    if (jj_3R_97()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_435()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(76)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(43)) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_257()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_392()) jj_scanpos = xsp;
+    if (jj_3R_61()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_340()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_435()) jj_scanpos = xsp;
+    if (jj_scan_token(FUNCTION)) return true;
+    if (jj_3R_433()) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_436()) jj_scanpos = xsp;
+    if (jj_scan_token(RETURN)) return true;
+    if (jj_3R_68()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_198()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_339()) {
+    jj_scanpos = xsp;
+    if (jj_3R_340()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_339()
+ {
+    if (jj_scan_token(PROCEDURE)) return true;
+    if (jj_3R_433()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_434()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_203()
+ {
+    if (jj_3R_262()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_202()
+ {
+    if (jj_3R_98()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_693()
+ {
+    if (jj_scan_token(FUNCTION)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_692()
+ {
+    if (jj_scan_token(PROCEDURE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_658()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_692()) {
+    jj_scanpos = xsp;
+    if (jj_3R_693()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_201()
+ {
+    if (jj_3R_262()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_89()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_201()) {
+    jj_scanpos = xsp;
+    if (jj_3R_202()) {
+    jj_scanpos = xsp;
+    if (jj_3R_203()) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3_113()
+ {
+    if (jj_scan_token(GROUP)) return true;
+    if (jj_3R_85()) return true;
+    if (jj_scan_token(IS)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_656()
+ {
+    if (jj_3R_691()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_617()
+ {
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_656()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_465()
+ {
+    if (jj_scan_token(DISCONNECT)) return true;
+    if (jj_3R_518()) return true;
+    if (jj_scan_token(AFTER)) return true;
+    if (jj_3R_595()) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3_112()
+ {
+    if (jj_3R_84()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_734()
+ {
+    if (jj_3R_466()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_620()
+ {
+    if (jj_3R_433()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_733()
+ {
+    if (jj_3R_129()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_732()
+ {
+    if (jj_3R_347()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_97()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(101)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(29)) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_731()
+ {
+    if (jj_3R_463()) return true;
+    return false;
+  }
+
+  private boolean jj_3_111()
+ {
+    if (jj_3R_83()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_730()
+ {
+    if (jj_3R_84()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_729()
+ {
+    if (jj_3R_461()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_501()
+ {
+    if (jj_3R_391()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_728()
+ {
+    if (jj_3R_460()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_500()
+ {
+    if (jj_3R_85()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_433()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_500()) {
+    jj_scanpos = xsp;
+    if (jj_3R_501()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_727()
+ {
+    if (jj_3R_613()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_726()
+ {
+    if (jj_3R_457()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_725()
+ {
+    if (jj_3R_456()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_724()
+ {
+    if (jj_3R_455()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_723()
+ {
+    if (jj_3R_454()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_722()
+ {
+    if (jj_3R_83()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_691()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_722()) {
+    jj_scanpos = xsp;
+    if (jj_3R_723()) {
+    jj_scanpos = xsp;
+    if (jj_3R_724()) {
+    jj_scanpos = xsp;
+    if (jj_3R_725()) {
+    jj_scanpos = xsp;
+    if (jj_3R_726()) {
+    jj_scanpos = xsp;
+    if (jj_3R_727()) {
+    jj_scanpos = xsp;
+    if (jj_3R_728()) {
+    jj_scanpos = xsp;
+    if (jj_3R_729()) {
+    jj_scanpos = xsp;
+    if (jj_3R_730()) {
+    jj_scanpos = xsp;
+    if (jj_3R_731()) {
+    jj_scanpos = xsp;
+    if (jj_3R_732()) {
+    jj_scanpos = xsp;
+    if (jj_3R_733()) {
+    jj_scanpos = xsp;
+    if (jj_3R_734()) return true;
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_407()
+ {
+    if (jj_scan_token(TO)) return true;
+    if (jj_3R_482()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_619()
+ {
+    if (jj_3R_658()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_83()
+ {
+    if (jj_3R_198()) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_504()
+ {
+    if (jj_scan_token(REJECT)) return true;
+    if (jj_3R_595()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_437()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_504()) jj_scanpos = xsp;
+    if (jj_scan_token(INERTIAL)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_342()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(103)) {
+    jj_scanpos = xsp;
+    if (jj_3R_437()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_454()
+ {
+    if (jj_3R_198()) return true;
+    if (jj_scan_token(IS)) return true;
+    if (jj_3R_617()) return true;
+    if (jj_scan_token(BEGIN)) return true;
+    if (jj_3R_618()) return true;
+    if (jj_scan_token(END)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_619()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_620()) jj_scanpos = xsp;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_302()
+ {
+    if (jj_3R_406()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_407()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3_109()
+ {
+    if (jj_scan_token(160)) return true;
+    if (jj_3R_68()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_470()
+ {
+    if (jj_scan_token(TERMINAL)) return true;
+    if (jj_3R_233()) return true;
+    if (jj_scan_token(COLON)) return true;
+    if (jj_3R_635()) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_623()
+ {
+    if (jj_scan_token(ASSIGN)) return true;
+    if (jj_3R_61()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_390()
+ {
+    if (jj_3R_85()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_389()
+ {
+    if (jj_scan_token(160)) return true;
+    if (jj_3R_68()) return true;
+    return false;
+  }
+
+  private boolean jj_3_110()
+ {
+    if (jj_3R_147()) return true;
+    if (jj_3R_148()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_204()
+ {
+    if (jj_3R_341()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_766()
+ {
+    if (jj_scan_token(160)) return true;
+    if (jj_3R_62()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_90()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_204()) jj_scanpos = xsp;
+    if (jj_3R_148()) return true;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3_110()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_247()
+ {
+    if (jj_scan_token(RETURN)) return true;
+    if (jj_3R_68()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_622()
+ {
+    if (jj_3R_659()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_246()
+ {
+    if (jj_3R_68()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_389()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_118()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_246()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_247()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_298()
+ {
+    if (jj_3R_405()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_151()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_297()) {
+    jj_scanpos = xsp;
+    if (jj_3R_298()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_297()
+ {
+    if (jj_3R_131()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_690()
+ {
+    if (jj_3R_62()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_766()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_649()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_690()) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(67)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(12)) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_659()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(80)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(23)) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_817()
+ {
+    if (jj_scan_token(ARRAY)) return true;
+    if (jj_3R_405()) return true;
+    if (jj_scan_token(OF)) return true;
+    if (jj_3R_194()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_771()
+ {
+    if (jj_3R_342()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_621()
+ {
+    if (jj_scan_token(ASSIGN)) return true;
+    if (jj_3R_61()) return true;
+    return false;
+  }
+
+  private boolean jj_3_108()
+ {
+    if (jj_3R_91()) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_458()
+ {
+    if (jj_scan_token(SIGNAL)) return true;
+    if (jj_3R_233()) return true;
+    if (jj_scan_token(COLON)) return true;
+    if (jj_3R_215()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_622()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_623()) jj_scanpos = xsp;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_457()
+ {
+    if (jj_scan_token(CONSTANT)) return true;
+    if (jj_3R_233()) return true;
+    if (jj_scan_token(COLON)) return true;
+    if (jj_3R_215()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_621()) jj_scanpos = xsp;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3_32()
+ {
+    if (jj_3R_96()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_464()
+ {
+    if (jj_scan_token(FOR)) return true;
+    if (jj_3R_517()) return true;
+    if (jj_3R_631()) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_651()
+ {
+    if (jj_3R_91()) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_614()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_651()) jj_scanpos = xsp;
+    if (jj_3R_92()) return true;
+    if (jj_scan_token(LE)) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_771()) jj_scanpos = xsp;
+    if (jj_3R_208()) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_444()
+ {
+    if (jj_3R_511()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_348()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_443()) {
+    jj_scanpos = xsp;
+    if (jj_3R_444()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_443()
+ {
+    if (jj_3R_96()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_341()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(145)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(146)) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_292()
+ {
+    if (jj_scan_token(ROR)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_291()
+ {
+    if (jj_scan_token(ROL)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_290()
+ {
+    if (jj_scan_token(SRA)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_289()
+ {
+    if (jj_scan_token(SLA)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_288()
+ {
+    if (jj_scan_token(SRL)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_146()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_287()) {
+    jj_scanpos = xsp;
+    if (jj_3R_288()) {
+    jj_scanpos = xsp;
+    if (jj_3R_289()) {
+    jj_scanpos = xsp;
+    if (jj_3R_290()) {
+    jj_scanpos = xsp;
+    if (jj_3R_291()) {
+    jj_scanpos = xsp;
+    if (jj_3R_292()) return true;
+    }
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_287()
+ {
+    if (jj_scan_token(SLL)) return true;
+    return false;
+  }
+
+  private boolean jj_3_107()
+ {
+    if (jj_3R_146()) return true;
+    if (jj_3R_90()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_325()
+ {
+    if (jj_3R_90()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3_107()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3_31()
+ {
+    if (jj_scan_token(WHEN)) return true;
+    if (jj_3R_95()) return true;
+    if (jj_scan_token(ELSE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_559()
+ {
+    if (jj_3R_616()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_210()
+ {
+    if (jj_scan_token(WHEN)) return true;
+    if (jj_3R_95()) return true;
+    return false;
+  }
+
+  private boolean jj_3_106()
+ {
+    if (jj_3R_145()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_209()
+ {
+    if (jj_scan_token(WHEN)) return true;
+    if (jj_3R_95()) return true;
+    if (jj_scan_token(ELSE)) return true;
+    if (jj_3R_208()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_137()
+ {
+    if (jj_3R_91()) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3_105()
+ {
+    if (jj_3R_144()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_136()
+ {
+    if (jj_3R_91()) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3_98()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_137()) jj_scanpos = xsp;
+    if (jj_3R_92()) return true;
+    if (jj_scan_token(ASSIGN)) return true;
+    return false;
+  }
+
+  private boolean jj_3_104()
+ {
+    if (jj_3R_143()) return true;
+    return false;
+  }
+
+  private boolean jj_3_97()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_136()) jj_scanpos = xsp;
+    if (jj_3R_92()) return true;
+    if (jj_scan_token(LE)) return true;
+    return false;
+  }
+
+  private boolean jj_3_103()
+ {
+    if (jj_3R_142()) return true;
+    return false;
+  }
+
+  private boolean jj_3_102()
+ {
+    if (jj_3R_141()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_94()
+ {
+    if (jj_3R_208()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_209()) { jj_scanpos = xsp; break; }
+    }
+    xsp = jj_scanpos;
+    if (jj_3R_210()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3_101()
+ {
+    if (jj_3R_140()) return true;
+    return false;
+  }
+
+  private boolean jj_3_100()
+ {
+    if (jj_3R_139()) return true;
+    return false;
+  }
+
+  private boolean jj_3_99()
+ {
+    if (jj_3R_138()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_558()
+ {
+    if (jj_3R_615()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_179()
+ {
+    if (jj_3R_92()) return true;
+    if (jj_scan_token(LE)) return true;
+    if (jj_3R_93()) return true;
+    if (jj_3R_94()) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_557()
+ {
+    if (jj_3R_614()) return true;
+    return false;
+  }
+
+  private boolean jj_3_96()
+ {
+    if (jj_3R_135()) return true;
+    return false;
+  }
+
+  private boolean jj_3_95()
+ {
+    if (jj_3R_134()) return true;
+    return false;
+  }
+
+  private boolean jj_3_30()
+ {
+    if (jj_3R_92()) return true;
+    if (jj_scan_token(LE)) return true;
+    if (jj_3R_93()) return true;
+    if (jj_3R_94()) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_399()
+ {
+    if (jj_scan_token(UNTIL)) return true;
+    if (jj_3R_95()) return true;
+    return false;
+  }
+
+  private boolean jj_3_94()
+ {
+    if (jj_3R_133()) return true;
+    return false;
+  }
+
+  private boolean jj_3_29()
+ {
+    if (jj_3R_91()) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_499()
+ {
+    if (jj_scan_token(160)) return true;
+    if (jj_3R_62()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_95()
+ {
+    if (jj_3R_211()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_480()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3_94()) {
+    jj_scanpos = xsp;
+    if (jj_3_95()) {
+    jj_scanpos = xsp;
+    if (jj_3_96()) {
+    jj_scanpos = xsp;
+    if (jj_3R_557()) {
+    jj_scanpos = xsp;
+    if (jj_3R_558()) {
+    jj_scanpos = xsp;
+    if (jj_3_99()) {
+    jj_scanpos = xsp;
+    if (jj_3_100()) {
+    jj_scanpos = xsp;
+    if (jj_3_101()) {
+    jj_scanpos = xsp;
+    if (jj_3_102()) {
+    jj_scanpos = xsp;
+    if (jj_3_103()) {
+    jj_scanpos = xsp;
+    if (jj_3_104()) {
+    jj_scanpos = xsp;
+    if (jj_3_105()) {
+    jj_scanpos = xsp;
+    if (jj_3_106()) {
+    jj_scanpos = xsp;
+    if (jj_3R_559()) return true;
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_586()
+ {
+    if (jj_3R_181()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_404()
+ {
+    if (jj_3R_480()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_585()
+ {
+    if (jj_3R_179()) return true;
+    return false;
+  }
+
+  private boolean jj_3_28()
+ {
+    if (jj_3R_91()) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_277()
+ {
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_404()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_584()
+ {
+    if (jj_3R_91()) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_495()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_584()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(71)) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_585()) {
+    jj_scanpos = xsp;
+    if (jj_3R_586()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_432()
+ {
+    if (jj_3R_62()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_499()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_583()
+ {
+    if (jj_3R_91()) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_494()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_583()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(71)) jj_scanpos = xsp;
+    if (jj_3R_72()) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_338()
+ {
+    if (jj_scan_token(ON)) return true;
+    if (jj_3R_432()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_218()
+ {
+    if (jj_3R_91()) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_103()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_218()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(71)) jj_scanpos = xsp;
+    if (jj_3R_219()) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_419()
+ {
+    if (jj_scan_token(160)) return true;
+    if (jj_3R_208()) return true;
+    if (jj_scan_token(WHEN)) return true;
+    if (jj_3R_99()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_329()
+ {
+    if (jj_3R_208()) return true;
+    if (jj_scan_token(WHEN)) return true;
+    if (jj_3R_99()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_419()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_509()
+ {
+    if (jj_3R_391()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_785()
+ {
+    if (jj_3R_798()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_784()
+ {
+    if (jj_3R_797()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_760()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_784()) {
+    jj_scanpos = xsp;
+    if (jj_3R_785()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3_93()
+ {
+    if (jj_3R_117()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_181()
+ {
+    if (jj_scan_token(WITH)) return true;
+    if (jj_3R_61()) return true;
+    if (jj_scan_token(SELECT)) return true;
+    if (jj_3R_92()) return true;
+    if (jj_scan_token(LE)) return true;
+    if (jj_3R_93()) return true;
+    if (jj_3R_329()) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_517()
+ {
+    if (jj_3R_610()) return true;
+    if (jj_scan_token(COLON)) return true;
+    if (jj_3R_330()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_748()
+ {
+    if (jj_3R_768()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_629()
+ {
+    if (jj_3R_663()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_510()
+ {
+    if (jj_3R_117()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_747()
+ {
+    if (jj_3R_767()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_701()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_747()) {
+    jj_scanpos = xsp;
+    if (jj_3R_748()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_508()
+ {
+    if (jj_3R_390()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_588()
+ {
+    if (jj_3R_644()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_587()
+ {
+    if (jj_3R_643()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_441()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_508()) {
+    jj_scanpos = xsp;
+    if (jj_3R_509()) return true;
+    }
+    xsp = jj_scanpos;
+    if (jj_3R_510()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3_92()
+ {
+    if (jj_scan_token(PACKAGE)) return true;
+    if (jj_scan_token(BODY)) return true;
+    return false;
+  }
+
+  private boolean jj_3_91()
+ {
+    if (jj_scan_token(ARCHITECTURE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_602()
+ {
+    if (jj_3R_96()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_496()
+ {
+    if (jj_3R_76()) return true;
+    if (jj_scan_token(COLON)) return true;
+    if (jj_3R_77()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_587()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_588()) jj_scanpos = xsp;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_628()
+ {
+    if (jj_3R_662()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_601()
+ {
+    if (jj_3R_631()) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_815()
+ {
+    if (jj_3R_85()) return true;
+    if (jj_scan_token(EQ)) return true;
+    if (jj_3R_120()) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_627()
+ {
+    if (jj_3R_661()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_462()
+ {
+    if (jj_scan_token(COMPONENT)) return true;
+    if (jj_3R_85()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(47)) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_627()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_628()) jj_scanpos = xsp;
+    if (jj_scan_token(END)) return true;
+    if (jj_scan_token(COMPONENT)) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_629()) jj_scanpos = xsp;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_217()
+ {
+    if (jj_scan_token(162)) return true;
+    if (jj_3R_216()) return true;
+    return false;
+  }
+
+  private boolean jj_3_90()
+ {
+    if (jj_3R_132()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_783()
+ {
+    if (jj_3R_131()) return true;
+    return false;
+  }
+
+  private boolean jj_3_89()
+ {
+    if (jj_3R_131()) return true;
+    if (jj_scan_token(UNITS)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_285()
+ {
+    if (jj_3R_61()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_511()
+ {
+    if (jj_scan_token(FOR)) return true;
+    if (jj_3R_517()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_601()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_602()) jj_scanpos = xsp;
+    if (jj_scan_token(END)) return true;
+    if (jj_scan_token(FOR)) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3_27()
+ {
+    if (jj_3R_90()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(157)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(162)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(154)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(160)) return true;
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_782()
+ {
+    if (jj_3R_132()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_777()
+ {
+    if (jj_3R_401()) return true;
+    return false;
+  }
+
+  private boolean jj_3_26()
+ {
+    if (jj_3R_89()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(157)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(162)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(154)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(160)) return true;
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_99()
+ {
+    if (jj_3R_216()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_217()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_781()
+ {
+    if (jj_3R_796()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_759()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_781()) {
+    jj_scanpos = xsp;
+    if (jj_3R_782()) {
+    jj_scanpos = xsp;
+    if (jj_3R_783()) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_776()
+ {
+    if (jj_3R_775()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_355()
+ {
+    if (jj_3R_449()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_354()
+ {
+    if (jj_3R_90()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_353()
+ {
+    if (jj_3R_89()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_700()
+ {
+    if (jj_3R_68()) return true;
+    if (jj_scan_token(ACROSS)) return true;
+    if (jj_3R_68()) return true;
+    if (jj_scan_token(THROUGH)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_216()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_353()) {
+    jj_scanpos = xsp;
+    if (jj_3R_354()) {
+    jj_scanpos = xsp;
+    if (jj_3R_355()) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(67)) return true;
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_284()
+ {
+    if (jj_3R_91()) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_144()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_284()) jj_scanpos = xsp;
+    if (jj_scan_token(RETURN)) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_285()) jj_scanpos = xsp;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_775()
+ {
+    if (jj_scan_token(WHEN)) return true;
+    if (jj_3R_99()) return true;
+    if (jj_scan_token(RARROW)) return true;
+    if (jj_3R_277()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_271()
+ {
+    if (jj_scan_token(SEVERITY)) return true;
+    if (jj_3R_61()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_270()
+ {
+    if (jj_3R_91()) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_655()
+ {
+    if (jj_scan_token(WHEN)) return true;
+    if (jj_3R_95()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_135()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_270()) jj_scanpos = xsp;
+    if (jj_scan_token(REPORT)) return true;
+    if (jj_3R_61()) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_271()) jj_scanpos = xsp;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_274()
+ {
+    if (jj_3R_401()) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_140()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_274()) jj_scanpos = xsp;
+    if (jj_scan_token(CASE)) return true;
+    if (jj_3R_61()) return true;
+    if (jj_scan_token(IS)) return true;
+    if (jj_3R_775()) return true;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_776()) { jj_scanpos = xsp; break; }
+    }
+    if (jj_scan_token(END)) return true;
+    if (jj_scan_token(CASE)) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_777()) jj_scanpos = xsp;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_490()
+ {
+    if (jj_scan_token(GE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_489()
+ {
+    if (jj_scan_token(GT)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_488()
+ {
+    if (jj_scan_token(LE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_487()
+ {
+    if (jj_scan_token(LO)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_486()
+ {
+    if (jj_scan_token(NEQ)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_412()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_485()) {
+    jj_scanpos = xsp;
+    if (jj_3R_486()) {
+    jj_scanpos = xsp;
+    if (jj_3R_487()) {
+    jj_scanpos = xsp;
+    if (jj_3R_488()) {
+    jj_scanpos = xsp;
+    if (jj_3R_489()) {
+    jj_scanpos = xsp;
+    if (jj_3R_490()) return true;
+    }
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_485()
+ {
+    if (jj_scan_token(EQ)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_593()
+ {
+    if (jj_scan_token(FOR)) return true;
+    if (jj_3R_328()) return true;
+    if (jj_scan_token(USE)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_431()
+ {
+    if (jj_scan_token(160)) return true;
+    if (jj_3R_430()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_810()
+ {
+    if (jj_3R_819()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_654()
+ {
+    if (jj_3R_337()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_498()
+ {
+    if (jj_3R_593()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_430()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_498()) jj_scanpos = xsp;
+    if (jj_3R_328()) return true;
+    if (jj_scan_token(RARROW)) return true;
+    if (jj_3R_61()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_326()
+ {
+    if (jj_3R_412()) return true;
+    if (jj_3R_325()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_793()
+ {
+    if (jj_3R_803()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_164()
+ {
+    if (jj_3R_325()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_326()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_577()
+ {
+    if (jj_3R_174()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_337()
+ {
+    if (jj_3R_430()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_431()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_809()
+ {
+    if (jj_3R_818()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_798()
+ {
+    if (jj_scan_token(RECORD)) return true;
+    Token xsp;
+    if (jj_3R_809()) return true;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_809()) { jj_scanpos = xsp; break; }
+    }
+    if (jj_scan_token(END)) return true;
+    if (jj_scan_token(RECORD)) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_810()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_573()
+ {
+    if (jj_scan_token(158)) return true;
+    if (jj_3R_636()) return true;
+    if (jj_scan_token(159)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_653()
+ {
+    if (jj_3R_91()) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_440()
+ {
+    if (jj_scan_token(158)) return true;
+    if (jj_3R_507()) return true;
+    if (jj_scan_token(159)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_792()
+ {
+    if (jj_3R_802()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_616()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_653()) jj_scanpos = xsp;
+    if (jj_scan_token(BREAK)) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_654()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_655()) jj_scanpos = xsp;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_768()
+ {
+    if (jj_scan_token(RECORD)) return true;
+    Token xsp;
+    if (jj_3R_792()) return true;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_792()) { jj_scanpos = xsp; break; }
+    }
+    if (jj_scan_token(END)) return true;
+    if (jj_scan_token(RECORD)) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_793()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3_88()
+ {
+    if (jj_3R_90()) return true;
+    if (jj_3R_97()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_640()
+ {
+    if (jj_3R_336()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_131()
+ {
+    if (jj_scan_token(RANGE)) return true;
+    if (jj_3R_262()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_576()
+ {
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_640()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3_87()
+ {
+    if (jj_3R_127()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_397()
+ {
+    if (jj_3R_476()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_262()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_396()) {
+    jj_scanpos = xsp;
+    if (jj_3R_397()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_396()
+ {
+    if (jj_3R_90()) return true;
+    if (jj_3R_97()) return true;
+    if (jj_3R_90()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_678()
+ {
+    if (jj_3R_644()) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3_25()
+ {
+    if (jj_3R_88()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_676()
+ {
+    if (jj_3R_643()) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3_24()
+ {
+    if (jj_3R_87()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_251()
+ {
+    if (jj_scan_token(158)) return true;
+    if (jj_3R_61()) return true;
+    if (jj_scan_token(159)) return true;
+    return false;
+  }
+
+  private boolean jj_3_23()
+ {
+    if (jj_3R_86()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_492()
+ {
+    if (jj_3R_174()) return true;
+    if (jj_scan_token(COLON)) return true;
+    if (jj_scan_token(BLOCK)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_573()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(47)) jj_scanpos = xsp;
+    if (jj_3R_574()) return true;
+    if (jj_3R_575()) return true;
+    if (jj_scan_token(BEGIN)) return true;
+    if (jj_3R_576()) return true;
+    if (jj_scan_token(END)) return true;
+    if (jj_scan_token(BLOCK)) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_577()) jj_scanpos = xsp;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3_86()
+ {
+    if (jj_3R_130()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_250()
+ {
+    if (jj_3R_127()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_124()
+ {
+    if (jj_3R_68()) return true;
+    if (jj_scan_token(161)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_250()) {
+    jj_scanpos = xsp;
+    if (jj_3R_251()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_346()
+ {
+    if (jj_3R_88()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_440()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_787()
+ {
+    if (jj_3R_799()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_345()
+ {
+    if (jj_3R_87()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_786()
+ {
+    if (jj_3R_130()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_763()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_786()) {
+    jj_scanpos = xsp;
+    if (jj_3R_787()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_212()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_344()) {
+    jj_scanpos = xsp;
+    if (jj_3R_345()) {
+    jj_scanpos = xsp;
+    if (jj_3R_346()) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_344()
+ {
+    if (jj_3R_86()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_812()
+ {
+    if (jj_3R_390()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_638()
+ {
+    if (jj_3R_677()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_678()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_820()
+ {
+    if (jj_3R_822()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_637()
+ {
+    if (jj_3R_675()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_676()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_811()
+ {
+    Token xsp;
+    if (jj_3R_820()) return true;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_820()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_574()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_637()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_638()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_825()
+ {
+    if (jj_3R_347()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_824()
+ {
+    if (jj_3R_84()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_639()
+ {
+    if (jj_3R_232()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_823()
+ {
+    if (jj_3R_83()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_822()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_823()) {
+    jj_scanpos = xsp;
+    if (jj_3R_824()) {
+    jj_scanpos = xsp;
+    if (jj_3R_825()) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_575()
+ {
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_639()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_799()
+ {
+    if (jj_scan_token(PROTECTED)) return true;
+    if (jj_3R_811()) return true;
+    if (jj_scan_token(END)) return true;
+    if (jj_scan_token(PROTECTED)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_812()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3_85()
+ {
+    if (jj_3R_129()) return true;
+    return false;
+  }
+
+  private boolean jj_3_22()
+ {
+    if (jj_scan_token(GROUP)) return true;
+    if (jj_3R_85()) return true;
+    if (jj_scan_token(IS)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_381()
+ {
+    if (jj_3R_470()) return true;
+    return false;
+  }
+
+  private boolean jj_3_84()
+ {
+    if (jj_3R_84()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_380()
+ {
+    if (jj_3R_469()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_395()
+ {
+    if (jj_3R_475()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_379()
+ {
+    if (jj_3R_468()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_260()
+ {
+    Token xsp;
+    if (jj_3R_395()) return true;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_395()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_261()
+ {
+    if (jj_3R_390()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_378()
+ {
+    if (jj_3R_467()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_555()
+ {
+    if (jj_3R_466()) return true;
+    return false;
+  }
+
+  private boolean jj_3_21()
+ {
+    if (jj_3R_84()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_554()
+ {
+    if (jj_3R_129()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_377()
+ {
+    if (jj_3R_466()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_553()
+ {
+    if (jj_3R_347()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_552()
+ {
+    if (jj_3R_463()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_376()
+ {
+    if (jj_3R_129()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_375()
+ {
+    if (jj_3R_347()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_551()
+ {
+    if (jj_3R_84()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_374()
+ {
+    if (jj_3R_465()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_550()
+ {
+    if (jj_3R_461()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_373()
+ {
+    if (jj_3R_464()) return true;
+    return false;
+  }
+
+  private boolean jj_3_83()
+ {
+    if (jj_3R_83()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_549()
+ {
+    if (jj_3R_460()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_372()
+ {
+    if (jj_3R_463()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_548()
+ {
+    if (jj_3R_613()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_547()
+ {
+    if (jj_3R_457()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_371()
+ {
+    if (jj_3R_84()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_546()
+ {
+    if (jj_3R_456()) return true;
+    return false;
+  }
+
+  private boolean jj_3_20()
+ {
+    if (jj_3R_83()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_370()
+ {
+    if (jj_3R_462()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_545()
+ {
+    if (jj_3R_455()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_369()
+ {
+    if (jj_3R_461()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_544()
+ {
+    if (jj_3R_454()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_368()
+ {
+    if (jj_3R_460()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_367()
+ {
+    if (jj_3R_459()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_582()
+ {
+    if (jj_3R_175()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_366()
+ {
+    if (jj_3R_458()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_214()
+ {
+    if (jj_3R_348()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_365()
+ {
+    if (jj_3R_457()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_543()
+ {
+    if (jj_3R_83()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_213()
+ {
+    if (jj_3R_347()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_364()
+ {
+    if (jj_3R_456()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_475()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_543()) {
+    jj_scanpos = xsp;
+    if (jj_3R_544()) {
+    jj_scanpos = xsp;
+    if (jj_3R_545()) {
+    jj_scanpos = xsp;
+    if (jj_3R_546()) {
+    jj_scanpos = xsp;
+    if (jj_3R_547()) {
+    jj_scanpos = xsp;
+    if (jj_3R_548()) {
+    jj_scanpos = xsp;
+    if (jj_3R_549()) {
+    jj_scanpos = xsp;
+    if (jj_3R_550()) {
+    jj_scanpos = xsp;
+    if (jj_3R_551()) {
+    jj_scanpos = xsp;
+    if (jj_3R_552()) {
+    jj_scanpos = xsp;
+    if (jj_3R_553()) {
+    jj_scanpos = xsp;
+    if (jj_3R_554()) {
+    jj_scanpos = xsp;
+    if (jj_3R_555()) return true;
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_363()
+ {
+    if (jj_3R_455()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_362()
+ {
+    if (jj_3R_454()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_361()
+ {
+    if (jj_3R_83()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_232()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_361()) {
+    jj_scanpos = xsp;
+    if (jj_3R_362()) {
+    jj_scanpos = xsp;
+    if (jj_3R_363()) {
+    jj_scanpos = xsp;
+    if (jj_3R_364()) {
+    jj_scanpos = xsp;
+    if (jj_3R_365()) {
+    jj_scanpos = xsp;
+    if (jj_3R_366()) {
+    jj_scanpos = xsp;
+    if (jj_3R_367()) {
+    jj_scanpos = xsp;
+    if (jj_3R_368()) {
+    jj_scanpos = xsp;
+    if (jj_3R_369()) {
+    jj_scanpos = xsp;
+    if (jj_3R_370()) {
+    jj_scanpos = xsp;
+    if (jj_3R_371()) {
+    jj_scanpos = xsp;
+    if (jj_3R_372()) {
+    jj_scanpos = xsp;
+    if (jj_3R_373()) {
+    jj_scanpos = xsp;
+    if (jj_3R_374()) {
+    jj_scanpos = xsp;
+    if (jj_3R_375()) {
+    jj_scanpos = xsp;
+    if (jj_3R_376()) {
+    jj_scanpos = xsp;
+    if (jj_3R_377()) {
+    jj_scanpos = xsp;
+    if (jj_3R_378()) {
+    jj_scanpos = xsp;
+    if (jj_3R_379()) {
+    jj_scanpos = xsp;
+    if (jj_3R_380()) {
+    jj_scanpos = xsp;
+    if (jj_3R_381()) return true;
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_130()
+ {
+    if (jj_scan_token(PROTECTED)) return true;
+    if (jj_scan_token(BODY)) return true;
+    if (jj_3R_260()) return true;
+    if (jj_scan_token(END)) return true;
+    if (jj_scan_token(PROTECTED)) return true;
+    if (jj_scan_token(BODY)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_261()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_96()
+ {
+    if (jj_scan_token(FOR)) return true;
+    if (jj_3R_212()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_213()) { jj_scanpos = xsp; break; }
+    }
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_214()) { jj_scanpos = xsp; break; }
+    }
+    if (jj_scan_token(END)) return true;
+    if (jj_scan_token(FOR)) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_642()
+ {
+    if (jj_3R_480()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_667()
+ {
+    if (jj_3R_644()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_581()
+ {
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_642()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_666()
+ {
+    if (jj_3R_643()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_665()
+ {
+    if (jj_scan_token(USE)) return true;
+    if (jj_3R_698()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_631()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_665()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_666()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_667()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_804()
+ {
+    if (jj_3R_85()) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_579()
+ {
+    if (jj_scan_token(158)) return true;
+    if (jj_3R_432()) return true;
+    if (jj_scan_token(159)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_578()
+ {
+    if (jj_3R_175()) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_493()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_578()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(71)) jj_scanpos = xsp;
+    if (jj_scan_token(PROCESS)) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_579()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(47)) jj_scanpos = xsp;
+    if (jj_3R_580()) return true;
+    if (jj_scan_token(BEGIN)) return true;
+    if (jj_3R_581()) return true;
+    if (jj_scan_token(END)) return true;
+    xsp = jj_scanpos;
+    if (jj_scan_token(71)) jj_scanpos = xsp;
+    if (jj_scan_token(PROCESS)) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_582()) jj_scanpos = xsp;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_463()
+ {
+    if (jj_scan_token(ATTRIBUTE)) return true;
+    if (jj_3R_385()) return true;
+    if (jj_scan_token(OF)) return true;
+    if (jj_3R_630()) return true;
+    if (jj_scan_token(IS)) return true;
+    if (jj_3R_61()) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3_82()
+ {
+    if (jj_scan_token(GROUP)) return true;
+    if (jj_3R_85()) return true;
+    if (jj_scan_token(IS)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_641()
+ {
+    if (jj_3R_679()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_453()
+ {
+    if (jj_scan_token(160)) return true;
+    if (jj_3R_452()) return true;
+    return false;
+  }
+
+  private boolean jj_3_81()
+ {
+    if (jj_3R_84()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_580()
+ {
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_641()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_719()
+ {
+    if (jj_3R_466()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_718()
+ {
+    if (jj_3R_129()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_717()
+ {
+    if (jj_3R_347()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_716()
+ {
+    if (jj_3R_463()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_385()
+ {
+    if (jj_3R_471()) return true;
+    return false;
+  }
+
+  private boolean jj_3_80()
+ {
+    if (jj_3R_83()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_715()
+ {
+    if (jj_3R_84()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_714()
+ {
+    if (jj_3R_461()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_713()
+ {
+    if (jj_3R_460()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_712()
+ {
+    if (jj_3R_613()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_711()
+ {
+    if (jj_3R_457()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_710()
+ {
+    if (jj_3R_456()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_84()
+ {
+    if (jj_scan_token(ATTRIBUTE)) return true;
+    if (jj_3R_85()) return true;
+    if (jj_scan_token(COLON)) return true;
+    if (jj_3R_68()) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3_79()
+ {
+    if (jj_3R_91()) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_709()
+ {
+    if (jj_3R_455()) return true;
+    return false;
+  }
+
+  private boolean jj_3_19()
+ {
+    if (jj_3R_82()) return true;
+    if (jj_scan_token(RARROW)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_177()
+ {
+    if (jj_scan_token(158)) return true;
+    if (jj_3R_109()) return true;
+    if (jj_scan_token(159)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_708()
+ {
+    if (jj_3R_454()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_707()
+ {
+    if (jj_3R_83()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_679()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_707()) {
+    jj_scanpos = xsp;
+    if (jj_3R_708()) {
+    jj_scanpos = xsp;
+    if (jj_3R_709()) {
+    jj_scanpos = xsp;
+    if (jj_3R_710()) {
+    jj_scanpos = xsp;
+    if (jj_3R_711()) {
+    jj_scanpos = xsp;
+    if (jj_3R_712()) {
+    jj_scanpos = xsp;
+    if (jj_3R_713()) {
+    jj_scanpos = xsp;
+    if (jj_3R_714()) {
+    jj_scanpos = xsp;
+    if (jj_3R_715()) {
+    jj_scanpos = xsp;
+    if (jj_3R_716()) {
+    jj_scanpos = xsp;
+    if (jj_3R_717()) {
+    jj_scanpos = xsp;
+    if (jj_3R_718()) {
+    jj_scanpos = xsp;
+    if (jj_3R_719()) return true;
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_360()
+ {
+    if (jj_3R_452()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_453()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_272()
+ {
+    if (jj_3R_91()) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_512()
+ {
+    if (jj_3R_82()) return true;
+    if (jj_scan_token(RARROW)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_138()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_272()) jj_scanpos = xsp;
+    if (jj_3R_72()) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_452()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_512()) jj_scanpos = xsp;
+    if (jj_3R_513()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_813()
+ {
+    if (jj_scan_token(160)) return true;
+    if (jj_3R_80()) return true;
+    return false;
+  }
+
+  private boolean jj_3_78()
+ {
+    if (jj_scan_token(PACKAGE)) return true;
+    if (jj_3R_85()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_269()
+ {
+    if (jj_3R_91()) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_72()
+ {
+    if (jj_3R_176()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_177()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_134()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_269()) jj_scanpos = xsp;
+    if (jj_3R_219()) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3_18()
+ {
+    if (jj_3R_81()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_357()
+ {
+    if (jj_scan_token(SEVERITY)) return true;
+    if (jj_3R_61()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_356()
+ {
+    if (jj_scan_token(REPORT)) return true;
+    if (jj_3R_61()) return true;
+    return false;
+  }
+
+  private boolean jj_3_77()
+ {
+    if (jj_3R_128()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_219()
+ {
+    if (jj_scan_token(ASSERT)) return true;
+    if (jj_3R_95()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_356()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_357()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3_76()
+ {
+    if (jj_scan_token(158)) return true;
+    if (jj_3R_61()) return true;
+    if (jj_scan_token(159)) return true;
+    return false;
+  }
+
+  private boolean jj_3_75()
+ {
+    if (jj_3R_127()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_808()
+ {
+    if (jj_3R_817()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_227()
+ {
+    if (jj_3R_358()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_807()
+ {
+    if (jj_3R_81()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_797()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_807()) {
+    jj_scanpos = xsp;
+    if (jj_3R_808()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3_74()
+ {
+    if (jj_3R_126()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_226()
+ {
+    if (jj_3R_128()) return true;
+    return false;
+  }
+
+  private boolean jj_3_73()
+ {
+    if (jj_3R_125()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_225()
+ {
+    if (jj_scan_token(158)) return true;
+    if (jj_3R_61()) return true;
+    if (jj_scan_token(159)) return true;
+    return false;
+  }
+
+  private boolean jj_3_72()
+ {
+    if (jj_3R_123()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_224()
+ {
+    if (jj_3R_127()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_801()
+ {
+    if (jj_scan_token(ARRAY)) return true;
+    if (jj_3R_405()) return true;
+    if (jj_scan_token(OF)) return true;
+    if (jj_3R_635()) return true;
+    return false;
+  }
+
+  private boolean jj_3_71()
+ {
+    if (jj_3R_124()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_223()
+ {
+    if (jj_3R_126()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_222()
+ {
+    if (jj_3R_125()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_221()
+ {
+    if (jj_3R_123()) return true;
+    return false;
+  }
+
+  private boolean jj_3_17()
+ {
+    if (jj_scan_token(ARRAY)) return true;
+    if (jj_scan_token(158)) return true;
+    if (jj_3R_80()) return true;
+    return false;
+  }
+
+  private boolean jj_3_70()
+ {
+    if (jj_3R_123()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_800()
+ {
+    if (jj_scan_token(ARRAY)) return true;
+    if (jj_scan_token(158)) return true;
+    if (jj_3R_80()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_813()) { jj_scanpos = xsp; break; }
+    }
+    if (jj_scan_token(159)) return true;
+    if (jj_scan_token(OF)) return true;
+    if (jj_3R_635()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_105()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_220()) {
+    jj_scanpos = xsp;
+    if (jj_3R_221()) {
+    jj_scanpos = xsp;
+    if (jj_3R_222()) {
+    jj_scanpos = xsp;
+    if (jj_3R_223()) {
+    jj_scanpos = xsp;
+    if (jj_3R_224()) {
+    jj_scanpos = xsp;
+    if (jj_3R_225()) {
+    jj_scanpos = xsp;
+    if (jj_3R_226()) {
+    jj_scanpos = xsp;
+    if (jj_3R_227()) return true;
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_220()
+ {
+    if (jj_3R_124()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_791()
+ {
+    if (jj_3R_801()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_790()
+ {
+    if (jj_3R_800()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_767()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_790()) {
+    jj_scanpos = xsp;
+    if (jj_3R_791()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_644()
+ {
+    if (jj_scan_token(PORT)) return true;
+    if (jj_scan_token(MAP)) return true;
+    if (jj_scan_token(158)) return true;
+    if (jj_3R_681()) return true;
+    if (jj_scan_token(159)) return true;
+    return false;
+  }
+
+  private boolean jj_3_16()
+ {
+    if (jj_3R_79()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_806()
+ {
+    if (jj_3R_816()) return true;
+    return false;
+  }
+
+  private boolean jj_3_15()
+ {
+    if (jj_3R_78()) return true;
+    return false;
+  }
+
+  private boolean jj_3_14()
+ {
+    if (jj_3R_76()) return true;
+    if (jj_scan_token(COLON)) return true;
+    if (jj_3R_77()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_706()
+ {
+    if (jj_3R_752()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_180()
+ {
+    if (jj_3R_91()) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_178()
+ {
+    if (jj_3R_91()) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_75()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_180()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(71)) jj_scanpos = xsp;
+    if (jj_3R_181()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_429()
+ {
+    if (jj_3R_497()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_74()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_178()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(71)) jj_scanpos = xsp;
+    if (jj_3R_179()) return true;
+    return false;
+  }
+
+  private boolean jj_3_13()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_74()) {
+    jj_scanpos = xsp;
+    if (jj_3R_75()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_73()
+ {
+    if (jj_3R_91()) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_428()
+ {
+    if (jj_3R_79()) return true;
+    return false;
+  }
+
+  private boolean jj_3_12()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_73()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(71)) jj_scanpos = xsp;
+    if (jj_scan_token(ASSERT)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_71()
+ {
+    if (jj_3R_91()) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_677()
+ {
+    if (jj_scan_token(PORT)) return true;
+    if (jj_scan_token(158)) return true;
+    if (jj_3R_706()) return true;
+    if (jj_scan_token(159)) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3_11()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_71()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(71)) jj_scanpos = xsp;
+    if (jj_3R_72()) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_70()
+ {
+    if (jj_3R_175()) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_427()
+ {
+    if (jj_3R_78()) return true;
+    return false;
+  }
+
+  private boolean jj_3_10()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_70()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(71)) jj_scanpos = xsp;
+    if (jj_scan_token(PROCESS)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_69()
+ {
+    if (jj_3R_174()) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_426()
+ {
+    if (jj_3R_496()) return true;
+    return false;
+  }
+
+  private boolean jj_3_9()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_69()) jj_scanpos = xsp;
+    if (jj_scan_token(BLOCK)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_805()
+ {
+    if (jj_3R_815()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_425()
+ {
+    if (jj_3R_495()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_424()
+ {
+    if (jj_3R_103()) return true;
+    return false;
+  }
+
+  private boolean jj_3_69()
+ {
+    if (jj_3R_121()) return true;
+    if (jj_3R_122()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_423()
+ {
+    if (jj_3R_494()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_796()
+ {
+    if (jj_3R_131()) return true;
+    if (jj_scan_token(UNITS)) return true;
+    if (jj_3R_804()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_805()) { jj_scanpos = xsp; break; }
+    }
+    if (jj_scan_token(END)) return true;
+    if (jj_scan_token(UNITS)) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_806()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_422()
+ {
+    if (jj_3R_493()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_421()
+ {
+    if (jj_3R_492()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_336()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_421()) {
+    jj_scanpos = xsp;
+    if (jj_3R_422()) {
+    jj_scanpos = xsp;
+    if (jj_3R_423()) {
+    jj_scanpos = xsp;
+    if (jj_3R_424()) {
+    jj_scanpos = xsp;
+    if (jj_3R_425()) {
+    jj_scanpos = xsp;
+    if (jj_3R_426()) {
+    jj_scanpos = xsp;
+    if (jj_3R_427()) {
+    jj_scanpos = xsp;
+    if (jj_3R_428()) {
+    jj_scanpos = xsp;
+    if (jj_3R_429()) return true;
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_248()
+ {
+    if (jj_3R_121()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_120()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_248()) jj_scanpos = xsp;
+    if (jj_3R_122()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_491()
+ {
+    if (jj_3R_85()) return true;
+    if (jj_scan_token(IN)) return true;
+    if (jj_3R_89()) return true;
+    return false;
+  }
+
+  private boolean jj_3_68()
+ {
+    if (jj_scan_token(GROUP)) return true;
+    if (jj_3R_85()) return true;
+    if (jj_scan_token(IS)) return true;
+    return false;
+  }
+
+  private boolean jj_3_67()
+ {
+    if (jj_3R_84()) return true;
+    return false;
+  }
+
+  private boolean jj_3_8()
+ {
+    if (jj_3R_68()) return true;
+    if (jj_scan_token(161)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_451()
+ {
+    if (jj_3R_215()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_258()
+ {
+    if (jj_scan_token(160)) return true;
+    if (jj_3R_257()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_450()
+ {
+    if (jj_3R_124()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_358()
+ {
+    if (jj_scan_token(NEW)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_450()) {
+    jj_scanpos = xsp;
+    if (jj_3R_451()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_624()
+ {
+    if (jj_scan_token(ASSIGN)) return true;
+    if (jj_3R_61()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_609()
+ {
+    if (jj_3R_391()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_608()
+ {
+    if (jj_3R_85()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_516()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_608()) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(136)) {
+    jj_scanpos = xsp;
+    if (jj_3R_609()) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_626()
+ {
+    if (jj_scan_token(COLON)) return true;
+    if (jj_3R_215()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_461()
+ {
+    if (jj_scan_token(ALIAS)) return true;
+    if (jj_3R_516()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_626()) jj_scanpos = xsp;
+    if (jj_scan_token(IS)) return true;
+    if (jj_3R_125()) return true;
+    if (jj_3R_118()) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3_66()
+ {
+    if (jj_scan_token(GROUP)) return true;
+    if (jj_3R_85()) return true;
+    if (jj_scan_token(IS)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_127()
+ {
+    if (jj_scan_token(158)) return true;
+    if (jj_3R_257()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_258()) { jj_scanpos = xsp; break; }
+    }
+    if (jj_scan_token(159)) return true;
+    return false;
+  }
+
+  private boolean jj_3_65()
+ {
+    if (jj_3R_83()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_459()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(90)) jj_scanpos = xsp;
+    if (jj_scan_token(VARIABLE)) return true;
+    if (jj_3R_233()) return true;
+    if (jj_scan_token(COLON)) return true;
+    if (jj_3R_215()) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_624()) jj_scanpos = xsp;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3_7()
+ {
+    if (jj_3R_68()) return true;
+    if (jj_scan_token(158)) return true;
+    if (jj_3R_67()) return true;
+    if (jj_scan_token(159)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_295()
+ {
+    if (jj_scan_token(CONCAT)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_294()
+ {
+    if (jj_scan_token(SUB)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_147()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_293()) {
+    jj_scanpos = xsp;
+    if (jj_3R_294()) {
+    jj_scanpos = xsp;
+    if (jj_3R_295()) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3_6()
+ {
+    if (jj_3R_66()) return true;
+    if (jj_scan_token(158)) return true;
+    if (jj_3R_67()) return true;
+    if (jj_scan_token(159)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_293()
+ {
+    if (jj_scan_token(ADD)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_605()
+ {
+    if (jj_3R_67()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_482()
+ {
+    if (jj_3R_125()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_604()
+ {
+    if (jj_3R_68()) return true;
+    if (jj_scan_token(158)) return true;
+    if (jj_3R_67()) return true;
+    if (jj_scan_token(159)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_207()
+ {
+    if (jj_3R_342()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_603()
+ {
+    if (jj_3R_66()) return true;
+    if (jj_scan_token(158)) return true;
+    if (jj_3R_67()) return true;
+    if (jj_scan_token(159)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_513()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_603()) {
+    jj_scanpos = xsp;
+    if (jj_3R_604()) {
+    jj_scanpos = xsp;
+    if (jj_3R_605()) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_406()
+ {
+    if (jj_3R_125()) return true;
+    return false;
+  }
+
+  private boolean jj_3_5()
+ {
+    if (jj_3R_65()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_109()
+ {
+    if (jj_3R_231()) return true;
+    return false;
+  }
+
+  private boolean jj_3_4()
+ {
+    if (jj_3R_64()) return true;
+    return false;
+  }
+
+  private boolean jj_3_3()
+ {
+    if (jj_3R_63()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_93()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(41)) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_207()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_328()
+ {
+    if (jj_3R_125()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_171()
+ {
+    if (jj_3R_328()) return true;
+    return false;
+  }
+
+  private boolean jj_3_2()
+ {
+    if (jj_3R_62()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_170()
+ {
+    if (jj_3R_65()) return true;
+    return false;
+  }
+
+  private boolean jj_3_1()
+ {
+    if (jj_3R_61()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_391()
+ {
+    if (jj_scan_token(string_literal)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_169()
+ {
+    if (jj_3R_64()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_280()
+ {
+    if (jj_scan_token(WHEN)) return true;
+    if (jj_3R_95()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_168()
+ {
+    if (jj_3R_63()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_65()
+ {
+    if (jj_3R_125()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_167()
+ {
+    if (jj_3R_62()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_166()
+ {
+    if (jj_3R_61()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_67()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_166()) {
+    jj_scanpos = xsp;
+    if (jj_3R_167()) {
+    jj_scanpos = xsp;
+    if (jj_3R_168()) {
+    jj_scanpos = xsp;
+    if (jj_3R_169()) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(65)) {
+    jj_scanpos = xsp;
+    if (jj_3R_170()) {
+    jj_scanpos = xsp;
+    if (jj_3R_171()) return true;
+    }
+    }
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_102()
+ {
+    if (jj_3R_125()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_761()
+ {
+    if (jj_scan_token(ACCESS)) return true;
+    if (jj_3R_215()) return true;
+    return false;
+  }
+
+  private boolean jj_3_64()
+ {
+    if (jj_3R_120()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_279()
+ {
+    if (jj_3R_402()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_101()
+ {
+    if (jj_3R_125()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_121()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(137)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(130)) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_770()
+ {
+    if (jj_3R_90()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_240()
+ {
+    if (jj_3R_121()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_116()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_239()) {
+    jj_scanpos = xsp;
+    if (jj_3R_240()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_239()
+ {
+    if (jj_3R_120()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_769()
+ {
+    if (jj_3R_90()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_286()
+ {
+    if (jj_3R_91()) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_145()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_286()) jj_scanpos = xsp;
+    if (jj_scan_token(NULL)) return true;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_119()
+ {
+    if (jj_scan_token(160)) return true;
+    if (jj_3R_61()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_278()
+ {
+    if (jj_3R_91()) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_142()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_278()) jj_scanpos = xsp;
+    if (jj_scan_token(NEXT)) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_279()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_280()) jj_scanpos = xsp;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_814()
+ {
+    if (jj_3R_635()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_420()
+ {
+    if (jj_3R_491()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_388()
+ {
+    if (jj_scan_token(160)) return true;
+    if (jj_3R_61()) return true;
+    return false;
+  }
+
+  private boolean jj_3_63()
+ {
+    if (jj_3R_117()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_556()
+ {
+    if (jj_3R_491()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_802()
+ {
+    if (jj_3R_233()) return true;
+    if (jj_scan_token(COLON)) return true;
+    if (jj_3R_814()) return true;
+    return false;
+  }
+
+  private boolean jj_3_62()
+ {
+    if (jj_scan_token(158)) return true;
+    if (jj_3R_61()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_119()) { jj_scanpos = xsp; break; }
+    }
+    if (jj_scan_token(159)) return true;
+    return false;
+  }
+
+  private boolean jj_3_61()
+ {
+    if (jj_scan_token(158)) return true;
+    if (jj_3R_89()) return true;
+    if (jj_scan_token(159)) return true;
+    return false;
+  }
+
+  private boolean jj_3_59()
+ {
+    if (jj_scan_token(158)) return true;
+    if (jj_3R_61()) return true;
+    if (jj_scan_token(159)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_98()
+ {
+    if (jj_3R_215()) return true;
+    return false;
+  }
+
+  private boolean jj_3_60()
+ {
+    if (jj_3R_118()) return true;
+    if (jj_scan_token(161)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_245()
+ {
+    if (jj_3R_117()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_194()
+ {
+    if (jj_3R_215()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_244()
+ {
+    if (jj_scan_token(158)) return true;
+    if (jj_3R_61()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_388()) { jj_scanpos = xsp; break; }
+    }
+    if (jj_scan_token(159)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_243()
+ {
+    if (jj_scan_token(158)) return true;
+    if (jj_3R_89()) return true;
+    if (jj_scan_token(159)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_253()
+ {
+    if (jj_3R_391()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_386()
+ {
+    if (jj_scan_token(158)) return true;
+    if (jj_3R_61()) return true;
+    if (jj_scan_token(159)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_242()
+ {
+    if (jj_scan_token(164)) return true;
+    if (jj_3R_387()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_661()
+ {
+    if (jj_3R_675()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_241()
+ {
+    if (jj_3R_118()) return true;
+    if (jj_scan_token(161)) return true;
+    if (jj_3R_385()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_386()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3_58()
+ {
+    if (jj_3R_117()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_117()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_241()) {
+    jj_scanpos = xsp;
+    if (jj_3R_242()) {
+    jj_scanpos = xsp;
+    if (jj_3R_243()) {
+    jj_scanpos = xsp;
+    if (jj_3R_244()) return true;
+    }
+    }
+    }
+    xsp = jj_scanpos;
+    if (jj_3R_245()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_662()
+ {
+    if (jj_3R_677()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_254()
+ {
+    if (jj_3R_117()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_252()
+ {
+    if (jj_3R_390()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_125()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_252()) {
+    jj_scanpos = xsp;
+    if (jj_3R_253()) return true;
+    }
+    xsp = jj_scanpos;
+    if (jj_3R_254()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_752()
+ {
+    if (jj_3R_647()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_310()
+ {
+    if (jj_scan_token(REM)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_309()
+ {
+    if (jj_scan_token(MOD)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_308()
+ {
+    if (jj_scan_token(DIV)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_594()
+ {
+    if (jj_3R_647()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_156()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_307()) {
+    jj_scanpos = xsp;
+    if (jj_3R_308()) {
+    jj_scanpos = xsp;
+    if (jj_3R_309()) {
+    jj_scanpos = xsp;
+    if (jj_3R_310()) return true;
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_307()
+ {
+    if (jj_scan_token(MUL)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_751()
+ {
+    if (jj_3R_647()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_384()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(44)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(68)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(46)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(22)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(50)) return true;
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_680()
+ {
+    if (jj_3R_360()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_778()
+ {
+    if (jj_3R_402()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_681()
+ {
+    if (jj_3R_360()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_231()
+ {
+    if (jj_3R_360()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_276()
+ {
+    if (jj_3R_403()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_275()
+ {
+    if (jj_3R_402()) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_611()
+ {
+    if (jj_3R_649()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_141()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_275()) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_276()) jj_scanpos = xsp;
+    if (jj_scan_token(LOOP)) return true;
+    if (jj_3R_277()) return true;
+    if (jj_scan_token(END)) return true;
+    if (jj_scan_token(LOOP)) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_778()) jj_scanpos = xsp;
+    if (jj_scan_token(SEMICOLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_418()
+ {
+    if (jj_scan_token(XNOR)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_417()
+ {
+    if (jj_scan_token(XOR)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_296()
+ {
+    if (jj_3R_61()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_416()
+ {
+    if (jj_scan_token(NOR)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_115()
+ {
+    if (jj_scan_token(PACKAGE)) return true;
+    if (jj_3R_85()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_415()
+ {
+    if (jj_scan_token(NAND)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_414()
+ {
+    if (jj_scan_token(OR)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_327()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_413()) {
+    jj_scanpos = xsp;
+    if (jj_3R_414()) {
+    jj_scanpos = xsp;
+    if (jj_3R_415()) {
+    jj_scanpos = xsp;
+    if (jj_3R_416()) {
+    jj_scanpos = xsp;
+    if (jj_3R_417()) {
+    jj_scanpos = xsp;
+    if (jj_3R_418()) return true;
+    }
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_413()
+ {
+    if (jj_scan_token(AND)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_597()
+ {
+    if (jj_3R_61()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_477()
+ {
+    if (jj_3R_61()) return true;
+    return false;
+  }
+
+  private boolean jj_3_57()
+ {
+    if (jj_3R_116()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_595()
+ {
+    if (jj_3R_61()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_636()
+ {
+    if (jj_3R_61()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_256()
+ {
+    if (jj_3R_263()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_126()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_255()) {
+    jj_scanpos = xsp;
+    if (jj_3R_256()) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(141)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(134)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(62)) return true;
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3_56()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(33)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(26)) {
+    jj_scanpos = xsp;
+    if (jj_3R_115()) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_255()
+ {
+    if (jj_3R_116()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_740()
+ {
+    if (jj_3R_61()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_236()
+ {
+    if (jj_scan_token(ASSIGN)) return true;
+    if (jj_3R_383()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_238()
+ {
+    if (jj_scan_token(ASSIGN)) return true;
+    if (jj_3R_383()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_211()
+ {
+    if (jj_3R_61()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_383()
+ {
+    if (jj_3R_61()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_100()
+ {
+    if (jj_3R_85()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_91()
+ {
+    if (jj_3R_85()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_63()
+ {
+    if (jj_3R_125()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_479()
+ {
+    if (jj_scan_token(FOR)) return true;
+    if (jj_3R_556()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_403()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_478()) {
+    jj_scanpos = xsp;
+    if (jj_3R_479()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_478()
+ {
+    if (jj_scan_token(WHILE)) return true;
+    if (jj_3R_95()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_122()
+ {
+    if (jj_3R_125()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_689()
+ {
+    if (jj_scan_token(SEMICOLON)) return true;
+    if (jj_3R_688()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_795()
+ {
+    if (jj_scan_token(ASSIGN)) return true;
+    if (jj_3R_383()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_237()
+ {
+    if (jj_3R_384()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_159()
+ {
+    if (jj_3R_125()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_113()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(109)) jj_scanpos = xsp;
+    if (jj_3R_233()) return true;
+    if (jj_scan_token(COLON)) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_237()) jj_scanpos = xsp;
+    if (jj_3R_215()) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_238()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_150()
+ {
+    if (jj_3R_125()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_235()
+ {
+    if (jj_3R_384()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_112()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(89)) jj_scanpos = xsp;
+    if (jj_3R_233()) return true;
+    if (jj_scan_token(COLON)) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_235()) jj_scanpos = xsp;
+    if (jj_3R_215()) return true;
+    xsp = jj_scanpos;
+    if (jj_scan_token(23)) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_236()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_819()
+ {
+    if (jj_3R_390()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_647()
+ {
+    if (jj_3R_688()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_689()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_803()
+ {
+    if (jj_3R_390()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_114()
+ {
+    if (jj_scan_token(FILE)) return true;
+    if (jj_3R_233()) return true;
+    if (jj_scan_token(COLON)) return true;
+    if (jj_3R_215()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_158()
+ {
+    if (jj_3R_125()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_688()
+ {
+    if (jj_3R_720()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_62()
+ {
+    if (jj_3R_125()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_794()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(44)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(68)) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_780()
+ {
+    if (jj_scan_token(QUANTITY)) return true;
+    if (jj_3R_233()) return true;
+    if (jj_scan_token(COLON)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_794()) jj_scanpos = xsp;
+    if (jj_3R_215()) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_795()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_476()
+ {
+    if (jj_3R_125()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_176()
+ {
+    if (jj_3R_125()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_779()
+ {
+    if (jj_scan_token(TERMINAL)) return true;
+    if (jj_3R_233()) return true;
+    if (jj_scan_token(COLON)) return true;
+    if (jj_3R_635()) return true;
+    return false;
+  }
+
+  private boolean jj_3_55()
+ {
+    if (jj_3R_114()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_107()
+ {
+    if (jj_3R_125()) return true;
+    return false;
+  }
+
+  private boolean jj_3_54()
+ {
+    if (jj_3R_113()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_234()
+ {
+    if (jj_scan_token(ASSIGN)) return true;
+    if (jj_3R_383()) return true;
+    return false;
+  }
+
+  private boolean jj_3_53()
+ {
+    if (jj_3R_112()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_758()
+ {
+    if (jj_3R_780()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_757()
+ {
+    if (jj_3R_779()) return true;
+    return false;
+  }
+
+  private boolean jj_3_52()
+ {
+    if (jj_3R_111()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_816()
+ {
+    if (jj_3R_390()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_756()
+ {
+    if (jj_3R_114()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_755()
+ {
+    if (jj_3R_113()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_359()
+ {
+    if (jj_3R_125()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_754()
+ {
+    if (jj_3R_112()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_753()
+ {
+    if (jj_3R_111()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_720()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_753()) {
+    jj_scanpos = xsp;
+    if (jj_3R_754()) {
+    jj_scanpos = xsp;
+    if (jj_3R_755()) {
+    jj_scanpos = xsp;
+    if (jj_3R_756()) {
+    jj_scanpos = xsp;
+    if (jj_3R_757()) {
+    jj_scanpos = xsp;
+    if (jj_3R_758()) return true;
+    }
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_721()
+ {
+    if (jj_scan_token(160)) return true;
+    if (jj_3R_76()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_632()
+ {
+    if (jj_3R_125()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_332()
+ {
+    if (jj_scan_token(158)) return true;
+    if (jj_3R_100()) return true;
+    if (jj_scan_token(159)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_106()
+ {
+    if (jj_3R_125()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_111()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(27)) jj_scanpos = xsp;
+    if (jj_3R_233()) return true;
+    if (jj_scan_token(COLON)) return true;
+    xsp = jj_scanpos;
+    if (jj_scan_token(44)) jj_scanpos = xsp;
+    if (jj_3R_215()) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_234()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_330()
+ {
+    if (jj_3R_125()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_333()
+ {
+    if (jj_3R_125()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_648()
+ {
+    if (jj_3R_76()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_721()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_610()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_648()) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(67)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(12)) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_66()
+ {
+    if (jj_3R_125()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_184()
+ {
+    if (jj_scan_token(CONFIGURATION)) return true;
+    if (jj_3R_333()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_64()
+ {
+    if (jj_3R_125()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_183()
+ {
+    if (jj_scan_token(ENTITY)) return true;
+    if (jj_3R_331()) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_332()) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3R_182()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(25)) jj_scanpos = xsp;
+    if (jj_3R_330()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_77()
+ {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_182()) {
+    jj_scanpos = xsp;
+    if (jj_3R_183()) {
+    jj_scanpos = xsp;
+    if (jj_3R_184()) return true;
+    }
+    }
+    return false;
+  }
+
+  /** Generated Token Manager. */
+  public VhdlParserCoreTokenManager token_source;
+  SimpleCharStream jj_input_stream;
+  /** Current token. */
+  public Token token;
+  /** Next token. */
+  public Token jj_nt;
+  private int jj_ntk;
+  private Token jj_scanpos, jj_lastpos;
+  private int jj_la;
+  private int jj_gen;
+  final private int[] jj_la1 = new int[306];
+  static private int[] jj_la1_0;
+  static private int[] jj_la1_1;
+  static private int[] jj_la1_2;
+  static private int[] jj_la1_3;
+  static private int[] jj_la1_4;
+  static private int[] jj_la1_5;
+  static {
+      jj_la1_init_0();
+      jj_la1_init_1();
+      jj_la1_init_2();
+      jj_la1_init_3();
+      jj_la1_init_4();
+      jj_la1_init_5();
+   }
+   private static void jj_la1_init_0() {
+      jj_la1_0 = new int[] {0x0,0x0,0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x4000,0x0,0x1a020800,0x1210080,0x1000080,0x8000,0x0,0x8000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa000800,0x10020000,0x0,0x1a020800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1210080,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000,0x8000,0x0,0x0,0x0,0x0,0x0,0x0,0x4000000,0x0,0x20000,0x20000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4004000,0x0,0x20000000,0x80,0x4000000,0xe004000,0x0,0x0,0x40000,0x0,0x0,0x8000800,0x10020000,0x0,0x8000,0x0,0x0,0x18020800,0x0,0x0,0x0,0x1000,0x0,0x10000,0x0,0x0,0x0,0x0,0x0,0x0,0x2000,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x1a020800,0x1210080,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x40000000,0x0,0x0,0x80,0x0,0x2000000,0x0,0x6000000,0x0,0x1000,0x8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400000,0x800000,0x0,0x0,0x400000,0x0,0x0,0x4000,0x0,0x0,0x2000,0x0,0x0,0x0,0x80,0x400000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0x0,0x0,0x8000800,0x0,0x8000800,0x0,0x0,0xa000800,0x10020000,0x0,0x1a020800,0x0,0x0,0x0,0x0,0x4000000,0x0,0x8000800,0x20000,0x0,0x8020800,0x0,0x0,0x0,0x0,0x0,0x0,0x1210000,0x0,0x8000800,0x20000,0x0,0x8020800,0x0,0x20000,0x20000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x0,0x0,0x0,0x0,0x1210000,0x200000,0x0,0x0,0x0,0x800000,0x0,0x800000,0x0,0x1000,0x0,0x0,0x0,0x0,0x0,0x8000800,0x20000,0x0,0x8020800,0x0,0x0,0x0,0x0,0x0,0x0,0x1210000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000,0x0,0x0,0x8100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x400,0x400,0x80,0x1000080,0x0,0x0,0x0,0x0,0x0,0x80000000,0x40000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8020800,0x8000800,0x20000,0x0,0x1210000,0x0,0x0,0x0,0x0,};
+   }
+   private static void jj_la1_init_1() {
+      jj_la1_1 = new int[] {0x0,0x0,0x0,0x62000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000938,0x62000c00,0x62000c00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x0,0x0,0x10,0x828,0x10,0x1000100,0x1000938,0x80,0x80,0x0,0x0,0x0,0x0,0x8000,0x0,0x62000c00,0x0,0x10,0x0,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x80,0x10,0x8000,0x80,0x0,0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100,0x100,0x10,0x0,0x0,0x20000,0x20000,0x0,0x0,0x2000,0x20002,0x0,0x0,0x62000000,0x2,0x109012a,0x0,0x0,0x0,0x2,0x0,0x828,0x0,0x1000100,0x0,0x0,0x0,0x1000928,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10800000,0x62000000,0x8000,0x1000,0x1000,0x8000,0x0,0x0,0x1000938,0x62000c00,0x0,0x0,0x10,0x0,0x0,0x410,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x62000000,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x1000,0x0,0x0,0x1000,0x1000,0x0,0x0,0x0,0x45000,0x0,0x0,0x0,0x45000,0x0,0x10,0x0,0x40000000,0x0,0x10800000,0x0,0x10,0x0,0x20000000,0x45000,0x400000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x200,0x2000,0x0,0x0,0x828,0x100,0x928,0x0,0x0,0x828,0x0,0x1000100,0x1000928,0x0,0x0,0x0,0x2000000,0x2,0x0,0x828,0x0,0x100,0x928,0x0,0x0,0x0,0x8000,0x0,0x0,0x44100414,0x0,0x828,0x0,0x100,0x928,0x0,0x820,0x820,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x62000000,0x0,0x0,0x0,0x0,0x44100414,0x0,0x0,0x0,0x2000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x0,0x828,0x0,0x100,0x928,0x20,0x0,0x800,0x800,0x0,0x820,0x44100414,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x0,0x62000000,0x0,0x0,0x62000000,0x62000c00,0x40000000,0x800,0x800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800,0x800,0x8000,0x0,0x920,0x820,0x0,0x100,0x44100414,0x0,0x0,0x0,0x0,};
+   }
+   private static void jj_la1_init_2() {
+      jj_la1_2 = new int[] {0x0,0x2,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6003200,0x1580,0x1100,0x0,0x0,0x0,0x80000,0x1000000,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x0,0x0,0x6001200,0x0,0x2000,0x6003200,0x0,0x0,0x40,0x40,0x0,0x0,0x0,0x0,0x1580,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x40,0x0,0x0,0x0,0x40,0x0,0x0,0x40,0x8000,0x8000,0x0,0x80,0x80,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000,0x0,0x0,0x0,0x20000,0x20000,0x20,0x0,0x0,0x0,0x2,0x2000220,0x0,0x0,0x0,0x0,0x0,0x6001200,0x0,0x0,0x8000,0x0,0x0,0x6001200,0x0,0x40,0x0,0x8,0x80,0x480,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x2,0x10,0x10,0x2,0x0,0x0,0x6003200,0x1580,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x2000,0x10,0x10,0x0,0x0,0x2000000,0x10,0x0,0x0,0x0,0x10,0x0,0x0,0x20,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x10,0x40000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6002000,0x0,0x20000,0x20,0x0,0x4001200,0x0,0x4001200,0x20,0x0,0x6001200,0x0,0x0,0x6001200,0x0,0x0,0x0,0x0,0x0,0x0,0x4001200,0x0,0x0,0x4001200,0x0,0x80,0x0,0x0,0x80,0x0,0x180000,0x0,0x4001200,0x0,0x0,0x4001200,0x0,0x1200,0x1200,0x800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000000,0x0,0x0,0x4000,0x0,0x0,0x0,0x180000,0x0,0xd8600000,0x0,0x20000,0x10000,0x0,0x10000,0x0,0x8,0x0,0x100000,0x0,0x200,0x0,0x4001200,0x0,0x0,0x4001200,0x200,0x0,0x1000,0x1000,0x0,0x1200,0x180000,0x2000,0x0,0x0,0x0,0x0,0x0,0x20000000,0x0,0x0,0x0,0xc800,0x0,0x0,0x4000000,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1100,0x0,0x1000,0x1000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000,0x1000,0x0,0x0,0x4001200,0x4001200,0x0,0x0,0x180000,0x0,0x4000,0x4000000,0x0,};
+   }
+   private static void jj_la1_init_3() {
+      jj_la1_3 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3107,0x20000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000,0x0,0x0,0x1000,0x0,0x2102,0x1000,0x5,0x3107,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000,0x0,0x0,0x8000,0x0,0x0,0x0,0x8000,0x0,0x0,0x0,0x1000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000,0x8000,0x0,0x0,0x1000,0x1000,0x0,0x0,0x0,0x1000,0x1000,0x20,0x0,0x80,0x1000,0x0,0x20,0x0,0x0,0x2507,0x0,0x0,0x0,0x0,0x0,0x2102,0x1000,0x5,0x0,0x0,0x40,0x3107,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000,0xc0000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3107,0x20000,0x0,0x0,0x0,0x0,0x8000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000,0x0,0x0,0x10000,0x0,0x0,0x0,0xc0000,0x0,0x10000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000,0x0,0x0,0x2004,0x0,0x80,0x0,0x0,0x3102,0x0,0x3102,0x0,0x0,0x2102,0x1000,0x5,0x3107,0x0,0x0,0x0,0x0,0x0,0x0,0x2102,0x1000,0x0,0x3102,0x0,0x0,0x0,0x0,0x0,0x0,0x14000,0x0,0x2102,0x1000,0x0,0x3102,0x0,0x1000,0x1000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x14000,0x0,0x0,0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2102,0x1000,0x0,0x3102,0x0,0x0,0x0,0x0,0x0,0x0,0x14000,0x0,0x0,0x40,0x0,0x40,0x0,0x0,0x0,0x0,0x100,0x0,0x0,0x0,0x0,0x0,0x0,0x800,0x0,0x0,0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x8000,0x0,0x0,0x0,0x0,0x0,0x0,0x3102,0x2102,0x1000,0x0,0x14000,0x0,0x0,0x0,0x0,};
+   }
+   private static void jj_la1_init_4() {
+      jj_la1_4 = new int[] {0x204,0x0,0x2820,0x40062b64,0xe0000,0x0,0x8000000,0x2920,0x2820,0x0,0x820,0x0,0x40062b64,0x40062b64,0x0,0x0,0x0,0x0,0x0,0x820,0x0,0x0,0x40000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000000,0x40000000,0x0,0x820,0x40062b64,0x820,0x2820,0x0,0x0,0x0,0x820,0x0,0x820,0x820,0x0,0x4000000,0x0,0x0,0x0,0x0,0x820,0x0,0x0,0x0,0x0,0x820,0x0,0x0,0x0,0x0,0x0,0x0,0x820,0x0,0x0,0x0,0x10000000,0x40000000,0x0,0x0,0x0,0x0,0x0,0x0,0x2820,0x0,0x40062b64,0x0,0x0,0x0,0x0,0x0,0x0,0x820,0x0,0x0,0x0,0x2820,0x40000000,0x0,0x0,0x0,0x0,0x0,0x2920,0x2820,0x2820,0x2920,0x920,0x0,0x820,0x820,0x0,0x0,0x40002b64,0x0,0x0,0x0,0x0,0x2820,0x2820,0x0,0x40062b64,0x820,0x820,0x2820,0x0,0x0,0x0,0x2920,0x0,0x820,0x0,0x820,0x0,0x0,0x820,0x0,0x40062b64,0x0,0x0,0x40000000,0x2820,0x0,0x820,0x0,0x0,0x10000000,0x0,0x0,0x0,0x10000000,0x4000000,0x0,0x0,0x0,0x10000000,0x0,0x0,0x10000000,0x0,0x0,0x2960,0x0,0x0,0x820,0x0,0x820,0x4000,0x0,0x18000,0x2820,0x0,0x0,0x820,0x820,0x0,0x820,0x204,0x0,0x0,0x0,0x0,0x820,0x0,0x0,0x0,0x0,0x820,0x0,0x0,0x0,0x0,0x820,0x820,0x2820,0x0,0x0,0x40000000,0x0,0x0,0x0,0x0,0x820,0x0,0x40000000,0x0,0x0,0x820,0x48002820,0x820,0x0,0x0,0x0,0x0,0x820,0x0,0x0,0x0,0x40000000,0x2820,0x820,0x820,0x820,0x820,0x3f00000,0x3f00000,0x820,0x0,0x820,0x40062b64,0x0,0x2820,0x0,0x0,0x48002820,0x820,0x0,0x60000,0x0,0x0,0x10000000,0x0,0x0,0x2820,0x2820,0x0,0x60000,0x0,0x2820,0x0,0x0,0x0,0x0,0x0,0x40000000,0x0,0x0,0x40000000,0x0,0x48002820,0x0,0x10000000,0x0,0x10000000,0x0,0x10000000,0x0,0x2920,0x40002820,0x0,0x40000000,0x0,0x0,0x0,0x10000000,0x0,0x0,0x0,0x0,0x40062b64,0x0,0x0,0x40062b64,0x40062b64,0x820,0x0,0x0,0x0,0x820,0x0,0x0,0x820,0x820,0x0,0x820,0x820,0x0,0x0,0x0,0x820,0x0,0x0,0x0,0x0,0x48002820,0x820,0x820,0x0,0x10000000,};
+   }
+   private static void jj_la1_init_5() {
+      jj_la1_5 = new int[] {0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x1,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x1,0x0,0x0,0x0,0x0,0x1,0x0,0x1,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x1,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
+   }
+  final private JJCalls[] jj_2_rtns = new JJCalls[140];
+  private boolean jj_rescan = false;
+  private int jj_gc = 0;
+
+  /** Constructor with InputStream. */
+  public VhdlParserCore(java.io.InputStream stream) {
+     this(stream, null);
+  }
+  /** Constructor with InputStream and supplied encoding */
+  public VhdlParserCore(java.io.InputStream stream, String encoding) {
+    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
+    token_source = new VhdlParserCoreTokenManager(jj_input_stream);
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 306; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  /** Reinitialise. */
+  public void ReInit(java.io.InputStream stream) {
+     ReInit(stream, null);
+  }
+  /** Reinitialise. */
+  public void ReInit(java.io.InputStream stream, String encoding) {
+    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
+    token_source.ReInit(jj_input_stream);
+    token = new Token();
+    jj_ntk = -1;
+    jjtree.reset();
+    jj_gen = 0;
+    for (int i = 0; i < 306; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  /** Constructor. */
+  public VhdlParserCore(java.io.Reader stream) {
+    jj_input_stream = new SimpleCharStream(stream, 1, 1);
+    token_source = new VhdlParserCoreTokenManager(jj_input_stream);
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 306; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  /** Reinitialise. */
+  public void ReInit(java.io.Reader stream) {
+    jj_input_stream.ReInit(stream, 1, 1);
+    token_source.ReInit(jj_input_stream);
+    token = new Token();
+    jj_ntk = -1;
+    jjtree.reset();
+    jj_gen = 0;
+    for (int i = 0; i < 306; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  /** Constructor with generated Token Manager. */
+  public VhdlParserCore(VhdlParserCoreTokenManager tm) {
+    token_source = tm;
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 306; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  /** Reinitialise. */
+  public void ReInit(VhdlParserCoreTokenManager tm) {
+    token_source = tm;
+    token = new Token();
+    jj_ntk = -1;
+    jjtree.reset();
+    jj_gen = 0;
+    for (int i = 0; i < 306; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  private Token jj_consume_token(int kind) throws ParseException {
+    Token oldToken;
+    if ((oldToken = token).next != null) token = token.next;
+    else token = token.next = token_source.getNextToken();
+    jj_ntk = -1;
+    if (token.kind == kind) {
+      jj_gen++;
+      if (++jj_gc > 100) {
+        jj_gc = 0;
+        for (int i = 0; i < jj_2_rtns.length; i++) {
+          JJCalls c = jj_2_rtns[i];
+          while (c != null) {
+            if (c.gen < jj_gen) c.first = null;
+            c = c.next;
+          }
+        }
+      }
+      return token;
+    }
+    token = oldToken;
+    jj_kind = kind;
+    throw generateParseException();
+  }
+
+  @SuppressWarnings("serial")
+  static private final class LookaheadSuccess extends java.lang.Error { }
+  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
+  private boolean jj_scan_token(int kind) {
+    if (jj_scanpos == jj_lastpos) {
+      jj_la--;
+      if (jj_scanpos.next == null) {
+        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
+      } else {
+        jj_lastpos = jj_scanpos = jj_scanpos.next;
+      }
+    } else {
+      jj_scanpos = jj_scanpos.next;
+    }
+    if (jj_rescan) {
+      int i = 0; Token tok = token;
+      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
+      if (tok != null) jj_add_error_token(kind, i);
+    }
+    if (jj_scanpos.kind != kind) return true;
+    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
+    return false;
+  }
+
+
+/** Get the next Token. */
+  final public Token getNextToken() {
+    if (token.next != null) token = token.next;
+    else token = token.next = token_source.getNextToken();
+    jj_ntk = -1;
+    jj_gen++;
+    return token;
+  }
+
+/** Get the specific Token. */
+  final public Token getToken(int index) {
+    Token t = token;
+    for (int i = 0; i < index; i++) {
+      if (t.next != null) t = t.next;
+      else t = t.next = token_source.getNextToken();
+    }
+    return t;
+  }
+
+  private int jj_ntk_f() {
+    if ((jj_nt=token.next) == null)
+      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
+    else
+      return (jj_ntk = jj_nt.kind);
+  }
+
+  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
+  private int[] jj_expentry;
+  private int jj_kind = -1;
+  private int[] jj_lasttokens = new int[100];
+  private int jj_endpos;
+
+  private void jj_add_error_token(int kind, int pos) {
+    if (pos >= 100) return;
+    if (pos == jj_endpos + 1) {
+      jj_lasttokens[jj_endpos++] = kind;
+    } else if (jj_endpos != 0) {
+      jj_expentry = new int[jj_endpos];
+      for (int i = 0; i < jj_endpos; i++) {
+        jj_expentry[i] = jj_lasttokens[i];
+      }
+      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
+        int[] oldentry = (int[])(it.next());
+        if (oldentry.length == jj_expentry.length) {
+          for (int i = 0; i < jj_expentry.length; i++) {
+            if (oldentry[i] != jj_expentry[i]) {
+              continue jj_entries_loop;
+            }
+          }
+          jj_expentries.add(jj_expentry);
+          break jj_entries_loop;
+        }
+      }
+      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
+    }
+  }
+
+  /** Generate ParseException. */
+  public ParseException generateParseException() {
+    jj_expentries.clear();
+    boolean[] la1tokens = new boolean[166];
+    if (jj_kind >= 0) {
+      la1tokens[jj_kind] = true;
+      jj_kind = -1;
+    }
+    for (int i = 0; i < 306; i++) {
+      if (jj_la1[i] == jj_gen) {
+        for (int j = 0; j < 32; j++) {
+          if ((jj_la1_0[i] & (1<<j)) != 0) {
+            la1tokens[j] = true;
+          }
+          if ((jj_la1_1[i] & (1<<j)) != 0) {
+            la1tokens[32+j] = true;
+          }
+          if ((jj_la1_2[i] & (1<<j)) != 0) {
+            la1tokens[64+j] = true;
+          }
+          if ((jj_la1_3[i] & (1<<j)) != 0) {
+            la1tokens[96+j] = true;
+          }
+          if ((jj_la1_4[i] & (1<<j)) != 0) {
+            la1tokens[128+j] = true;
+          }
+          if ((jj_la1_5[i] & (1<<j)) != 0) {
+            la1tokens[160+j] = true;
+          }
+        }
+      }
+    }
+    for (int i = 0; i < 166; i++) {
+      if (la1tokens[i]) {
+        jj_expentry = new int[1];
+        jj_expentry[0] = i;
+        jj_expentries.add(jj_expentry);
+      }
+    }
+    jj_endpos = 0;
+    jj_rescan_token();
+    jj_add_error_token(0, 0);
+    int[][] exptokseq = new int[jj_expentries.size()][];
+    for (int i = 0; i < jj_expentries.size(); i++) {
+      exptokseq[i] = jj_expentries.get(i);
+    }
+    return new ParseException(token, exptokseq, tokenImage);
+  }
+
+  /** Enable tracing. */
+  final public void enable_tracing() {
+  }
+
+  /** Disable tracing. */
+  final public void disable_tracing() {
+  }
+
+  private void jj_rescan_token() {
+    jj_rescan = true;
+    for (int i = 0; i < 140; i++) {
+    try {
+      JJCalls p = jj_2_rtns[i];
+      do {
+        if (p.gen > jj_gen) {
+          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
+          switch (i) {
+            case 0: jj_3_1(); break;
+            case 1: jj_3_2(); break;
+            case 2: jj_3_3(); break;
+            case 3: jj_3_4(); break;
+            case 4: jj_3_5(); break;
+            case 5: jj_3_6(); break;
+            case 6: jj_3_7(); break;
+            case 7: jj_3_8(); break;
+            case 8: jj_3_9(); break;
+            case 9: jj_3_10(); break;
+            case 10: jj_3_11(); break;
+            case 11: jj_3_12(); break;
+            case 12: jj_3_13(); break;
+            case 13: jj_3_14(); break;
+            case 14: jj_3_15(); break;
+            case 15: jj_3_16(); break;
+            case 16: jj_3_17(); break;
+            case 17: jj_3_18(); break;
+            case 18: jj_3_19(); break;
+            case 19: jj_3_20(); break;
+            case 20: jj_3_21(); break;
+            case 21: jj_3_22(); break;
+            case 22: jj_3_23(); break;
+            case 23: jj_3_24(); break;
+            case 24: jj_3_25(); break;
+            case 25: jj_3_26(); break;
+            case 26: jj_3_27(); break;
+            case 27: jj_3_28(); break;
+            case 28: jj_3_29(); break;
+            case 29: jj_3_30(); break;
+            case 30: jj_3_31(); break;
+            case 31: jj_3_32(); break;
+            case 32: jj_3_33(); break;
+            case 33: jj_3_34(); break;
+            case 34: jj_3_35(); break;
+            case 35: jj_3_36(); break;
+            case 36: jj_3_37(); break;
+            case 37: jj_3_38(); break;
+            case 38: jj_3_39(); break;
+            case 39: jj_3_40(); break;
+            case 40: jj_3_41(); break;
+            case 41: jj_3_42(); break;
+            case 42: jj_3_43(); break;
+            case 43: jj_3_44(); break;
+            case 44: jj_3_45(); break;
+            case 45: jj_3_46(); break;
+            case 46: jj_3_47(); break;
+            case 47: jj_3_48(); break;
+            case 48: jj_3_49(); break;
+            case 49: jj_3_50(); break;
+            case 50: jj_3_51(); break;
+            case 51: jj_3_52(); break;
+            case 52: jj_3_53(); break;
+            case 53: jj_3_54(); break;
+            case 54: jj_3_55(); break;
+            case 55: jj_3_56(); break;
+            case 56: jj_3_57(); break;
+            case 57: jj_3_58(); break;
+            case 58: jj_3_59(); break;
+            case 59: jj_3_60(); break;
+            case 60: jj_3_61(); break;
+            case 61: jj_3_62(); break;
+            case 62: jj_3_63(); break;
+            case 63: jj_3_64(); break;
+            case 64: jj_3_65(); break;
+            case 65: jj_3_66(); break;
+            case 66: jj_3_67(); break;
+            case 67: jj_3_68(); break;
+            case 68: jj_3_69(); break;
+            case 69: jj_3_70(); break;
+            case 70: jj_3_71(); break;
+            case 71: jj_3_72(); break;
+            case 72: jj_3_73(); break;
+            case 73: jj_3_74(); break;
+            case 74: jj_3_75(); break;
+            case 75: jj_3_76(); break;
+            case 76: jj_3_77(); break;
+            case 77: jj_3_78(); break;
+            case 78: jj_3_79(); break;
+            case 79: jj_3_80(); break;
+            case 80: jj_3_81(); break;
+            case 81: jj_3_82(); break;
+            case 82: jj_3_83(); break;
+            case 83: jj_3_84(); break;
+            case 84: jj_3_85(); break;
+            case 85: jj_3_86(); break;
+            case 86: jj_3_87(); break;
+            case 87: jj_3_88(); break;
+            case 88: jj_3_89(); break;
+            case 89: jj_3_90(); break;
+            case 90: jj_3_91(); break;
+            case 91: jj_3_92(); break;
+            case 92: jj_3_93(); break;
+            case 93: jj_3_94(); break;
+            case 94: jj_3_95(); break;
+            case 95: jj_3_96(); break;
+            case 96: jj_3_97(); break;
+            case 97: jj_3_98(); break;
+            case 98: jj_3_99(); break;
+            case 99: jj_3_100(); break;
+            case 100: jj_3_101(); break;
+            case 101: jj_3_102(); break;
+            case 102: jj_3_103(); break;
+            case 103: jj_3_104(); break;
+            case 104: jj_3_105(); break;
+            case 105: jj_3_106(); break;
+            case 106: jj_3_107(); break;
+            case 107: jj_3_108(); break;
+            case 108: jj_3_109(); break;
+            case 109: jj_3_110(); break;
+            case 110: jj_3_111(); break;
+            case 111: jj_3_112(); break;
+            case 112: jj_3_113(); break;
+            case 113: jj_3_114(); break;
+            case 114: jj_3_115(); break;
+            case 115: jj_3_116(); break;
+            case 116: jj_3_117(); break;
+            case 117: jj_3_118(); break;
+            case 118: jj_3_119(); break;
+            case 119: jj_3_120(); break;
+            case 120: jj_3_121(); break;
+            case 121: jj_3_122(); break;
+            case 122: jj_3_123(); break;
+            case 123: jj_3_124(); break;
+            case 124: jj_3_125(); break;
+            case 125: jj_3_126(); break;
+            case 126: jj_3_127(); break;
+            case 127: jj_3_128(); break;
+            case 128: jj_3_129(); break;
+            case 129: jj_3_130(); break;
+            case 130: jj_3_131(); break;
+            case 131: jj_3_132(); break;
+            case 132: jj_3_133(); break;
+            case 133: jj_3_134(); break;
+            case 134: jj_3_135(); break;
+            case 135: jj_3_136(); break;
+            case 136: jj_3_137(); break;
+            case 137: jj_3_138(); break;
+            case 138: jj_3_139(); break;
+            case 139: jj_3_140(); break;
+          }
+        }
+        p = p.next;
+      } while (p != null);
+      } catch(LookaheadSuccess ls) { }
+    }
+    jj_rescan = false;
+  }
+
+  private void jj_save(int index, int xla) {
+    JJCalls p = jj_2_rtns[index];
+    while (p.gen > jj_gen) {
+      if (p.next == null) { p = p.next = new JJCalls(); break; }
+      p = p.next;
+    }
+    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
+  }
+
+  static final class JJCalls {
+    int gen;
+    Token first;
+    int arg;
+    JJCalls next;
+  }
+
+}
diff -U 3 -dHrN -- vdt-veditor/_generated/com/elphel/vdt/veditor/parser/vhdl/VhdlParserCoreTokenManager.java vdt/_generated/com/elphel/vdt/veditor/parser/vhdl/VhdlParserCoreTokenManager.java
--- vdt-veditor/_generated/com/elphel/vdt/veditor/parser/vhdl/VhdlParserCoreTokenManager.java	2016-06-24 10:29:40.836496072 -0600
+++ vdt/_generated/com/elphel/vdt/veditor/parser/vhdl/VhdlParserCoreTokenManager.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,1426 +1,2572 @@
-/* Generated By:JavaCC: Do not edit this line. VhdlParserCoreTokenManager.java */
-package net.sourceforge.veditor.parser;
-
-public class VhdlParserCoreTokenManager implements VhdlParserCoreConstants
-{
-  public  java.io.PrintStream debugStream = System.out;
-  public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }
-private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1)
-{
-   switch (pos)
-   {
-      case 0:
-         if ((active0 & 0x80000400800L) != 0L)
-         {
-            jjmatchedKind = 71;
-            return 11;
-         }
-         if ((active0 & 0x20000000020000L) != 0L)
-         {
-            jjmatchedKind = 71;
-            return 5;
-         }
-         if ((active0 & 0x2000010000L) != 0L)
-         {
-            jjmatchedKind = 71;
-            return 23;
-         }
-         if ((active0 & 0x1808000000400L) != 0L)
-         {
-            jjmatchedKind = 71;
-            return 18;
-         }
-         if ((active0 & 0x2L) != 0L || (active1 & 0x20L) != 0L)
-         {
-            jjmatchedKind = 72;
-            return -1;
-         }
-         if ((active0 & 0x5e775fffbcf000L) != 0L)
-         {
-            jjmatchedKind = 71;
-            return 20;
-         }
-         return -1;
-      case 1:
-         if ((active0 & 0x7affdffffcf800L) != 0L)
-         {
-            jjmatchedKind = 71;
-            jjmatchedPos = 1;
-            return 20;
-         }
-         if ((active0 & 0x1000000000400L) != 0L)
-         {
-            jjmatchedKind = 71;
-            jjmatchedPos = 1;
-            return 17;
-         }
-         if ((active0 & 0x2L) != 0L || (active1 & 0x20L) != 0L)
-         {
-            if (jjmatchedPos == 0)
-            {
-               jjmatchedKind = 72;
-               jjmatchedPos = 0;
-            }
-            return -1;
-         }
-         if ((active0 & 0x4002000030000L) != 0L)
-            return 20;
-         return -1;
-      case 2:
-         if ((active0 & 0x3bffcfff7cdc00L) != 0L)
-         {
-            jjmatchedKind = 71;
-            jjmatchedPos = 2;
-            return 20;
-         }
-         if ((active0 & 0x40001000802000L) != 0L)
-            return 20;
-         return -1;
-      case 3:
-         if ((active0 & 0x1000c140100800L) != 0L)
-            return 20;
-         if ((active0 & 0x2bff0ebf6cd400L) != 0L)
-         {
-            jjmatchedKind = 71;
-            jjmatchedPos = 3;
-            return 20;
-         }
-         return -1;
-      case 4:
-         if ((active0 & 0x21730cbf2cd400L) != 0L)
-         {
-            jjmatchedKind = 71;
-            jjmatchedPos = 4;
-            return 20;
-         }
-         if ((active0 & 0xa8c0200400000L) != 0L)
-            return 20;
-         return -1;
-      case 5:
-         if ((active0 & 0x1620ca7289400L) != 0L)
-         {
-            jjmatchedKind = 71;
-            jjmatchedPos = 5;
-            return 20;
-         }
-         if ((active0 & 0x20110018044000L) != 0L)
-            return 20;
-         return -1;
-      case 6:
-         if ((active0 & 0x620c27008000L) != 0L)
-         {
-            jjmatchedKind = 71;
-            jjmatchedPos = 6;
-            return 20;
-         }
-         if ((active0 & 0x1000080281400L) != 0L)
-            return 20;
-         return -1;
-      case 7:
-         if ((active0 & 0x420c02008000L) != 0L)
-         {
-            jjmatchedKind = 71;
-            jjmatchedPos = 7;
-            return 20;
-         }
-         if ((active0 & 0x200025000000L) != 0L)
-            return 20;
-         return -1;
-      case 8:
-         if ((active0 & 0x420000008000L) != 0L)
-         {
-            jjmatchedKind = 71;
-            jjmatchedPos = 8;
-            return 20;
-         }
-         if ((active0 & 0xc02000000L) != 0L)
-            return 20;
-         return -1;
-      case 9:
-         if ((active0 & 0x400000008000L) != 0L)
-         {
-            jjmatchedKind = 71;
-            jjmatchedPos = 9;
-            return 20;
-         }
-         if ((active0 & 0x20000000000L) != 0L)
-            return 20;
-         return -1;
-      case 10:
-         if ((active0 & 0x400000008000L) != 0L)
-         {
-            jjmatchedKind = 71;
-            jjmatchedPos = 10;
-            return 20;
-         }
-         return -1;
-      case 11:
-         if ((active0 & 0x400000000000L) != 0L)
-         {
-            jjmatchedKind = 71;
-            jjmatchedPos = 11;
-            return 20;
-         }
-         if ((active0 & 0x8000L) != 0L)
-            return 20;
-         return -1;
-      default :
-         return -1;
-   }
-}
-private final int jjStartNfa_0(int pos, long active0, long active1)
-{
-   return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0, active1), pos + 1);
-}
-private final int jjStopAtPos(int pos, int kind)
-{
-   jjmatchedKind = kind;
-   jjmatchedPos = pos;
-   return pos + 1;
-}
-private final int jjStartNfaWithStates_0(int pos, int kind, int state)
-{
-   jjmatchedKind = kind;
-   jjmatchedPos = pos;
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) { return pos + 1; }
-   return jjMoveNfa_0(state, pos + 1);
-}
-private final int jjMoveStringLiteralDfa0_0()
-{
-   switch(curChar)
-   {
-      case 10:
-         return jjStopAtPos(0, 7);
-      case 12:
-         return jjStopAtPos(0, 8);
-      case 13:
-         return jjStopAtPos(0, 6);
-      case 35:
-         return jjStopAtPos(0, 63);
-      case 36:
-         return jjStopAtPos(0, 66);
-      case 40:
-         return jjStopAtPos(0, 56);
-      case 41:
-         return jjStopAtPos(0, 57);
-      case 44:
-         return jjStopAtPos(0, 67);
-      case 47:
-         return jjMoveStringLiteralDfa1_0(0x2L, 0x0L);
-      case 58:
-         return jjStopAtPos(0, 68);
-      case 59:
-         return jjStopAtPos(0, 62);
-      case 60:
-         return jjMoveStringLiteralDfa1_0(0x0L, 0x20L);
-      case 61:
-         return jjStopAtPos(0, 70);
-      case 64:
-         return jjStopAtPos(0, 64);
-      case 91:
-         jjmatchedKind = 60;
-         return jjMoveStringLiteralDfa1_0(0x0L, 0x200L);
-      case 93:
-         return jjStopAtPos(0, 61);
-      case 96:
-         return jjStopAtPos(0, 65);
-      case 65:
-      case 97:
-         return jjMoveStringLiteralDfa1_0(0x40100600008000L, 0x0L);
-      case 66:
-      case 98:
-         return jjMoveStringLiteralDfa1_0(0x80000400800L, 0x0L);
-      case 67:
-      case 99:
-         return jjMoveStringLiteralDfa1_0(0x404801000000L, 0x0L);
-      case 68:
-      case 100:
-         return jjMoveStringLiteralDfa1_0(0x20000000000L, 0x0L);
-      case 69:
-      case 101:
-         return jjMoveStringLiteralDfa1_0(0x804000L, 0x0L);
-      case 70:
-      case 102:
-         return jjMoveStringLiteralDfa1_0(0x1104000000L, 0x0L);
-      case 71:
-      case 103:
-         return jjMoveStringLiteralDfa1_0(0x240000080000L, 0x0L);
-      case 73:
-      case 105:
-         return jjMoveStringLiteralDfa1_0(0x2000010000L, 0x0L);
-      case 76:
-      case 108:
-         return jjMoveStringLiteralDfa1_0(0x1808000000400L, 0x0L);
-      case 79:
-      case 111:
-         return jjMoveStringLiteralDfa1_0(0x20000000020000L, 0x0L);
-      case 80:
-      case 112:
-         return jjMoveStringLiteralDfa1_0(0x2301000L, 0x0L);
-      case 82:
-      case 114:
-         return jjMoveStringLiteralDfa1_0(0x8010000040000L, 0x0L);
-      case 83:
-      case 115:
-         return jjMoveStringLiteralDfa1_0(0x98000000L, 0x0L);
-      case 84:
-      case 116:
-         return jjMoveStringLiteralDfa1_0(0x4000040000000L, 0x0L);
-      case 85:
-      case 117:
-         return jjMoveStringLiteralDfa1_0(0x2000000002000L, 0x0L);
-      case 86:
-      case 118:
-         return jjMoveStringLiteralDfa1_0(0x20000000L, 0x0L);
-      case 87:
-      case 119:
-         return jjMoveStringLiteralDfa1_0(0x10000000000000L, 0x0L);
-      case 123:
-         return jjStopAtPos(0, 58);
-      case 125:
-         return jjStopAtPos(0, 59);
-      default :
-         return jjMoveNfa_0(3, 0);
-   }
-}
-private final int jjMoveStringLiteralDfa1_0(long active0, long active1)
-{
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      jjStopStringLiteralDfa_0(0, active0, active1);
-      return 1;
-   }
-   switch(curChar)
-   {
-      case 42:
-         if ((active0 & 0x2L) != 0L)
-            return jjStopAtPos(1, 1);
-         break;
-      case 46:
-         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x200L);
-      case 61:
-         if ((active1 & 0x20L) != 0L)
-            return jjStopAtPos(1, 69);
-         break;
-      case 65:
-      case 97:
-         return jjMoveStringLiteralDfa2_0(active0, 0x8804020001000L, active1, 0L);
-      case 69:
-      case 101:
-         return jjMoveStringLiteralDfa2_0(active0, 0x2100004c0000L, active1, 0L);
-      case 70:
-      case 102:
-         if ((active0 & 0x20000L) != 0L)
-            return jjStartNfaWithStates_0(1, 17, 20);
-         else if ((active0 & 0x2000000000L) != 0L)
-            return jjStartNfaWithStates_0(1, 37, 20);
-         break;
-      case 72:
-      case 104:
-         return jjMoveStringLiteralDfa2_0(active0, 0x10000000L, active1, 0L);
-      case 73:
-      case 105:
-         return jjMoveStringLiteralDfa2_0(active0, 0x11020108000400L, active1, 0L);
-      case 76:
-      case 108:
-         return jjMoveStringLiteralDfa2_0(active0, 0x40080200000000L, active1, 0L);
-      case 78:
-      case 110:
-         return jjMoveStringLiteralDfa2_0(active0, 0x2000000804000L, active1, 0L);
-      case 79:
-      case 111:
-         if ((active0 & 0x4000000000000L) != 0L)
-            return jjStartNfaWithStates_0(1, 50, 20);
-         return jjMoveStringLiteralDfa2_0(active0, 0x409801100800L, active1, 0L);
-      case 82:
-      case 114:
-         return jjMoveStringLiteralDfa2_0(active0, 0x40002208000L, active1, 0L);
-      case 83:
-      case 115:
-         if ((active0 & 0x10000L) != 0L)
-            return jjStartNfaWithStates_0(1, 16, 20);
-         return jjMoveStringLiteralDfa2_0(active0, 0x100000002000L, active1, 0L);
-      case 84:
-      case 116:
-         return jjMoveStringLiteralDfa2_0(active0, 0x20000400000000L, active1, 0L);
-      case 85:
-      case 117:
-         return jjMoveStringLiteralDfa2_0(active0, 0x84000000L, active1, 0L);
-      case 89:
-      case 121:
-         return jjMoveStringLiteralDfa2_0(active0, 0x40000000L, active1, 0L);
-      default :
-         break;
-   }
-   return jjStartNfa_0(0, active0, active1);
-}
-private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1)
-{
-   if (((active0 &= old0) | (active1 &= old1)) == 0L)
-      return jjStartNfa_0(0, old0, old1); 
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      jjStopStringLiteralDfa_0(1, active0, active1);
-      return 2;
-   }
-   switch(curChar)
-   {
-      case 93:
-         if ((active1 & 0x200L) != 0L)
-            return jjStopAtPos(2, 73);
-         break;
-      case 65:
-      case 97:
-         return jjMoveStringLiteralDfa3_0(active0, 0x10000000L, active1, 0L);
-      case 66:
-      case 98:
-         return jjMoveStringLiteralDfa3_0(active0, 0x800080000400L, active1, 0L);
-      case 67:
-      case 99:
-         return jjMoveStringLiteralDfa3_0(active0, 0x49000L, active1, 0L);
-      case 68:
-      case 100:
-         if ((active0 & 0x800000L) != 0L)
-            return jjStartNfaWithStates_0(2, 23, 20);
-         return jjMoveStringLiteralDfa3_0(active0, 0x800L, active1, 0L);
-      case 69:
-      case 101:
-         if ((active0 & 0x2000L) != 0L)
-            return jjStartNfaWithStates_0(2, 13, 20);
-         break;
-      case 71:
-      case 103:
-         return jjMoveStringLiteralDfa3_0(active0, 0x8400000L, active1, 0L);
-      case 72:
-      case 104:
-         return jjMoveStringLiteralDfa3_0(active0, 0x20000000000000L, active1, 0L);
-      case 73:
-      case 105:
-         return jjMoveStringLiteralDfa3_0(active0, 0x2000200000000L, active1, 0L);
-      case 76:
-      case 108:
-         if ((active0 & 0x40000000000000L) != 0L)
-            return jjStartNfaWithStates_0(2, 54, 20);
-         return jjMoveStringLiteralDfa3_0(active0, 0x100000000L, active1, 0L);
-      case 77:
-      case 109:
-         return jjMoveStringLiteralDfa3_0(active0, 0x800000000L, active1, 0L);
-      case 78:
-      case 110:
-         return jjMoveStringLiteralDfa3_0(active0, 0x8600005080000L, active1, 0L);
-      case 79:
-      case 111:
-         return jjMoveStringLiteralDfa3_0(active0, 0xc8002200000L, active1, 0L);
-      case 80:
-      case 112:
-         return jjMoveStringLiteralDfa3_0(active0, 0x40000000L, active1, 0L);
-      case 82:
-      case 114:
-         if ((active0 & 0x1000000000L) != 0L)
-            return jjStartNfaWithStates_0(2, 36, 20);
-         return jjMoveStringLiteralDfa3_0(active0, 0x20100000L, active1, 0L);
-      case 83:
-      case 115:
-         return jjMoveStringLiteralDfa3_0(active0, 0x124000000000L, active1, 0L);
-      case 84:
-      case 116:
-         return jjMoveStringLiteralDfa3_0(active0, 0x11010400004000L, active1, 0L);
-      default :
-         break;
-   }
-   return jjStartNfa_0(1, active0, active1);
-}
-private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1)
-{
-   if (((active0 &= old0) | (active1 &= old1)) == 0L)
-      return jjStartNfa_0(1, old0, old1); 
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      jjStopStringLiteralDfa_0(2, active0, 0L);
-      return 3;
-   }
-   switch(curChar)
-   {
-      case 65:
-      case 97:
-         return jjMoveStringLiteralDfa4_0(active0, 0x200000000L);
-      case 67:
-      case 99:
-         return jjMoveStringLiteralDfa4_0(active0, 0xa0006200000L);
-      case 69:
-      case 101:
-         if ((active0 & 0x40000000L) != 0L)
-            return jjStartNfaWithStates_0(3, 30, 20);
-         else if ((active0 & 0x100000000L) != 0L)
-            return jjStartNfaWithStates_0(3, 32, 20);
-         else if ((active0 & 0x4000000000L) != 0L)
-            return jjStartNfaWithStates_0(3, 38, 20);
-         return jjMoveStringLiteralDfa4_0(active0, 0x21300000080000L);
-      case 70:
-      case 102:
-         return jjMoveStringLiteralDfa4_0(active0, 0x400000000000L);
-      case 71:
-      case 103:
-         return jjMoveStringLiteralDfa4_0(active0, 0x8000000000000L);
-      case 72:
-      case 104:
-         if ((active0 & 0x10000000000000L) != 0L)
-            return jjStartNfaWithStates_0(3, 52, 20);
-         return jjMoveStringLiteralDfa4_0(active0, 0x8000L);
-      case 73:
-      case 105:
-         return jjMoveStringLiteralDfa4_0(active0, 0x20404000L);
-      case 75:
-      case 107:
-         return jjMoveStringLiteralDfa4_0(active0, 0x1000L);
-      case 76:
-      case 108:
-         return jjMoveStringLiteralDfa4_0(active0, 0x800000000000L);
-      case 78:
-      case 110:
-         return jjMoveStringLiteralDfa4_0(active0, 0x8000000L);
-      case 79:
-      case 111:
-         return jjMoveStringLiteralDfa4_0(active0, 0x40000L);
-      case 80:
-      case 112:
-         if ((active0 & 0x8000000000L) != 0L)
-            return jjStartNfaWithStates_0(3, 39, 20);
-         return jjMoveStringLiteralDfa4_0(active0, 0x800000000L);
-      case 82:
-      case 114:
-         return jjMoveStringLiteralDfa4_0(active0, 0x410000400L);
-      case 83:
-      case 115:
-         return jjMoveStringLiteralDfa4_0(active0, 0x1000000L);
-      case 84:
-      case 116:
-         if ((active0 & 0x100000L) != 0L)
-            return jjStartNfaWithStates_0(3, 20, 20);
-         return jjMoveStringLiteralDfa4_0(active0, 0x2000080000000L);
-      case 85:
-      case 117:
-         return jjMoveStringLiteralDfa4_0(active0, 0x50000000000L);
-      case 89:
-      case 121:
-         if ((active0 & 0x800L) != 0L)
-            return jjStartNfaWithStates_0(3, 11, 20);
-         break;
-      default :
-         break;
-   }
-   return jjStartNfa_0(2, active0, 0L);
-}
-private final int jjMoveStringLiteralDfa4_0(long old0, long active0)
-{
-   if (((active0 &= old0)) == 0L)
-      return jjStartNfa_0(2, old0, 0L);
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      jjStopStringLiteralDfa_0(3, active0, 0L);
-      return 4;
-   }
-   switch(curChar)
-   {
-      case 65:
-      case 97:
-         return jjMoveStringLiteralDfa5_0(active0, 0x28001400L);
-      case 69:
-      case 101:
-         if ((active0 & 0x800000000000L) != 0L)
-            return jjStartNfaWithStates_0(4, 47, 20);
-         else if ((active0 & 0x8000000000000L) != 0L)
-            return jjStartNfaWithStates_0(4, 51, 20);
-         return jjMoveStringLiteralDfa5_0(active0, 0x12200000L);
-      case 73:
-      case 105:
-         return jjMoveStringLiteralDfa5_0(active0, 0x400400008000L);
-      case 75:
-      case 107:
-         if ((active0 & 0x80000000000L) != 0L)
-            return jjStartNfaWithStates_0(4, 43, 20);
-         break;
-      case 78:
-      case 110:
-         if ((active0 & 0x400000L) != 0L)
-            return jjStartNfaWithStates_0(4, 22, 20);
-         break;
-      case 79:
-      case 111:
-         return jjMoveStringLiteralDfa5_0(active0, 0x20800000000L);
-      case 80:
-      case 112:
-         if ((active0 & 0x40000000000L) != 0L)
-            return jjStartNfaWithStates_0(4, 42, 20);
-         break;
-      case 82:
-      case 114:
-         return jjMoveStringLiteralDfa5_0(active0, 0x213100000c0000L);
-      case 83:
-      case 115:
-         if ((active0 & 0x200000000L) != 0L)
-            return jjStartNfaWithStates_0(4, 33, 20);
-         else if ((active0 & 0x2000000000000L) != 0L)
-            return jjStartNfaWithStates_0(4, 49, 20);
-         break;
-      case 84:
-      case 116:
-         return jjMoveStringLiteralDfa5_0(active0, 0x5004000L);
-      case 89:
-      case 121:
-         return jjMoveStringLiteralDfa5_0(active0, 0x80000000L);
-      default :
-         break;
-   }
-   return jjStartNfa_0(3, active0, 0L);
-}
-private final int jjMoveStringLiteralDfa5_0(long old0, long active0)
-{
-   if (((active0 &= old0)) == 0L)
-      return jjStartNfa_0(3, old0, 0L);
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      jjStopStringLiteralDfa_0(4, active0, 0L);
-      return 5;
-   }
-   switch(curChar)
-   {
-      case 65:
-      case 97:
-         return jjMoveStringLiteralDfa6_0(active0, 0x1200001000000L);
-      case 66:
-      case 98:
-         return jjMoveStringLiteralDfa6_0(active0, 0x420000000L);
-      case 68:
-      case 100:
-         if ((active0 & 0x40000L) != 0L)
-            return jjStartNfaWithStates_0(5, 18, 20);
-         else if ((active0 & 0x10000000L) != 0L)
-            return jjStartNfaWithStates_0(5, 28, 20);
-         return jjMoveStringLiteralDfa6_0(active0, 0x2000000L);
-      case 71:
-      case 103:
-         return jjMoveStringLiteralDfa6_0(active0, 0x400000001000L);
-      case 73:
-      case 105:
-         return jjMoveStringLiteralDfa6_0(active0, 0x4080000L);
-      case 76:
-      case 108:
-         if ((active0 & 0x8000000L) != 0L)
-            return jjStartNfaWithStates_0(5, 27, 20);
-         break;
-      case 78:
-      case 110:
-         if ((active0 & 0x10000000000L) != 0L)
-            return jjStartNfaWithStates_0(5, 40, 20);
-         return jjMoveStringLiteralDfa6_0(active0, 0x20800000000L);
-      case 80:
-      case 112:
-         return jjMoveStringLiteralDfa6_0(active0, 0x80000000L);
-      case 82:
-      case 114:
-         return jjMoveStringLiteralDfa6_0(active0, 0x400L);
-      case 83:
-      case 115:
-         if ((active0 & 0x20000000000000L) != 0L)
-            return jjStartNfaWithStates_0(5, 53, 20);
-         return jjMoveStringLiteralDfa6_0(active0, 0x200000L);
-      case 84:
-      case 116:
-         if ((active0 & 0x100000000000L) != 0L)
-            return jjStartNfaWithStates_0(5, 44, 20);
-         return jjMoveStringLiteralDfa6_0(active0, 0x8000L);
-      case 89:
-      case 121:
-         if ((active0 & 0x4000L) != 0L)
-            return jjStartNfaWithStates_0(5, 14, 20);
-         break;
-      default :
-         break;
-   }
-   return jjStartNfa_0(4, active0, 0L);
-}
-private final int jjMoveStringLiteralDfa6_0(long old0, long active0)
-{
-   if (((active0 &= old0)) == 0L)
-      return jjStartNfa_0(4, old0, 0L);
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      jjStopStringLiteralDfa_0(5, active0, 0L);
-      return 6;
-   }
-   switch(curChar)
-   {
-      case 67:
-      case 99:
-         if ((active0 & 0x80000L) != 0L)
-            return jjStartNfaWithStates_0(6, 19, 20);
-         break;
-      case 69:
-      case 101:
-         if ((active0 & 0x1000L) != 0L)
-            return jjStartNfaWithStates_0(6, 12, 20);
-         else if ((active0 & 0x80000000L) != 0L)
-            return jjStartNfaWithStates_0(6, 31, 20);
-         return jjMoveStringLiteralDfa7_0(active0, 0x800008000L);
-      case 76:
-      case 108:
-         if ((active0 & 0x1000000000000L) != 0L)
-            return jjStartNfaWithStates_0(6, 48, 20);
-         return jjMoveStringLiteralDfa7_0(active0, 0x20000000L);
-      case 78:
-      case 110:
-         return jjMoveStringLiteralDfa7_0(active0, 0x20001000000L);
-      case 79:
-      case 111:
-         return jjMoveStringLiteralDfa7_0(active0, 0x4000000L);
-      case 83:
-      case 115:
-         if ((active0 & 0x200000L) != 0L)
-            return jjStartNfaWithStates_0(6, 21, 20);
-         break;
-      case 84:
-      case 116:
-         return jjMoveStringLiteralDfa7_0(active0, 0x200000000000L);
-      case 85:
-      case 117:
-         return jjMoveStringLiteralDfa7_0(active0, 0x400402000000L);
-      case 89:
-      case 121:
-         if ((active0 & 0x400L) != 0L)
-            return jjStartNfaWithStates_0(6, 10, 20);
-         break;
-      default :
-         break;
-   }
-   return jjStartNfa_0(5, active0, 0L);
-}
-private final int jjMoveStringLiteralDfa7_0(long old0, long active0)
-{
-   if (((active0 &= old0)) == 0L)
-      return jjStartNfa_0(5, old0, 0L);
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      jjStopStringLiteralDfa_0(6, active0, 0L);
-      return 7;
-   }
-   switch(curChar)
-   {
-      case 67:
-      case 99:
-         return jjMoveStringLiteralDfa8_0(active0, 0x8000L);
-      case 69:
-      case 101:
-         if ((active0 & 0x20000000L) != 0L)
-            return jjStartNfaWithStates_0(7, 29, 20);
-         else if ((active0 & 0x200000000000L) != 0L)
-            return jjStartNfaWithStates_0(7, 45, 20);
-         return jjMoveStringLiteralDfa8_0(active0, 0x20000000000L);
-      case 78:
-      case 110:
-         if ((active0 & 0x4000000L) != 0L)
-            return jjStartNfaWithStates_0(7, 26, 20);
-         return jjMoveStringLiteralDfa8_0(active0, 0x800000000L);
-      case 82:
-      case 114:
-         return jjMoveStringLiteralDfa8_0(active0, 0x400002000000L);
-      case 84:
-      case 116:
-         if ((active0 & 0x1000000L) != 0L)
-            return jjStartNfaWithStates_0(7, 24, 20);
-         return jjMoveStringLiteralDfa8_0(active0, 0x400000000L);
-      default :
-         break;
-   }
-   return jjStartNfa_0(6, active0, 0L);
-}
-private final int jjMoveStringLiteralDfa8_0(long old0, long active0)
-{
-   if (((active0 &= old0)) == 0L)
-      return jjStartNfa_0(6, old0, 0L);
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      jjStopStringLiteralDfa_0(7, active0, 0L);
-      return 8;
-   }
-   switch(curChar)
-   {
-      case 65:
-      case 97:
-         return jjMoveStringLiteralDfa9_0(active0, 0x400000000000L);
-      case 67:
-      case 99:
-         return jjMoveStringLiteralDfa9_0(active0, 0x20000000000L);
-      case 69:
-      case 101:
-         if ((active0 & 0x2000000L) != 0L)
-            return jjStartNfaWithStates_0(8, 25, 20);
-         else if ((active0 & 0x400000000L) != 0L)
-            return jjStartNfaWithStates_0(8, 34, 20);
-         break;
-      case 84:
-      case 116:
-         if ((active0 & 0x800000000L) != 0L)
-            return jjStartNfaWithStates_0(8, 35, 20);
-         return jjMoveStringLiteralDfa9_0(active0, 0x8000L);
-      default :
-         break;
-   }
-   return jjStartNfa_0(7, active0, 0L);
-}
-private final int jjMoveStringLiteralDfa9_0(long old0, long active0)
-{
-   if (((active0 &= old0)) == 0L)
-      return jjStartNfa_0(7, old0, 0L);
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      jjStopStringLiteralDfa_0(8, active0, 0L);
-      return 9;
-   }
-   switch(curChar)
-   {
-      case 84:
-      case 116:
-         if ((active0 & 0x20000000000L) != 0L)
-            return jjStartNfaWithStates_0(9, 41, 20);
-         return jjMoveStringLiteralDfa10_0(active0, 0x400000000000L);
-      case 85:
-      case 117:
-         return jjMoveStringLiteralDfa10_0(active0, 0x8000L);
-      default :
-         break;
-   }
-   return jjStartNfa_0(8, active0, 0L);
-}
-private final int jjMoveStringLiteralDfa10_0(long old0, long active0)
-{
-   if (((active0 &= old0)) == 0L)
-      return jjStartNfa_0(8, old0, 0L);
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      jjStopStringLiteralDfa_0(9, active0, 0L);
-      return 10;
-   }
-   switch(curChar)
-   {
-      case 73:
-      case 105:
-         return jjMoveStringLiteralDfa11_0(active0, 0x400000000000L);
-      case 82:
-      case 114:
-         return jjMoveStringLiteralDfa11_0(active0, 0x8000L);
-      default :
-         break;
-   }
-   return jjStartNfa_0(9, active0, 0L);
-}
-private final int jjMoveStringLiteralDfa11_0(long old0, long active0)
-{
-   if (((active0 &= old0)) == 0L)
-      return jjStartNfa_0(9, old0, 0L);
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      jjStopStringLiteralDfa_0(10, active0, 0L);
-      return 11;
-   }
-   switch(curChar)
-   {
-      case 69:
-      case 101:
-         if ((active0 & 0x8000L) != 0L)
-            return jjStartNfaWithStates_0(11, 15, 20);
-         break;
-      case 79:
-      case 111:
-         return jjMoveStringLiteralDfa12_0(active0, 0x400000000000L);
-      default :
-         break;
-   }
-   return jjStartNfa_0(10, active0, 0L);
-}
-private final int jjMoveStringLiteralDfa12_0(long old0, long active0)
-{
-   if (((active0 &= old0)) == 0L)
-      return jjStartNfa_0(10, old0, 0L);
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      jjStopStringLiteralDfa_0(11, active0, 0L);
-      return 12;
-   }
-   switch(curChar)
-   {
-      case 78:
-      case 110:
-         if ((active0 & 0x400000000000L) != 0L)
-            return jjStartNfaWithStates_0(12, 46, 20);
-         break;
-      default :
-         break;
-   }
-   return jjStartNfa_0(11, active0, 0L);
-}
-private final void jjCheckNAdd(int state)
-{
-   if (jjrounds[state] != jjround)
-   {
-      jjstateSet[jjnewStateCnt++] = state;
-      jjrounds[state] = jjround;
-   }
-}
-private final void jjAddStates(int start, int end)
-{
-   do {
-      jjstateSet[jjnewStateCnt++] = jjnextStates[start];
-   } while (start++ != end);
-}
-private final void jjCheckNAddTwoStates(int state1, int state2)
-{
-   jjCheckNAdd(state1);
-   jjCheckNAdd(state2);
-}
-private final void jjCheckNAddStates(int start, int end)
-{
-   do {
-      jjCheckNAdd(jjnextStates[start]);
-   } while (start++ != end);
-}
-private final void jjCheckNAddStates(int start)
-{
-   jjCheckNAdd(jjnextStates[start]);
-   jjCheckNAdd(jjnextStates[start + 1]);
-}
-static final long[] jjbitVec0 = {
-   0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL
-};
-static final long[] jjbitVec2 = {
-   0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL
-};
-private final int jjMoveNfa_0(int startState, int curPos)
-{
-   int[] nextStates;
-   int startsAt = 0;
-   jjnewStateCnt = 27;
-   int i = 1;
-   jjstateSet[0] = startState;
-   int j, kind = 0x7fffffff;
-   for (;;)
-   {
-      if (++jjround == 0x7fffffff)
-         ReInitRounds();
-      if (curChar < 64)
-      {
-         long l = 1L << curChar;
-         MatchLoop: do
-         {
-            switch(jjstateSet[--i])
-            {
-               case 17:
-               case 20:
-                  if ((0x83ff408400000000L & l) == 0L)
-                     break;
-                  if (kind > 71)
-                     kind = 71;
-                  jjCheckNAdd(20);
-                  break;
-               case 5:
-                  if ((0x83ff408400000000L & l) == 0L)
-                     break;
-                  if (kind > 71)
-                     kind = 71;
-                  jjCheckNAdd(20);
-                  break;
-               case 11:
-                  if ((0x83ff408400000000L & l) == 0L)
-                     break;
-                  if (kind > 71)
-                     kind = 71;
-                  jjCheckNAdd(20);
-                  break;
-               case 23:
-                  if ((0x83ff408400000000L & l) == 0L)
-                     break;
-                  if (kind > 71)
-                     kind = 71;
-                  jjCheckNAdd(20);
-                  break;
-               case 18:
-                  if ((0x83ff408400000000L & l) == 0L)
-                     break;
-                  if (kind > 71)
-                     kind = 71;
-                  jjCheckNAdd(20);
-                  break;
-               case 3:
-                  if ((0xfffffffefffffdffL & l) != 0L)
-                  {
-                     if (kind > 72)
-                        kind = 72;
-                  }
-                  if ((0x83ff408400000000L & l) != 0L)
-                  {
-                     if (kind > 71)
-                        kind = 71;
-                     jjCheckNAdd(20);
-                  }
-                  else if (curChar == 45)
-                     jjstateSet[jjnewStateCnt++] = 0;
-                  break;
-               case 0:
-                  if (curChar == 45)
-                     jjCheckNAddTwoStates(1, 2);
-                  break;
-               case 1:
-                  if ((0xfffffffffffffbffL & l) != 0L)
-                     jjCheckNAddTwoStates(1, 2);
-                  break;
-               case 2:
-                  if (curChar == 10 && kind > 9)
-                     kind = 9;
-                  break;
-               case 21:
-                  if ((0xfffffffefffffdffL & l) != 0L && kind > 72)
-                     kind = 72;
-                  break;
-               default : break;
-            }
-         } while(i != startsAt);
-      }
-      else if (curChar < 128)
-      {
-         long l = 1L << (curChar & 077);
-         MatchLoop: do
-         {
-            switch(jjstateSet[--i])
-            {
-               case 17:
-                  if ((0x7fffffe87fffffeL & l) != 0L)
-                  {
-                     if (kind > 71)
-                        kind = 71;
-                     jjCheckNAdd(20);
-                  }
-                  if ((0x400000004000L & l) != 0L)
-                     jjstateSet[jjnewStateCnt++] = 16;
-                  break;
-               case 5:
-                  if ((0x7fffffe87fffffeL & l) != 0L)
-                  {
-                     if (kind > 71)
-                        kind = 71;
-                     jjCheckNAdd(20);
-                  }
-                  if ((0x20000000200000L & l) != 0L)
-                     jjCheckNAdd(4);
-                  break;
-               case 11:
-                  if ((0x7fffffe87fffffeL & l) != 0L)
-                  {
-                     if (kind > 71)
-                        kind = 71;
-                     jjCheckNAdd(20);
-                  }
-                  if ((0x20000000200000L & l) != 0L)
-                     jjstateSet[jjnewStateCnt++] = 10;
-                  break;
-               case 23:
-                  if ((0x7fffffe87fffffeL & l) != 0L)
-                  {
-                     if (kind > 71)
-                        kind = 71;
-                     jjCheckNAdd(20);
-                  }
-                  if ((0x400000004000L & l) != 0L)
-                     jjstateSet[jjnewStateCnt++] = 25;
-                  if ((0x400000004000L & l) != 0L)
-                  {
-                     if (kind > 55)
-                        kind = 55;
-                  }
-                  break;
-               case 18:
-                  if ((0x7fffffe87fffffeL & l) != 0L)
-                  {
-                     if (kind > 71)
-                        kind = 71;
-                     jjCheckNAdd(20);
-                  }
-                  if ((0x20000000200L & l) != 0L)
-                     jjstateSet[jjnewStateCnt++] = 17;
-                  break;
-               case 3:
-                  if (kind > 72)
-                     kind = 72;
-                  if ((0x7fffffe87fffffeL & l) != 0L)
-                  {
-                     if (kind > 71)
-                        kind = 71;
-                     jjCheckNAdd(20);
-                  }
-                  if ((0x20000000200L & l) != 0L)
-                     jjAddStates(0, 1);
-                  else if ((0x100000001000L & l) != 0L)
-                     jjstateSet[jjnewStateCnt++] = 18;
-                  else if ((0x400000004L & l) != 0L)
-                     jjstateSet[jjnewStateCnt++] = 11;
-                  else if ((0x800000008000L & l) != 0L)
-                     jjstateSet[jjnewStateCnt++] = 5;
-                  break;
-               case 1:
-                  jjAddStates(2, 3);
-                  break;
-               case 4:
-                  if ((0x10000000100000L & l) != 0L && kind > 55)
-                     kind = 55;
-                  break;
-               case 6:
-                  if ((0x800000008000L & l) != 0L)
-                     jjstateSet[jjnewStateCnt++] = 5;
-                  break;
-               case 7:
-                  if ((0x4000000040000L & l) != 0L && kind > 55)
-                     kind = 55;
-                  break;
-               case 8:
-                  if ((0x2000000020L & l) != 0L)
-                     jjstateSet[jjnewStateCnt++] = 7;
-                  break;
-               case 9:
-                  if ((0x4000000040L & l) != 0L)
-                     jjstateSet[jjnewStateCnt++] = 8;
-                  break;
-               case 10:
-                  if ((0x4000000040L & l) != 0L)
-                     jjstateSet[jjnewStateCnt++] = 9;
-                  break;
-               case 12:
-                  if ((0x400000004L & l) != 0L)
-                     jjstateSet[jjnewStateCnt++] = 11;
-                  break;
-               case 13:
-                  if ((0x2000000020L & l) != 0L && kind > 55)
-                     kind = 55;
-                  break;
-               case 14:
-                  if ((0x8000000080L & l) != 0L)
-                     jjstateSet[jjnewStateCnt++] = 13;
-                  break;
-               case 15:
-                  if ((0x200000002L & l) != 0L)
-                     jjstateSet[jjnewStateCnt++] = 14;
-                  break;
-               case 16:
-                  if ((0x80000000800L & l) != 0L)
-                     jjstateSet[jjnewStateCnt++] = 15;
-                  break;
-               case 19:
-                  if ((0x100000001000L & l) != 0L)
-                     jjstateSet[jjnewStateCnt++] = 18;
-                  break;
-               case 20:
-                  if ((0x7fffffe87fffffeL & l) == 0L)
-                     break;
-                  if (kind > 71)
-                     kind = 71;
-                  jjCheckNAdd(20);
-                  break;
-               case 21:
-                  if (kind > 72)
-                     kind = 72;
-                  break;
-               case 22:
-                  if ((0x20000000200L & l) != 0L)
-                     jjAddStates(0, 1);
-                  break;
-               case 24:
-                  if ((0x20000000200000L & l) != 0L)
-                     jjCheckNAdd(4);
-                  break;
-               case 25:
-                  if ((0x800000008000L & l) != 0L)
-                     jjstateSet[jjnewStateCnt++] = 24;
-                  break;
-               case 26:
-                  if ((0x400000004000L & l) != 0L)
-                     jjstateSet[jjnewStateCnt++] = 25;
-                  break;
-               default : break;
-            }
-         } while(i != startsAt);
-      }
-      else
-      {
-         int hiByte = (int)(curChar >> 8);
-         int i1 = hiByte >> 6;
-         long l1 = 1L << (hiByte & 077);
-         int i2 = (curChar & 0xff) >> 6;
-         long l2 = 1L << (curChar & 077);
-         MatchLoop: do
-         {
-            switch(jjstateSet[--i])
-            {
-               case 3:
-                  if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 72)
-                     kind = 72;
-                  break;
-               case 1:
-                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
-                     jjAddStates(2, 3);
-                  break;
-               default : break;
-            }
-         } while(i != startsAt);
-      }
-      if (kind != 0x7fffffff)
-      {
-         jjmatchedKind = kind;
-         jjmatchedPos = curPos;
-         kind = 0x7fffffff;
-      }
-      ++curPos;
-      if ((i = jjnewStateCnt) == (startsAt = 27 - (jjnewStateCnt = startsAt)))
-         return curPos;
-      try { curChar = input_stream.readChar(); }
-      catch(java.io.IOException e) { return curPos; }
-   }
-}
-private final int jjMoveStringLiteralDfa0_1()
-{
-   switch(curChar)
-   {
-      case 42:
-         return jjMoveStringLiteralDfa1_1(0x4L);
-      default :
-         return 1;
-   }
-}
-private final int jjMoveStringLiteralDfa1_1(long active0)
-{
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      return 1;
-   }
-   switch(curChar)
-   {
-      case 47:
-         if ((active0 & 0x4L) != 0L)
-            return jjStopAtPos(1, 2);
-         break;
-      default :
-         return 2;
-   }
-   return 2;
-}
-static final int[] jjnextStates = {
-   23, 26, 1, 2, 
-};
-private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2)
-{
-   switch(hiByte)
-   {
-      case 0:
-         return ((jjbitVec2[i2] & l2) != 0L);
-      default : 
-         if ((jjbitVec0[i1] & l1) != 0L)
-            return true;
-         return false;
-   }
-}
-public static final String[] jjstrLiteralImages = {
-"", null, null, null, null, null, null, null, null, null, null, null, null, 
-null, null, null, null, null, null, null, null, null, null, null, null, null, null, 
-null, null, null, null, null, null, null, null, null, null, null, null, null, null, 
-null, null, null, null, null, null, null, null, null, null, null, null, null, null, 
-null, "\50", "\51", "\173", "\175", "\133", "\135", "\73", "\43", "\100", "\140", 
-"\44", "\54", "\72", "\74\75", "\75", null, null, "\133\56\135", };
-public static final String[] lexStateNames = {
-   "DEFAULT", 
-   "IN_MULTI_LINE_COMMENT", 
-};
-public static final int[] jjnewLexState = {
-   -1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
-   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
-   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
-};
-static final long[] jjtoToken = {
-   0xfffffffffffffc01L, 0x3ffL, 
-};
-static final long[] jjtoSkip = {
-   0x3f4L, 0x0L, 
-};
-static final long[] jjtoSpecial = {
-   0x200L, 0x0L, 
-};
-static final long[] jjtoMore = {
-   0xaL, 0x0L, 
-};
-protected JavaCharStream input_stream;
-private final int[] jjrounds = new int[27];
-private final int[] jjstateSet = new int[54];
-protected char curChar;
-public VhdlParserCoreTokenManager(JavaCharStream stream){
-   if (JavaCharStream.staticFlag)
-      throw new Error("ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.");
-   input_stream = stream;
-}
-public VhdlParserCoreTokenManager(JavaCharStream stream, int lexState){
-   this(stream);
-   SwitchTo(lexState);
-}
-public void ReInit(JavaCharStream stream)
-{
-   jjmatchedPos = jjnewStateCnt = 0;
-   curLexState = defaultLexState;
-   input_stream = stream;
-   ReInitRounds();
-}
-private final void ReInitRounds()
-{
-   int i;
-   jjround = 0x80000001;
-   for (i = 27; i-- > 0;)
-      jjrounds[i] = 0x80000000;
-}
-public void ReInit(JavaCharStream stream, int lexState)
-{
-   ReInit(stream);
-   SwitchTo(lexState);
-}
-public void SwitchTo(int lexState)
-{
-   if (lexState >= 2 || lexState < 0)
-      throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", TokenMgrError.INVALID_LEXICAL_STATE);
-   else
-      curLexState = lexState;
-}
-
-protected Token jjFillToken()
-{
-   Token t = Token.newToken(jjmatchedKind);
-   t.kind = jjmatchedKind;
-   String im = jjstrLiteralImages[jjmatchedKind];
-   t.image = (im == null) ? input_stream.GetImage() : im;
-   t.beginLine = input_stream.getBeginLine();
-   t.beginColumn = input_stream.getBeginColumn();
-   t.endLine = input_stream.getEndLine();
-   t.endColumn = input_stream.getEndColumn();
-   return t;
-}
-
-int curLexState = 0;
-int defaultLexState = 0;
-int jjnewStateCnt;
-int jjround;
-int jjmatchedPos;
-int jjmatchedKind;
-
-public Token getNextToken() 
-{
-  int kind;
-  Token specialToken = null;
-  Token matchedToken;
-  int curPos = 0;
-
-  EOFLoop :
-  for (;;)
-  {   
-   try   
-   {     
-      curChar = input_stream.BeginToken();
-   }     
-   catch(java.io.IOException e)
-   {        
-      jjmatchedKind = 0;
-      matchedToken = jjFillToken();
-      matchedToken.specialToken = specialToken;
-      return matchedToken;
-   }
-
-   for (;;)
-   {
-     switch(curLexState)
-     {
-       case 0:
-         try { input_stream.backup(0);
-            while (curChar <= 32 && (0x100000200L & (1L << curChar)) != 0L)
-               curChar = input_stream.BeginToken();
-         }
-         catch (java.io.IOException e1) { continue EOFLoop; }
-         jjmatchedKind = 0x7fffffff;
-         jjmatchedPos = 0;
-         curPos = jjMoveStringLiteralDfa0_0();
-         break;
-       case 1:
-         jjmatchedKind = 0x7fffffff;
-         jjmatchedPos = 0;
-         curPos = jjMoveStringLiteralDfa0_1();
-         if (jjmatchedPos == 0 && jjmatchedKind > 3)
-         {
-            jjmatchedKind = 3;
-         }
-         break;
-     }
-     if (jjmatchedKind != 0x7fffffff)
-     {
-        if (jjmatchedPos + 1 < curPos)
-           input_stream.backup(curPos - jjmatchedPos - 1);
-        if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
-        {
-           matchedToken = jjFillToken();
-           matchedToken.specialToken = specialToken;
-       if (jjnewLexState[jjmatchedKind] != -1)
-         curLexState = jjnewLexState[jjmatchedKind];
-           return matchedToken;
-        }
-        else if ((jjtoSkip[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
-        {
-           if ((jjtoSpecial[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
-           {
-              matchedToken = jjFillToken();
-              if (specialToken == null)
-                 specialToken = matchedToken;
-              else
-              {
-                 matchedToken.specialToken = specialToken;
-                 specialToken = (specialToken.next = matchedToken);
-              }
-           }
-         if (jjnewLexState[jjmatchedKind] != -1)
-           curLexState = jjnewLexState[jjmatchedKind];
-           continue EOFLoop;
-        }
-      if (jjnewLexState[jjmatchedKind] != -1)
-        curLexState = jjnewLexState[jjmatchedKind];
-        curPos = 0;
-        jjmatchedKind = 0x7fffffff;
-        try {
-           curChar = input_stream.readChar();
-           continue;
-        }
-        catch (java.io.IOException e1) { }
-     }
-     int error_line = input_stream.getEndLine();
-     int error_column = input_stream.getEndColumn();
-     String error_after = null;
-     boolean EOFSeen = false;
-     try { input_stream.readChar(); input_stream.backup(1); }
-     catch (java.io.IOException e1) {
-        EOFSeen = true;
-        error_after = curPos <= 1 ? "" : input_stream.GetImage();
-        if (curChar == '\n' || curChar == '\r') {
-           error_line++;
-           error_column = 0;
-        }
-        else
-           error_column++;
-     }
-     if (!EOFSeen) {
-        input_stream.backup(1);
-        error_after = curPos <= 1 ? "" : input_stream.GetImage();
-     }
-     throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);
-   }
-  }
-}
-
-}
+/* VhdlParserCoreTokenManager.java */
+/* Generated By:JJTree&JavaCC: Do not edit this line. VhdlParserCoreTokenManager.java */
+package com.elphel.vdt.veditor.parser.vhdl;
+
+/** Token Manager. */
+@SuppressWarnings("unused")public class VhdlParserCoreTokenManager implements VhdlParserCoreConstants {
+
+  /** Debug output. */
+  public  java.io.PrintStream debugStream = System.out;
+  /** Set debug output. */
+  public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }
+private int jjStopAtPos(int pos, int kind)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   return pos + 1;
+}
+private int jjMoveStringLiteralDfa0_0(){
+   switch(curChar)
+   {
+      case 9:
+         jjmatchedKind = 4;
+         return jjMoveNfa_0(5, 0);
+      case 10:
+         jjmatchedKind = 2;
+         return jjMoveNfa_0(5, 0);
+      case 12:
+         jjmatchedKind = 5;
+         return jjMoveNfa_0(5, 0);
+      case 13:
+         jjmatchedKind = 3;
+         return jjMoveNfa_0(5, 0);
+      case 32:
+         jjmatchedKind = 1;
+         return jjMoveNfa_0(5, 0);
+      case 38:
+         jjmatchedKind = 147;
+         return jjMoveNfa_0(5, 0);
+      case 39:
+         jjmatchedKind = 161;
+         return jjMoveNfa_0(5, 0);
+      case 40:
+         jjmatchedKind = 158;
+         return jjMoveNfa_0(5, 0);
+      case 41:
+         jjmatchedKind = 159;
+         return jjMoveNfa_0(5, 0);
+      case 42:
+         jjmatchedKind = 143;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x0L, 0x4000L);
+      case 43:
+         jjmatchedKind = 145;
+         return jjMoveNfa_0(5, 0);
+      case 44:
+         jjmatchedKind = 160;
+         return jjMoveNfa_0(5, 0);
+      case 45:
+         jjmatchedKind = 146;
+         return jjMoveNfa_0(5, 0);
+      case 46:
+         jjmatchedKind = 164;
+         return jjMoveNfa_0(5, 0);
+      case 47:
+         jjmatchedKind = 144;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x0L, 0x200000L);
+      case 58:
+         jjmatchedKind = 155;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x0L, 0x10000000L);
+      case 59:
+         jjmatchedKind = 154;
+         return jjMoveNfa_0(5, 0);
+      case 60:
+         jjmatchedKind = 153;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x0L, 0x800800000L);
+      case 61:
+         jjmatchedKind = 148;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x0L, 0x2020000000L);
+      case 62:
+         jjmatchedKind = 152;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x0L, 0x400000L);
+      case 65:
+         return jjMoveStringLiteralDfa1_0(0x3ff80L, 0x0L, 0x0L);
+      case 66:
+         return jjMoveStringLiteralDfa1_0(0xfc0000L, 0x0L, 0x0L);
+      case 67:
+         return jjMoveStringLiteralDfa1_0(0xf000000L, 0x0L, 0x0L);
+      case 68:
+         return jjMoveStringLiteralDfa1_0(0x30000000L, 0x0L, 0x0L);
+      case 69:
+         return jjMoveStringLiteralDfa1_0(0x7c0000000L, 0x0L, 0x0L);
+      case 70:
+         return jjMoveStringLiteralDfa1_0(0x3800000000L, 0x0L, 0x0L);
+      case 71:
+         return jjMoveStringLiteralDfa1_0(0x3c000000000L, 0x0L, 0x0L);
+      case 73:
+         return jjMoveStringLiteralDfa1_0(0xfc0000000000L, 0x0L, 0x0L);
+      case 76:
+         return jjMoveStringLiteralDfa1_0(0x1f000000000000L, 0x0L, 0x0L);
+      case 77:
+         return jjMoveStringLiteralDfa1_0(0x60000000000000L, 0x0L, 0x0L);
+      case 78:
+         return jjMoveStringLiteralDfa1_0(0x7f80000000000000L, 0x0L, 0x0L);
+      case 79:
+         return jjMoveStringLiteralDfa1_0(0x8000000000000000L, 0x1fL, 0x0L);
+      case 80:
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x1fe0L, 0x0L);
+      case 81:
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x2000L, 0x0L);
+      case 82:
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x7fc000L, 0x0L);
+      case 83:
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x3ff800000L, 0x0L);
+      case 84:
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x1fc00000000L, 0x0L);
+      case 85:
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x1e0000000000L, 0x0L);
+      case 86:
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x200000000000L, 0x0L);
+      case 87:
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x3c00000000000L, 0x0L);
+      case 88:
+         return jjMoveStringLiteralDfa1_0(0x0L, 0xc000000000000L, 0x0L);
+      case 97:
+         return jjMoveStringLiteralDfa1_0(0x3ff80L, 0x0L, 0x0L);
+      case 98:
+         return jjMoveStringLiteralDfa1_0(0xfc0000L, 0x0L, 0x0L);
+      case 99:
+         return jjMoveStringLiteralDfa1_0(0xf000000L, 0x0L, 0x0L);
+      case 100:
+         return jjMoveStringLiteralDfa1_0(0x30000000L, 0x0L, 0x0L);
+      case 101:
+         return jjMoveStringLiteralDfa1_0(0x7c0000000L, 0x0L, 0x0L);
+      case 102:
+         return jjMoveStringLiteralDfa1_0(0x3800000000L, 0x0L, 0x0L);
+      case 103:
+         return jjMoveStringLiteralDfa1_0(0x3c000000000L, 0x0L, 0x0L);
+      case 105:
+         return jjMoveStringLiteralDfa1_0(0xfc0000000000L, 0x0L, 0x0L);
+      case 108:
+         return jjMoveStringLiteralDfa1_0(0x1f000000000000L, 0x0L, 0x0L);
+      case 109:
+         return jjMoveStringLiteralDfa1_0(0x60000000000000L, 0x0L, 0x0L);
+      case 110:
+         return jjMoveStringLiteralDfa1_0(0x7f80000000000000L, 0x0L, 0x0L);
+      case 111:
+         return jjMoveStringLiteralDfa1_0(0x8000000000000000L, 0x1fL, 0x0L);
+      case 112:
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x1fe0L, 0x0L);
+      case 113:
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x2000L, 0x0L);
+      case 114:
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x7fc000L, 0x0L);
+      case 115:
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x3ff800000L, 0x0L);
+      case 116:
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x1fc00000000L, 0x0L);
+      case 117:
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x1e0000000000L, 0x0L);
+      case 118:
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x200000000000L, 0x0L);
+      case 119:
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x3c00000000000L, 0x0L);
+      case 120:
+         return jjMoveStringLiteralDfa1_0(0x0L, 0xc000000000000L, 0x0L);
+      case 124:
+         jjmatchedKind = 162;
+         return jjMoveNfa_0(5, 0);
+      default :
+         return jjMoveNfa_0(5, 0);
+   }
+}
+private int jjMoveStringLiteralDfa1_0(long active0, long active1, long active2){
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+   return jjMoveNfa_0(5, 0);
+   }
+   switch(curChar)
+   {
+      case 42:
+         if ((active2 & 0x4000L) != 0L)
+         {
+            jjmatchedKind = 142;
+            jjmatchedPos = 1;
+         }
+         break;
+      case 61:
+         if ((active2 & 0x200000L) != 0L)
+         {
+            jjmatchedKind = 149;
+            jjmatchedPos = 1;
+         }
+         else if ((active2 & 0x400000L) != 0L)
+         {
+            jjmatchedKind = 150;
+            jjmatchedPos = 1;
+         }
+         else if ((active2 & 0x800000L) != 0L)
+         {
+            jjmatchedKind = 151;
+            jjmatchedPos = 1;
+         }
+         else if ((active2 & 0x10000000L) != 0L)
+         {
+            jjmatchedKind = 156;
+            jjmatchedPos = 1;
+         }
+         else if ((active2 & 0x2000000000L) != 0L)
+         {
+            jjmatchedKind = 165;
+            jjmatchedPos = 1;
+         }
+         break;
+      case 62:
+         if ((active2 & 0x20000000L) != 0L)
+         {
+            jjmatchedKind = 157;
+            jjmatchedPos = 1;
+         }
+         else if ((active2 & 0x800000000L) != 0L)
+         {
+            jjmatchedKind = 163;
+            jjmatchedPos = 1;
+         }
+         break;
+      case 65:
+         return jjMoveStringLiteralDfa2_0(active0, 0x1a1000001000000L, active1, 0x600000004020L, active2, 0L);
+      case 66:
+         return jjMoveStringLiteralDfa2_0(active0, 0x80L, active1, 0L, active2, 0L);
+      case 67:
+         return jjMoveStringLiteralDfa2_0(active0, 0x300L, active1, 0L, active2, 0L);
+      case 69:
+         return jjMoveStringLiteralDfa2_0(active0, 0x60000c000040000L, active1, 0x4019f8000L, active2, 0L);
+      case 70:
+         if ((active0 & 0x40000000000L) != 0L)
+         {
+            jjmatchedKind = 42;
+            jjmatchedPos = 1;
+         }
+         else if ((active0 & 0x8000000000000000L) != 0L)
+         {
+            jjmatchedKind = 63;
+            jjmatchedPos = 1;
+         }
+         return jjMoveStringLiteralDfa2_0(active0, 0x400L, active1, 0L, active2, 0L);
+      case 72:
+         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x1801804000000L, active2, 0L);
+      case 73:
+         return jjMoveStringLiteralDfa2_0(active0, 0xe000810000000L, active1, 0x2000002000000L, active2, 0L);
+      case 76:
+         return jjMoveStringLiteralDfa2_0(active0, 0xc0081800L, active1, 0x18000000L, active2, 0L);
+      case 77:
+         return jjMoveStringLiteralDfa2_0(active0, 0x80000000000L, active1, 0L, active2, 0L);
+      case 78:
+         if ((active0 & 0x100000000000L) != 0L)
+         {
+            jjmatchedKind = 44;
+            jjmatchedPos = 1;
+         }
+         else if ((active1 & 0x1L) != 0L)
+         {
+            jjmatchedKind = 64;
+            jjmatchedPos = 1;
+         }
+         return jjMoveStringLiteralDfa2_0(active0, 0x600300002000L, active1, 0x40e0000000000L, active2, 0L);
+      case 79:
+         if ((active1 & 0x2000000000L) != 0L)
+         {
+            jjmatchedKind = 101;
+            jjmatchedPos = 1;
+         }
+         return jjMoveStringLiteralDfa2_0(active0, 0x385000102e100000L, active1, 0x80040006000c0L, active2, 0L);
+      case 80:
+         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x20000002L, active2, 0L);
+      case 82:
+         if ((active1 & 0x4L) != 0L)
+         {
+            jjmatchedKind = 66;
+            jjmatchedPos = 1;
+         }
+         return jjMoveStringLiteralDfa2_0(active0, 0x1000020c000L, active1, 0x80c0000f00L, active2, 0L);
+      case 83:
+         if ((active0 & 0x800000000000L) != 0L)
+         {
+            jjmatchedKind = 47;
+            jjmatchedPos = 1;
+         }
+         return jjMoveStringLiteralDfa2_0(active0, 0x10000L, active1, 0x100000000000L, active2, 0L);
+      case 84:
+         return jjMoveStringLiteralDfa2_0(active0, 0x20000L, active1, 0x8L, active2, 0L);
+      case 85:
+         return jjMoveStringLiteralDfa2_0(active0, 0x4000022000c00000L, active1, 0x300003010L, active2, 0L);
+      case 88:
+         return jjMoveStringLiteralDfa2_0(active0, 0x400000000L, active1, 0L, active2, 0L);
+      case 89:
+         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x10000000000L, active2, 0L);
+      case 97:
+         return jjMoveStringLiteralDfa2_0(active0, 0x1a1000001000000L, active1, 0x600000004020L, active2, 0L);
+      case 98:
+         return jjMoveStringLiteralDfa2_0(active0, 0x80L, active1, 0L, active2, 0L);
+      case 99:
+         return jjMoveStringLiteralDfa2_0(active0, 0x300L, active1, 0L, active2, 0L);
+      case 101:
+         return jjMoveStringLiteralDfa2_0(active0, 0x60000c000040000L, active1, 0x4019f8000L, active2, 0L);
+      case 102:
+         if ((active0 & 0x40000000000L) != 0L)
+         {
+            jjmatchedKind = 42;
+            jjmatchedPos = 1;
+         }
+         else if ((active0 & 0x8000000000000000L) != 0L)
+         {
+            jjmatchedKind = 63;
+            jjmatchedPos = 1;
+         }
+         return jjMoveStringLiteralDfa2_0(active0, 0x400L, active1, 0L, active2, 0L);
+      case 104:
+         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x1801804000000L, active2, 0L);
+      case 105:
+         return jjMoveStringLiteralDfa2_0(active0, 0xe000810000000L, active1, 0x2000002000000L, active2, 0L);
+      case 108:
+         return jjMoveStringLiteralDfa2_0(active0, 0xc0081800L, active1, 0x18000000L, active2, 0L);
+      case 109:
+         return jjMoveStringLiteralDfa2_0(active0, 0x80000000000L, active1, 0L, active2, 0L);
+      case 110:
+         if ((active0 & 0x100000000000L) != 0L)
+         {
+            jjmatchedKind = 44;
+            jjmatchedPos = 1;
+         }
+         else if ((active1 & 0x1L) != 0L)
+         {
+            jjmatchedKind = 64;
+            jjmatchedPos = 1;
+         }
+         return jjMoveStringLiteralDfa2_0(active0, 0x600300002000L, active1, 0x40e0000000000L, active2, 0L);
+      case 111:
+         if ((active1 & 0x2000000000L) != 0L)
+         {
+            jjmatchedKind = 101;
+            jjmatchedPos = 1;
+         }
+         return jjMoveStringLiteralDfa2_0(active0, 0x385000102e100000L, active1, 0x80040006000c0L, active2, 0L);
+      case 112:
+         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x20000002L, active2, 0L);
+      case 114:
+         if ((active1 & 0x4L) != 0L)
+         {
+            jjmatchedKind = 66;
+            jjmatchedPos = 1;
+         }
+         return jjMoveStringLiteralDfa2_0(active0, 0x1000020c000L, active1, 0x80c0000f00L, active2, 0L);
+      case 115:
+         if ((active0 & 0x800000000000L) != 0L)
+         {
+            jjmatchedKind = 47;
+            jjmatchedPos = 1;
+         }
+         return jjMoveStringLiteralDfa2_0(active0, 0x10000L, active1, 0x100000000000L, active2, 0L);
+      case 116:
+         return jjMoveStringLiteralDfa2_0(active0, 0x20000L, active1, 0x8L, active2, 0L);
+      case 117:
+         return jjMoveStringLiteralDfa2_0(active0, 0x4000022000c00000L, active1, 0x300003010L, active2, 0L);
+      case 120:
+         return jjMoveStringLiteralDfa2_0(active0, 0x400000000L, active1, 0L, active2, 0L);
+      case 121:
+         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x10000000000L, active2, 0L);
+      default :
+         break;
+   }
+   return jjMoveNfa_0(5, 1);
+}
+private int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1, long old2, long active2){
+   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)
+      return jjMoveNfa_0(5, 1);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+   return jjMoveNfa_0(5, 1);
+   }
+   switch(curChar)
+   {
+      case 65:
+         if ((active1 & 0x8000000L) != 0L)
+         {
+            jjmatchedKind = 91;
+            jjmatchedPos = 2;
+         }
+         else if ((active1 & 0x40000000L) != 0L)
+         {
+            jjmatchedKind = 94;
+            jjmatchedPos = 2;
+         }
+         return jjMoveStringLiteralDfa3_0(active0, 0x20000000000L, active1, 0x28004002000L);
+      case 66:
+         return jjMoveStringLiteralDfa3_0(active0, 0x3000000000000L, active1, 0x300000000L);
+      case 67:
+         return jjMoveStringLiteralDfa3_0(active0, 0x4100L, active1, 0x8020L);
+      case 68:
+         if ((active0 & 0x2000L) != 0L)
+         {
+            jjmatchedKind = 13;
+            jjmatchedPos = 2;
+         }
+         else if ((active0 & 0x100000000L) != 0L)
+         {
+            jjmatchedKind = 32;
+            jjmatchedPos = 2;
+         }
+         else if ((active0 & 0x40000000000000L) != 0L)
+         {
+            jjmatchedKind = 54;
+            jjmatchedPos = 2;
+         }
+         return jjMoveStringLiteralDfa3_0(active0, 0x100000L, active1, 0L);
+      case 69:
+         if ((active1 & 0x100000000000L) != 0L)
+         {
+            jjmatchedKind = 108;
+            jjmatchedPos = 2;
+         }
+         return jjMoveStringLiteralDfa3_0(active0, 0x200000200000L, active1, 0x800820000002L);
+      case 70:
+         return jjMoveStringLiteralDfa3_0(active0, 0x400000L, active1, 0L);
+      case 71:
+         return jjMoveStringLiteralDfa3_0(active0, 0x40000L, active1, 0x2010000L);
+      case 72:
+         return jjMoveStringLiteralDfa3_0(active0, 0L, active1, 0x8L);
+      case 73:
+         return jjMoveStringLiteralDfa3_0(active0, 0x800000400000800L, active1, 0x1440000000000L);
+      case 74:
+         return jjMoveStringLiteralDfa3_0(active0, 0L, active1, 0x20000L);
+      case 76:
+         if ((active0 & 0x1000L) != 0L)
+         {
+            jjmatchedKind = 12;
+            jjmatchedPos = 2;
+         }
+         else if ((active1 & 0x200000L) != 0L)
+         {
+            jjmatchedKind = 85;
+            jjmatchedPos = 2;
+         }
+         else if ((active1 & 0x10000000L) != 0L)
+         {
+            jjmatchedKind = 92;
+            jjmatchedPos = 2;
+         }
+         else if ((active1 & 0x80000000L) != 0L)
+         {
+            jjmatchedKind = 95;
+            jjmatchedPos = 2;
+         }
+         return jjMoveStringLiteralDfa3_0(active0, 0x4000000800000000L, active1, 0x4000800000L);
+      case 77:
+         if ((active1 & 0x40000L) != 0L)
+         {
+            jjmatchedKind = 82;
+            jjmatchedPos = 2;
+         }
+         return jjMoveStringLiteralDfa3_0(active0, 0x2000000L, active1, 0L);
+      case 78:
+         return jjMoveStringLiteralDfa3_0(active0, 0x8400e00c000000L, active1, 0x4000L);
+      case 79:
+         return jjMoveStringLiteralDfa3_0(active0, 0x10410000080000L, active1, 0x4000000000f00L);
+      case 80:
+         if ((active0 & 0x20000000000000L) != 0L)
+         {
+            jjmatchedKind = 53;
+            jjmatchedPos = 2;
+         }
+         return jjMoveStringLiteralDfa3_0(active0, 0x80000000000L, active1, 0x10000080000L);
+      case 82:
+         if ((active0 & 0x1000000000L) != 0L)
+         {
+            jjmatchedKind = 36;
+            jjmatchedPos = 2;
+         }
+         else if ((active0 & 0x1000000000000000L) != 0L)
+         {
+            jjmatchedKind = 60;
+            jjmatchedPos = 2;
+         }
+         else if ((active1 & 0x400000L) != 0L)
+         {
+            jjmatchedKind = 86;
+            jjmatchedPos = 2;
+         }
+         else if ((active1 & 0x8000000000000L) != 0L)
+         {
+            jjmatchedKind = 115;
+            jjmatchedPos = 2;
+         }
+         return jjMoveStringLiteralDfa3_0(active0, 0x8200L, active1, 0x201400001040L);
+      case 83:
+         if ((active0 & 0x80L) != 0L)
+         {
+            jjmatchedKind = 7;
+            jjmatchedPos = 2;
+         }
+         else if ((active0 & 0x800000L) != 0L)
+         {
+            jjmatchedKind = 23;
+            jjmatchedPos = 2;
+         }
+         return jjMoveStringLiteralDfa3_0(active0, 0xd1010000L, active1, 0x80L);
+      case 84:
+         if ((active0 & 0x2000000000000000L) != 0L)
+         {
+            jjmatchedKind = 61;
+            jjmatchedPos = 2;
+         }
+         else if ((active1 & 0x10L) != 0L)
+         {
+            jjmatchedKind = 68;
+            jjmatchedPos = 2;
+         }
+         return jjMoveStringLiteralDfa3_0(active0, 0x108000200020400L, active1, 0x2080000100000L);
+      case 86:
+         return jjMoveStringLiteralDfa3_0(active0, 0L, active1, 0x1000000L);
+      case 87:
+         if ((active0 & 0x200000000000000L) != 0L)
+         {
+            jjmatchedKind = 57;
+            jjmatchedPos = 2;
+         }
+         return jjMoveStringLiteralDfa3_0(active0, 0x20000000L, active1, 0L);
+      case 88:
+         return jjMoveStringLiteralDfa3_0(active0, 0x400000000000000L, active1, 0L);
+      case 97:
+         if ((active1 & 0x8000000L) != 0L)
+         {
+            jjmatchedKind = 91;
+            jjmatchedPos = 2;
+         }
+         else if ((active1 & 0x40000000L) != 0L)
+         {
+            jjmatchedKind = 94;
+            jjmatchedPos = 2;
+         }
+         return jjMoveStringLiteralDfa3_0(active0, 0x20000000000L, active1, 0x28004002000L);
+      case 98:
+         return jjMoveStringLiteralDfa3_0(active0, 0x3000000000000L, active1, 0x300000000L);
+      case 99:
+         return jjMoveStringLiteralDfa3_0(active0, 0x4100L, active1, 0x8020L);
+      case 100:
+         if ((active0 & 0x2000L) != 0L)
+         {
+            jjmatchedKind = 13;
+            jjmatchedPos = 2;
+         }
+         else if ((active0 & 0x100000000L) != 0L)
+         {
+            jjmatchedKind = 32;
+            jjmatchedPos = 2;
+         }
+         else if ((active0 & 0x40000000000000L) != 0L)
+         {
+            jjmatchedKind = 54;
+            jjmatchedPos = 2;
+         }
+         return jjMoveStringLiteralDfa3_0(active0, 0x100000L, active1, 0L);
+      case 101:
+         if ((active1 & 0x100000000000L) != 0L)
+         {
+            jjmatchedKind = 108;
+            jjmatchedPos = 2;
+         }
+         return jjMoveStringLiteralDfa3_0(active0, 0x200000200000L, active1, 0x800820000002L);
+      case 102:
+         return jjMoveStringLiteralDfa3_0(active0, 0x400000L, active1, 0L);
+      case 103:
+         return jjMoveStringLiteralDfa3_0(active0, 0x40000L, active1, 0x2010000L);
+      case 104:
+         return jjMoveStringLiteralDfa3_0(active0, 0L, active1, 0x8L);
+      case 105:
+         return jjMoveStringLiteralDfa3_0(active0, 0x800000400000800L, active1, 0x1440000000000L);
+      case 106:
+         return jjMoveStringLiteralDfa3_0(active0, 0L, active1, 0x20000L);
+      case 108:
+         if ((active0 & 0x1000L) != 0L)
+         {
+            jjmatchedKind = 12;
+            jjmatchedPos = 2;
+         }
+         else if ((active1 & 0x200000L) != 0L)
+         {
+            jjmatchedKind = 85;
+            jjmatchedPos = 2;
+         }
+         else if ((active1 & 0x10000000L) != 0L)
+         {
+            jjmatchedKind = 92;
+            jjmatchedPos = 2;
+         }
+         else if ((active1 & 0x80000000L) != 0L)
+         {
+            jjmatchedKind = 95;
+            jjmatchedPos = 2;
+         }
+         return jjMoveStringLiteralDfa3_0(active0, 0x4000000800000000L, active1, 0x4000800000L);
+      case 109:
+         if ((active1 & 0x40000L) != 0L)
+         {
+            jjmatchedKind = 82;
+            jjmatchedPos = 2;
+         }
+         return jjMoveStringLiteralDfa3_0(active0, 0x2000000L, active1, 0L);
+      case 110:
+         return jjMoveStringLiteralDfa3_0(active0, 0x8400e00c000000L, active1, 0x4000L);
+      case 111:
+         return jjMoveStringLiteralDfa3_0(active0, 0x10410000080000L, active1, 0x4000000000f00L);
+      case 112:
+         if ((active0 & 0x20000000000000L) != 0L)
+         {
+            jjmatchedKind = 53;
+            jjmatchedPos = 2;
+         }
+         return jjMoveStringLiteralDfa3_0(active0, 0x80000000000L, active1, 0x10000080000L);
+      case 114:
+         if ((active0 & 0x1000000000L) != 0L)
+         {
+            jjmatchedKind = 36;
+            jjmatchedPos = 2;
+         }
+         else if ((active0 & 0x1000000000000000L) != 0L)
+         {
+            jjmatchedKind = 60;
+            jjmatchedPos = 2;
+         }
+         else if ((active1 & 0x400000L) != 0L)
+         {
+            jjmatchedKind = 86;
+            jjmatchedPos = 2;
+         }
+         else if ((active1 & 0x8000000000000L) != 0L)
+         {
+            jjmatchedKind = 115;
+            jjmatchedPos = 2;
+         }
+         return jjMoveStringLiteralDfa3_0(active0, 0x8200L, active1, 0x201400001040L);
+      case 115:
+         if ((active0 & 0x80L) != 0L)
+         {
+            jjmatchedKind = 7;
+            jjmatchedPos = 2;
+         }
+         else if ((active0 & 0x800000L) != 0L)
+         {
+            jjmatchedKind = 23;
+            jjmatchedPos = 2;
+         }
+         return jjMoveStringLiteralDfa3_0(active0, 0xd1010000L, active1, 0x80L);
+      case 116:
+         if ((active0 & 0x2000000000000000L) != 0L)
+         {
+            jjmatchedKind = 61;
+            jjmatchedPos = 2;
+         }
+         else if ((active1 & 0x10L) != 0L)
+         {
+            jjmatchedKind = 68;
+            jjmatchedPos = 2;
+         }
+         return jjMoveStringLiteralDfa3_0(active0, 0x108000200020400L, active1, 0x2080000100000L);
+      case 118:
+         return jjMoveStringLiteralDfa3_0(active0, 0L, active1, 0x1000000L);
+      case 119:
+         if ((active0 & 0x200000000000000L) != 0L)
+         {
+            jjmatchedKind = 57;
+            jjmatchedPos = 2;
+         }
+         return jjMoveStringLiteralDfa3_0(active0, 0x20000000L, active1, 0L);
+      case 120:
+         return jjMoveStringLiteralDfa3_0(active0, 0x400000000000000L, active1, 0L);
+      default :
+         break;
+   }
+   return jjMoveNfa_0(5, 2);
+}
+private int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1){
+   if (((active0 &= old0) | (active1 &= old1)) == 0L)
+      return jjMoveNfa_0(5, 2);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+   return jjMoveNfa_0(5, 2);
+   }
+   switch(curChar)
+   {
+      case 65:
+         return jjMoveStringLiteralDfa4_0(active0, 0x208800L, active1, 0L);
+      case 67:
+         return jjMoveStringLiteralDfa4_0(active0, 0x2010080000L, active1, 0x20000700L);
+      case 68:
+         if ((active0 & 0x80000000000000L) != 0L)
+         {
+            jjmatchedKind = 55;
+            jjmatchedPos = 3;
+         }
+         break;
+      case 69:
+         if ((active0 & 0x1000000L) != 0L)
+         {
+            jjmatchedKind = 24;
+            jjmatchedPos = 3;
+         }
+         else if ((active0 & 0x40000000L) != 0L)
+         {
+            jjmatchedKind = 30;
+            jjmatchedPos = 3;
+         }
+         else if ((active0 & 0x800000000L) != 0L)
+         {
+            jjmatchedKind = 35;
+            jjmatchedPos = 3;
+         }
+         else if ((active1 & 0x1000L) != 0L)
+         {
+            jjmatchedKind = 76;
+            jjmatchedPos = 3;
+         }
+         else if ((active1 & 0x10000000000L) != 0L)
+         {
+            jjmatchedKind = 104;
+            jjmatchedPos = 3;
+         }
+         return jjMoveStringLiteralDfa4_0(active0, 0x900c000010500L, active1, 0x4001820008L);
+      case 70:
+         return jjMoveStringLiteralDfa4_0(active0, 0x4400000L, active1, 0x20000000000L);
+      case 71:
+         return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x4000L);
+      case 72:
+         if ((active1 & 0x2000000000000L) != 0L)
+         {
+            jjmatchedKind = 113;
+            jjmatchedPos = 3;
+         }
+         return jjMoveStringLiteralDfa4_0(active0, 0x4000L, active1, 0L);
+      case 73:
+         return jjMoveStringLiteralDfa4_0(active0, 0x280040000L, active1, 0x280000010000L);
+      case 75:
+         return jjMoveStringLiteralDfa4_0(active0, 0x4000000000000L, active1, 0x20L);
+      case 76:
+         if ((active0 & 0x4000000000000000L) != 0L)
+         {
+            jjmatchedKind = 62;
+            jjmatchedPos = 3;
+         }
+         return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x1000000000000L);
+      case 77:
+         return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x400000000L);
+      case 78:
+         if ((active1 & 0x2L) != 0L)
+         {
+            jjmatchedKind = 65;
+            jjmatchedPos = 3;
+         }
+         else if ((active1 & 0x800000000L) != 0L)
+         {
+            jjmatchedKind = 99;
+            jjmatchedPos = 3;
+         }
+         else if ((active1 & 0x800000000000L) != 0L)
+         {
+            jjmatchedKind = 111;
+            jjmatchedPos = 3;
+         }
+         return jjMoveStringLiteralDfa4_0(active0, 0x20000000L, active1, 0x8102002000L);
+      case 79:
+         return jjMoveStringLiteralDfa4_0(active0, 0x200L, active1, 0x1000088000L);
+      case 80:
+         if ((active0 & 0x10000000000000L) != 0L)
+         {
+            jjmatchedKind = 52;
+            jjmatchedPos = 3;
+         }
+         return jjMoveStringLiteralDfa4_0(active0, 0x2000000L, active1, 0L);
+      case 82:
+         if ((active1 & 0x4000000000000L) != 0L)
+         {
+            jjmatchedKind = 114;
+            jjmatchedPos = 3;
+         }
+         return jjMoveStringLiteralDfa4_0(active0, 0x2220000020000L, active1, 0x4000000L);
+      case 83:
+         return jjMoveStringLiteralDfa4_0(active0, 0x800000008000000L, active1, 0L);
+      case 84:
+         if ((active0 & 0x400000000L) != 0L)
+         {
+            jjmatchedKind = 34;
+            jjmatchedPos = 3;
+         }
+         else if ((active0 & 0x400000000000000L) != 0L)
+         {
+            jjmatchedKind = 58;
+            jjmatchedPos = 3;
+         }
+         else if ((active1 & 0x40L) != 0L)
+         {
+            jjmatchedKind = 70;
+            jjmatchedPos = 3;
+         }
+         else if ((active1 & 0x400000000000L) != 0L)
+         {
+            jjmatchedKind = 110;
+            jjmatchedPos = 3;
+         }
+         return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x40200000880L);
+      case 85:
+         return jjMoveStringLiteralDfa4_0(active0, 0x100490000000000L, active1, 0x100000L);
+      case 89:
+         if ((active0 & 0x100000L) != 0L)
+         {
+            jjmatchedKind = 20;
+            jjmatchedPos = 3;
+         }
+         break;
+      case 97:
+         return jjMoveStringLiteralDfa4_0(active0, 0x208800L, active1, 0L);
+      case 99:
+         return jjMoveStringLiteralDfa4_0(active0, 0x2010080000L, active1, 0x20000700L);
+      case 100:
+         if ((active0 & 0x80000000000000L) != 0L)
+         {
+            jjmatchedKind = 55;
+            jjmatchedPos = 3;
+         }
+         break;
+      case 101:
+         if ((active0 & 0x1000000L) != 0L)
+         {
+            jjmatchedKind = 24;
+            jjmatchedPos = 3;
+         }
+         else if ((active0 & 0x40000000L) != 0L)
+         {
+            jjmatchedKind = 30;
+            jjmatchedPos = 3;
+         }
+         else if ((active0 & 0x800000000L) != 0L)
+         {
+            jjmatchedKind = 35;
+            jjmatchedPos = 3;
+         }
+         else if ((active1 & 0x1000L) != 0L)
+         {
+            jjmatchedKind = 76;
+            jjmatchedPos = 3;
+         }
+         else if ((active1 & 0x10000000000L) != 0L)
+         {
+            jjmatchedKind = 104;
+            jjmatchedPos = 3;
+         }
+         return jjMoveStringLiteralDfa4_0(active0, 0x900c000010500L, active1, 0x4001820008L);
+      case 102:
+         return jjMoveStringLiteralDfa4_0(active0, 0x4400000L, active1, 0x20000000000L);
+      case 103:
+         return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x4000L);
+      case 104:
+         if ((active1 & 0x2000000000000L) != 0L)
+         {
+            jjmatchedKind = 113;
+            jjmatchedPos = 3;
+         }
+         return jjMoveStringLiteralDfa4_0(active0, 0x4000L, active1, 0L);
+      case 105:
+         return jjMoveStringLiteralDfa4_0(active0, 0x280040000L, active1, 0x280000010000L);
+      case 107:
+         return jjMoveStringLiteralDfa4_0(active0, 0x4000000000000L, active1, 0x20L);
+      case 108:
+         if ((active0 & 0x4000000000000000L) != 0L)
+         {
+            jjmatchedKind = 62;
+            jjmatchedPos = 3;
+         }
+         return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x1000000000000L);
+      case 109:
+         return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x400000000L);
+      case 110:
+         if ((active1 & 0x2L) != 0L)
+         {
+            jjmatchedKind = 65;
+            jjmatchedPos = 3;
+         }
+         else if ((active1 & 0x800000000L) != 0L)
+         {
+            jjmatchedKind = 99;
+            jjmatchedPos = 3;
+         }
+         else if ((active1 & 0x800000000000L) != 0L)
+         {
+            jjmatchedKind = 111;
+            jjmatchedPos = 3;
+         }
+         return jjMoveStringLiteralDfa4_0(active0, 0x20000000L, active1, 0x8102002000L);
+      case 111:
+         return jjMoveStringLiteralDfa4_0(active0, 0x200L, active1, 0x1000088000L);
+      case 112:
+         if ((active0 & 0x10000000000000L) != 0L)
+         {
+            jjmatchedKind = 52;
+            jjmatchedPos = 3;
+         }
+         return jjMoveStringLiteralDfa4_0(active0, 0x2000000L, active1, 0L);
+      case 114:
+         if ((active1 & 0x4000000000000L) != 0L)
+         {
+            jjmatchedKind = 114;
+            jjmatchedPos = 3;
+         }
+         return jjMoveStringLiteralDfa4_0(active0, 0x2220000020000L, active1, 0x4000000L);
+      case 115:
+         return jjMoveStringLiteralDfa4_0(active0, 0x800000008000000L, active1, 0L);
+      case 116:
+         if ((active0 & 0x400000000L) != 0L)
+         {
+            jjmatchedKind = 34;
+            jjmatchedPos = 3;
+         }
+         else if ((active0 & 0x400000000000000L) != 0L)
+         {
+            jjmatchedKind = 58;
+            jjmatchedPos = 3;
+         }
+         else if ((active1 & 0x40L) != 0L)
+         {
+            jjmatchedKind = 70;
+            jjmatchedPos = 3;
+         }
+         else if ((active1 & 0x400000000000L) != 0L)
+         {
+            jjmatchedKind = 110;
+            jjmatchedPos = 3;
+         }
+         return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x40200000880L);
+      case 117:
+         return jjMoveStringLiteralDfa4_0(active0, 0x100490000000000L, active1, 0x100000L);
+      case 121:
+         if ((active0 & 0x100000L) != 0L)
+         {
+            jjmatchedKind = 20;
+            jjmatchedPos = 3;
+         }
+         break;
+      default :
+         break;
+   }
+   return jjMoveNfa_0(5, 3);
+}
+private int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1){
+   if (((active0 &= old0) | (active1 &= old1)) == 0L)
+      return jjMoveNfa_0(5, 3);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+   return jjMoveNfa_0(5, 3);
+   }
+   switch(curChar)
+   {
+      case 65:
+         return jjMoveStringLiteralDfa5_0(active0, 0x6000000000000L, active1, 0x200102000020L);
+      case 67:
+         return jjMoveStringLiteralDfa5_0(active0, 0L, active1, 0x820000L);
+      case 68:
+         return jjMoveStringLiteralDfa5_0(active0, 0x20000000000L, active1, 0L);
+      case 69:
+         if ((active0 & 0x800000000000000L) != 0L)
+         {
+            jjmatchedKind = 59;
+            jjmatchedPos = 4;
+         }
+         else if ((active1 & 0x4000L) != 0L)
+         {
+            jjmatchedKind = 78;
+            jjmatchedPos = 4;
+         }
+         else if ((active1 & 0x1000000000000L) != 0L)
+         {
+            jjmatchedKind = 112;
+            jjmatchedPos = 4;
+         }
+         return jjMoveStringLiteralDfa5_0(active0, 0x400000L, active1, 0x4000f00L);
+      case 70:
+         if ((active0 & 0x80000000L) != 0L)
+         {
+            jjmatchedKind = 31;
+            jjmatchedPos = 4;
+         }
+         return jjMoveStringLiteralDfa5_0(active0, 0L, active1, 0x20000000000L);
+      case 73:
+         return jjMoveStringLiteralDfa5_0(active0, 0x4024000L, active1, 0x400000000L);
+      case 75:
+         if ((active0 & 0x80000L) != 0L)
+         {
+            jjmatchedKind = 19;
+            jjmatchedPos = 4;
+         }
+         else if ((active0 & 0x200000L) != 0L)
+         {
+            jjmatchedKind = 21;
+            jjmatchedPos = 4;
+         }
+         break;
+      case 76:
+         if ((active0 & 0x1000000000000L) != 0L)
+         {
+            jjmatchedKind = 48;
+            jjmatchedPos = 4;
+         }
+         else if ((active1 & 0x80000000000L) != 0L)
+         {
+            jjmatchedKind = 107;
+            jjmatchedPos = 4;
+         }
+         break;
+      case 78:
+         if ((active0 & 0x40000L) != 0L)
+         {
+            jjmatchedKind = 18;
+            jjmatchedPos = 4;
+         }
+         break;
+      case 79:
+         return jjMoveStringLiteralDfa5_0(active0, 0x12000000L, active1, 0L);
+      case 80:
+         if ((active0 & 0x10000000000L) != 0L)
+         {
+            jjmatchedKind = 40;
+            jjmatchedPos = 4;
+         }
+         return jjMoveStringLiteralDfa5_0(active0, 0L, active1, 0x80L);
+      case 82:
+         if ((active0 & 0x400L) != 0L)
+         {
+            jjmatchedKind = 10;
+            jjmatchedPos = 4;
+         }
+         return jjMoveStringLiteralDfa5_0(active0, 0x10808c000010000L, active1, 0x4001188008L);
+      case 83:
+         if ((active0 & 0x800L) != 0L)
+         {
+            jjmatchedKind = 11;
+            jjmatchedPos = 4;
+         }
+         else if ((active1 & 0x40000000000L) != 0L)
+         {
+            jjmatchedKind = 106;
+            jjmatchedPos = 4;
+         }
+         return jjMoveStringLiteralDfa5_0(active0, 0x300L, active1, 0x8000010000L);
+      case 84:
+         if ((active0 & 0x400000000000L) != 0L)
+         {
+            jjmatchedKind = 46;
+            jjmatchedPos = 4;
+         }
+         return jjMoveStringLiteralDfa5_0(active0, 0x202228000000L, active1, 0x20002000L);
+      case 85:
+         return jjMoveStringLiteralDfa5_0(active0, 0L, active1, 0x1000000000L);
+      case 89:
+         if ((active0 & 0x8000L) != 0L)
+         {
+            jjmatchedKind = 15;
+            jjmatchedPos = 4;
+         }
+         return jjMoveStringLiteralDfa5_0(active0, 0L, active1, 0x200000000L);
+      case 97:
+         return jjMoveStringLiteralDfa5_0(active0, 0x6000000000000L, active1, 0x200102000020L);
+      case 99:
+         return jjMoveStringLiteralDfa5_0(active0, 0L, active1, 0x820000L);
+      case 100:
+         return jjMoveStringLiteralDfa5_0(active0, 0x20000000000L, active1, 0L);
+      case 101:
+         if ((active0 & 0x800000000000000L) != 0L)
+         {
+            jjmatchedKind = 59;
+            jjmatchedPos = 4;
+         }
+         else if ((active1 & 0x4000L) != 0L)
+         {
+            jjmatchedKind = 78;
+            jjmatchedPos = 4;
+         }
+         else if ((active1 & 0x1000000000000L) != 0L)
+         {
+            jjmatchedKind = 112;
+            jjmatchedPos = 4;
+         }
+         return jjMoveStringLiteralDfa5_0(active0, 0x400000L, active1, 0x4000f00L);
+      case 102:
+         if ((active0 & 0x80000000L) != 0L)
+         {
+            jjmatchedKind = 31;
+            jjmatchedPos = 4;
+         }
+         return jjMoveStringLiteralDfa5_0(active0, 0L, active1, 0x20000000000L);
+      case 105:
+         return jjMoveStringLiteralDfa5_0(active0, 0x4024000L, active1, 0x400000000L);
+      case 107:
+         if ((active0 & 0x80000L) != 0L)
+         {
+            jjmatchedKind = 19;
+            jjmatchedPos = 4;
+         }
+         else if ((active0 & 0x200000L) != 0L)
+         {
+            jjmatchedKind = 21;
+            jjmatchedPos = 4;
+         }
+         break;
+      case 108:
+         if ((active0 & 0x1000000000000L) != 0L)
+         {
+            jjmatchedKind = 48;
+            jjmatchedPos = 4;
+         }
+         else if ((active1 & 0x80000000000L) != 0L)
+         {
+            jjmatchedKind = 107;
+            jjmatchedPos = 4;
+         }
+         break;
+      case 110:
+         if ((active0 & 0x40000L) != 0L)
+         {
+            jjmatchedKind = 18;
+            jjmatchedPos = 4;
+         }
+         break;
+      case 111:
+         return jjMoveStringLiteralDfa5_0(active0, 0x12000000L, active1, 0L);
+      case 112:
+         if ((active0 & 0x10000000000L) != 0L)
+         {
+            jjmatchedKind = 40;
+            jjmatchedPos = 4;
+         }
+         return jjMoveStringLiteralDfa5_0(active0, 0L, active1, 0x80L);
+      case 114:
+         if ((active0 & 0x400L) != 0L)
+         {
+            jjmatchedKind = 10;
+            jjmatchedPos = 4;
+         }
+         return jjMoveStringLiteralDfa5_0(active0, 0x10808c000010000L, active1, 0x4001188008L);
+      case 115:
+         if ((active0 & 0x800L) != 0L)
+         {
+            jjmatchedKind = 11;
+            jjmatchedPos = 4;
+         }
+         else if ((active1 & 0x40000000000L) != 0L)
+         {
+            jjmatchedKind = 106;
+            jjmatchedPos = 4;
+         }
+         return jjMoveStringLiteralDfa5_0(active0, 0x300L, active1, 0x8000010000L);
+      case 116:
+         if ((active0 & 0x400000000000L) != 0L)
+         {
+            jjmatchedKind = 46;
+            jjmatchedPos = 4;
+         }
+         return jjMoveStringLiteralDfa5_0(active0, 0x202228000000L, active1, 0x20002000L);
+      case 117:
+         return jjMoveStringLiteralDfa5_0(active0, 0L, active1, 0x1000000000L);
+      case 121:
+         if ((active0 & 0x8000L) != 0L)
+         {
+            jjmatchedKind = 15;
+            jjmatchedPos = 4;
+         }
+         return jjMoveStringLiteralDfa5_0(active0, 0L, active1, 0x200000000L);
+      default :
+         break;
+   }
+   return jjMoveNfa_0(5, 4);
+}
+private int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1){
+   if (((active0 &= old0) | (active1 &= old1)) == 0L)
+      return jjMoveNfa_0(5, 4);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+   return jjMoveNfa_0(5, 4);
+   }
+   switch(curChar)
+   {
+      case 65:
+         return jjMoveStringLiteralDfa6_0(active0, 0x8004008000000L, active1, 0x4000000000L);
+      case 66:
+         return jjMoveStringLiteralDfa6_0(active0, 0x20000L, active1, 0x200000000000L);
+      case 67:
+         return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x800L);
+      case 68:
+         if ((active1 & 0x8000L) != 0L)
+         {
+            jjmatchedKind = 79;
+            jjmatchedPos = 5;
+         }
+         else if ((active1 & 0x4000000L) != 0L)
+         {
+            jjmatchedKind = 90;
+            jjmatchedPos = 5;
+         }
+         return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x300L);
+      case 69:
+         if ((active0 & 0x80000000000L) != 0L)
+         {
+            jjmatchedKind = 43;
+            jjmatchedPos = 5;
+         }
+         else if ((active0 & 0x100000000000000L) != 0L)
+         {
+            jjmatchedKind = 56;
+            jjmatchedPos = 5;
+         }
+         return jjMoveStringLiteralDfa6_0(active0, 0x20000000000L, active1, 0x20000000000L);
+      case 71:
+         return jjMoveStringLiteralDfa6_0(active0, 0x4000004000000L, active1, 0x1000000020L);
+      case 73:
+         return jjMoveStringLiteralDfa6_0(active0, 0x20a000000000L, active1, 0x1002000L);
+      case 76:
+         if ((active1 & 0x2000000L) != 0L)
+         {
+            jjmatchedKind = 89;
+            jjmatchedPos = 5;
+         }
+         break;
+      case 78:
+         if ((active1 & 0x100000L) != 0L)
+         {
+            jjmatchedKind = 84;
+            jjmatchedPos = 5;
+         }
+         return jjMoveStringLiteralDfa6_0(active0, 0x12000000L, active1, 0x400000000L);
+      case 79:
+         if ((active0 & 0x20000000L) != 0L)
+         {
+            jjmatchedKind = 29;
+            jjmatchedPos = 5;
+         }
+         return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x80L);
+      case 80:
+         return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x8200000000L);
+      case 82:
+         if ((active0 & 0x400000L) != 0L)
+         {
+            jjmatchedKind = 22;
+            jjmatchedPos = 5;
+         }
+         return jjMoveStringLiteralDfa6_0(active0, 0x2000000000000L, active1, 0x20000000L);
+      case 83:
+         if ((active0 & 0x100L) != 0L)
+         {
+            jjmatchedKind = 8;
+            jjmatchedPos = 5;
+         }
+         else if ((active0 & 0x200L) != 0L)
+         {
+            jjmatchedKind = 9;
+            jjmatchedPos = 5;
+         }
+         else if ((active1 & 0x8L) != 0L)
+         {
+            jjmatchedKind = 67;
+            jjmatchedPos = 5;
+         }
+         return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x400L);
+      case 84:
+         if ((active0 & 0x10000L) != 0L)
+         {
+            jjmatchedKind = 16;
+            jjmatchedPos = 5;
+         }
+         else if ((active1 & 0x20000L) != 0L)
+         {
+            jjmatchedKind = 81;
+            jjmatchedPos = 5;
+         }
+         else if ((active1 & 0x80000L) != 0L)
+         {
+            jjmatchedKind = 83;
+            jjmatchedPos = 5;
+         }
+         else if ((active1 & 0x800000L) != 0L)
+         {
+            jjmatchedKind = 87;
+            jjmatchedPos = 5;
+         }
+         return jjMoveStringLiteralDfa6_0(active0, 0x4000L, active1, 0x100010000L);
+      case 89:
+         if ((active0 & 0x200000000L) != 0L)
+         {
+            jjmatchedKind = 33;
+            jjmatchedPos = 5;
+         }
+         break;
+      case 97:
+         return jjMoveStringLiteralDfa6_0(active0, 0x8004008000000L, active1, 0x4000000000L);
+      case 98:
+         return jjMoveStringLiteralDfa6_0(active0, 0x20000L, active1, 0x200000000000L);
+      case 99:
+         return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x800L);
+      case 100:
+         if ((active1 & 0x8000L) != 0L)
+         {
+            jjmatchedKind = 79;
+            jjmatchedPos = 5;
+         }
+         else if ((active1 & 0x4000000L) != 0L)
+         {
+            jjmatchedKind = 90;
+            jjmatchedPos = 5;
+         }
+         return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x300L);
+      case 101:
+         if ((active0 & 0x80000000000L) != 0L)
+         {
+            jjmatchedKind = 43;
+            jjmatchedPos = 5;
+         }
+         else if ((active0 & 0x100000000000000L) != 0L)
+         {
+            jjmatchedKind = 56;
+            jjmatchedPos = 5;
+         }
+         return jjMoveStringLiteralDfa6_0(active0, 0x20000000000L, active1, 0x20000000000L);
+      case 103:
+         return jjMoveStringLiteralDfa6_0(active0, 0x4000004000000L, active1, 0x1000000020L);
+      case 105:
+         return jjMoveStringLiteralDfa6_0(active0, 0x20a000000000L, active1, 0x1002000L);
+      case 108:
+         if ((active1 & 0x2000000L) != 0L)
+         {
+            jjmatchedKind = 89;
+            jjmatchedPos = 5;
+         }
+         break;
+      case 110:
+         if ((active1 & 0x100000L) != 0L)
+         {
+            jjmatchedKind = 84;
+            jjmatchedPos = 5;
+         }
+         return jjMoveStringLiteralDfa6_0(active0, 0x12000000L, active1, 0x400000000L);
+      case 111:
+         if ((active0 & 0x20000000L) != 0L)
+         {
+            jjmatchedKind = 29;
+            jjmatchedPos = 5;
+         }
+         return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x80L);
+      case 112:
+         return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x8200000000L);
+      case 114:
+         if ((active0 & 0x400000L) != 0L)
+         {
+            jjmatchedKind = 22;
+            jjmatchedPos = 5;
+         }
+         return jjMoveStringLiteralDfa6_0(active0, 0x2000000000000L, active1, 0x20000000L);
+      case 115:
+         if ((active0 & 0x100L) != 0L)
+         {
+            jjmatchedKind = 8;
+            jjmatchedPos = 5;
+         }
+         else if ((active0 & 0x200L) != 0L)
+         {
+            jjmatchedKind = 9;
+            jjmatchedPos = 5;
+         }
+         else if ((active1 & 0x8L) != 0L)
+         {
+            jjmatchedKind = 67;
+            jjmatchedPos = 5;
+         }
+         return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x400L);
+      case 116:
+         if ((active0 & 0x10000L) != 0L)
+         {
+            jjmatchedKind = 16;
+            jjmatchedPos = 5;
+         }
+         else if ((active1 & 0x20000L) != 0L)
+         {
+            jjmatchedKind = 81;
+            jjmatchedPos = 5;
+         }
+         else if ((active1 & 0x80000L) != 0L)
+         {
+            jjmatchedKind = 83;
+            jjmatchedPos = 5;
+         }
+         else if ((active1 & 0x800000L) != 0L)
+         {
+            jjmatchedKind = 87;
+            jjmatchedPos = 5;
+         }
+         return jjMoveStringLiteralDfa6_0(active0, 0x4000L, active1, 0x100010000L);
+      case 121:
+         if ((active0 & 0x200000000L) != 0L)
+         {
+            jjmatchedKind = 33;
+            jjmatchedPos = 5;
+         }
+         break;
+      default :
+         break;
+   }
+   return jjMoveNfa_0(5, 5);
+}
+private int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1){
+   if (((active0 &= old0) | (active1 &= old1)) == 0L)
+      return jjMoveNfa_0(5, 5);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+   return jjMoveNfa_0(5, 5);
+   }
+   switch(curChar)
+   {
+      case 65:
+         return jjMoveStringLiteralDfa7_0(active0, 0x200000000000L, active1, 0x400000000L);
+      case 67:
+         if ((active0 & 0x8000000000L) != 0L)
+         {
+            jjmatchedKind = 39;
+            jjmatchedPos = 6;
+         }
+         return jjMoveStringLiteralDfa7_0(active0, 0L, active1, 0x20000000000L);
+      case 68:
+         if ((active0 & 0x20000000000L) != 0L)
+         {
+            jjmatchedKind = 41;
+            jjmatchedPos = 6;
+         }
+         break;
+      case 69:
+         if ((active0 & 0x4000000000000L) != 0L)
+         {
+            jjmatchedKind = 50;
+            jjmatchedPos = 6;
+         }
+         else if ((active1 & 0x20L) != 0L)
+         {
+            jjmatchedKind = 69;
+            jjmatchedPos = 6;
+         }
+         else if ((active1 & 0x200000000L) != 0L)
+         {
+            jjmatchedKind = 97;
+            jjmatchedPos = 6;
+         }
+         return jjMoveStringLiteralDfa7_0(active0, 0x2004000L, active1, 0x10000L);
+      case 72:
+         if ((active1 & 0x1000000000L) != 0L)
+         {
+            jjmatchedKind = 100;
+            jjmatchedPos = 6;
+         }
+         break;
+      case 76:
+         if ((active0 & 0x8000000000000L) != 0L)
+         {
+            jjmatchedKind = 51;
+            jjmatchedPos = 6;
+         }
+         return jjMoveStringLiteralDfa7_0(active0, 0L, active1, 0x200000000000L);
+      case 78:
+         return jjMoveStringLiteralDfa7_0(active0, 0x18000000L, active1, 0x4000000080L);
+      case 79:
+         return jjMoveStringLiteralDfa7_0(active0, 0x2000000000L, active1, 0x8000000000L);
+      case 83:
+         if ((active1 & 0x400L) != 0L)
+         {
+            jjmatchedKind = 74;
+            jjmatchedPos = 6;
+         }
+         break;
+      case 84:
+         return jjMoveStringLiteralDfa7_0(active0, 0x4000000000L, active1, 0x1002800L);
+      case 85:
+         return jjMoveStringLiteralDfa7_0(active0, 0x4020000L, active1, 0x120000300L);
+      case 89:
+         if ((active0 & 0x2000000000000L) != 0L)
+         {
+            jjmatchedKind = 49;
+            jjmatchedPos = 6;
+         }
+         break;
+      case 97:
+         return jjMoveStringLiteralDfa7_0(active0, 0x200000000000L, active1, 0x400000000L);
+      case 99:
+         if ((active0 & 0x8000000000L) != 0L)
+         {
+            jjmatchedKind = 39;
+            jjmatchedPos = 6;
+         }
+         return jjMoveStringLiteralDfa7_0(active0, 0L, active1, 0x20000000000L);
+      case 100:
+         if ((active0 & 0x20000000000L) != 0L)
+         {
+            jjmatchedKind = 41;
+            jjmatchedPos = 6;
+         }
+         break;
+      case 101:
+         if ((active0 & 0x4000000000000L) != 0L)
+         {
+            jjmatchedKind = 50;
+            jjmatchedPos = 6;
+         }
+         else if ((active1 & 0x20L) != 0L)
+         {
+            jjmatchedKind = 69;
+            jjmatchedPos = 6;
+         }
+         else if ((active1 & 0x200000000L) != 0L)
+         {
+            jjmatchedKind = 97;
+            jjmatchedPos = 6;
+         }
+         return jjMoveStringLiteralDfa7_0(active0, 0x2004000L, active1, 0x10000L);
+      case 104:
+         if ((active1 & 0x1000000000L) != 0L)
+         {
+            jjmatchedKind = 100;
+            jjmatchedPos = 6;
+         }
+         break;
+      case 108:
+         if ((active0 & 0x8000000000000L) != 0L)
+         {
+            jjmatchedKind = 51;
+            jjmatchedPos = 6;
+         }
+         return jjMoveStringLiteralDfa7_0(active0, 0L, active1, 0x200000000000L);
+      case 110:
+         return jjMoveStringLiteralDfa7_0(active0, 0x18000000L, active1, 0x4000000080L);
+      case 111:
+         return jjMoveStringLiteralDfa7_0(active0, 0x2000000000L, active1, 0x8000000000L);
+      case 115:
+         if ((active1 & 0x400L) != 0L)
+         {
+            jjmatchedKind = 74;
+            jjmatchedPos = 6;
+         }
+         break;
+      case 116:
+         return jjMoveStringLiteralDfa7_0(active0, 0x4000000000L, active1, 0x1002800L);
+      case 117:
+         return jjMoveStringLiteralDfa7_0(active0, 0x4020000L, active1, 0x120000300L);
+      case 121:
+         if ((active0 & 0x2000000000000L) != 0L)
+         {
+            jjmatchedKind = 49;
+            jjmatchedPos = 6;
+         }
+         break;
+      default :
+         break;
+   }
+   return jjMoveNfa_0(5, 6);
+}
+private int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1){
+   if (((active0 &= old0) | (active1 &= old1)) == 0L)
+      return jjMoveNfa_0(5, 6);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+   return jjMoveNfa_0(5, 6);
+   }
+   switch(curChar)
+   {
+      case 67:
+         return jjMoveStringLiteralDfa8_0(active0, 0x4000L, active1, 0x4000000000L);
+      case 69:
+         if ((active0 & 0x4000000000L) != 0L)
+         {
+            jjmatchedKind = 38;
+            jjmatchedPos = 7;
+         }
+         else if ((active1 & 0x200000000000L) != 0L)
+         {
+            jjmatchedKind = 109;
+            jjmatchedPos = 7;
+         }
+         return jjMoveStringLiteralDfa8_0(active0, 0x10000000L, active1, 0x880L);
+      case 76:
+         if ((active0 & 0x200000000000L) != 0L)
+         {
+            jjmatchedKind = 45;
+            jjmatchedPos = 7;
+         }
+         else if ((active1 & 0x400000000L) != 0L)
+         {
+            jjmatchedKind = 98;
+            jjmatchedPos = 7;
+         }
+         break;
+      case 77:
+         if ((active1 & 0x20000000L) != 0L)
+         {
+            jjmatchedKind = 93;
+            jjmatchedPos = 7;
+         }
+         break;
+      case 78:
+         if ((active0 & 0x2000000000L) != 0L)
+         {
+            jjmatchedKind = 37;
+            jjmatchedPos = 7;
+         }
+         return jjMoveStringLiteralDfa8_0(active0, 0x2000000L, active1, 0L);
+      case 82:
+         if ((active1 & 0x10000L) != 0L)
+         {
+            jjmatchedKind = 80;
+            jjmatchedPos = 7;
+         }
+         return jjMoveStringLiteralDfa8_0(active0, 0x4000000L, active1, 0x8100000300L);
+      case 84:
+         if ((active0 & 0x8000000L) != 0L)
+         {
+            jjmatchedKind = 27;
+            jjmatchedPos = 7;
+         }
+         return jjMoveStringLiteralDfa8_0(active0, 0x20000L, active1, 0x20000000000L);
+      case 89:
+         if ((active1 & 0x2000L) != 0L)
+         {
+            jjmatchedKind = 77;
+            jjmatchedPos = 7;
+         }
+         else if ((active1 & 0x1000000L) != 0L)
+         {
+            jjmatchedKind = 88;
+            jjmatchedPos = 7;
+         }
+         break;
+      case 99:
+         return jjMoveStringLiteralDfa8_0(active0, 0x4000L, active1, 0x4000000000L);
+      case 101:
+         if ((active0 & 0x4000000000L) != 0L)
+         {
+            jjmatchedKind = 38;
+            jjmatchedPos = 7;
+         }
+         else if ((active1 & 0x200000000000L) != 0L)
+         {
+            jjmatchedKind = 109;
+            jjmatchedPos = 7;
+         }
+         return jjMoveStringLiteralDfa8_0(active0, 0x10000000L, active1, 0x880L);
+      case 108:
+         if ((active0 & 0x200000000000L) != 0L)
+         {
+            jjmatchedKind = 45;
+            jjmatchedPos = 7;
+         }
+         else if ((active1 & 0x400000000L) != 0L)
+         {
+            jjmatchedKind = 98;
+            jjmatchedPos = 7;
+         }
+         break;
+      case 109:
+         if ((active1 & 0x20000000L) != 0L)
+         {
+            jjmatchedKind = 93;
+            jjmatchedPos = 7;
+         }
+         break;
+      case 110:
+         if ((active0 & 0x2000000000L) != 0L)
+         {
+            jjmatchedKind = 37;
+            jjmatchedPos = 7;
+         }
+         return jjMoveStringLiteralDfa8_0(active0, 0x2000000L, active1, 0L);
+      case 114:
+         if ((active1 & 0x10000L) != 0L)
+         {
+            jjmatchedKind = 80;
+            jjmatchedPos = 7;
+         }
+         return jjMoveStringLiteralDfa8_0(active0, 0x4000000L, active1, 0x8100000300L);
+      case 116:
+         if ((active0 & 0x8000000L) != 0L)
+         {
+            jjmatchedKind = 27;
+            jjmatchedPos = 7;
+         }
+         return jjMoveStringLiteralDfa8_0(active0, 0x20000L, active1, 0x20000000000L);
+      case 121:
+         if ((active1 & 0x2000L) != 0L)
+         {
+            jjmatchedKind = 77;
+            jjmatchedPos = 7;
+         }
+         else if ((active1 & 0x1000000L) != 0L)
+         {
+            jjmatchedKind = 88;
+            jjmatchedPos = 7;
+         }
+         break;
+      default :
+         break;
+   }
+   return jjMoveNfa_0(5, 7);
+}
+private int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1){
+   if (((active0 &= old0) | (active1 &= old1)) == 0L)
+      return jjMoveNfa_0(5, 7);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+   return jjMoveNfa_0(5, 7);
+   }
+   switch(curChar)
+   {
+      case 65:
+         return jjMoveStringLiteralDfa9_0(active0, 0x4000000L, active1, 0x100L);
+      case 67:
+         return jjMoveStringLiteralDfa9_0(active0, 0x10000000L, active1, 0L);
+      case 68:
+         if ((active1 & 0x80L) != 0L)
+         {
+            jjmatchedKind = 71;
+            jjmatchedPos = 8;
+         }
+         else if ((active1 & 0x800L) != 0L)
+         {
+            jjmatchedKind = 75;
+            jjmatchedPos = 8;
+         }
+         break;
+      case 69:
+         if ((active0 & 0x20000L) != 0L)
+         {
+            jjmatchedKind = 17;
+            jjmatchedPos = 8;
+         }
+         else if ((active1 & 0x200L) != 0L)
+         {
+            jjmatchedKind = 73;
+            jjmatchedPos = 8;
+         }
+         else if ((active1 & 0x100000000L) != 0L)
+         {
+            jjmatchedKind = 96;
+            jjmatchedPos = 8;
+         }
+         else if ((active1 & 0x4000000000L) != 0L)
+         {
+            jjmatchedKind = 102;
+            jjmatchedPos = 8;
+         }
+         return jjMoveStringLiteralDfa9_0(active0, 0L, active1, 0x20000000000L);
+      case 84:
+         if ((active0 & 0x2000000L) != 0L)
+         {
+            jjmatchedKind = 25;
+            jjmatchedPos = 8;
+         }
+         else if ((active1 & 0x8000000000L) != 0L)
+         {
+            jjmatchedKind = 103;
+            jjmatchedPos = 8;
+         }
+         return jjMoveStringLiteralDfa9_0(active0, 0x4000L, active1, 0L);
+      case 97:
+         return jjMoveStringLiteralDfa9_0(active0, 0x4000000L, active1, 0x100L);
+      case 99:
+         return jjMoveStringLiteralDfa9_0(active0, 0x10000000L, active1, 0L);
+      case 100:
+         if ((active1 & 0x80L) != 0L)
+         {
+            jjmatchedKind = 71;
+            jjmatchedPos = 8;
+         }
+         else if ((active1 & 0x800L) != 0L)
+         {
+            jjmatchedKind = 75;
+            jjmatchedPos = 8;
+         }
+         break;
+      case 101:
+         if ((active0 & 0x20000L) != 0L)
+         {
+            jjmatchedKind = 17;
+            jjmatchedPos = 8;
+         }
+         else if ((active1 & 0x200L) != 0L)
+         {
+            jjmatchedKind = 73;
+            jjmatchedPos = 8;
+         }
+         else if ((active1 & 0x100000000L) != 0L)
+         {
+            jjmatchedKind = 96;
+            jjmatchedPos = 8;
+         }
+         else if ((active1 & 0x4000000000L) != 0L)
+         {
+            jjmatchedKind = 102;
+            jjmatchedPos = 8;
+         }
+         return jjMoveStringLiteralDfa9_0(active0, 0L, active1, 0x20000000000L);
+      case 116:
+         if ((active0 & 0x2000000L) != 0L)
+         {
+            jjmatchedKind = 25;
+            jjmatchedPos = 8;
+         }
+         else if ((active1 & 0x8000000000L) != 0L)
+         {
+            jjmatchedKind = 103;
+            jjmatchedPos = 8;
+         }
+         return jjMoveStringLiteralDfa9_0(active0, 0x4000L, active1, 0L);
+      default :
+         break;
+   }
+   return jjMoveNfa_0(5, 8);
+}
+private int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1){
+   if (((active0 &= old0) | (active1 &= old1)) == 0L)
+      return jjMoveNfa_0(5, 8);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+   return jjMoveNfa_0(5, 8);
+   }
+   switch(curChar)
+   {
+      case 68:
+         if ((active1 & 0x20000000000L) != 0L)
+         {
+            jjmatchedKind = 105;
+            jjmatchedPos = 9;
+         }
+         break;
+      case 76:
+         if ((active1 & 0x100L) != 0L)
+         {
+            jjmatchedKind = 72;
+            jjmatchedPos = 9;
+         }
+         break;
+      case 84:
+         if ((active0 & 0x10000000L) != 0L)
+         {
+            jjmatchedKind = 28;
+            jjmatchedPos = 9;
+         }
+         return jjMoveStringLiteralDfa10_0(active0, 0x4000000L, active1, 0L);
+      case 85:
+         return jjMoveStringLiteralDfa10_0(active0, 0x4000L, active1, 0L);
+      case 100:
+         if ((active1 & 0x20000000000L) != 0L)
+         {
+            jjmatchedKind = 105;
+            jjmatchedPos = 9;
+         }
+         break;
+      case 108:
+         if ((active1 & 0x100L) != 0L)
+         {
+            jjmatchedKind = 72;
+            jjmatchedPos = 9;
+         }
+         break;
+      case 116:
+         if ((active0 & 0x10000000L) != 0L)
+         {
+            jjmatchedKind = 28;
+            jjmatchedPos = 9;
+         }
+         return jjMoveStringLiteralDfa10_0(active0, 0x4000000L, active1, 0L);
+      case 117:
+         return jjMoveStringLiteralDfa10_0(active0, 0x4000L, active1, 0L);
+      default :
+         break;
+   }
+   return jjMoveNfa_0(5, 9);
+}
+private int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1){
+   if (((active0 &= old0) | (active1 &= old1)) == 0L)
+      return jjMoveNfa_0(5, 9);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+   return jjMoveNfa_0(5, 9);
+   }
+   switch(curChar)
+   {
+      case 73:
+         return jjMoveStringLiteralDfa11_0(active0, 0x4000000L);
+      case 82:
+         return jjMoveStringLiteralDfa11_0(active0, 0x4000L);
+      case 105:
+         return jjMoveStringLiteralDfa11_0(active0, 0x4000000L);
+      case 114:
+         return jjMoveStringLiteralDfa11_0(active0, 0x4000L);
+      default :
+         break;
+   }
+   return jjMoveNfa_0(5, 10);
+}
+private int jjMoveStringLiteralDfa11_0(long old0, long active0){
+   if (((active0 &= old0)) == 0L)
+      return jjMoveNfa_0(5, 10);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+   return jjMoveNfa_0(5, 10);
+   }
+   switch(curChar)
+   {
+      case 69:
+         if ((active0 & 0x4000L) != 0L)
+         {
+            jjmatchedKind = 14;
+            jjmatchedPos = 11;
+         }
+         break;
+      case 79:
+         return jjMoveStringLiteralDfa12_0(active0, 0x4000000L);
+      case 101:
+         if ((active0 & 0x4000L) != 0L)
+         {
+            jjmatchedKind = 14;
+            jjmatchedPos = 11;
+         }
+         break;
+      case 111:
+         return jjMoveStringLiteralDfa12_0(active0, 0x4000000L);
+      default :
+         break;
+   }
+   return jjMoveNfa_0(5, 11);
+}
+private int jjMoveStringLiteralDfa12_0(long old0, long active0){
+   if (((active0 &= old0)) == 0L)
+      return jjMoveNfa_0(5, 11);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+   return jjMoveNfa_0(5, 11);
+   }
+   switch(curChar)
+   {
+      case 78:
+         if ((active0 & 0x4000000L) != 0L)
+         {
+            jjmatchedKind = 26;
+            jjmatchedPos = 12;
+         }
+         break;
+      case 110:
+         if ((active0 & 0x4000000L) != 0L)
+         {
+            jjmatchedKind = 26;
+            jjmatchedPos = 12;
+         }
+         break;
+      default :
+         break;
+   }
+   return jjMoveNfa_0(5, 12);
+}
+static final long[] jjbitVec0 = {
+   0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL
+};
+private int jjMoveNfa_0(int startState, int curPos)
+{
+   int strKind = jjmatchedKind;
+   int strPos = jjmatchedPos;
+   int seenUpto;
+   input_stream.backup(seenUpto = curPos + 1);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) { throw new Error("Internal Error"); }
+   curPos = 0;
+   int startsAt = 0;
+   jjnewStateCnt = 54;
+   int i = 1;
+   jjstateSet[0] = startState;
+   int kind = 0x7fffffff;
+   for (;;)
+   {
+      if (++jjround == 0x7fffffff)
+         ReInitRounds();
+      if (curChar < 64)
+      {
+         long l = 1L << curChar;
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 5:
+                  if ((0x3ff000000000000L & l) != 0L)
+                  {
+                     if (kind > 137)
+                        kind = 137;
+                     { jjCheckNAddStates(0, 6); }
+                  }
+                  else if (curChar == 34)
+                     { jjCheckNAddStates(7, 9); }
+                  else if (curChar == 39)
+                     jjstateSet[jjnewStateCnt++] = 15;
+                  else if (curChar == 45)
+                     jjstateSet[jjnewStateCnt++] = 0;
+                  break;
+               case 0:
+                  if (curChar == 45)
+                     { jjCheckNAddStates(10, 12); }
+                  break;
+               case 1:
+                  if ((0xffffffffffffdbffL & l) != 0L)
+                     { jjCheckNAddStates(10, 12); }
+                  break;
+               case 2:
+                  if ((0x2400L & l) != 0L && kind > 6)
+                     kind = 6;
+                  break;
+               case 3:
+                  if (curChar == 10 && kind > 6)
+                     kind = 6;
+                  break;
+               case 4:
+                  if (curChar == 13)
+                     jjstateSet[jjnewStateCnt++] = 3;
+                  break;
+               case 8:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 133)
+                     kind = 133;
+                  { jjAddStates(13, 14); }
+                  break;
+               case 10:
+                  if (curChar == 34)
+                     { jjCheckNAdd(11); }
+                  break;
+               case 11:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     { jjCheckNAddStates(15, 17); }
+                  break;
+               case 13:
+                  if (curChar == 34 && kind > 134)
+                     kind = 134;
+                  break;
+               case 14:
+                  if (curChar == 39)
+                     jjstateSet[jjnewStateCnt++] = 15;
+                  break;
+               case 15:
+                  if ((0xffffffff00000000L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 16;
+                  break;
+               case 16:
+                  if (curChar == 39 && kind > 136)
+                     kind = 136;
+                  break;
+               case 18:
+                  if ((0xfffffffb00000000L & l) != 0L)
+                     { jjAddStates(18, 19); }
+                  break;
+               case 20:
+               case 21:
+                  if (curChar == 34)
+                     { jjCheckNAddStates(7, 9); }
+                  break;
+               case 22:
+                  if (curChar == 34)
+                     jjstateSet[jjnewStateCnt++] = 21;
+                  break;
+               case 23:
+                  if ((0xfffffffb00000000L & l) != 0L)
+                     { jjCheckNAddStates(7, 9); }
+                  break;
+               case 24:
+                  if (curChar == 34 && kind > 141)
+                     kind = 141;
+                  break;
+               case 25:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 137)
+                     kind = 137;
+                  { jjCheckNAddStates(0, 6); }
+                  break;
+               case 27:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     { jjCheckNAddStates(20, 22); }
+                  break;
+               case 28:
+                  if (curChar == 35)
+                     { jjCheckNAddStates(23, 26); }
+                  break;
+               case 30:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     { jjCheckNAddStates(23, 26); }
+                  break;
+               case 31:
+                  if (curChar == 46)
+                     { jjCheckNAddStates(27, 29); }
+                  break;
+               case 33:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     { jjCheckNAddStates(27, 29); }
+                  break;
+               case 34:
+                  if (curChar != 35)
+                     break;
+                  if (kind > 130)
+                     kind = 130;
+                  jjstateSet[jjnewStateCnt++] = 35;
+                  break;
+               case 36:
+                  if (curChar == 43)
+                     { jjCheckNAdd(37); }
+                  break;
+               case 37:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 130)
+                     kind = 130;
+                  { jjCheckNAddTwoStates(38, 37); }
+                  break;
+               case 39:
+                  if (curChar == 45)
+                     { jjCheckNAdd(40); }
+                  break;
+               case 40:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 130)
+                     kind = 130;
+                  { jjCheckNAddTwoStates(41, 40); }
+                  break;
+               case 43:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 137)
+                     kind = 137;
+                  { jjCheckNAddStates(30, 33); }
+                  break;
+               case 44:
+                  if (curChar == 46)
+                     { jjCheckNAdd(45); }
+                  break;
+               case 45:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 137)
+                     kind = 137;
+                  { jjCheckNAddStates(34, 36); }
+                  break;
+               case 48:
+                  if (curChar == 43)
+                     { jjCheckNAdd(49); }
+                  break;
+               case 49:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 137)
+                     kind = 137;
+                  { jjCheckNAddTwoStates(50, 49); }
+                  break;
+               case 51:
+                  if (curChar == 45)
+                     { jjCheckNAdd(52); }
+                  break;
+               case 52:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 137)
+                     kind = 137;
+                  { jjCheckNAddTwoStates(53, 52); }
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else if (curChar < 128)
+      {
+         long l = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 5:
+                  if ((0x7fffffe07fffffeL & l) != 0L)
+                  {
+                     if (kind > 133)
+                        kind = 133;
+                     { jjCheckNAddTwoStates(7, 8); }
+                  }
+                  else if (curChar == 92)
+                     { jjCheckNAdd(18); }
+                  if ((0x100800401008004L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 10;
+                  break;
+               case 1:
+                  { jjAddStates(10, 12); }
+                  break;
+               case 6:
+               case 8:
+                  if ((0x7fffffe07fffffeL & l) == 0L)
+                     break;
+                  if (kind > 133)
+                     kind = 133;
+                  { jjCheckNAddTwoStates(7, 8); }
+                  break;
+               case 7:
+                  if (curChar == 95)
+                     { jjCheckNAdd(8); }
+                  break;
+               case 9:
+                  if ((0x100800401008004L & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 10;
+                  break;
+               case 11:
+                  if ((0x7e0000007eL & l) != 0L)
+                     { jjCheckNAddStates(15, 17); }
+                  break;
+               case 12:
+                  if (curChar == 95)
+                     { jjCheckNAdd(11); }
+                  break;
+               case 15:
+                  if ((0x7fffffffffffffffL & l) != 0L)
+                     jjstateSet[jjnewStateCnt++] = 16;
+                  break;
+               case 17:
+                  if (curChar == 92)
+                     { jjCheckNAdd(18); }
+                  break;
+               case 18:
+                  if ((0x7fffffffffffffffL & l) != 0L)
+                     { jjCheckNAddTwoStates(18, 19); }
+                  break;
+               case 19:
+                  if (curChar == 92 && kind > 139)
+                     kind = 139;
+                  break;
+               case 23:
+                  if ((0x7fffffffffffffffL & l) != 0L)
+                     { jjAddStates(7, 9); }
+                  break;
+               case 26:
+                  if (curChar == 95)
+                     jjstateSet[jjnewStateCnt++] = 27;
+                  break;
+               case 29:
+                  if (curChar == 95)
+                     { jjCheckNAdd(30); }
+                  break;
+               case 30:
+                  if ((0x7e0000007eL & l) != 0L)
+                     { jjCheckNAddStates(23, 26); }
+                  break;
+               case 32:
+                  if (curChar == 95)
+                     { jjCheckNAdd(33); }
+                  break;
+               case 33:
+                  if ((0x7e0000007eL & l) != 0L)
+                     { jjCheckNAddStates(27, 29); }
+                  break;
+               case 35:
+                  if (curChar == 69)
+                     { jjCheckNAddStates(37, 39); }
+                  break;
+               case 38:
+                  if (curChar == 95)
+                     { jjCheckNAdd(37); }
+                  break;
+               case 41:
+                  if (curChar == 95)
+                     jjstateSet[jjnewStateCnt++] = 40;
+                  break;
+               case 42:
+                  if (curChar == 95)
+                     jjstateSet[jjnewStateCnt++] = 43;
+                  break;
+               case 46:
+                  if (curChar == 95)
+                     jjstateSet[jjnewStateCnt++] = 45;
+                  break;
+               case 47:
+                  if (curChar == 69)
+                     { jjCheckNAddStates(40, 42); }
+                  break;
+               case 50:
+                  if (curChar == 95)
+                     { jjCheckNAdd(49); }
+                  break;
+               case 53:
+                  if (curChar == 95)
+                     jjstateSet[jjnewStateCnt++] = 52;
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else
+      {
+         int i2 = (curChar & 0xff) >> 6;
+         long l2 = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 1:
+                  if ((jjbitVec0[i2] & l2) != 0L)
+                     { jjAddStates(10, 12); }
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      if (kind != 0x7fffffff)
+      {
+         jjmatchedKind = kind;
+         jjmatchedPos = curPos;
+         kind = 0x7fffffff;
+      }
+      ++curPos;
+      if ((i = jjnewStateCnt) == (startsAt = 54 - (jjnewStateCnt = startsAt)))
+         break;
+      try { curChar = input_stream.readChar(); }
+      catch(java.io.IOException e) { break; }
+   }
+   if (jjmatchedPos > strPos)
+      return curPos;
+
+   int toRet = Math.max(curPos, seenUpto);
+
+   if (curPos < toRet)
+      for (i = toRet - Math.min(curPos, seenUpto); i-- > 0; )
+         try { curChar = input_stream.readChar(); }
+         catch(java.io.IOException e) { throw new Error("Internal Error : Please send a bug report."); }
+
+   if (jjmatchedPos < strPos)
+   {
+      jjmatchedKind = strKind;
+      jjmatchedPos = strPos;
+   }
+   else if (jjmatchedPos == strPos && jjmatchedKind > strKind)
+      jjmatchedKind = strKind;
+
+   return toRet;
+}
+static final int[] jjnextStates = {
+   26, 27, 28, 42, 43, 44, 47, 22, 23, 24, 1, 2, 4, 7, 8, 12, 
+   11, 13, 18, 19, 26, 27, 28, 29, 30, 31, 34, 32, 33, 34, 42, 43, 
+   44, 47, 46, 45, 47, 36, 37, 39, 48, 49, 51, 
+};
+
+/** Token literal values. */
+public static final String[] jjstrLiteralImages = {
+"", null, null, null, null, null, null, null, null, null, null, null, null, 
+null, null, null, null, null, null, null, null, null, null, null, null, null, null, 
+null, null, null, null, null, null, null, null, null, null, null, null, null, null, 
+null, null, null, null, null, null, null, null, null, null, null, null, null, null, 
+null, null, null, null, null, null, null, null, null, null, null, null, null, null, 
+null, null, null, null, null, null, null, null, null, null, null, null, null, null, 
+null, null, null, null, null, null, null, null, null, null, null, null, null, null, 
+null, null, null, null, null, null, null, null, null, null, null, null, null, null, 
+null, null, null, null, null, null, null, null, null, null, null, null, null, null, 
+null, null, null, null, null, null, null, null, null, null, null, null, null, null, 
+null, null, null, "\52\52", "\52", "\57", "\53", "\55", "\46", "\75", "\57\75", 
+"\76\75", "\74\75", "\76", "\74", "\73", "\72", "\72\75", "\75\76", "\50", "\51", "\54", 
+"\47", "\174", "\74\76", "\56", "\75\75", };
+protected Token jjFillToken()
+{
+   final Token t;
+   final String curTokenImage;
+   final int beginLine;
+   final int endLine;
+   final int beginColumn;
+   final int endColumn;
+   String im = jjstrLiteralImages[jjmatchedKind];
+   curTokenImage = (im == null) ? input_stream.GetImage() : im;
+   beginLine = input_stream.getBeginLine();
+   beginColumn = input_stream.getBeginColumn();
+   endLine = input_stream.getEndLine();
+   endColumn = input_stream.getEndColumn();
+   t = Token.newToken(jjmatchedKind, curTokenImage);
+
+   t.beginLine = beginLine;
+   t.endLine = endLine;
+   t.beginColumn = beginColumn;
+   t.endColumn = endColumn;
+
+   return t;
+}
+
+int curLexState = 0;
+int defaultLexState = 0;
+int jjnewStateCnt;
+int jjround;
+int jjmatchedPos;
+int jjmatchedKind;
+
+/** Get the next Token. */
+public Token getNextToken() 
+{
+  Token specialToken = null;
+  Token matchedToken;
+  int curPos = 0;
+
+  EOFLoop :
+  for (;;)
+  {
+   try
+   {
+      curChar = input_stream.BeginToken();
+   }
+   catch(java.io.IOException e)
+   {
+      jjmatchedKind = 0;
+      jjmatchedPos = -1;
+      matchedToken = jjFillToken();
+      matchedToken.specialToken = specialToken;
+      return matchedToken;
+   }
+
+   jjmatchedKind = 0x7fffffff;
+   jjmatchedPos = 0;
+   curPos = jjMoveStringLiteralDfa0_0();
+   if (jjmatchedKind != 0x7fffffff)
+   {
+      if (jjmatchedPos + 1 < curPos)
+         input_stream.backup(curPos - jjmatchedPos - 1);
+      if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
+      {
+         matchedToken = jjFillToken();
+         matchedToken.specialToken = specialToken;
+         return matchedToken;
+      }
+      else
+      {
+         if ((jjtoSpecial[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
+         {
+            matchedToken = jjFillToken();
+            if (specialToken == null)
+               specialToken = matchedToken;
+            else
+            {
+               matchedToken.specialToken = specialToken;
+               specialToken = (specialToken.next = matchedToken);
+            }
+         }
+         continue EOFLoop;
+      }
+   }
+   int error_line = input_stream.getEndLine();
+   int error_column = input_stream.getEndColumn();
+   String error_after = null;
+   boolean EOFSeen = false;
+   try { input_stream.readChar(); input_stream.backup(1); }
+   catch (java.io.IOException e1) {
+      EOFSeen = true;
+      error_after = curPos <= 1 ? "" : input_stream.GetImage();
+      if (curChar == '\n' || curChar == '\r') {
+         error_line++;
+         error_column = 0;
+      }
+      else
+         error_column++;
+   }
+   if (!EOFSeen) {
+      input_stream.backup(1);
+      error_after = curPos <= 1 ? "" : input_stream.GetImage();
+   }
+   throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);
+  }
+}
+
+private void jjCheckNAdd(int state)
+{
+   if (jjrounds[state] != jjround)
+   {
+      jjstateSet[jjnewStateCnt++] = state;
+      jjrounds[state] = jjround;
+   }
+}
+private void jjAddStates(int start, int end)
+{
+   do {
+      jjstateSet[jjnewStateCnt++] = jjnextStates[start];
+   } while (start++ != end);
+}
+private void jjCheckNAddTwoStates(int state1, int state2)
+{
+   jjCheckNAdd(state1);
+   jjCheckNAdd(state2);
+}
+
+private void jjCheckNAddStates(int start, int end)
+{
+   do {
+      jjCheckNAdd(jjnextStates[start]);
+   } while (start++ != end);
+}
+
+    /** Constructor. */
+    public VhdlParserCoreTokenManager(SimpleCharStream stream){
+
+      if (SimpleCharStream.staticFlag)
+            throw new Error("ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.");
+
+    input_stream = stream;
+  }
+
+  /** Constructor. */
+  public VhdlParserCoreTokenManager (SimpleCharStream stream, int lexState){
+    ReInit(stream);
+    SwitchTo(lexState);
+  }
+
+  /** Reinitialise parser. */
+  public void ReInit(SimpleCharStream stream)
+  {
+    jjmatchedPos = jjnewStateCnt = 0;
+    curLexState = defaultLexState;
+    input_stream = stream;
+    ReInitRounds();
+  }
+
+  private void ReInitRounds()
+  {
+    int i;
+    jjround = 0x80000001;
+    for (i = 54; i-- > 0;)
+      jjrounds[i] = 0x80000000;
+  }
+
+  /** Reinitialise parser. */
+  public void ReInit(SimpleCharStream stream, int lexState)
+  {
+    ReInit(stream);
+    SwitchTo(lexState);
+  }
+
+  /** Switch to specified lex state. */
+  public void SwitchTo(int lexState)
+  {
+    if (lexState >= 1 || lexState < 0)
+      throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", TokenMgrError.INVALID_LEXICAL_STATE);
+    else
+      curLexState = lexState;
+  }
+
+/** Lexer state names. */
+public static final String[] lexStateNames = {
+   "DEFAULT",
+};
+static final long[] jjtoToken = {
+   0xffffffffffffff81L, 0xfffffffffffffL, 0x3fffffeb64L, 
+};
+static final long[] jjtoSkip = {
+   0x7eL, 0x0L, 0x0L, 
+};
+static final long[] jjtoSpecial = {
+   0x40L, 0x0L, 0x0L, 
+};
+    protected SimpleCharStream  input_stream;
+
+    private final int[] jjrounds = new int[54];
+    private final int[] jjstateSet = new int[2 * 54];
+
+    
+    protected char curChar;
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/core/launching/VDTErrorParser.java vdt/src/com/elphel/vdt/core/launching/VDTErrorParser.java
--- vdt-veditor/src/com/elphel/vdt/core/launching/VDTErrorParser.java	2016-06-24 10:29:40.840495962 -0600
+++ vdt/src/com/elphel/vdt/core/launching/VDTErrorParser.java	2016-06-24 10:29:40.816496628 -0600
@@ -1,450 +1,904 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-
-package net.sourceforge.veditor.builder;
-
-import java.io.File;
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-import net.sourceforge.veditor.VerilogPlugin;
-
-import org.eclipse.core.resources.IContainer;
-import org.eclipse.core.resources.IFile;
-import org.eclipse.core.resources.IMarker;
-import org.eclipse.core.resources.IProject;
-import org.eclipse.core.resources.IResource;
-import org.eclipse.core.resources.ResourcesPlugin;
-import org.eclipse.core.runtime.CoreException;
-import org.eclipse.core.runtime.IPath;
-import org.eclipse.core.runtime.Path;
-import org.eclipse.debug.ui.console.FileLink;
-import org.eclipse.jface.text.BadLocationException;
-import org.eclipse.ui.console.IPatternMatchListener;
-import org.eclipse.ui.console.PatternMatchEvent;
-import org.eclipse.ui.console.TextConsole;
-
-public class ErrorParser
-{
-	private static final String DEFAULT_ERROR_PARSER_REGEX =
-		"ModelSim"
-		+ "\n" + "[#|\\*].*Error: ([^\\(]*)\\(([0-9]*)\\): (.*)"		
-		+ "\n" + "[#|\\*].*Warning: ([^\\(]*)\\(([0-9]*)\\): (.*)"		
-		+ "\n" + ""
-		+ "\n" + "ModelSimSimulation"
-		+ "\n" + "[#|\\*] Break in ([^\\#]*) at ([^\\(#]*) line ([0-9]*)"
-		+ "\n" + ""
-		+ "\n" + "[#|\\*](.*)File: ([^\\#]*) Line: ([0-9]*)"
-		+ "\n" + "Cver"
-		+ "\n" + "\\*\\*(.*)\\(([0-9]+)\\) ERROR\\*\\* (.*)"
-		+ "\n" + "\\*\\*(.*)\\(([0-9]+)\\) WARN\\*\\* (.*)"
-		+ "\n" + "--(.*)\\(([0-9]+)\\) INFORM-- (.*)" 
-		+ "\n" + "Icarus Verilog"
-		+ "\n" + "(.*):([0-9]+): [a-z ]*error: (.*)"
-		+ "\n" + "(.*):([0-9]+): warning: (.*)"
-		+ "\n" + ""
-		+ "\n" + "FreeHDL"
-		+ "\n" + "(.*):([0-9]+): error: (.*)" 
-		+ "\n" + "(.*):([0-9]+): warning: (.*)" 
-		+ "\n" + "";
-	
-	
-	private static final String PREFERENCE_NAME = "ErrorParser";
-	private static ErrorParser[] parsers = null;
-	private static String previousCompiler = "";
-	
-	public static ErrorParser[] getParsers()
-	{
-		if(parsers==null) {
-			// first add the default parsers:
-			String[] stringsdefault = DEFAULT_ERROR_PARSER_REGEX.split("\n",-1);
-			List<String> stringsuser = VerilogPlugin.getPreferenceStrings(PREFERENCE_NAME);
-			
-			// remove user parsers with the same name as a default parser:
-			for (int i = 0; i < stringsuser.size(); i += 4) {
-				String username = stringsuser.get(i);
-				boolean found=false;
-				for (int j = 0; j < stringsdefault.length; j += 4) {
-					String defaultname = stringsdefault[j];
-					if(defaultname.equals(username)) found=true;
-				}
-				if(found) {
-					stringsuser.remove(i+3);
-					stringsuser.remove(i+2);
-					stringsuser.remove(i+1);
-					stringsuser.remove(i);
-					i-=4;
-				}
-			}
-		
-			parsers = new ErrorParser[stringsdefault.length/4  + stringsuser.size() / 4];
-			
-			for (int i = 0; i < stringsdefault.length; i += 4) {
-				String name = stringsdefault[i];
-				String err = stringsdefault[i + 1];
-				String warn = stringsdefault[i + 2];
-				String info = stringsdefault[i + 3];
-				ErrorParser parser = new ErrorParser(name);
-				parser.setRegex(err, warn, info);
-				parser.editable = false;
-				parsers[i/4] = parser;
-			}
-			
-			for (int i = 0; i < stringsuser.size(); i += 4)
-		{
-				String name = stringsuser.get(i).toString();
-				String err = stringsuser.get(i + 1).toString();
-				String warn = stringsuser.get(i + 2).toString();
-				String info = stringsuser.get(i + 3).toString();
-				ErrorParser parser = new ErrorParser(name);
-				parser.setRegex(err, warn, info);
-				parser.editable = true;
-				parsers[stringsdefault.length/4 + i/4] = parser;
-			}
-		}
-		return parsers;
-	}
-	
-	public static List<ErrorParser> getParserList()
-	{
-		ErrorParser[] parsers = getParsers();
-		List<ErrorParser> list = new ArrayList<ErrorParser>();
-		for (ErrorParser parser:parsers)
-			{
-			list.add(parser);
-		}
-		return list;
-	}
-		
-	public static void installParser(BuildConfig buildconfig, IProject proj)
-		{
-		String compiler = buildconfig.getParser();
-		ErrorParser[] parsers = getParsers();
-		for (ErrorParser parse:parsers)
-			{
-			if (parse.getCompilerName().equals(compiler))
-			{
-				parse.project = proj;
-				parse.buildConfig=buildconfig;
-			}
-		}
-		
-		if(!compiler.equals(previousCompiler)) {
-			for (ErrorParser parse:parsers)
-			{
-				if (parse.getCompilerName().equals(compiler))
-				{
-					VerilogPlugin.addPatternMatchListener(parse.errParser);
-					VerilogPlugin.addPatternMatchListener(parse.warnParser);
-					VerilogPlugin.addPatternMatchListener(parse.infoParser);
-	}
-				if (parse.getCompilerName().equals(previousCompiler))
-	{
-					VerilogPlugin.removePatternMatchListener(parse.errParser);
-					VerilogPlugin.removePatternMatchListener(parse.warnParser);
-					VerilogPlugin.removePatternMatchListener(parse.infoParser);
-				}
-			}
-			previousCompiler = compiler;
-		}
-	}
-	
-	public static void setParsers(ErrorParser[] parsers)
-	{
-		List<String> strings = new ArrayList<String>();
-		for (int i = 0; i < parsers.length; i++)
-		{
-			if(!parsers[i].isEditable()) continue;
-			strings.add(parsers[i].compilerName);
-			strings.add(parsers[i].errRegex);
-			strings.add(parsers[i].warnRegex);
-			strings.add(parsers[i].infoRegex);
-		}
-		VerilogPlugin.setPreference(PREFERENCE_NAME, strings);
-		parsers = null;
-	}
-	
-	public static void setParserList(List<ErrorParser> list)
-	{
-		List<String> strings = new ArrayList<String>();
-		Iterator<ErrorParser> i = list.iterator();
-		while(i.hasNext())
-		{
-			ErrorParser parser = (ErrorParser)i.next();
-			if(!parser.isEditable()) continue;
-			strings.add(parser.compilerName);
-			strings.add(parser.errRegex);
-			strings.add(parser.warnRegex);
-			strings.add(parser.infoRegex);
-		}
-		VerilogPlugin.setPreference(PREFERENCE_NAME, strings);
-		parsers = null;
-	}
-	
-	public static void setDefaultParsers()
-	{
-		VerilogPlugin.setDefaultPreference(PREFERENCE_NAME);
-		parsers = null;
-	}
-
-	private IProject project;
-	private BuildConfig buildConfig;
-	private String compilerName;
-	private String errRegex;
-	private String warnRegex;
-	private String infoRegex;
-	private boolean editable;
-	ConsoleParser errParser;
-	ConsoleParser warnParser;
-	ConsoleParser infoParser;
-
-	public ErrorParser(String compilerName)
-	{
-		this.compilerName = compilerName;
-		editable = true;
-	}
-	
-	public String getCompilerName()
-	{
-		return compilerName;
-	}
-	
-	public boolean isEditable()
-	{
-		return editable;
-	}
-	
-	public void setRegex(String errRegex, String warnRegex, String infoRegex)
-	{
-		this.errRegex = errRegex;
-		this.warnRegex = warnRegex;
-		this.infoRegex = infoRegex;
-		errParser = new ConsoleParser(errRegex, IMarker.SEVERITY_ERROR);
-		warnParser = new ConsoleParser(warnRegex, IMarker.SEVERITY_WARNING);
-		infoParser = new ConsoleParser(infoRegex, IMarker.SEVERITY_INFO);
-	}
-	public void setRegex(int num, String regex)
-	{
-		switch(num)
-		{
-			case 0:
-				errRegex = regex;
-				break;
-			case 1:
-				warnRegex = regex;
-				break;
-			case 2:
-				infoRegex = regex;
-				break;
-		}
-	}
-	public String getErrorRegex()
-	{
-		return errRegex;
-	}
-	public String getWarningRegex()
-	{
-		return warnRegex;
-	}
-	public String getInfoRegex()
-	{
-		return infoRegex;
-	}
-	
-	private void reportMissingFile(String filename){
-		String message = new String();
-		message=String.format("\"%s\" is not found in the project. MS Windows users, check filename case!!!", filename);			
-		try{
-			IMarker marker=project.createMarker("net.sourceforge.veditor.builderproblemmarker");
-			marker.setAttribute(IMarker.SEVERITY, IMarker.SEVERITY_ERROR);			
-			marker.setAttribute(IMarker.MESSAGE, message);
-		}
-		catch (CoreException e)
-		{
-		}		
-	}
-
-	private void setProblemMarker(String filename, int level, int lineNumber, String msg)
-	{
-		IResource file = getFile(filename);
-		if (file != null && lineNumber > 0){
-			VerilogPlugin.setExternalProblemMarker(file, level, lineNumber, msg);
-		}
-		else{
-			reportMissingFile(filename);
-		}
-	}
-
-
-	private IFile getFileRecursive(IContainer cont, IPath path) {
-		try {
-			for(IResource res: cont.members()) {
-				if(res instanceof IContainer) {
-					IFile result = getFileRecursive((IContainer)res,path);
-					if(result!=null) return result;
-				} else if(res instanceof IFile) {					
-					IPath res_path = ((IFile)res).getLocation();					
-					if(res_path.equals(path)) 
-						return (IFile)res;
-		}
-		}
-		} catch (CoreException e) {
-		}
-		return null;
-	}
-	
-	// Christian R. aka supachris from http://www.mikrocontroller.net/topic/264288
-	// mg
-	private IResource getFile(String filename) {
-		File TestFile = new File(filename);
-		IResource test;
-		if(TestFile.isAbsolute())
-		{
-			IContainer project = ResourcesPlugin.getWorkspace().getRoot();
-			IPath projectPath = Path.fromOSString(TestFile.getAbsolutePath());
-			test = getFileRecursive(project, projectPath);
-		}
-		else
-	{
-		IPath projectPath = project.getLocation().append(buildConfig.getWorkFolder());
-		projectPath = projectPath.append(filename);	
-			IContainer project = ResourcesPlugin.getWorkspace().getRoot();
-			test = getFileRecursive(project,projectPath);
-		}
-
-		return test;
-	}
-	
-	public static class ParseErrorString {
-		private String regex;
-		// results of parse(String string);
-		public String filename;
-		public int linenr;
-		public String message;
-		public int startinmatchedstring;
-		public int endinmatchedstring;
-		
-		public ParseErrorString(String regexpr) {
-			regex = regexpr;
-		}
-
-		/**
-		 * Tries to parse string using regex
-		 * @return boolean: parse succeeded
-		 */
-		public boolean parse(String string) {
-			Pattern errPattern = Pattern.compile(regex);
-			Matcher m = errPattern.matcher(string);
-			if (!m.matches()) return false;
-
-			int groupCount=m.groupCount();
-			if(groupCount < 3) return false;
-			
-			int linenrindex = -1;
-		
-			for(int i=2;i<=groupCount;i++) {
-				String group = m.group(i);
-				try {
-					linenr = Integer.parseInt(group);
-					linenrindex = i;
-				}
-				catch (NumberFormatException e) {
-				}
-			}
-			if(linenrindex==-1) return false;
-			
-			// filename is now at linenrindex-1
-			filename = m.group(linenrindex-1);
-			
-			// now search for the longest string to capture the message:
-			int length_win=-1;
-			int messageindex=-1;
-			for(int i=1;i<=groupCount;i++) {
-				if(i==linenrindex-1) continue;
-				if(i==linenrindex) continue;
-				String group = m.group(i);
-				if(group.length()>length_win) {
-					length_win = group.length();
-					messageindex = i;
-				}
-			}
-			if(messageindex==-1) return false;
-			
-			message = m.group(messageindex);
-			startinmatchedstring = m.start(linenrindex-1);
-			endinmatchedstring = m.end(linenrindex);
-			
-			return true;
-		}
-	}
-	
-	public class ConsoleParser implements IPatternMatchListener {
-		private String regex;
-		private int problemlevel;
-		
-		ConsoleParser(String regexpr, int level) {
-			regex = regexpr;
-			problemlevel = level;
-		}
-		
-		public int getCompilerFlags() {
-			return 0;
-		}
-	
-		public String getLineQualifier() {
-			return null;
-		}
-	
-		public String getPattern() {
-			return regex;
-		}
-
-		public void connect(TextConsole console) {}
-		public void disconnect() {}
-	
-		public void matchFound(PatternMatchEvent event) {
-			int offset = event.getOffset();
-			int length = event.getLength();
-			
-			Object object = event.getSource();
-			if(! (object instanceof TextConsole)) return;
-			TextConsole console = (TextConsole)object;
-			
-			String consolecontent = console.getDocument().get();
-			String matchedstring = consolecontent.substring(offset, offset+length);
-			
-			ParseErrorString parser = new ParseErrorString(regex);
-			boolean success = parser.parse(matchedstring);
-			if (!success) return;
-				
-			setProblemMarker(parser.filename, problemlevel, parser.linenr, parser.message);			
-			
-			IResource resource = getFile(parser.filename);
-			if(resource instanceof IFile) {
-				IFile file = (IFile) resource;
-				FileLink hyperlink = new FileLink(file,null,-1,-1,parser.linenr);
-				try {
-					console.addHyperlink(hyperlink, offset+parser.startinmatchedstring,
-							parser.endinmatchedstring-parser.startinmatchedstring+1);
-				} catch (BadLocationException e) {
-				}
-			} else {
-				//VerilogPlugin.println("Not a filename!");
-			}
-		}
-	}
-
-}
-
-
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+
+package com.elphel.vdt.core.launching;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.util.NavigableSet;
+import java.util.concurrent.ConcurrentSkipListSet;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import com.elphel.vdt.VerilogUtils;
+import com.elphel.vdt.ui.variables.SelectedResourceManager;
+import com.elphel.vdt.veditor.VerilogPlugin;
+import com.elphel.vdt.veditor.parser.OutlineDatabase;
+import com.elphel.vdt.veditor.parser.OutlineElement;
+import com.elphel.vdt.veditor.preference.PreferenceStrings;
+
+import org.eclipse.core.resources.IContainer;
+import org.eclipse.core.resources.IFile;
+import org.eclipse.core.resources.IMarker;
+import org.eclipse.core.resources.IProject;
+import org.eclipse.core.resources.IResource;
+import org.eclipse.core.resources.ResourcesPlugin;
+import org.eclipse.core.runtime.CoreException;
+import org.eclipse.core.runtime.IPath;
+import org.eclipse.core.runtime.Path;
+import org.eclipse.debug.core.model.IProcess;
+import org.eclipse.debug.ui.DebugUITools;
+import org.eclipse.debug.ui.console.FileLink;
+import org.eclipse.jface.text.BadLocationException;
+import org.eclipse.jface.text.IDocument;
+import org.eclipse.ui.console.IOConsole;
+import org.eclipse.ui.console.IPatternMatchListener;
+import org.eclipse.ui.console.PatternMatchEvent;
+import org.eclipse.ui.console.TextConsole;
+
+public class VDTErrorParser {
+	private static final String REFERENCE_PATTERN = "@\\{(.*)\\}@";
+	public static final String SUPPRESS_WARNINGS = "SuppressWarnings"; 
+	public static final String SUPPRESS_THIS_WARNING = "SuppressThisWarning"; 
+	private IProject project;
+	private String workingDirectory;
+	private String toolName;
+	private String errRegex;
+	private String warnRegex;
+	private String infoRegex;
+	private String instCaptureRegex; // RegEx to extract hierarchical name form
+										// tool output (may need extra "()"
+										// around)
+	private String instSeparatorRegex;// RegEx to split name segments (i.e.
+										// "\.")
+	private String instSuffixRegex; // RegEx to remove tool-generated name
+									// suffixes, like "_reg|_suffix2|suffix3"
+	private ConsoleParser errParser;
+	private ConsoleParser warnParser;
+	private ConsoleParser infoParser;
+	private IProcess process;
+	private IOConsole iCons;
+	private ConcurrentSkipListSet<String> messageLines;
+	private ConcurrentSkipListSet<Integer> linesToRemove;
+	private AtomicInteger numListeners;
+
+	public VDTErrorParser() {
+		errParser = null;
+		warnRegex = null;
+		infoRegex = null;
+		instCaptureRegex = null;
+		instSeparatorRegex = null;
+		instSuffixRegex = null;
+		messageLines = new ConcurrentSkipListSet<String>();
+		linesToRemove = new ConcurrentSkipListSet<Integer>();
+	}
+
+	public VDTErrorParser(
+			// never used
+			VDTRunnerConfiguration configuration, IProcess process,
+			String patternErrors, String patternWarnings, String patternInfo,
+			String instCapture, String instSeparator, String instSuffix) {
+		parserSetup(configuration, process, patternErrors, patternWarnings,
+				patternInfo, instCapture, instSeparator, instSuffix);
+	}
+
+	/* 1 - set up OK, 0 - no console, -1 - error */
+	public void parserSetup(VDTRunnerConfiguration configuration,
+			IProcess process, String patternErrors, String patternWarnings,
+			String patternInfo, String instCapture, String instSeparator,
+			String instSuffix) {
+		iCons = (IOConsole) DebugUITools.getConsole(process); /*
+															 * had non-null
+															 * fPatternMatcher ,
+															 * fType=
+															 * "org.eclipse.debug.ui.ProcessConsoleType"
+															 */
+		if (iCons == null) {
+			System.out
+					.println("Could not get a console for the specified process");
+		}
+		if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_PARSING)) {
+			System.out.println("Setting console parser for " + iCons.getName());
+		}
+		/* If listeners are not null - disconnect them */
+		removePatternMatchListeners();
+		// disconnect listeners if they are not null and console is not null
+		// this.workingDirectory=workingDirectory;
+		this.workingDirectory = configuration.getWorkingDirectory();
+		this.toolName = configuration.getToolName();
+		// this.errRegex= configuration.getPatternErrors();
+		// this.warnRegex= configuration.getPatternWarnings();
+		// this.infoRegex= configuration.getPatternInfo();
+		this.errRegex = patternErrors;
+		this.warnRegex = patternWarnings;
+		this.infoRegex = patternInfo;
+		this.instCaptureRegex = instCapture;
+		this.instSeparatorRegex = instSeparator;
+		if (this.instSeparatorRegex==null) this.instSeparatorRegex="\\.";
+		this.instSuffixRegex = instSuffix;
+
+		this.project = null;
+		String thisProjectPath = configuration.getProjectPath();
+		if (thisProjectPath == null) {
+			System.out.println("This project is null");
+			return;
+		}
+		IProject rp_projects[] = ResourcesPlugin.getWorkspace().getRoot()
+				.getProjects();
+		if (rp_projects != null)
+			for (int i = 0; i < rp_projects.length; i++) {
+				if (thisProjectPath.equals(rp_projects[i].getLocation()
+						.toOSString())) {
+					this.project = rp_projects[i];
+					break;
+				}
+			}
+		else {
+			System.out.println("No projectas found in the workspace");
+			return;
+		}
+		if (this.project == null) {
+			System.out.println("This project is not found in the workspace");
+			return;
+		}
+		numListeners = new AtomicInteger(0);
+		addPatternMatchListeners();
+		messageLines.clear();
+		linesToRemove.clear();
+	}
+
+	private void removePatternMatchListeners() {
+		if (iCons != null) {
+			if (errParser != null)
+				iCons.removePatternMatchListener(errParser);
+			if (warnParser != null)
+				iCons.removePatternMatchListener(warnParser);
+			if (infoParser != null)
+				iCons.removePatternMatchListener(infoParser);
+		}
+	}
+
+	private void addPatternMatchListeners() {
+		if (iCons != null) {
+			if (errRegex != null) {
+				errParser = new ConsoleParser(errRegex, IMarker.SEVERITY_ERROR);
+				if (errParser != null)
+					iCons.addPatternMatchListener(errParser);
+			} else
+				errParser = null;
+
+			if (warnRegex != null) {
+				warnParser = new ConsoleParser(warnRegex,
+						IMarker.SEVERITY_WARNING);
+				if (warnParser != null)
+					iCons.addPatternMatchListener(warnParser);
+			} else
+				errParser = null;
+			if (infoRegex != null) {
+				infoParser = new ConsoleParser(infoRegex, IMarker.SEVERITY_INFO);
+				if (infoParser != null)
+					iCons.addPatternMatchListener(infoParser);
+			} else
+				errParser = null;
+		}
+	}
+
+	// /getWorkingDirectory
+	private void reportMissingFile(String filename) {
+		String message = new String();
+		message = String
+				.format("\"%s\" is not found in the project.", filename);
+		if (!VerilogPlugin
+				.getPreferenceBoolean(PreferenceStrings.WARNING_MISSING_ABSOLUTE_RESOURCE)
+				&& (filename.substring(0, 1).equals("/")))
+			return;
+		try {
+			IMarker marker = project
+					.createMarker("com.elphel.vdt.veditor.builderproblemmarker");
+			if (filename.substring(0, 1).equals("/")) // absolute path (like
+														// Xilinx library on
+														// remote server )
+				marker.setAttribute(IMarker.SEVERITY, IMarker.SEVERITY_INFO);
+			else
+				marker.setAttribute(IMarker.SEVERITY, IMarker.SEVERITY_ERROR);
+			marker.setAttribute(IMarker.MESSAGE, message);
+			marker.setAttribute(IMarker.SOURCE_ID, "VDTErrorParser");
+			marker.setAttribute(IMarker.LOCATION, "VDTErrorParser"); // Shows in
+																		// "location"
+																		// field
+		} catch (CoreException e) {
+		}
+	}
+
+	// Line number is negative for wrong format, and 0 for non-file problems
+/*	
+	private void setProblemMarker(String filename, int level, int lineNumber, String msg) {
+		IResource file = getFile(filename);
+		setProblemMarker(file, level, lineNumber, msg);
+	}
+	private void setProblemMarker(IResource file, int level, int lineNumber, String msg) {
+*/	
+	private void setProblemMarker(IResource file, int level, int lineNumber, String msg) {
+		VerilogPlugin.setExternalProblemMarker(file, level, lineNumber,  toolName + ": " + msg);
+	}
+	private void setProblemMarker(String filename, int level, int lineNumber, String msg) {
+		IResource file = getFile(filename);
+		if (file != null && lineNumber > 0) {
+			setProblemMarker(file, level, lineNumber, msg);
+//			VerilogPlugin.setExternalProblemMarker(file, level, lineNumber,
+//					toolName + ": " + msg);
+			if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_PARSING)) {
+				System.out.println("setProblemMarker("+filename+","+level+","+lineNumber+":"+msg+") -> success");
+			}
+			// System.out.println(
+			// "setExternalProblemMarker("+filename+", "+level+", "+lineNumber+", "+msg+")");
+		} else if (lineNumber == 0) {
+			try {
+				IMarker marker = project
+						.createMarker("com.elphel.vdt.veditor.builderproblemmarker");
+				marker.setAttribute(IMarker.SEVERITY, level);
+
+				marker.setAttribute(IMarker.MESSAGE, msg);
+				marker.setAttribute(IMarker.SOURCE_ID, "VDTErrorParser");
+				// marker.setAttribute(IMarker.LOCATION, toolName); // Shows in
+				// "location" field
+				marker.setAttribute(IMarker.LOCATION, filename); // Shows in
+				// "location"
+				// field
+			} catch (CoreException e) {
+			}
+
+		} else {
+			reportMissingFile(filename);
+			if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_PARSING)) {
+				System.out.println("setProblemMarker("+filename+","+level+","+lineNumber+":"+msg+") -> failure");
+			}
+		}
+	}
+
+	private IFile getFileRecursive(IContainer cont, IPath path) {
+		try {
+			for (IResource res : cont.members()) {
+				if (res instanceof IContainer) {
+					IFile result = getFileRecursive((IContainer) res, path);
+					if (result != null)
+						return result;
+				} else if (res instanceof IFile) {
+					IPath res_path = ((IFile) res).getLocation();
+					if (res_path==null ){
+//						System.out.println("getFileRecursive(...,"+path+") failed, res_path="+res_path+" res="+res);
+						return null;
+					}
+					if (res_path.equals(path))
+						return (IFile) res;
+				}
+			}
+		} catch (CoreException e) {
+		}
+		return null;
+	}
+
+	// Christian R. aka supachris from
+	// http://www.mikrocontroller.net/topic/264288
+	// mg
+
+	private IResource getFile(String filename) {
+		File TestFile = new File(filename);
+		IResource test = null;
+		if (TestFile.isAbsolute()) {
+			IContainer project = ResourcesPlugin.getWorkspace().getRoot();
+			IPath projectPath = Path.fromOSString(TestFile.getAbsolutePath());
+			test = getFileRecursive(project, projectPath);
+		} else {
+			/* TODO: Add build folder */
+			IPath projectPath = project.getLocation();
+			projectPath = projectPath.append(filename);
+			IContainer project = ResourcesPlugin.getWorkspace().getRoot();
+			test = getFileRecursive(project, projectPath);
+		}
+		return test;
+	}
+
+	public static class ParseErrorString {
+		private String regex;
+		// results of parse(String string);
+		public String filename;
+		public int linenr;
+		public String message;
+		public int startinmatchedstring;
+		public int endinmatchedstring;
+
+		public ParseErrorString(String regexpr) {
+			// System.out.println("VDT New ParseErrorString(>"+regexpr+"<");
+			// Only errors, no warnings?
+			// VDT New ParseErrorString(>(.*):([0-9]+): [a-z ]*error: (.*)<
+			// for each later:
+			// matchFound(): [2] 103136:88
+			regex = regexpr;
+		}
+
+		/**
+		 * Tries to parse string using regex
+		 * 
+		 * @return boolean: parse succeeded
+		 */
+		public boolean parse(String string) {
+//			System.out.println("...VDTErrorParser.parse("+string+")");
+			Pattern errPattern = Pattern.compile(regex);
+			Matcher m = errPattern.matcher(string);
+			if (!m.matches())
+				return false;
+
+			int groupCount = m.groupCount();
+			if (groupCount < 3)
+				return false;
+			if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_PARSING)) {
+				System.out.println("---VDTErrorParser.parse("+string+")+, count="+groupCount);
+				for (int i = 0; i <= groupCount; i++) {
+					String group = m.group(i);
+					System.out.println("Group("+i+") = "+group);
+				}
+			}
+			int linenrindex = -1;
+//			int skipGroup=0;
+
+			for (int i = 2; i <= groupCount; i++) {
+				String group = m.group(i);
+				try {
+					linenr = Integer.parseInt(group);
+					linenrindex = i;
+				} catch (NumberFormatException e) {
+				}
+			}
+			if (linenrindex == -1)
+				return false;
+
+			// filename is now at linenrindex-1
+			filename = m.group(linenrindex - 1);
+
+			// now search for the longest string to capture the message:
+			int length_win = -1;
+			int messageindex = -1;
+			for (int i = 1; i <= groupCount; i++) {
+				if (i == linenrindex - 1)
+					continue;
+				if (i == linenrindex)
+					continue;
+				String group = m.group(i);
+				if (group.length() > length_win) {
+					length_win = group.length();
+					messageindex = i;
+				}
+			}
+			if (messageindex == -1)
+				return false;
+
+			message = m.group(messageindex); /* error message (w/o "error") */
+			startinmatchedstring = m.start(linenrindex - 1); /* start of link */
+			endinmatchedstring = m.end(linenrindex); /* end of link */
+			if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_PARSING)) {
+				System.out.println("......message_index="+messageindex+", ("+startinmatchedstring+","+endinmatchedstring+")="+
+						m.group(linenrindex - 1)+ "->"+message);
+			}
+
+			return true;
+		}
+	}
+
+	public class ConsoleParser implements IPatternMatchListener {
+		private String regex;
+		private int problemlevel;
+		private Pattern refPattern;
+		private Pattern instCapturePattern; // RegEx to extract hierarchical
+											// name form tool output (may need
+											// extra "()" around)
+		private Pattern instSeparatorPattern;// RegEx to split name segments
+												// (i.e. "\.")
+		private Pattern instSuffixPattern; // RegEx to remove tool-generated
+											// name suffixes, like
+											// "_reg|_suffix2|suffix3"
+		private OutlineElement topModule;
+
+		ConsoleParser(String regexpr, int level) {
+			regex = regexpr;
+			problemlevel = level;
+			refPattern = Pattern.compile(REFERENCE_PATTERN); // TODO: Remove
+			if ((instCaptureRegex == null) || (instCaptureRegex.length() == 0)) {
+				// Instance pattern not used, skip parsing attempts
+				instCapturePattern = null;
+				instSeparatorPattern = null;
+				instSuffixPattern = null;
+				return;
+			}
+			try {
+				instCapturePattern = Pattern.compile(instCaptureRegex);
+			} catch (Exception e) {
+				System.out.println("ConsoleParser(): Bad instCaptureRegex '"
+						+ instCaptureRegex + "'");
+				instCapturePattern = null;
+			}
+			try {
+				instSeparatorPattern = Pattern.compile(instSeparatorRegex);
+			} catch (Exception e) {
+				System.out.println("ConsoleParser(): Bad instSeparatorRegex '"
+						+ instSeparatorRegex + "'");
+				instCapturePattern = null;
+				instSeparatorPattern = null;
+			}
+			if ((instSuffixRegex == null) || (instSuffixRegex.length() == 0)) {
+				instSuffixPattern = null; // not an error
+			} else {
+				try {
+					instSuffixPattern = Pattern.compile(instSuffixRegex);
+					// System.out.println("VDT New ConsoleParser(>"+regex+"<, "+level);
+					// // should be no sleep here - will loose listeners
+				} catch (Exception e) {
+					System.out.println("ConsoleParser(): Bad instSuffixRegex '"
+							+ instSuffixRegex + "'");
+					instSuffixPattern = null;
+				}
+			}
+	        IResource resource = SelectedResourceManager.getDefault().getChosenVerilogFile();
+	        topModule=null;
+	        if ((resource != null) && (resource.getType() == IResource.FILE)) {
+	        	String[] outlineElementsNames= VerilogUtils.getTopModuleNames((IFile)resource);
+	        	if ((outlineElementsNames!=null) && (outlineElementsNames.length>0)) {
+					OutlineDatabase database = OutlineDatabase.getProjectsDatabase(project);
+					OutlineElement[] allTop=database.findTopLevelElements(outlineElementsNames[0],true);
+					if (allTop.length>0) topModule=allTop[0];
+					if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_PARSING)) {
+						System.out.println("ConsoleParser(): topModule="+topModule.getName());
+					}
+	        	}
+	        }
+		}
+
+		public int getCompilerFlags() {
+			return 0;
+		}
+
+		public String getLineQualifier() {
+			return null;
+		}
+
+		public String getPattern() {
+			return regex;
+		}
+
+		public void connect(TextConsole console) {
+			numListeners.incrementAndGet();
+
+			// System.out.println("VDT connect "+problemlevel); // should be no
+			// sleep here - will loose listeners
+		}
+
+		public void disconnect() {
+			// System.out.println("VDT disconnect"+problemlevel);
+			if (numListeners.decrementAndGet() == 0) { /* Last disconnected */
+				updateConsoleContents();
+			}
+		}
+
+		private void updateConsoleContents() {
+			/*
+			 * Remove some of the problem lines. TODO: add on/off, verify
+			 * console has no data lost
+			 */
+			NavigableSet<Integer> ns = linesToRemove.descendingSet();
+			// Iterator<Integer> iterator =ns.iterator();
+			for (Integer line : ns) {
+				if (VerilogPlugin
+						.getPreferenceBoolean(PreferenceStrings.DEBUG_PARSING))
+					System.out.println("Line to remove: " + line);
+			}
+			IDocument consoleDocument = iCons.getDocument();
+			/* Does not work */
+			/*
+			 * for (Integer line : ns){ try { consoleDocument.replace(
+			 * consoleDocument.getLineOffset(line),
+			 * consoleDocument.getLineLength(line), ""); } catch
+			 * (BadLocationException e) { } }
+			 */
+		}
+
+		private String readResourceString(IFile file, int lineNo) {
+			if (lineNo < 1)
+				return null;
+			BufferedReader br;
+			try {
+				br = new BufferedReader(new InputStreamReader(
+						file.getContents()));
+			} catch (CoreException e) {
+				return null;
+			}
+			for (int i = 1; i < lineNo; i++) {
+				try {
+					br.readLine();
+				} catch (IOException e) {
+					return null; // no need to close, EOF is not an error
+				}
+			}
+			try {
+				String line=br.readLine();
+				br.close();
+				return line;
+			} catch (IOException e) {
+				return null;
+			}
+		}
+
+
+		
+		
+		private void addLineToRemove(IDocument consoleDocument, int offset) {
+			try {
+				linesToRemove.add(new Integer(consoleDocument.getLineOfOffset(offset)));
+			} catch (BadLocationException e) {
+			}
+
+		}
+
+		public void matchFound(PatternMatchEvent event) {
+			int offset = event.getOffset();
+			int length = event.getLength();
+			//				System.out.println("matchFound(): ["+problemlevel+"] "+offset+":"+length);
+			Object object = event.getSource();
+			if(! (object instanceof TextConsole)) return;
+			TextConsole console = (TextConsole)object;
+			IDocument consoleDocument=console.getDocument();
+
+			String consolecontent = consoleDocument.get();
+			String matchedstring = consolecontent.substring(offset, offset+length); /* matchstring - full matched string in console */
+
+			ParseErrorString parser = new ParseErrorString(regex);
+			boolean success = parser.parse(matchedstring);
+			if (!success) return;
+			boolean newMesssage = messageLines.add(matchedstring);
+			if (!newMesssage){
+				addLineToRemove(consoleDocument,offset);
+				if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_PARSING))
+					System.out.println("Duplicate problem line: "+matchedstring);
+				return;
+			}
+			Matcher matcher0=refPattern.matcher(matchedstring);
+			// just for debugging				
+			String instCapture=instCaptureRegex;
+			String instSeparator=instSeparatorRegex;
+			String instSuffix=instSuffixRegex;
+			String patternErrors=errRegex;
+			Matcher matcher=null;
+			if (instCapturePattern!=null) try {
+				matcher=instCapturePattern.matcher(matchedstring);
+			} catch (Exception e ){
+				//					System.out.println("ConsoleParser.matchFound(): failed to create matcher with instCapturePattern");
+			}
+			// If line number recognized - skip parsing instance (filename with dot is recognized as a name)
+			if (parser.linenr!=0){
+				matcher=null;
+			}
+			if ((matcher!=null) && matcher.find()){
+				String ref=matcher.group(1);
+				if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_PARSING)) {
+					System.out.println("matchFound(): "+ref+" start="+matcher.start(1));
+				}
+				if (matchedstring.contains("dq_block")){
+					System.out.println("debug this");
+				}
+				
+				boolean startFromInstance=ref.startsWith("#");
+				if (startFromInstance) ref=ref.substring(1);
+				int lastSegmentStart=ref.lastIndexOf(".")+1;
+				int lastSegmentEnd=  ref.lastIndexOf("[");
+				if (lastSegmentEnd<=lastSegmentStart) lastSegmentEnd=ref.length();
+				int portSepIndex=ref.indexOf(":",lastSegmentStart);
+				boolean lastIsPort=(portSepIndex>0) && (portSepIndex<(lastSegmentEnd-1));
+				if (lastIsPort) ref=ref.substring(0,portSepIndex)+"."+ref.substring(portSepIndex+1);
+
+				String [] refSegments=ref.split(instSeparatorRegex);
+
+				int [] refIndices= new int [refSegments.length];
+				refIndices[0]=matcher.start(1);
+				// First - top module name, then instances, last may be wire/reg
+				Matcher matchSep=instSeparatorPattern.matcher(ref);
+				for (int i=1;i<refSegments.length;i++){
+					matchSep.find();
+					refIndices[i]=refIndices[0]+matchSep.end();
+				}
+				// Remove bit selection 
+				for (int i=0;i<refSegments.length;i++){
+					if (refSegments[i].contains("[")){
+						refSegments[i]=refSegments[i].substring(0,refSegments[i].indexOf("["));
+					}
+				}
+				OutlineDatabase database = OutlineDatabase.getProjectsDatabase(project);
+				OutlineElement de;
+				OutlineElement [] elements=new OutlineElement [refSegments.length];
+				for (int i=0;i<refSegments.length;i++)
+					elements[i]=null;
+				boolean firstSegment=true; // actual list may start with the named block that is not supported in the database
+				for (int i=0;i<refSegments.length;i++){
+
+					try {
+						if (firstSegment) { //i==0){
+							if (startFromInstance) {
+								elements[i]=null;
+								OutlineElement[] instances=database.getChildInstances(topModule, refSegments[i],0);
+								if ((instances!=null) && (instances.length>0)) {
+									elements[i]=instances[0]; // first matched instance with this name (may be many !
+								}
+								instances=null;
+								if ((elements[i]==null) && (instSuffixPattern!=null)){
+									instances=database.getChildInstances(topModule, refSegments[i],1);
+									for (OutlineElement oe:instances){
+										if ((oe!=null) && instSuffixPattern.matcher(refSegments[i].substring(oe.getName().length())).matches()){
+											if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_PARSING)) {
+												System.out.println("Suffix match found for "+refSegments[i]+" (instance), using "+oe.getName());
+											}
+											refSegments[i]=oe.getName();
+											elements[i]=oe;
+											firstSegment=false;
+											break;
+										}
+									}
+								}
+								if (elements[i]==null){
+									// Now try "wild guess" - any suffix OK
+									if (instances==null) { // not already calculated
+										instances=database.getChildInstances(topModule, refSegments[i],1);
+									}
+									for (OutlineElement oe:elements) if (oe!=null){
+										if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_PARSING)) {
+											System.out.println("Suffix match NOT found for "+refSegments[i]+" (instance), anyway using "+oe.getName());
+										}
+										refSegments[i]=oe.getName();
+										elements[i]=oe;
+										firstSegment=false;
+										break;
+									}
+								}
+								if (elements[i]==null){
+									// debug problem, possibly there is a generate named block (not currently supported in the database)
+									// need to remove the first segment and try again
+//									if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_PARSING)) {
+										System.out.println(matchedstring);
+										System.out.println("Failed to find instance named #"+refSegments[i]+" for the segnment "+i+", assuming named block");
+//									}
+								} else {
+									firstSegment=false;
+								}
+							} else {
+								elements[i]=null;
+								OutlineElement[] allTop=database.findTopLevelElements(refSegments[i],true);
+								if ((allTop!=null) && (allTop.length>0)) {
+									elements[i]=allTop[0]; // find top level modules with specified name
+								}
+								allTop=null;
+								if (elements[i]==null){
+									if (instSuffixPattern!=null) {
+										allTop=database.findTopLevelElements(refSegments[i],false,true);
+										for (OutlineElement oe:allTop){
+											if ((oe!=null) && refSegments[i].startsWith(oe.getName())){
+												if (instSuffixPattern.matcher(refSegments[i].substring(oe.getName().length())).matches()){
+													if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_PARSING)) {
+														System.out.println("Suffix match found for "+refSegments[i]+" (module), using "+oe.getName());
+													}
+													refSegments[i]=oe.getName();
+													elements[i]=oe;
+													firstSegment=false;
+													break;
+												}
+											}
+										}
+									}
+								}
+								if (elements[i]==null){
+									// Now try "wild guess" - any suffix OK
+									if (allTop==null) { // not already calculated
+										allTop=database.findTopLevelElements(refSegments[i],true,true); // TODO - use already found?
+									}
+									for (OutlineElement oe:allTop){
+										if ((oe!=null) && refSegments[i].startsWith(oe.getName())){
+											if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_PARSING)) {
+												System.out.println("Suffix match NOT found for "+refSegments[i]+" (module), anyway using "+oe.getName());
+											}
+											refSegments[i]=oe.getName();
+											elements[i]=oe;
+											firstSegment=false;
+											break;
+										}
+									}
+								}
+								if (elements[i]==null){
+									// debug problem, possibly there is a generate named block (not currently supported in the database)
+									// need to remove the first segment and try again
+//									if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_PARSING)) {
+										System.out.println(matchedstring);
+										System.out.println("Failed to find instance named "+refSegments[i]+" for the segnment "+i+", assuming named block");
+//									}
+								} else {
+									firstSegment=false;
+								}
+							}
+						} else { // below: not the first segment
+							de=elements[i-1];
+							// not the last element if it is port
+							if ((i>1) && (!lastIsPort || (i<(refSegments.length-1)))) {
+								de=database.findDefinition(de); // all but first are instances, find their defs
+							}
+							if (de==null) break;
+							// First try literary
+							elements[i]=de.findChild(refSegments[i]);
+							if (elements[i]==null){
+								// now try all children, so the reported name starts with its name and the rest matches suffix
+								if (instSuffixPattern!=null) {
+									OutlineElement[] allChildren=de.getChildren();
+									for (OutlineElement oe:allChildren){
+										if ((oe!=null) && refSegments[i].startsWith(oe.getName())){
+											if (instSuffixPattern.matcher(refSegments[i].substring(oe.getName().length())).matches()){
+												if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_PARSING)) {
+													System.out.println("Suffix match found for "+refSegments[i]+", using "+oe.getName());
+												}
+												refSegments[i]=oe.getName();
+												elements[i]=oe;
+												break;
+											}
+										}
+									}
+								}
+								if (elements[i]==null){
+									// Now try "wild guess" - any suffix OK
+									OutlineElement[] allChildren=de.getChildren(); // make single search
+									for (OutlineElement oe:allChildren){
+										if ((oe!=null) && refSegments[i].startsWith(oe.getName())){
+											if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_PARSING)) {
+												System.out.println("Suffix match NOT found for "+refSegments[i]+", anyway using "+oe.getName());
+											}
+											refSegments[i]=oe.getName();
+											elements[i]=oe;
+											break;
+										}
+									}
+								}									
+							}
+							if (elements[i]==null) break;
+						}
+					} catch (Exception e){
+						break;
+					}
+				}
+				int lastSegment=-1;
+				boolean suppressed=false;
+				for (int i=0;i<refSegments.length;i++){
+					if (elements[i]==null) continue; // break;
+					lastSegment=i;
+					FileLink hyperlink = new FileLink(elements[i].getFile(),null,-1,-1,elements[i].getStartingLine());
+					try {
+						console.addHyperlink(hyperlink, offset+refIndices[i]+(startFromInstance?1:0),
+								refSegments[i].length());
+					} catch (BadLocationException e) {
+						System.out.println("matchFound() exception: "+e);
+						continue;
+					}
+					// test if any of the segment source lines has warning suppressed
+					if (!suppressed && VerilogPlugin.getPreferenceBoolean(PreferenceStrings.SUPPRESS_WARNINGS_ANYLEVEL)) {
+						String previousLine=readResourceString(elements[i].getFile(),elements[i].getStartingLine()-1);
+						if (previousLine!=null){
+							if (previousLine.contains(SUPPRESS_WARNINGS) && (previousLine.contains(toolName) || previousLine.contains("all"))){
+								suppressed=true;
+							}
+						}
+						if (!suppressed) {
+							String thisLine=readResourceString(elements[i].getFile(),elements[i].getStartingLine());
+							if (thisLine!=null){
+								if (thisLine.contains(SUPPRESS_THIS_WARNING) && (thisLine.contains(toolName) || thisLine.contains("all"))){
+									suppressed=true;
+								}
+							}
+						}
+					}
+				}
+				// if only last level is enabled for suppressing warnings - check it now 
+				if (!suppressed && !VerilogPlugin.getPreferenceBoolean(PreferenceStrings.SUPPRESS_WARNINGS_ANYLEVEL) && (lastSegment>=0)) {
+					if (!VerilogPlugin.getPreferenceBoolean(PreferenceStrings.IGNORE_SUPPRESS_WARNINGS)) {
+						String previousLine=readResourceString(elements[lastSegment].getFile(),elements[lastSegment].getStartingLine()-1);
+						if (previousLine!=null){
+							if (previousLine.contains(SUPPRESS_WARNINGS) && (previousLine.contains(toolName) || previousLine.contains("all"))){
+								if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_PARSING))
+									System.out.println(parser.filename+":"+(elements[lastSegment].getStartingLine()-1)+" -> "+previousLine);
+								suppressed=true;
+							}
+						}
+						if (!suppressed) {
+							String thisLine=readResourceString(elements[lastSegment].getFile(),elements[lastSegment].getStartingLine());
+							if (thisLine!=null){
+								if (thisLine.contains(SUPPRESS_THIS_WARNING) && (thisLine.contains(toolName) || thisLine.contains("all"))){
+									if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_PARSING))
+										System.out.println(parser.filename+":"+(elements[lastSegment].getStartingLine())+" -> "+thisLine);
+									suppressed=true;
+								}
+							}
+						}
+					}
+				}
+				if (suppressed || (lastSegment<0)) return;
+				addLineToRemove(consoleDocument,offset);
+//TODO: Currently problem marker is set only to the last segment source. Maybe need to set to all levels? Or make it a configurable option?				
+				setProblemMarker(
+						//								elements[lastSegment].getFile().getName(),
+						elements[lastSegment].getFile(),
+						problemlevel,
+						elements[lastSegment].getStartingLine(),
+						parser.message);
+				if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_PARSING)) {
+					System.out.println(
+							"setProblemMarker("+
+									elements[lastSegment].getFile().getFullPath().toOSString()+
+									" , "+problemlevel+
+									" , "+elements[lastSegment].getStartingLine()+
+									" ,\n "+parser.message+")");
+				}
+				return;
+			} // if ((matcher!=null) && matcher.find()){
+			// Below - easy way when file+line are explicitly provided
+			if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_PARSING)) {
+				System.out.println ("Setting marker at line "+parser.linenr);
+			}
+			IResource resource = getFile(parser.filename);
+			if(resource instanceof IFile) {
+				IFile file = (IFile) resource;
+				if (!VerilogPlugin.getPreferenceBoolean(PreferenceStrings.IGNORE_SUPPRESS_WARNINGS)) {
+					String previousLine=readResourceString(file, parser.linenr-1);
+					if (previousLine!=null){
+						if (previousLine.contains(SUPPRESS_WARNINGS) && (previousLine.contains(toolName) || previousLine.contains("all"))){
+							addLineToRemove(consoleDocument,offset);
+							if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_PARSING))
+								System.out.println(parser.filename+":"+(parser.linenr-1)+" -> "+previousLine);
+							return;
+						}
+					}
+					String thisLine=readResourceString(file, parser.linenr);
+					if (thisLine!=null){
+						if (thisLine.contains(SUPPRESS_THIS_WARNING) && (thisLine.contains(toolName) || thisLine.contains("all"))){
+							addLineToRemove(consoleDocument,offset);
+							if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_PARSING))
+								System.out.println(parser.filename+":"+(parser.linenr)+" -> "+thisLine);
+							return;
+						}
+					}
+				}					
+				FileLink hyperlink = new FileLink(file,null,-1,-1,parser.linenr);
+				try {
+					console.addHyperlink(hyperlink, offset+parser.startinmatchedstring, /* here makes console blue (in debug mode it lags as is not redrawn immediately */
+							parser.endinmatchedstring-parser.startinmatchedstring+1);
+				} catch (BadLocationException e) {
+				}
+			} else {
+				//VerilogPlugin.println("Not a filename!");
+			}
+			setProblemMarker(parser.filename, problemlevel, parser.linenr, parser.message);		/* liner - line in file */	
+		}
+	}
+
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/actions/AbstractAction.java vdt/src/com/elphel/vdt/veditor/actions/AbstractAction.java
--- vdt-veditor/src/com/elphel/vdt/veditor/actions/AbstractAction.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/actions/AbstractAction.java	2016-06-24 10:29:40.816496628 -0600
@@ -1,51 +1,68 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.actions;
-
-import java.util.ResourceBundle;
-
-import net.sourceforge.veditor.editor.HdlEditor;
-import net.sourceforge.veditor.editor.EditorMessages;
-
-import org.eclipse.jface.action.Action;
-import org.eclipse.jface.text.source.ISourceViewer;
-
-
-public abstract class AbstractAction extends Action
-{
-	private HdlEditor editor;
-
-	public AbstractAction(String name)
-	{
-		editor = HdlEditor.current();
-		setEnabled(true);
-		String id = "net.sourceforge.veditor.actions." + name;
-		setId(id);
-		setActionDefinitionId(id);
-		ResourceBundle resource = EditorMessages.getResourceBundle();
-		setText(resource.getString(name + ".label"));
-	}
-
-	public abstract void run();
-
-	protected HdlEditor getEditor()
-	{
-		return HdlEditor.current();
-	}
-	protected ISourceViewer getViewer()
-	{
-		return getEditor().getViewer();
-	}
-	protected void beep()
-	{
-		editor.beep();
-	}
-}
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.actions;
+
+import java.util.ResourceBundle;
+
+import com.elphel.vdt.veditor.editor.HdlEditor;
+import com.elphel.vdt.veditor.editor.EditorMessages;
+
+import org.eclipse.jface.action.Action;
+import org.eclipse.jface.text.source.ISourceViewer;
+
+
+public abstract class AbstractAction extends Action
+{
+	private HdlEditor editor;
+
+	public AbstractAction(String name)
+	{
+		editor = HdlEditor.current();
+		setEnabled(true);
+		String id = "com.elphel.vdt.veditor.actions." + name;
+		setId(id);
+		setActionDefinitionId(id);
+		ResourceBundle resource = EditorMessages.getResourceBundle();
+		setText(resource.getString(name + ".label"));
+	}
+
+	public abstract void run();
+
+	protected HdlEditor getEditor()  // Andrey: May point to last loaded include file, not the window/tab source
+	{
+		return HdlEditor.current();
+	}
+	
+	protected HdlEditor getThisEditor() //Andrey: works instead of getEditor, replaced in 2 actions so far
+	{
+		return this.editor;
+	}
+	
+	protected ISourceViewer getViewer()
+	{
+		return getThisEditor().getViewer();
+	}
+	protected void beep()
+	{
+		editor.beep();
+	}
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/actions/ClearErrorMarkersAction.java vdt/src/com/elphel/vdt/veditor/actions/ClearErrorMarkersAction.java
--- vdt-veditor/src/com/elphel/vdt/veditor/actions/ClearErrorMarkersAction.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/actions/ClearErrorMarkersAction.java	2016-06-24 10:29:40.816496628 -0600
@@ -1,78 +1,78 @@
-package net.sourceforge.veditor.actions;
-
-import net.sourceforge.veditor.VerilogPlugin;
-
-import org.eclipse.core.resources.IFile;
-import org.eclipse.jface.resource.ImageDescriptor;
-import org.eclipse.ui.IPageLayout;
-import org.eclipse.ui.IViewPart;
-import org.eclipse.ui.IWorkbenchPage;
-import org.eclipse.ui.PartInitException;
-import org.eclipse.ui.PlatformUI;
-
-public class ClearErrorMarkersAction extends AbstractAction {
-	private static final String CLEAR_ERROR_MARKERS_ACTION_IMAGE="$nl$/icons/single_gray_x.gif";
-	public static final String ID="ClearErrorMarkers";
-	private static int m_InstallCount=0;
-	
-	public ClearErrorMarkersAction() {
-		super(ID);
-	}
-
-	@Override
-	public void run() {
-		IFile file=getEditor().getHdlDocument().getFile();
-			
-		VerilogPlugin.deleteMarkers(file);
-	}
-	
-	
-	public ImageDescriptor getImageDescriptor(){		
-		return VerilogPlugin.getPlugin().getImageDescriptor(CLEAR_ERROR_MARKERS_ACTION_IMAGE);
-	}
-	
-	/**
-	 * Installs the action in the problems window
-	 */
-	public static void install(){
-		//IViewPart view=getProblemsView();
-		
-		
-		m_InstallCount++;
-	}
-	
-	/**
-	 * Removes the action from problems window
-	 */
-	public void unInstall(){
-		
-		m_InstallCount--;
-	}
-	
-	/**
-	 * Gets the current active page
-	 * @return
-	 */
-	protected static IWorkbenchPage getPage(){
-		IWorkbenchPage page=PlatformUI.getWorkbench()
-				.getActiveWorkbenchWindow().getActivePage();
-		
-		return page;
-	}
-	/**
-	 * Gets hold of the problems window
-	 * @return
-	 */
-	protected static IViewPart getProblemsView(){
-		IWorkbenchPage page = getPage();
-		IViewPart view=null;
-		
-		if (page != null) {
-			try {
-				view = page.showView(IPageLayout.ID_PROBLEM_VIEW);				
-			} catch (PartInitException e) {	
-			}
-		}
-		return view;
-	}
-}
+package com.elphel.vdt.veditor.actions;
+
+import com.elphel.vdt.veditor.VerilogPlugin;
+
+import org.eclipse.core.resources.IFile;
+import org.eclipse.jface.resource.ImageDescriptor;
+import org.eclipse.ui.IPageLayout;
+import org.eclipse.ui.IViewPart;
+import org.eclipse.ui.IWorkbenchPage;
+import org.eclipse.ui.PartInitException;
+import org.eclipse.ui.PlatformUI;
+
+public class ClearErrorMarkersAction extends AbstractAction {
+	private static final String CLEAR_ERROR_MARKERS_ACTION_IMAGE="$nl$/icons/single_gray_x.gif";
+	public static final String ID="ClearErrorMarkers";
+	private static int m_InstallCount=0;
+	
+	public ClearErrorMarkersAction() {
+		super(ID);
+	}
+
+	@Override
+	public void run() {
+		IFile file=getThisEditor().getHdlDocument().getFile();
+			
+		VerilogPlugin.deleteMarkers(file);
+	}
+	
+	
+	public ImageDescriptor getImageDescriptor(){		
+		return VerilogPlugin.getPlugin().getImageDescriptor(CLEAR_ERROR_MARKERS_ACTION_IMAGE);
+	}
+	
+	/**
+	 * Installs the action in the problems window
+	 */
+	public static void install(){
+		//IViewPart view=getProblemsView();
+		
+		
+		m_InstallCount++;
+	}
+	
+	/**
+	 * Removes the action from problems window
+	 */
+	public void unInstall(){
+		
+		m_InstallCount--;
+	}
+	
+	/**
+	 * Gets the current active page
+	 * @return
+	 */
+	protected static IWorkbenchPage getPage(){
+		IWorkbenchPage page=PlatformUI.getWorkbench()
+				.getActiveWorkbenchWindow().getActivePage();
+		
+		return page;
+	}
+	/**
+	 * Gets hold of the problems window
+	 * @return
+	 */
+	protected static IViewPart getProblemsView(){
+		IWorkbenchPage page = getPage();
+		IViewPart view=null;
+		
+		if (page != null) {
+			try {
+				view = page.showView(IPageLayout.ID_PROBLEM_VIEW);				
+			} catch (PartInitException e) {	
+			}
+		}
+		return view;
+	}
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/actions/CollapseAll.java vdt/src/com/elphel/vdt/veditor/actions/CollapseAll.java
--- vdt-veditor/src/com/elphel/vdt/veditor/actions/CollapseAll.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/actions/CollapseAll.java	2016-06-24 10:29:40.816496628 -0600
@@ -1,31 +1,42 @@
-/*******************************************************************************
- * Copyright (c) 2006 Ali Ghorashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    Ali Ghorashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.actions;
-
-import net.sourceforge.veditor.VerilogPlugin;
-
-import org.eclipse.jface.resource.ImageDescriptor;
-
-public class CollapseAll extends AbstractAction {
-	private static final String COLLAPSE_ALL_ACTION_IMAGE="$nl$/icons/collapse_all.gif";
-	public CollapseAll() {
-		super("CollapseAll");		
-	}
-
-	@Override
-	public void run() {
-		getEditor().collapseAll();
-	}
-	
-	public ImageDescriptor getImageDescriptor(){
-		return VerilogPlugin.getPlugin().getImageDescriptor(COLLAPSE_ALL_ACTION_IMAGE);
-	}
-}
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2006 Ali Ghorashi and others.
+ *
+ * Contributors:
+ *    Ali Ghorashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.actions;
+
+import com.elphel.vdt.veditor.VerilogPlugin;
+
+import org.eclipse.jface.resource.ImageDescriptor;
+
+public class CollapseAll extends AbstractAction {
+	private static final String COLLAPSE_ALL_ACTION_IMAGE="$nl$/icons/collapse_all.gif";
+	public CollapseAll() {
+		super("CollapseAll");		
+	}
+
+	@Override
+	public void run() {
+		getThisEditor().collapseAll();
+	}
+	
+	public ImageDescriptor getImageDescriptor(){
+		return VerilogPlugin.getPlugin().getImageDescriptor(COLLAPSE_ALL_ACTION_IMAGE);
+	}
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/actions/CommentAction.java vdt/src/com/elphel/vdt/veditor/actions/CommentAction.java
--- vdt-veditor/src/com/elphel/vdt/veditor/actions/CommentAction.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/actions/CommentAction.java	2016-06-24 10:29:40.816496628 -0600
@@ -1,67 +1,78 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *   Ali Ghorashi - initial implementation
- *******************************************************************************/
-package net.sourceforge.veditor.actions;
-
-import net.sourceforge.veditor.editor.VerilogEditor;
-import net.sourceforge.veditor.editor.VhdlEditor;
-
-import org.eclipse.swt.custom.StyledText;
-import org.eclipse.swt.graphics.Point;
-
-import java.util.regex.*;
-
-
-/**
- * find module declaration from project tree<p>
- * file name and module name must be same
- */
-public class CommentAction extends AbstractAction
-{
-	public CommentAction()
-	{
-		super("Comment");
-	}
-	public void run()
-	{
-		StyledText widget = getViewer().getTextWidget();
-		Point point = widget.getSelection();
-		int begin = point.x;
-		int end = point.y;
-		String commentString="//";
-		
-		//get some vitals on the selection
-		int StartingLine = widget.getLineAtOffset(begin);		
-		begin = widget.getOffsetAtLine(StartingLine);
-		
-		String region = widget.getTextRange(begin, end-begin);
-				
-		//are we using VHDL or verilog
-		if(getEditor() instanceof VhdlEditor){
-			commentString="--";
-		}
-		else if (getEditor() instanceof VerilogEditor){
-			commentString="//";
-		}
-		else{
-			Error e=new Error("Unkown file type");
-			throw e;
-		}
-		
-		//some fancy foot work to replace the beginning of each line with the comment character
-		region = Pattern.compile("^",Pattern.MULTILINE).matcher(region).replaceAll(commentString);
-		
-		//replace the selection
-		widget.replaceTextRange(begin, end - begin, region.toString());
-	}
-}
-
-
-
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *   Ali Ghorashi - initial implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.actions;
+
+import com.elphel.vdt.veditor.editor.VerilogEditor;
+import com.elphel.vdt.veditor.editor.VhdlEditor;
+
+import org.eclipse.swt.custom.StyledText;
+import org.eclipse.swt.graphics.Point;
+
+import java.util.regex.*;
+
+
+/**
+ * find module declaration from project tree<p>
+ * file name and module name must be same
+ */
+public class CommentAction extends AbstractAction
+{
+	public CommentAction()
+	{
+		super("Comment");
+	}
+	public void run()
+	{
+		StyledText widget = getViewer().getTextWidget();
+		Point point = widget.getSelection();
+		int begin = point.x;
+		int end = point.y;
+		String commentString="//";
+		
+		//get some vitals on the selection
+		int StartingLine = widget.getLineAtOffset(begin);		
+		begin = widget.getOffsetAtLine(StartingLine);
+		
+		String region = widget.getTextRange(begin, end-begin);
+				
+		//are we using VHDL or verilog
+		if(getThisEditor() instanceof VhdlEditor){
+			commentString="--";
+		}
+		else if (getThisEditor() instanceof VerilogEditor){
+			commentString="//";
+		}
+		else{
+			Error e=new Error("Unkown file type");
+			throw e;
+		}
+		
+		//some fancy foot work to replace the beginning of each line with the comment character
+		region = Pattern.compile("^",Pattern.MULTILINE).matcher(region).replaceAll(commentString);
+		
+		//replace the selection
+		widget.replaceTextRange(begin, end - begin, region.toString());
+	}
+}
+
+
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/actions/CompileAction.java vdt/src/com/elphel/vdt/veditor/actions/CompileAction.java
--- vdt-veditor/src/com/elphel/vdt/veditor/actions/CompileAction.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/actions/CompileAction.java	2016-06-24 10:29:40.816496628 -0600
@@ -1,138 +1,149 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.actions;
-
-import java.io.File;
-
-
-import net.sourceforge.veditor.VerilogPlugin;
-import net.sourceforge.veditor.builder.ExternalLauncher;
-import org.eclipse.core.resources.IContainer;
-import org.eclipse.core.resources.IFile;
-import org.eclipse.core.resources.IFolder;
-import org.eclipse.core.resources.IProject;
-import org.eclipse.core.runtime.CoreException;
-import org.eclipse.core.runtime.IPath;
-import org.eclipse.core.variables.VariablesPlugin;
-
-public class CompileAction extends AbstractAction
-{
-	protected String commandString = "Compile.command";
-	
-	public CompileAction()
-	{
-		super("Compile");
-	}
-	
-	public CompileAction(String name)
-	{
-		super(name);
-	}
-	
-	 public static boolean isNeedToSaveSet() {
-		return VerilogPlugin.getPreferenceBoolean("Compile.SaveBeforeCompile");
-	 }
-	/**
-	 * Checks the save before build flag and saves the current file 
-	 * if necessary.
-	 */
-	private void checkAndSaveEditors(){
-		if(isNeedToSaveSet() && getEditor().isDirty()){
-			getEditor().doSave(null);
-		}
-	}
-	
-	public void run()
-	{
-		IFile file = getEditor().getHdlDocument().getFile();
-		IContainer parent = file.getParent();
-		while (parent instanceof IFolder)
-		{
-			parent = parent.getParent();
-		}
-		if (parent instanceof IProject)
-		{
-			//project = (IProject)parent;
-		}
-		else
-		{
-			// maybe never execute
-			return;
-		}
-		
-		VerilogPlugin.clear();
-		
-		VerilogPlugin.deleteExternalMarkers(file);
-		IPath path = parent.getLocation();
-		
-		String simulationdir = VerilogPlugin.getPreferenceString("Compile.Folder");
-		
-		if(simulationdir.length() != 0 && !(new File(path.toString()+"/"+simulationdir).exists()))
-		{			
-			VerilogPlugin.println("Warning directory \"" + path.toString()+"/"+simulationdir + "\" not found");
-			return;
-		}
-		
-		IContainer workdir = (IContainer)parent.findMember(simulationdir);
-		
-		if(workdir==null) {
-			VerilogPlugin.println("Warning directory \"" + path.toString()+"/"+simulationdir + "\""+
-					" exists on file system, but not in your project, try refreshing your project");
-			return;
-		}
-		
-		/*
-		 * %f - filename
-		 * %p - path
-		 * %w - workspace path
-		 * %d - path relative to workspace path
-		 * %s - simulation dir
-		 */
-		
-		String command = VerilogPlugin.getPreferenceString(commandString);
-		String temp = file.getLocation().toString().replace(file.getName(), "");
-		
-		command = command.replace("%f", file.getName());
-		command = command.replace("%p", temp);
-		command = command.replace("%s", simulationdir);		
-		command = command.replace("%w", path.toString());
-		
-		//mg
-		try {
-			command = VariablesPlugin.getDefault().getStringVariableManager()
-					.performStringSubstitution( command );
-		} catch ( final CoreException e ) {
-			e.printStackTrace();
-		}
-		//mg-------------------
-		
-		temp = temp.replace(path.toString(), "");
-		command = command.replace("%d", temp.substring(1,temp.length()));
-		
-		VerilogPlugin.println("Compiling: " + file.getLocation().toString());
-		VerilogPlugin.println("       in: " + path.toString()+ (simulationdir.length()==0?"":"/") +simulationdir);
-		VerilogPlugin.println("");
-		VerilogPlugin.println("  Command: " + command + "\n");
-
-		checkAndSaveEditors();
-        
-		ExternalLauncher launchar = new ExternalLauncher(workdir, command);
-		launchar.run();
-
-		getEditor().update();
-	}
-}
-
-
-
-
-
-
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.actions;
+
+import java.io.File;
+
+
+import com.elphel.vdt.veditor.VerilogPlugin;
+import com.elphel.vdt.veditor.builder.ExternalLauncher;
+import org.eclipse.core.resources.IContainer;
+import org.eclipse.core.resources.IFile;
+import org.eclipse.core.resources.IFolder;
+import org.eclipse.core.resources.IProject;
+import org.eclipse.core.runtime.CoreException;
+import org.eclipse.core.runtime.IPath;
+import org.eclipse.core.variables.VariablesPlugin;
+
+public class CompileAction extends AbstractAction
+{
+	protected String commandString = "Compile.command";
+	
+	public CompileAction()
+	{
+		super("Compile");
+	}
+	
+	public CompileAction(String name)
+	{
+		super(name);
+	}
+	
+	 public static boolean isNeedToSaveSet() {
+		return VerilogPlugin.getPreferenceBoolean("Compile.SaveBeforeCompile");
+	 }
+	/**
+	 * Checks the save before build flag and saves the current file 
+	 * if necessary.
+	 */
+	private void checkAndSaveEditors(){
+		if(isNeedToSaveSet() && getThisEditor().isDirty()){
+			getThisEditor().doSave(null);
+		}
+	}
+	
+	public void run()
+	{
+		IFile file = getThisEditor().getHdlDocument().getFile();
+		IContainer parent = file.getParent();
+		while (parent instanceof IFolder)
+		{
+			parent = parent.getParent();
+		}
+		if (parent instanceof IProject)
+		{
+			//project = (IProject)parent;
+		}
+		else
+		{
+			// maybe never execute
+			return;
+		}
+		
+		VerilogPlugin.clear();
+		
+		VerilogPlugin.deleteExternalMarkers(file);
+		IPath path = parent.getLocation();
+		
+		String simulationdir = VerilogPlugin.getPreferenceString("Compile.Folder");
+		
+		if(simulationdir.length() != 0 && !(new File(path.toString()+"/"+simulationdir).exists()))
+		{			
+			VerilogPlugin.println("Warning directory \"" + path.toString()+"/"+simulationdir + "\" not found");
+			return;
+		}
+		
+		IContainer workdir = (IContainer)parent.findMember(simulationdir);
+		
+		if(workdir==null) {
+			VerilogPlugin.println("Warning directory \"" + path.toString()+"/"+simulationdir + "\""+
+					" exists on file system, but not in your project, try refreshing your project");
+			return;
+		}
+		
+		/*
+		 * %f - filename
+		 * %p - path
+		 * %w - workspace path
+		 * %d - path relative to workspace path
+		 * %s - simulation dir
+		 */
+		
+		String command = VerilogPlugin.getPreferenceString(commandString);
+		String temp = file.getLocation().toString().replace(file.getName(), "");
+		
+		command = command.replace("%f", file.getName());
+		command = command.replace("%p", temp);
+		command = command.replace("%s", simulationdir);		
+		command = command.replace("%w", path.toString());
+		
+		//mg
+		try {
+			command = VariablesPlugin.getDefault().getStringVariableManager()
+					.performStringSubstitution( command );
+		} catch ( final CoreException e ) {
+			e.printStackTrace();
+		}
+		//mg-------------------
+		
+		temp = temp.replace(path.toString(), "");
+		command = command.replace("%d", temp.substring(1,temp.length()));
+		
+		VerilogPlugin.println("Compiling: " + file.getLocation().toString());
+		VerilogPlugin.println("       in: " + path.toString()+ (simulationdir.length()==0?"":"/") +simulationdir);
+		VerilogPlugin.println("");
+		VerilogPlugin.println("  Command: " + command + "\n");
+
+		checkAndSaveEditors();
+        
+		ExternalLauncher launchar = new ExternalLauncher(workdir, command);
+		launchar.run();
+
+		getThisEditor().update();
+	}
+}
+
+
+
+
+
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/actions/ExpandAll.java vdt/src/com/elphel/vdt/veditor/actions/ExpandAll.java
--- vdt-veditor/src/com/elphel/vdt/veditor/actions/ExpandAll.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/actions/ExpandAll.java	2016-06-24 10:29:40.816496628 -0600
@@ -1,32 +1,43 @@
-/*******************************************************************************
- * Copyright (c) 2006 Ali Ghorashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    Ali Ghorashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.actions;
-
-import net.sourceforge.veditor.VerilogPlugin;
-
-import org.eclipse.jface.resource.ImageDescriptor;
-
-public class ExpandAll extends AbstractAction {
-	private static final String EXPAND_ALL_ACTION_IMAGE="$nl$/icons/expand_all.gif";
-	public ExpandAll() {
-		super("ExpandAll");		
-	}
-
-	@Override
-	public void run() {
-		getEditor().expandAll();
-
-	}
-	public ImageDescriptor getImageDescriptor(){
-		return VerilogPlugin.getPlugin().getImageDescriptor(EXPAND_ALL_ACTION_IMAGE);
-	}
-
-}
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2006 Ali Ghorashi and others.
+ *
+ * Contributors:
+ *    Ali Ghorashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.actions;
+
+import com.elphel.vdt.veditor.VerilogPlugin;
+
+import org.eclipse.jface.resource.ImageDescriptor;
+
+public class ExpandAll extends AbstractAction {
+	private static final String EXPAND_ALL_ACTION_IMAGE="$nl$/icons/expand_all.gif";
+	public ExpandAll() {
+		super("ExpandAll");		
+	}
+
+	@Override
+	public void run() {
+		getThisEditor().expandAll();
+
+	}
+	public ImageDescriptor getImageDescriptor(){
+		return VerilogPlugin.getPlugin().getImageDescriptor(EXPAND_ALL_ACTION_IMAGE);
+	}
+
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/actions/FormatAction.java vdt/src/com/elphel/vdt/veditor/actions/FormatAction.java
--- vdt-veditor/src/com/elphel/vdt/veditor/actions/FormatAction.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/actions/FormatAction.java	2016-06-24 10:29:40.816496628 -0600
@@ -1,42 +1,53 @@
-/*******************************************************************************
- * Copyright (c) 2007 Ali Ghorashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    Ali Ghorashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.actions;
-
-import net.sourceforge.veditor.editor.VerilogEditor;
-import net.sourceforge.veditor.editor.VhdlEditor;
-
-public class FormatAction extends AbstractAction
-{
-	private VerilogFormatAction m_VerilogFormatAction;
-	private VhdlFormatAction m_VhdlFormatAction;
-
-	public FormatAction()
-	{
-		super("Format");
-		m_VhdlFormatAction=new VhdlFormatAction();
-		m_VerilogFormatAction=new VerilogFormatAction();		
-	}
-	
-	
-	public void run()
-	{
-		//run the appropriate format action
-		if(getEditor() instanceof VhdlEditor){
-			m_VhdlFormatAction.run();
-		}
-		else if(getEditor() instanceof VerilogEditor){
-			m_VerilogFormatAction.run();
-		}
-	}
-	
-	
-}
-
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2007 Ali Ghorashi and others.
+ *
+ * Contributors:
+ *    Ali Ghorashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.actions;
+
+import com.elphel.vdt.veditor.editor.VerilogEditor;
+import com.elphel.vdt.veditor.editor.VhdlEditor;
+
+public class FormatAction extends AbstractAction
+{
+	private VerilogFormatAction m_VerilogFormatAction;
+	private VhdlFormatAction m_VhdlFormatAction;
+
+	public FormatAction()
+	{
+		super("Format");
+		m_VhdlFormatAction=new VhdlFormatAction();
+		m_VerilogFormatAction=new VerilogFormatAction();		
+	}
+	
+	
+	public void run()
+	{
+		//run the appropriate format action
+		if(getThisEditor() instanceof VhdlEditor){
+			m_VhdlFormatAction.run();
+		}
+		else if(getThisEditor() instanceof VerilogEditor){
+			m_VerilogFormatAction.run();
+		}
+	}
+	
+	
+}
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/actions/GotoDriverAction.java vdt/src/com/elphel/vdt/veditor/actions/GotoDriverAction.java
--- vdt-veditor/src/com/elphel/vdt/veditor/actions/GotoDriverAction.java	1969-12-31 17:00:00.000000000 -0700
+++ vdt/src/com/elphel/vdt/veditor/actions/GotoDriverAction.java	2016-06-24 10:29:40.816496628 -0600
@@ -0,0 +1,237 @@
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.actions;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Vector;
+
+import com.elphel.vdt.veditor.VerilogPlugin;
+import com.elphel.vdt.veditor.document.HdlDocument;
+import com.elphel.vdt.veditor.editor.HdlEditor;
+import com.elphel.vdt.veditor.parser.OutlineElement;
+import com.elphel.vdt.veditor.parser.verilog.VerilogOutlineElementFactory;
+import com.elphel.vdt.veditor.preference.PreferenceStrings;
+import org.eclipse.jface.resource.ImageDescriptor;
+import org.eclipse.jface.resource.JFaceResources;
+import org.eclipse.jface.text.TextSelection;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.FocusEvent;
+import org.eclipse.swt.events.FocusListener;
+import org.eclipse.swt.events.SelectionEvent;
+import org.eclipse.swt.events.SelectionListener;
+import org.eclipse.swt.graphics.Point;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Shell;
+import org.eclipse.swt.widgets.Table;
+import org.eclipse.swt.widgets.TableItem;
+import org.eclipse.ui.IEditorReference;
+import org.eclipse.ui.IEditorSite;
+import org.eclipse.ui.IWorkbenchPage;
+import org.eclipse.ui.IWorkbenchWindow;
+import org.eclipse.ui.PlatformUI;
+
+
+/**
+ * find module declaration from project tree<p>
+ * file name and module name must be same
+ */
+public class GotoDriverAction extends AbstractAction
+{
+	Shell m_ProposalShell;
+	Table m_ProposalTable;
+	private static final String GOTO_DRIVER_ACTION_IMAGE="$nl$/icons/driver.png";
+	
+	public GotoDriverAction()
+	{
+		super("GotoDriver");
+		m_ProposalShell=null;
+	}
+	public void run()
+	{
+		gotoSignalDriver();
+	}
+	
+	public ImageDescriptor getImageDescriptor(){
+		return VerilogPlugin.getPlugin().getImageDescriptor(GOTO_DRIVER_ACTION_IMAGE);
+	}
+	
+	private class focusListener implements FocusListener{
+
+		public void focusGained(FocusEvent e) {
+			
+		}
+
+		public void focusLost(FocusEvent e) {
+			m_ProposalShell.setVisible(false);
+		}
+		
+	}
+	
+	private class selectionListener implements SelectionListener{
+
+		public void widgetDefaultSelected(SelectionEvent e) {
+			// TODO Auto-generated method stub
+			
+		}
+
+		public void widgetSelected(SelectionEvent e) {
+			if (e.item instanceof TableItem) {
+				TableItem tableItem = (TableItem) e.item;
+				if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR)) {
+					System.out.println("tableItem.getData()="+tableItem.getData());
+				}
+				if (tableItem.getData() instanceof Integer) {
+					int line = (Integer) tableItem.getData();
+
+					getThisEditor().showLine(line);
+				}
+			}
+			m_ProposalShell.setVisible(false);
+		}
+		
+	}
+	
+	private void showPopUp(List<Integer> driverLines, HdlEditor editor,Point position){	
+		IEditorSite control=editor.getEditorSite();
+		
+		if(m_ProposalShell == null){
+			m_ProposalShell= new Shell(control.getShell(), SWT.ON_TOP);
+			m_ProposalShell.setFont(JFaceResources.getDefaultFont());
+			GridLayout layout= new GridLayout();
+			layout.marginWidth= 0;
+			layout.marginHeight= 0;
+			layout.verticalSpacing= 1;		
+			m_ProposalShell.setLayout(layout);		
+			m_ProposalTable= new Table(m_ProposalShell, SWT.H_SCROLL | SWT.V_SCROLL);
+			m_ProposalTable.setLocation(0, 0);
+			GridData data= new GridData(GridData.FILL_BOTH);
+			m_ProposalTable.setLayoutData(data);
+			Point size= new Point(600,200);
+			m_ProposalShell.setSize(size);
+			m_ProposalTable.setSize(size);
+			m_ProposalTable.addFocusListener(new focusListener());
+			m_ProposalTable.addSelectionListener(new selectionListener());		
+		}
+		m_ProposalTable.setItemCount(driverLines.size());		
+		TableItem[] tableItem=m_ProposalTable.getItems();
+		for(int i=0;i<tableItem.length;i++){
+			String lineStr = editor.getLine(driverLines.get(i) - 1);
+			if (lineStr == null) lineStr = "";
+			lineStr=String.format("%4d: ", driverLines.get(i)) +lineStr.trim(); 
+			tableItem[i].setText(lineStr);
+			/*
+			String imageName=null; // Add something later ? (type of assignment)
+			if(imageName!=null){
+				tableItem[i].setImage(VerilogPlugin.getPlugin().getImage(imageName));
+			}
+			*/
+			tableItem[i].setData(driverLines.get(i) -1);
+		}		
+				
+		m_ProposalShell.setLocation(position);
+		m_ProposalShell.setVisible(true);
+		m_ProposalTable.setFocus();		
+	
+	}
+	
+	/**
+	 * Attempts to find the definition for the highlighted word
+	 */
+	public void gotoSignalDriver(){
+		IEditorReference[] er= PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().getEditorReferences();
+		
+		List<IEditorReference> editors = new ArrayList<IEditorReference>();
+		for (IWorkbenchWindow window : PlatformUI.getWorkbench().getWorkbenchWindows()) {
+		    for (IWorkbenchPage page : window.getPages()) {
+		        for (IEditorReference editor : page.getEditorReferences()) {
+		            editors.add(editor);
+		        }
+		    }
+		}
+		TextSelection textSelection = (TextSelection) PlatformUI.getWorkbench().getActiveWorkbenchWindow().getSelectionService().getSelection();
+		String selectionText =        textSelection.getText();
+		int selectionOffset =         textSelection.getOffset();
+		Point cursorCoordinates =     PlatformUI.getWorkbench().getDisplay().getCursorLocation();
+
+////		HdlEditor   editor= getThisEditor();
+		HdlEditor   editor= getThisEditor();
+		HdlDocument doc   = editor.getHdlDocument();
+		Vector<OutlineElement> definitionList = doc.getDefinitionList(selectionText,selectionOffset);
+		
+		List<Integer> driverLines=new ArrayList<Integer>();
+		if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR)) {
+			System.out.println("gotoSignalDriver(), doc.getFile()="+doc.getFile());
+			System.out.println("gotoSignalDriver(), cursorCoordinates="+cursorCoordinates.x +":"+cursorCoordinates.y);
+		}
+		//go to the definition
+		for (OutlineElement oe:definitionList){
+            if (oe instanceof VerilogOutlineElementFactory.VerilogOutlineElement){
+                VerilogOutlineElementFactory.VerilogOutlineElement ve=
+                        (VerilogOutlineElementFactory.VerilogOutlineElement) oe;
+                if (!doc.getFile().equals(ve.getFile())){
+            		if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR)) {
+            			System.out.println("not the same file, skipping: doc.getFile()="+doc.getFile()+" ve.getFile()="+ve.getFile());
+            		}
+                	continue;
+                }
+                
+        		if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR)) {
+        			System.out.print("gotoSignalDriver(), "+ve.getName()+".getType()=" +ve.getType()+" file="+ve.getFile());
+        			if (ve.getParent() != null) {
+        				System.out.print("    gotoSignalDriver(), "+ve.getParent().getName()+".getParent().getType()=" +ve.getParent().getType());
+        			}
+        			System.out.println();
+        		}
+        		String [] types=ve.getType().split("#");
+                List<Integer> edl = ve.getDrivers();
+                if (edl !=null) {
+                	driverLines.addAll(edl);
+                }
+                // Is it a module input port? Add its line as the first item
+                if ((ve.getParent() != null) &&
+               		ve.getParent().getType().split("#")[0].equals("module") &&
+               		types[0].equals("port") &&
+               		(types[1].equals("input") || types[1].equals("inout"))){
+                		driverLines.add(0, new Integer (ve.getStartingLine()));
+                }
+            }
+		}
+		if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR)) {
+			System.out.println("gotoSignalDriver(), driverLines.size()="+driverLines.size());
+			for (int i = 0; i< driverLines.size(); i++){
+				System.out.println(i+":"+driverLines.get(i));
+			}
+		}
+		if (driverLines.size() == 0) {
+			return;
+		} else if (driverLines.size() == 1) {
+			editor.showLine(driverLines.get(0) - 1);
+		} else {
+			showPopUp(driverLines, editor, cursorCoordinates);
+		}
+	}
+}
+
+
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/actions/GotoMatchingBracketAction.java vdt/src/com/elphel/vdt/veditor/actions/GotoMatchingBracketAction.java
--- vdt-veditor/src/com/elphel/vdt/veditor/actions/GotoMatchingBracketAction.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/actions/GotoMatchingBracketAction.java	2016-06-24 10:29:40.816496628 -0600
@@ -1,145 +1,156 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.actions;
-
-import org.eclipse.swt.custom.StyledText;
-
-/**
- * jamp bracket which includes begin/end
- */
-public class GotoMatchingBracketAction extends AbstractAction
-{
-	public GotoMatchingBracketAction()
-	{
-		super("GotoMatchingBracket");
-	}
-	public void run()
-	{
-		StyledText widget = getViewer().getTextWidget();
-		String text = widget.getText();
-
-		int pos = widget.getCaretOffset();
-		String[] open = { "(", "{", "[", "begin", "fork" };
-		String[] close = { ")", "}", "]", "end", "join" };
-
-		int openIdx = searchWord(open, text, pos);
-		int closeIdx = searchWord(close, text, pos);
-
-		int refPos = -1;
-		if (openIdx != -1)
-		{
-			refPos = searchCloseBracket(text, pos, open[openIdx], close[openIdx]);
-		}
-		else if (closeIdx != -1)
-		{
-			refPos = searchOpenBracket(text, pos, open[closeIdx], close[closeIdx]);
-		}
-		if (refPos >= 0)
-		{
-			widget.setSelection(refPos);
-			return;
-		}
-		beep();
-	}
-
-	/**
-	 * search open/close keywords
-	 * @param words	keywords
-	 * @param text	refered text
-	 * @param pos	begining of searching
-	 * @return keywords index
-	 */
-	private int searchWord(String[] words, String text, int pos)
-	{
-		for (int i = 0; i < words.length; i++)
-		{
-			int len = words[i].length();
-			if (text.substring(pos - len, pos).equals(words[i]))
-				return i;
-		}
-		return -1;
-	}
-
-	/**
-	 * search closing bracket
-	 * @param text	refered text
-	 * @param pos	begining of searching
-	 * @param open	open word
-	 * @param close	close word
-	 * @return offset
-	 */
-	private int searchCloseBracket(String text, int pos, String open, String close)
-	{
-		int level = 1;
-		int len = text.length();
-		pos++;
-		int openLen = open.length();
-		int closeLen = close.length();
-		while (pos < len)
-		{
-			// String ref = text.substring(pos, pos + 1);
-			if (testBracket(text, pos, open, openLen))
-				level++;
-			if (testBracket(text, pos, close, closeLen))
-				level--;
-			if (level == 0)
-				return pos + closeLen;
-			pos++;
-		}
-		return -1;
-	}
-
-	/**
-	 * search opening bracket
-	 * @param text	refered text
-	 * @param pos	begining of searching
-	 * @param open	open word
-	 * @param close	close word
-	 * @return offset
-	 */
-	private int searchOpenBracket(String text, int pos, String open, String close)
-	{
-		int level = 1;
-		int openLen = open.length();
-		int closeLen = close.length();
-		pos -= 1 + closeLen;
-		while (pos >= 0)
-		{
-			if (testBracket(text, pos, open, openLen))
-				level--;
-			if (testBracket(text, pos, close, closeLen))
-				level++;
-			if (level == 0)
-				return pos + openLen;
-			pos--;
-		}
-		return -1;
-	}
-
-	private boolean testBracket(String text, int pos, String bracket, int len)
-	{
-		if (bracket.equals(text.substring(pos, pos + len)))
-		{
-			if (Character.isJavaIdentifierStart(bracket.charAt(0)))
-			{
-				return !Character.isJavaIdentifierPart(text.charAt(pos - 1))
-						&& !Character.isJavaIdentifierPart(text.charAt(pos + len));
-			}
-			else
-				return true;
-		}
-		else
-			return false;
-	}
-}
-
-
-
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.actions;
+
+import org.eclipse.swt.custom.StyledText;
+
+/**
+ * jamp bracket which includes begin/end
+ */
+public class GotoMatchingBracketAction extends AbstractAction
+{
+	public GotoMatchingBracketAction()
+	{
+		super("GotoMatchingBracket");
+	}
+	public void run()
+	{
+		StyledText widget = getViewer().getTextWidget();
+		String text = widget.getText();
+
+		int pos = widget.getCaretOffset();
+		String[] open = { "(", "{", "[", "begin", "fork" };
+		String[] close = { ")", "}", "]", "end", "join" };
+
+		int openIdx = searchWord(open, text, pos);
+		int closeIdx = searchWord(close, text, pos);
+
+		int refPos = -1;
+		if (openIdx != -1)
+		{
+			refPos = searchCloseBracket(text, pos, open[openIdx], close[openIdx]);
+		}
+		else if (closeIdx != -1)
+		{
+			refPos = searchOpenBracket(text, pos, open[closeIdx], close[closeIdx]);
+		}
+		if (refPos >= 0)
+		{
+			widget.setSelection(refPos);
+			return;
+		}
+		beep();
+	}
+
+	/**
+	 * search open/close keywords
+	 * @param words	keywords
+	 * @param text	refered text
+	 * @param pos	begining of searching
+	 * @return keywords index
+	 */
+	private int searchWord(String[] words, String text, int pos)
+	{
+		for (int i = 0; i < words.length; i++)
+		{
+			int len = words[i].length();
+			if (text.substring(pos - len, pos).equals(words[i]))
+				return i;
+		}
+		return -1;
+	}
+
+	/**
+	 * search closing bracket
+	 * @param text	refered text
+	 * @param pos	begining of searching
+	 * @param open	open word
+	 * @param close	close word
+	 * @return offset
+	 */
+	private int searchCloseBracket(String text, int pos, String open, String close)
+	{
+		int level = 1;
+		int len = text.length();
+		pos++;
+		int openLen = open.length();
+		int closeLen = close.length();
+		while (pos < len)
+		{
+			// String ref = text.substring(pos, pos + 1);
+			if (testBracket(text, pos, open, openLen))
+				level++;
+			if (testBracket(text, pos, close, closeLen))
+				level--;
+			if (level == 0)
+				return pos + closeLen;
+			pos++;
+		}
+		return -1;
+	}
+
+	/**
+	 * search opening bracket
+	 * @param text	refered text
+	 * @param pos	begining of searching
+	 * @param open	open word
+	 * @param close	close word
+	 * @return offset
+	 */
+	private int searchOpenBracket(String text, int pos, String open, String close)
+	{
+		int level = 1;
+		int openLen = open.length();
+		int closeLen = close.length();
+		pos -= 1 + closeLen;
+		while (pos >= 0)
+		{
+			if (testBracket(text, pos, open, openLen))
+				level--;
+			if (testBracket(text, pos, close, closeLen))
+				level++;
+			if (level == 0)
+				return pos + openLen;
+			pos--;
+		}
+		return -1;
+	}
+
+	private boolean testBracket(String text, int pos, String bracket, int len)
+	{
+		if (bracket.equals(text.substring(pos, pos + len)))
+		{
+			if (Character.isJavaIdentifierStart(bracket.charAt(0)))
+			{
+				return !Character.isJavaIdentifierPart(text.charAt(pos - 1))
+						&& !Character.isJavaIdentifierPart(text.charAt(pos + len));
+			}
+			else
+				return true;
+		}
+		else
+			return false;
+	}
+}
+
+
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/actions/HdlEditorActionDelegate.java vdt/src/com/elphel/vdt/veditor/actions/HdlEditorActionDelegate.java
--- vdt-veditor/src/com/elphel/vdt/veditor/actions/HdlEditorActionDelegate.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/actions/HdlEditorActionDelegate.java	2016-06-24 10:29:40.816496628 -0600
@@ -1,72 +1,72 @@
-package net.sourceforge.veditor.actions;
-
-import net.sourceforge.veditor.editor.HdlEditor;
-
-import org.eclipse.jface.action.IAction;
-import org.eclipse.jface.viewers.ISelection;
-import org.eclipse.ui.IEditorActionDelegate;
-import org.eclipse.ui.IEditorPart;
-
-public class HdlEditorActionDelegate implements IEditorActionDelegate
- {
-	protected final String COMPILE="net.sourceforge.veditor.compile";
-	   /**
-     * Performs this action.
-     * <p>
-     * This method is called by the proxy action when the action has been
-     * triggered. Implement this method to do the actual work.
-     * </p><p>
-     * <b>Note:</b> If the action delegate also implements
-     * <code>IActionDelegate2</code>, then this method is not invoked but
-     * instead the <code>runWithEvent(IAction, Event)</code> method is called.
-     * </p>
-     *
-     * @param action the action proxy that handles the presentation portion of the
-     *   action
-     */
-    public void run(IAction action){
-    	
-    	if(action.getId().equals(COMPILE)){
-    		CompileAction compileAction=new CompileAction();
-    		compileAction.run();
-    	}
-    }
-
-    /**
-     * Notifies this action delegate that the selection in the workbench has changed.
-     * <p>
-     * Implementers can use this opportunity to change the availability of the
-     * action or to modify other presentation properties.
-     * </p><p>
-     * When the selection changes, the action enablement state is updated based on
-     * the criteria specified in the plugin.xml file. Then the delegate is notified
-     * of the selection change regardless of whether the enablement criteria in the
-     * plugin.xml file is met.
-     * </p>
-     *
-     * @param action the action proxy that handles presentation portion of 
-     * 		the action
-     * @param selection the current selection, or <code>null</code> if there
-     * 		is no selection.
-     */
-    public void selectionChanged(IAction action, ISelection selection){
-    	
-    }
-    
-    /**
-     * Sets the active editor for the delegate.  
-     * Implementors should disconnect from the old editor, connect to the 
-     * new editor, and update the action to reflect the new editor.
-     *
-     * @param action the action proxy that handles presentation portion of the action
-     * @param targetEditor the new editor target
-     */
-    public void setActiveEditor(IAction action, IEditorPart targetEditor){
-    	//FIXME: there should be a way to do this from inside the editor
-    	//but until then
-    	HdlEditor hdlEditor=(HdlEditor)targetEditor;
-    	if(hdlEditor!=null){
-    		hdlEditor.setCurrent();
-    	}
-    }
-}
+package com.elphel.vdt.veditor.actions;
+
+import com.elphel.vdt.veditor.editor.HdlEditor;
+
+import org.eclipse.jface.action.IAction;
+import org.eclipse.jface.viewers.ISelection;
+import org.eclipse.ui.IEditorActionDelegate;
+import org.eclipse.ui.IEditorPart;
+
+public class HdlEditorActionDelegate implements IEditorActionDelegate
+ {
+	protected final String COMPILE="com.elphel.vdt.veditor.compile";
+	   /**
+     * Performs this action.
+     * <p>
+     * This method is called by the proxy action when the action has been
+     * triggered. Implement this method to do the actual work.
+     * </p><p>
+     * <b>Note:</b> If the action delegate also implements
+     * <code>IActionDelegate2</code>, then this method is not invoked but
+     * instead the <code>runWithEvent(IAction, Event)</code> method is called.
+     * </p>
+     *
+     * @param action the action proxy that handles the presentation portion of the
+     *   action
+     */
+    public void run(IAction action){
+    	
+    	if(action.getId().equals(COMPILE)){
+    		CompileAction compileAction=new CompileAction();
+    		compileAction.run();
+    	}
+    }
+
+    /**
+     * Notifies this action delegate that the selection in the workbench has changed.
+     * <p>
+     * Implementers can use this opportunity to change the availability of the
+     * action or to modify other presentation properties.
+     * </p><p>
+     * When the selection changes, the action enablement state is updated based on
+     * the criteria specified in the plugin.xml file. Then the delegate is notified
+     * of the selection change regardless of whether the enablement criteria in the
+     * plugin.xml file is met.
+     * </p>
+     *
+     * @param action the action proxy that handles presentation portion of 
+     * 		the action
+     * @param selection the current selection, or <code>null</code> if there
+     * 		is no selection.
+     */
+    public void selectionChanged(IAction action, ISelection selection){
+    	
+    }
+    
+    /**
+     * Sets the active editor for the delegate.  
+     * Implementors should disconnect from the old editor, connect to the 
+     * new editor, and update the action to reflect the new editor.
+     *
+     * @param action the action proxy that handles presentation portion of the action
+     * @param targetEditor the new editor target
+     */
+    public void setActiveEditor(IAction action, IEditorPart targetEditor){
+    	//FIXME: there should be a way to do this from inside the editor
+    	//but until then
+    	HdlEditor hdlEditor=(HdlEditor)targetEditor;
+    	if(hdlEditor!=null){
+    		hdlEditor.setCurrent();
+    	}
+    }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/actions/HdlShowInNavigatorAction.java vdt/src/com/elphel/vdt/veditor/actions/HdlShowInNavigatorAction.java
--- vdt-veditor/src/com/elphel/vdt/veditor/actions/HdlShowInNavigatorAction.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/actions/HdlShowInNavigatorAction.java	2016-06-24 10:29:40.816496628 -0600
@@ -1,60 +1,60 @@
-package net.sourceforge.veditor.actions;
-
-import net.sourceforge.veditor.VerilogPlugin;
-
-import org.eclipse.core.resources.IFile;
-import org.eclipse.jface.resource.ImageDescriptor;
-import org.eclipse.jface.viewers.ISelection;
-import org.eclipse.jface.viewers.StructuredSelection;
-import org.eclipse.ui.IPageLayout;
-import org.eclipse.ui.IViewPart;
-import org.eclipse.ui.IWorkbenchPage;
-import org.eclipse.ui.PartInitException;
-import org.eclipse.ui.PlatformUI;
-import org.eclipse.ui.part.ISetSelectionTarget;
-
-public class HdlShowInNavigatorAction extends  AbstractAction {
-	private static final String SHOW_IN_NAVIGATOR_ACTION_IMAGE="$nl$/icons/nav.gif";
-	public static final String ID="ShowInNavigator";
-	
-	public HdlShowInNavigatorAction() {
-		super(ID);		
-	}
-	
-	/**
-	 * Gets the current active page
-	 * @return
-	 */
-	protected IWorkbenchPage getPage(){
-		IWorkbenchPage page=PlatformUI.getWorkbench()
-				.getActiveWorkbenchWindow().getActivePage();
-		
-		return page;
-	}
-
-	@Override
-	public void run() {
-		IWorkbenchPage page = getPage();
-
-		if (page == null) {
-			return;
-		}
-
-		try {
-			IViewPart view = page.showView(IPageLayout.ID_RES_NAV);
-			if (view instanceof ISetSelectionTarget) {
-				IFile file=getEditor().getHdlDocument().getFile();
-				if(file != null){
-					ISelection selection = new StructuredSelection(file);
-					((ISetSelectionTarget) view).selectReveal(selection);
-				}
-			}
-		} catch (PartInitException e) {
-
-		}
-	}
-	
-	public ImageDescriptor getImageDescriptor(){		
-		return VerilogPlugin.getPlugin().getImageDescriptor(SHOW_IN_NAVIGATOR_ACTION_IMAGE);
-	}
-}
+package com.elphel.vdt.veditor.actions;
+
+import com.elphel.vdt.veditor.VerilogPlugin;
+
+import org.eclipse.core.resources.IFile;
+import org.eclipse.jface.resource.ImageDescriptor;
+import org.eclipse.jface.viewers.ISelection;
+import org.eclipse.jface.viewers.StructuredSelection;
+import org.eclipse.ui.IPageLayout;
+import org.eclipse.ui.IViewPart;
+import org.eclipse.ui.IWorkbenchPage;
+import org.eclipse.ui.PartInitException;
+import org.eclipse.ui.PlatformUI;
+import org.eclipse.ui.part.ISetSelectionTarget;
+
+public class HdlShowInNavigatorAction extends  AbstractAction {
+	private static final String SHOW_IN_NAVIGATOR_ACTION_IMAGE="$nl$/icons/nav.gif";
+	public static final String ID="ShowInNavigator";
+	
+	public HdlShowInNavigatorAction() {
+		super(ID);		
+	}
+	
+	/**
+	 * Gets the current active page
+	 * @return
+	 */
+	protected IWorkbenchPage getPage(){
+		IWorkbenchPage page=PlatformUI.getWorkbench()
+				.getActiveWorkbenchWindow().getActivePage();
+		
+		return page;
+	}
+
+	@Override
+	public void run() {
+		IWorkbenchPage page = getPage();
+
+		if (page == null) {
+			return;
+		}
+
+		try {
+			IViewPart view = page.showView(IPageLayout.ID_RES_NAV);
+			if (view instanceof ISetSelectionTarget) {
+				IFile file=getThisEditor().getHdlDocument().getFile();
+				if(file != null){
+					ISelection selection = new StructuredSelection(file);
+					((ISetSelectionTarget) view).selectReveal(selection);
+				}
+			}
+		} catch (PartInitException e) {
+
+		}
+	}
+	
+	public ImageDescriptor getImageDescriptor(){		
+		return VerilogPlugin.getPlugin().getImageDescriptor(SHOW_IN_NAVIGATOR_ACTION_IMAGE);
+	}
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/actions/OpenDeclarationAction.java vdt/src/com/elphel/vdt/veditor/actions/OpenDeclarationAction.java
--- vdt-veditor/src/com/elphel/vdt/veditor/actions/OpenDeclarationAction.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/actions/OpenDeclarationAction.java	2016-06-24 10:29:40.816496628 -0600
@@ -1,219 +1,218 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.actions;
-
-import java.util.Vector;
-
-import net.sourceforge.veditor.VerilogPlugin;
-import net.sourceforge.veditor.document.HdlDocument;
-import net.sourceforge.veditor.editor.HdlEditor;
-import net.sourceforge.veditor.parser.OutlineDatabase;
-import net.sourceforge.veditor.parser.OutlineElement;
-import net.sourceforge.veditor.parser.vhdl.VhdlOutlineElementFactory.ArchitectureElement;
-import net.sourceforge.veditor.parser.vhdl.VhdlOutlineElementFactory.PackageDeclElement;
-
-import org.eclipse.jface.resource.ImageDescriptor;
-import org.eclipse.jface.resource.JFaceResources;
-import org.eclipse.swt.SWT;
-import org.eclipse.swt.custom.StyledText;
-import org.eclipse.swt.events.FocusEvent;
-import org.eclipse.swt.events.FocusListener;
-import org.eclipse.swt.events.SelectionEvent;
-import org.eclipse.swt.events.SelectionListener;
-import org.eclipse.swt.graphics.Point;
-import org.eclipse.swt.layout.GridData;
-import org.eclipse.swt.layout.GridLayout;
-import org.eclipse.swt.widgets.Shell;
-import org.eclipse.swt.widgets.Table;
-import org.eclipse.swt.widgets.TableItem;
-import org.eclipse.ui.IEditorSite;
-
-
-/**
- * find module declaration from project tree<p>
- * file name and module name must be same
- */
-public class OpenDeclarationAction extends AbstractAction
-{
-	Shell m_ProposalShell;
-	Table m_ProposalTable;
-	private static final String GOTO_DEF_ACTION_IMAGE="$nl$/icons/goto_def.gif";
-	
-	public OpenDeclarationAction()
-	{
-		super("OpenDeclaration");
-		m_ProposalShell=null;
-	}
-	public void run()
-	{
-//		StyledText widget = getViewer().getTextWidget();
-//
-//		String modName = widget.getSelectionText();
-//		if (modName.equals(""))
-//		{
-//			beep();
-//			return;
-//		}
-//		getEditor().openPage(modName);
-		
-		gotoDefinition();
-	}
-	
-	public ImageDescriptor getImageDescriptor(){
-		return VerilogPlugin.getPlugin().getImageDescriptor(GOTO_DEF_ACTION_IMAGE);
-	}
-	
-	private class focusListener implements FocusListener{
-
-		public void focusGained(FocusEvent e) {
-			
-		}
-
-		public void focusLost(FocusEvent e) {
-			m_ProposalShell.setVisible(false);
-		}
-		
-	}
-	
-	private class selectionListener implements SelectionListener{
-
-		public void widgetDefaultSelected(SelectionEvent e) {
-			// TODO Auto-generated method stub
-			
-		}
-
-		public void widgetSelected(SelectionEvent e) {
-			
-			if (e.item instanceof TableItem) {
-				TableItem tableItem = (TableItem) e.item;
-				if (tableItem.getData() instanceof OutlineElement) {
-					OutlineElement element = (OutlineElement) tableItem.getData();
-					getEditor().showElement(element);
-				}
-			}
-			m_ProposalShell.setVisible(false);
-		}
-		
-	}
-	
-	private void showPopUp(Vector<OutlineElement> definitionList,HdlEditor editor,Point position){	
-		IEditorSite control=editor.getEditorSite();
-		
-		if(m_ProposalShell == null){
-			m_ProposalShell= new Shell(control.getShell(), SWT.ON_TOP);
-			m_ProposalShell.setFont(JFaceResources.getDefaultFont());
-			GridLayout layout= new GridLayout();
-			layout.marginWidth= 0;
-			layout.marginHeight= 0;
-			layout.verticalSpacing= 1;		
-			m_ProposalShell.setLayout(layout);		
-			m_ProposalTable= new Table(m_ProposalShell, SWT.H_SCROLL | SWT.V_SCROLL);
-			m_ProposalTable.setLocation(0, 0);
-			GridData data= new GridData(GridData.FILL_BOTH);
-			m_ProposalTable.setLayoutData(data);
-			Point size= new Point(200,200);
-			m_ProposalShell.setSize(size);
-			m_ProposalTable.setSize(size);
-			m_ProposalTable.addFocusListener(new focusListener());
-			m_ProposalTable.addSelectionListener(new selectionListener());		
-		}
-		m_ProposalTable.setItemCount(definitionList.size());		
-		TableItem[] tableItem=m_ProposalTable.getItems();
-		for(int i=0;i<tableItem.length;i++){
-			tableItem[i].setText(definitionList.get(i).getName());
-			String imageName=definitionList.get(i).GetImageName();
-			if(imageName!=null){
-				tableItem[i].setImage(VerilogPlugin.getPlugin().getImage(imageName));
-			}
-			tableItem[i].setData(definitionList.get(i));
-		}		
-				
-		m_ProposalShell.setLocation(position);
-		m_ProposalShell.setVisible(true);
-		m_ProposalTable.setFocus();		
-	
-	}
-	
-	/**
-	 * Attempts to find the definition for the highlighted word
-	 */
-	public void gotoDefinition(){
-		HdlEditor   editor= getEditor();
-		HdlDocument doc   = editor.getHdlDocument();
-		StyledText widget = getViewer().getTextWidget();
-		String selectionText = widget.getSelectionText();
-		Point  selectionRange = widget.getSelection();
-		Point  selectionPos   = widget.getLocationAtOffset(selectionRange.y);
-
-		Vector<OutlineElement> definitionList=
-			doc.getDefinitionList(selectionText,selectionRange.x);
-		
-
-		//go to the definition
-		if(definitionList.size() == 1){
-			editor.showElement(definitionList.get(0));
-		}
-		else if(definitionList.size() > 1){
-			for(int i = 0; i < definitionList.size(); i++)
-			{
-				OutlineElement element = definitionList.get(i);
-				if (element.getType().equals("module#"))
-				{
-					editor.showElement(element);
-					return;
-				}
-			}
-			
-			// if module is not found, show popup
-			showPopUp(definitionList, editor, selectionPos);
-		} else { // not found in this file, search in packages of other files
-			OutlineDatabase database = doc.getOutlineDatabase();	
-			if (database != null) {
-				OutlineElement[] elements = database.findTopLevelElements("");
-				for (int i = 0; i < elements.length; i++) {
-					if(elements[i] instanceof PackageDeclElement ){
-						OutlineElement[] subPackageElements=elements[i].getChildren();
-						for(int j=0; j< subPackageElements.length; j++){
-							if ( subPackageElements[j].getName()
-											.equalsIgnoreCase(selectionText)) {
-								editor.showElement(subPackageElements[j]);
-
-							}
-						}
-					}
-					// jump to architecture
-					 if(elements[i] instanceof ArchitectureElement ){
-						 ArchitectureElement architureElement =(ArchitectureElement)elements[i];
-						 if(architureElement.GetEntityName().equalsIgnoreCase(selectionText)){
-							 editor.showElement(architureElement);
-						 }
-					 }
-					 
-					 if(elements[i] instanceof PackageDeclElement ){
-						 PackageDeclElement packageDeclElement = (PackageDeclElement)elements[i];
-						 if (packageDeclElement.getName().equalsIgnoreCase(selectionText)) {
-							 editor.showElement(packageDeclElement);
-						 }
-					 }
-				
-				}	
-
-			}
-
-			return ;
-		}
-	
-		
-	}
-}
-
-
-
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.actions;
+
+import java.util.Vector;
+
+import com.elphel.vdt.veditor.VerilogPlugin;
+import com.elphel.vdt.veditor.document.HdlDocument;
+import com.elphel.vdt.veditor.editor.HdlEditor;
+import com.elphel.vdt.veditor.parser.OutlineDatabase;
+import com.elphel.vdt.veditor.parser.OutlineElement;
+import com.elphel.vdt.veditor.parser.vhdl.VhdlOutlineElementFactory.ArchitectureElement;
+import com.elphel.vdt.veditor.parser.vhdl.VhdlOutlineElementFactory.PackageDeclElement;
+
+import org.eclipse.jface.resource.ImageDescriptor;
+import org.eclipse.jface.resource.JFaceResources;
+import org.eclipse.jface.text.TextSelection;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.FocusEvent;
+import org.eclipse.swt.events.FocusListener;
+import org.eclipse.swt.events.SelectionEvent;
+import org.eclipse.swt.events.SelectionListener;
+import org.eclipse.swt.graphics.Point;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Shell;
+import org.eclipse.swt.widgets.Table;
+import org.eclipse.swt.widgets.TableItem;
+import org.eclipse.ui.IEditorSite;
+import org.eclipse.ui.PlatformUI;
+
+
+/**
+ * find module declaration from project tree<p>
+ * file name and module name must be same
+ */
+public class OpenDeclarationAction extends AbstractAction
+{
+	Shell m_ProposalShell;
+	Table m_ProposalTable;
+	private static final String GOTO_DEF_ACTION_IMAGE="$nl$/icons/goto_def.gif";
+	
+	public OpenDeclarationAction()
+	{
+		super("OpenDeclaration");
+		m_ProposalShell=null;
+	}
+	public void run()
+	{
+		gotoDefinition();
+	}
+	
+	public ImageDescriptor getImageDescriptor(){
+		return VerilogPlugin.getPlugin().getImageDescriptor(GOTO_DEF_ACTION_IMAGE);
+	}
+	
+	private class focusListener implements FocusListener{
+
+		public void focusGained(FocusEvent e) {
+			
+		}
+
+		public void focusLost(FocusEvent e) {
+			m_ProposalShell.setVisible(false);
+		}
+		
+	}
+	
+	private class selectionListener implements SelectionListener{
+
+		public void widgetDefaultSelected(SelectionEvent e) {
+			// TODO Auto-generated method stub
+			
+		}
+
+		public void widgetSelected(SelectionEvent e) {
+			
+			if (e.item instanceof TableItem) {
+				TableItem tableItem = (TableItem) e.item;
+				if (tableItem.getData() instanceof OutlineElement) {
+					OutlineElement element = (OutlineElement) tableItem.getData();
+					getThisEditor().showElement(element);
+				}
+			}
+			m_ProposalShell.setVisible(false);
+		}
+		
+	}
+	
+	private void showPopUp(Vector<OutlineElement> definitionList,HdlEditor editor,Point position){	
+		IEditorSite control=editor.getEditorSite();
+		
+		if(m_ProposalShell == null){
+			m_ProposalShell= new Shell(control.getShell(), SWT.ON_TOP);
+			m_ProposalShell.setFont(JFaceResources.getDefaultFont());
+			GridLayout layout= new GridLayout();
+			layout.marginWidth= 0;
+			layout.marginHeight= 0;
+			layout.verticalSpacing= 1;		
+			m_ProposalShell.setLayout(layout);		
+			m_ProposalTable= new Table(m_ProposalShell, SWT.H_SCROLL | SWT.V_SCROLL);
+			m_ProposalTable.setLocation(0, 0);
+			GridData data= new GridData(GridData.FILL_BOTH);
+			m_ProposalTable.setLayoutData(data);
+			Point size= new Point(200,200);
+			m_ProposalShell.setSize(size);
+			m_ProposalTable.setSize(size);
+			m_ProposalTable.addFocusListener(new focusListener());
+			m_ProposalTable.addSelectionListener(new selectionListener());		
+		}
+		m_ProposalTable.setItemCount(definitionList.size());		
+		TableItem[] tableItem=m_ProposalTable.getItems();
+		for(int i=0;i<tableItem.length;i++){
+			tableItem[i].setText(definitionList.get(i).getName());
+			String imageName=definitionList.get(i).GetImageName();
+			if(imageName!=null){
+				tableItem[i].setImage(VerilogPlugin.getPlugin().getImage(imageName));
+			}
+			tableItem[i].setData(definitionList.get(i));
+		}		
+				
+		m_ProposalShell.setLocation(position);
+		m_ProposalShell.setVisible(true);
+		m_ProposalTable.setFocus();		
+	
+	}
+	
+	/**
+	 * Attempts to find the definition for the highlighted word
+	 */
+	public void gotoDefinition(){
+        TextSelection textSelection = (TextSelection) PlatformUI.getWorkbench().getActiveWorkbenchWindow().getSelectionService().getSelection();
+        String selectionText =        textSelection.getText();
+        int selectionOffset =         textSelection.getOffset();
+        Point cursorCoordinates =     PlatformUI.getWorkbench().getDisplay().getCursorLocation();
+
+        //HdlEditor   editor= getThisEditor(); // May point to last loaded include file, not the window/tab source
+        HdlEditor   editor= getThisEditor();
+		HdlDocument doc   = editor.getHdlDocument();
+        Vector<OutlineElement> definitionList = doc.getDefinitionList(selectionText,selectionOffset);
+		
+
+		//go to the definition
+		if(definitionList.size() == 1){
+			editor.showElement(definitionList.get(0));
+		}
+		else if(definitionList.size() > 1){
+			for(int i = 0; i < definitionList.size(); i++)
+			{
+				OutlineElement element = definitionList.get(i);
+				if (element.getType().equals("module#"))
+				{
+					editor.showElement(element);
+					return;
+				}
+			}
+			
+			// if module is not found, show popup
+			showPopUp(definitionList, editor, cursorCoordinates);
+		} else { // not found in this file, search in packages of other files
+			OutlineDatabase database = doc.getOutlineDatabase();	
+			if (database != null) {
+				OutlineElement[] elements = database.findTopLevelElements("");
+				for (int i = 0; i < elements.length; i++) {
+					if(elements[i] instanceof PackageDeclElement ){
+						OutlineElement[] subPackageElements=elements[i].getChildren();
+						for(int j=0; j< subPackageElements.length; j++){
+							if ( subPackageElements[j].getName()
+											.equalsIgnoreCase(selectionText)) {
+								editor.showElement(subPackageElements[j]);
+
+							}
+						}
+					}
+					// jump to architecture
+					 if(elements[i] instanceof ArchitectureElement ){
+						 ArchitectureElement architureElement =(ArchitectureElement)elements[i];
+						 if(architureElement.GetEntityName().equalsIgnoreCase(selectionText)){
+							 editor.showElement(architureElement);
+						 }
+					 }
+					 
+					 if(elements[i] instanceof PackageDeclElement ){
+						 PackageDeclElement packageDeclElement = (PackageDeclElement)elements[i];
+						 if (packageDeclElement.getName().equalsIgnoreCase(selectionText)) {
+							 editor.showElement(packageDeclElement);
+						 }
+					 }
+				
+				}	
+
+			}
+			return ;
+		}
+	}
+}
+
+
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/actions/ShowInHierarchy.java vdt/src/com/elphel/vdt/veditor/actions/ShowInHierarchy.java
--- vdt-veditor/src/com/elphel/vdt/veditor/actions/ShowInHierarchy.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/actions/ShowInHierarchy.java	2016-06-24 10:29:40.816496628 -0600
@@ -1,32 +1,43 @@
-/*******************************************************************************
- * Copyright (c) 2006 Ali Ghorashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    Ali Ghorashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.actions;
-
-import net.sourceforge.veditor.VerilogPlugin;
-
-import org.eclipse.jface.resource.ImageDescriptor;
-
-public class ShowInHierarchy extends AbstractAction {
-	private static final String SHOW_IN_HIERARCHY_ACTION_IMAGE="$nl$/icons/hierarchy.gif";
-	public ShowInHierarchy() {
-		super("ShowInHierarchy");		
-	}
-
-	@Override
-	public void run() {
-		getEditor().showInHierarchy();
-
-	}
-	public ImageDescriptor getImageDescriptor(){
-		return VerilogPlugin.getPlugin().getImageDescriptor(SHOW_IN_HIERARCHY_ACTION_IMAGE);
-	}
-
-}
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2006 Ali Ghorashi and others.
+ *
+ * Contributors:
+ *    Ali Ghorashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.actions;
+
+import com.elphel.vdt.veditor.VerilogPlugin;
+
+import org.eclipse.jface.resource.ImageDescriptor;
+
+public class ShowInHierarchy extends AbstractAction {
+	private static final String SHOW_IN_HIERARCHY_ACTION_IMAGE="$nl$/icons/hierarchy.gif";
+	public ShowInHierarchy() {
+		super("ShowInHierarchy");		
+	}
+
+	@Override
+	public void run() {
+		getThisEditor().showInHierarchy();
+
+	}
+	public ImageDescriptor getImageDescriptor(){
+		return VerilogPlugin.getPlugin().getImageDescriptor(SHOW_IN_HIERARCHY_ACTION_IMAGE);
+	}
+
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/actions/ShowInOutline.java vdt/src/com/elphel/vdt/veditor/actions/ShowInOutline.java
--- vdt-veditor/src/com/elphel/vdt/veditor/actions/ShowInOutline.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/actions/ShowInOutline.java	2016-06-24 10:29:40.816496628 -0600
@@ -1,32 +1,43 @@
-/*******************************************************************************
- * Copyright (c) 2006 Ali Ghorashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    Ali Ghorashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.actions;
-
-import net.sourceforge.veditor.VerilogPlugin;
-
-import org.eclipse.jface.resource.ImageDescriptor;
-
-public class ShowInOutline extends AbstractAction {
-	private static final String SHOW_IN_OUTLINE_ACTION_IMAGE="$nl$/icons/outline.gif";
-	public ShowInOutline() {
-		super("ShowInOutline");		
-	}
-
-	@Override
-	public void run() {
-		getEditor().showInOutline();
-
-	}
-	public ImageDescriptor getImageDescriptor(){
-		return VerilogPlugin.getPlugin().getImageDescriptor(SHOW_IN_OUTLINE_ACTION_IMAGE);
-	}
-
-}
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2006 Ali Ghorashi and others.
+ *
+ * Contributors:
+ *    Ali Ghorashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.actions;
+
+import com.elphel.vdt.veditor.VerilogPlugin;
+
+import org.eclipse.jface.resource.ImageDescriptor;
+
+public class ShowInOutline extends AbstractAction {
+	private static final String SHOW_IN_OUTLINE_ACTION_IMAGE="$nl$/icons/outline.gif";
+	public ShowInOutline() {
+		super("ShowInOutline");		
+	}
+
+	@Override
+	public void run() {
+		getThisEditor().showInOutline();
+
+	}
+	public ImageDescriptor getImageDescriptor(){
+		return VerilogPlugin.getPlugin().getImageDescriptor(SHOW_IN_OUTLINE_ACTION_IMAGE);
+	}
+
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/actions/SynthesizeAction.java vdt/src/com/elphel/vdt/veditor/actions/SynthesizeAction.java
--- vdt-veditor/src/com/elphel/vdt/veditor/actions/SynthesizeAction.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/actions/SynthesizeAction.java	2016-06-24 10:29:40.816496628 -0600
@@ -1,4 +1,4 @@
-package net.sourceforge.veditor.actions;
+package com.elphel.vdt.veditor.actions;
 
 public class SynthesizeAction extends CompileAction {
 	
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/actions/UnCommentAction.java vdt/src/com/elphel/vdt/veditor/actions/UnCommentAction.java
--- vdt-veditor/src/com/elphel/vdt/veditor/actions/UnCommentAction.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/actions/UnCommentAction.java	2016-06-24 10:29:40.816496628 -0600
@@ -1,67 +1,78 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    Ali Ghorashi - initial implementation
- *******************************************************************************/
-package net.sourceforge.veditor.actions;
-
-import net.sourceforge.veditor.editor.VerilogEditor;
-import net.sourceforge.veditor.editor.VhdlEditor;
-
-import org.eclipse.swt.custom.StyledText;
-import org.eclipse.swt.graphics.Point;
-
-import java.util.regex.*;
-
-
-/**
- * find module declaration from project tree<p>
- * file name and module name must be same
- */
-public class UnCommentAction extends AbstractAction
-{
-	public UnCommentAction()
-	{
-		super("Uncomment");
-	}
-	public void run()
-	{
-		StyledText widget = getViewer().getTextWidget();
-		Point point = widget.getSelection();
-		int begin = point.x;
-		int end = point.y;
-		String commentString="//";
-		
-		//get some vitals on the selection
-		int StartingLine = widget.getLineAtOffset(begin);		
-		begin = widget.getOffsetAtLine(StartingLine);
-		
-		String region = widget.getTextRange(begin, end-begin);
-		
-		//are we using VHDL or verilog
-		if(getEditor() instanceof VhdlEditor){
-			commentString="--";
-		}
-		else if (getEditor() instanceof VerilogEditor){
-			commentString="//";
-		}
-		else{
-			Error e=new Error("Unkown file type");
-			throw e;
-		}
-		
-		//remove the comment field from the beginning of the line
-		region = Pattern.compile("^"+commentString,Pattern.MULTILINE).matcher(region).replaceAll("");
-		
-		//replace the selection
-		widget.replaceTextRange(begin, end - begin, region.toString());
-	}
-}
-
-
-
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    Ali Ghorashi - initial implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.actions;
+
+import com.elphel.vdt.veditor.editor.VerilogEditor;
+import com.elphel.vdt.veditor.editor.VhdlEditor;
+
+import org.eclipse.swt.custom.StyledText;
+import org.eclipse.swt.graphics.Point;
+
+import java.util.regex.*;
+
+
+/**
+ * find module declaration from project tree<p>
+ * file name and module name must be same
+ */
+public class UnCommentAction extends AbstractAction
+{
+	public UnCommentAction()
+	{
+		super("Uncomment");
+	}
+	public void run()
+	{
+		StyledText widget = getViewer().getTextWidget();
+		Point point = widget.getSelection();
+		int begin = point.x;
+		int end = point.y;
+		String commentString="//";
+		
+		//get some vitals on the selection
+		int StartingLine = widget.getLineAtOffset(begin);		
+		begin = widget.getOffsetAtLine(StartingLine);
+		
+		String region = widget.getTextRange(begin, end-begin);
+		
+		//are we using VHDL or verilog
+		if(getThisEditor() instanceof VhdlEditor){
+			commentString="--";
+		}
+		else if (getThisEditor() instanceof VerilogEditor){
+			commentString="//";
+		}
+		else{
+			Error e=new Error("Unkown file type");
+			throw e;
+		}
+		
+		//remove the comment field from the beginning of the line
+		region = Pattern.compile("^"+commentString,Pattern.MULTILINE).matcher(region).replaceAll("");
+		
+		//replace the selection
+		widget.replaceTextRange(begin, end - begin, region.toString());
+	}
+}
+
+
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/actions/VerilogFormatAction.java vdt/src/com/elphel/vdt/veditor/actions/VerilogFormatAction.java
--- vdt-veditor/src/com/elphel/vdt/veditor/actions/VerilogFormatAction.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/actions/VerilogFormatAction.java	2016-06-24 10:29:40.816496628 -0600
@@ -1,748 +1,759 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.actions;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import net.sourceforge.veditor.VerilogPlugin;
-
-import org.eclipse.swt.custom.StyledText;
-import org.eclipse.swt.graphics.Point;
-
-/**
- * format region action (Verilog only now)
- * 
- * preference
- *   indent character
- *       tab
- *       n white spaces
- *   indent rule
- *       begin/end, fork/join, generate/endgenerate,
- *       if, for, while, repeat
- *       case, ":",
- *       port list, parameter list,
- *       wrapped expression
- *   white space rule(before and after)
- *       binary operator, unary operator, conditional operator,
- *       assign, comma, (), [], {}
- *       ":"(MSB:LSB), ";"(end of statement)
- *       if, for, while, repeat
- *   context
- *       begin/end, in [], in {}
- */
-
-public class VerilogFormatAction extends AbstractAction {
-	// preference
-	private String indentString = "\t";
-	private boolean noSpaceInBracket = true;
-	private boolean spaceBeforeOperator2 = true;
-	private boolean spaceAfterOperator2 = true;
-	private boolean spaceBeforeOperator1 = false;
-	private boolean spaceAfterOperator1 = false;
-	private boolean spaceBeforeComma = false;
-	private boolean spaceAfterComma = true;
-	private boolean spaceBeforeSemicolon = false;
-	private boolean spaceBeforeOpenParen = false;
-	private boolean spaceAfterOpenParen = false;
-	private boolean spaceBeforeCloseParen = false;
-	private boolean spaceBeforeOpenBracket = false;
-	private boolean spaceAfterOpenBracket = false;
-	private boolean spaceBeforeCloseBracket = false;
-	private boolean spaceBeforeOpenBrace = false;
-	private boolean spaceAfterOpenBrace = false;
-	private boolean spaceBeforeCloseBrace = false;
-	private boolean spaceBeforeCaseColon = false;
-	private boolean spaceAfterCaseColon = true;
-	private boolean spaceAfterIf = true;
-	private boolean spaceAfterFor = true;
-	private boolean spaceAfterWhile = true;
-	private boolean spaceAfterRepeat = true;
-
-	// context flag
-	private static final int CONTEXT_NORMAL = 1;
-	private static final int CONTEXT_BRACKET = 2;
-	private static final int CONTEXT_ALL = CONTEXT_NORMAL | CONTEXT_BRACKET;
-	
-	// space operation flag
-	private static final int SP_NOCARE = 0;
-	private static final int SP_1 = 1;
-	private static final int SP_0 = 2;
-	private static final int SP_MULTI = 3;
-	
-	private TokenAnalyzer analyzer = new TokenAnalyzer();
-	private StringBuffer dst = new StringBuffer();
-	private String indent;
-	private int reservedSpace;
-	private boolean afterNewLine;
-
-	public VerilogFormatAction()
-	{
-		super("VerilogFormatAction");
-	}
-	
-	private void setup()
-	{
-		loadPreference();
-
-		String operators2[] = {"+", "-", "*", "/", "%", "&", "|", "^", "&&",
-				"||", "<<", ">>", "==", "!=", "===", "!==", "<", ">", "<=",
-				">=", "?", ":", "=", "<="};
-		for (int i = 0; i < operators2.length; i++)
-		{
-			appendTokenRule(operators2[i], spaceBeforeOperator2,
-					spaceAfterOperator2);
-		}
-
-		String operators1[] = { "!", "~" };
-		for (int i = 0; i < operators1.length; i++)
-		{
-			appendTokenRule(operators1[i], spaceBeforeOperator1,
-					spaceAfterOperator1);
-		}
-
-		appendTokenRule(",", spaceBeforeComma, spaceAfterComma);
-		appendTokenRule(";", spaceBeforeSemicolon, true);
-
-		appendTokenRule("(", spaceBeforeOpenParen, spaceAfterOpenParen);
-		appendTokenRule(")", spaceBeforeCloseParen, false);
-		
-		appendTokenRule("[", spaceBeforeOpenBracket, spaceAfterOpenBracket);
-		appendTokenRule("]", spaceBeforeCloseBracket, false);
-		
-		appendTokenRule("{", spaceBeforeOpenBrace, spaceAfterOpenBrace);
-		appendTokenRule("}", spaceBeforeCloseBrace, false);
-		
-		analyzer.appendToken(".", SP_0, SP_0);
-		analyzer.appendToken("//", SP_MULTI, SP_MULTI);
-
-		appendWordRule("if", spaceAfterIf);
-		appendWordRule("for", spaceAfterFor);
-		appendWordRule("while", spaceAfterWhile);
-		appendWordRule("repeat", spaceAfterRepeat);
-		
-		analyzer.appendToken("begin", SP_1, SP_1);
-		analyzer.appendToken("end", SP_1, SP_1);
-		analyzer.appendToken("fork", SP_1, SP_1);
-		analyzer.appendToken("join", SP_1, SP_1);
-		analyzer.appendToken("else", SP_1, SP_1);
-	}
-	
-	private void loadPreference()
-	{
-		String indent = VerilogPlugin.getPreferenceString("Style.indent");
-		if (indent.equals("Tab"))
-			indentString = "\t";
-		else
-		{
-			String size = VerilogPlugin.getPreferenceString("Style.indentSize");
-			int n = Integer.parseInt(size);
-			StringBuffer buf = new StringBuffer(n);
-			for(int i = 0; i < n; i++)
-				buf.append(' ');
-			indentString = buf.toString();
-		}
-		
-		noSpaceInBracket = getSpacePreference("Style.noSpaceInBracket");
-		
-		spaceBeforeOperator2 = getSpacePreference("Style.spaceAfterOperator2");
-		spaceAfterOperator2 = getSpacePreference("Style.spaceAfterOperator2");
-		spaceBeforeOperator1 = getSpacePreference("Style.spaceBeforeOperator1");
-		spaceAfterOperator1 = getSpacePreference("Style.spaceAfterOperator1");
-		spaceBeforeComma = getSpacePreference("Style.spaceBeforeComma");
-		spaceAfterComma = getSpacePreference("Style.spaceAfterComma");
-		spaceBeforeSemicolon = getSpacePreference("Style.spaceBeforeSemicolon");
-		spaceBeforeOpenParen = getSpacePreference("Style.spaceBeforeOpenParen");
-		spaceAfterOpenParen = getSpacePreference("Style.spaceAfterOpenParen");
-		spaceBeforeCloseParen = getSpacePreference("Style.spaceBeforeCloseParen");
-		spaceBeforeOpenBracket = getSpacePreference("Style.spaceBeforeOpenBracket");
-		spaceAfterOpenBracket = getSpacePreference("Style.spaceAfterOpenBracket");
-		spaceBeforeCloseBracket = getSpacePreference("Style.spaceBeforeCloseBracket");
-		spaceBeforeOpenBrace = getSpacePreference("Style.spaceBeforeOpenBrace");
-		spaceAfterOpenBrace = getSpacePreference("Style.spaceAfterOpenBrace");
-		spaceBeforeCloseBrace = getSpacePreference("Style.spaceBeforeCloseBrace");
-		spaceBeforeCaseColon = getSpacePreference("Style.spaceBeforeCaseColon");
-		spaceAfterCaseColon = getSpacePreference("Style.spaceAfterCaseColon");
-		spaceAfterIf = getSpacePreference("Style.spaceAfterIf");
-		spaceAfterFor = getSpacePreference("Style.spaceAfterFor");
-		spaceAfterWhile = getSpacePreference("Style.spaceAfterWhile");
-		spaceAfterRepeat = getSpacePreference("Style.spaceAfterRepeat");
-	}
-	
-	private boolean getSpacePreference(String name)
-	{
-		return VerilogPlugin.getPreferenceBoolean(name);
-	}
-	
-	private void appendTokenRule(String word, boolean b, boolean a)
-	{
-		int before = b ? SP_1 : SP_0;
-		int after = a ? SP_1 : SP_0;
-		analyzer.appendToken(word, before, after, CONTEXT_NORMAL);
-		if (noSpaceInBracket)
-			analyzer.appendToken(word, SP_0, SP_0, CONTEXT_BRACKET);
-		else
-			analyzer.appendToken(word, before, after, CONTEXT_BRACKET);
-	}
-
-	private void appendWordRule(String word, boolean a)
-	{
-		int after = a ? SP_1 : SP_0;
-		analyzer.appendToken(word, SP_NOCARE, after);
-	}
-
-	public void run()
-	{
-		setup();
-
-		StyledText widget = getViewer().getTextWidget();
-
-		Point point = widget.getSelection();
-		int begin = point.x;
-		int end = point.y;
-		
-		//if nothing is selected
-		if(begin == end){
-			return;
-		}
-		
-		// begin index must be top of line
-		int line = widget.getLineAtOffset(begin);
-		begin = widget.getOffsetAtLine(line);
-		String region = widget.getText(begin, end - 1);
-
-		indent = getIndent(widget, begin);
-
-		// initialize instance variable
-		dst.setLength(0);
-		reservedSpace = SP_NOCARE;
-		afterNewLine = true;
-
-		analyzer.setText(region);
-		analyzer.next();
-
-		while(!analyzer.isEos())
-		{
-			execRegion(0);
-		}
-		dst.append(analyzer.getSpace());
-
-		widget.replaceTextRange(begin, end - begin, dst.toString());
-	}
-	
-	private void execRegion(int level)
-	{
-		boolean isStart = true;
-		while (!analyzer.isEos())
-		{
-			String word = analyzer.getWord();
-			if (isBlockBegin(word))
-			{
-				execToken(level);
-				execBlock(level+1);
-				break;
-			}
-			else if (isCaseBegin(word))
-			{
-				execCase(level);
-				break;
-			}
-			else if (word.equals("if"))
-			{
-				execIf(level);
-				break;
-			}
-			else if (word.equals("while") || word.equals("repeat") || word.equals("for"))
-			{
-				execToken(level);
-				execParen(level);
-				execStatement(level);
-				break;
-			}
-			else if (word.equals("reg") || word.equals("wire"))
-			{
-				execDeclaration(level);
-				break;
-			}
-			else if (word.equals(";"))
-			{
-				execToken(level);
-				break;
-			}
-
-			if (isStart)
-				execToken(level);
-			else
-				execToken(level + 1);	// line break causes indent
-			
-			isStart = false;
-		}
-	}
-
-	private void execBlock(int level)
-	{
-		while (!analyzer.isEos())
-		{
-			if (isBlockEnd(analyzer.getWord()))
-			{
-				execToken(level - 1);
-				break;
-			}
-			if (analyzer.equalsToCurrent(":"))
-			{
-				execToken(level);	// :
-				execToken(level);	// label
-			}
-			execRegion(level);
-		}
-	}
-	
-	private void execIf(int level)
-	{
-		execToken(level);	// if
-		execParen(level);	// (...)
-		
-		execStatement(level);
-		if (analyzer.equalsToCurrent("else"))
-		{
-			execToken(level);
-			if (isCaseBegin(analyzer.getWord()))
-				execCase(level);  // exception for "else case"
-			else if (analyzer.equalsToCurrent("if"))
-				execIf(level);  // exception for "else if"
-			else
-				execStatement(level);
-		}
-	}
-	private void execCase(int level)
-	{
-		execToken(level);	// case
-		execParen(level+1);	// (...)
-		
-		while (!isCaseEnd(analyzer.getWord()) && !analyzer.isEos())
-		{
-			while (!analyzer.equalsToCurrent(":") && !analyzer.isEos())
-			{
-				execToken(level + 1);
-			}
-
-			int before = spaceBeforeCaseColon ? SP_1 : SP_0;
-			int after = spaceAfterCaseColon ? SP_1 : SP_0;
-			analyzer.modifySpace(before, after);
-			execToken(level); // :
-			execStatement(level + 1);
-		}
-		execToken(level); // endcase
-	}
-
-	private void execParen(int level)
-	{
-		execToken(level); // (
-
-		int paren = 1;
-		while (paren >= 1 && !analyzer.isEos())
-		{
-			if (analyzer.equalsToCurrent("("))
-				paren++;
-			if (analyzer.equalsToCurrent(")"))
-				paren--;
-			execToken(level + paren);
-		}
-	}
-
-	private void execStatement(int level)
-	{
-		if (isBlockBegin(analyzer.getWord()))
-		{
-			execToken(level);
-			execBlock(level + 1);
-		}
-		else
-			execRegion(level + 1);
-	}
-	
-	private void execDeclaration(int level)
-	{
-		execToken(level); // reg/wire
-		if (analyzer.equalsToCurrent("["))
-		{
-			execToken(level + 1);
-			while (!analyzer.equalsToCurrent("]") && !analyzer.isEos())
-			{
-				execToken(level + 1);
-			}
-			execToken(level);	// "]"
-		}
-		reservedSpace = SP_1;
-		execRegion(level + 1);
-	}
-
-	private int execToken(int level)
-	{
-		String word = analyzer.getWord();
-
-		if (afterNewLine)
-		{
-			dst.append(indent);
-			for (int i = 0; i < level; i++)
-				dst.append(indentString);
-		}
-		else
-		{
-			int beforeSpace = analyzer.getBeforeSpace();
-			if (reservedSpace == SP_MULTI || beforeSpace == SP_MULTI)
-				dst.append(analyzer.getSpace());
-			else if (reservedSpace == SP_1 || beforeSpace == SP_1)
-				dst.append(" ");
-			else if (reservedSpace == SP_0 || beforeSpace == SP_0)
-				; // append no space
-			else
-				dst.append(analyzer.getSpace());
-		}
-		dst.append(word);
-		reservedSpace = analyzer.getAfterSpace();
-		afterNewLine = false;
-
-		analyzer.next();
-		word = analyzer.getWord();
-		while (word.equals("\r") || word.equals("\n") || word.equals("//"))
-		{
-			while (!word.equals("\n") && !analyzer.isEos())
-			{
-				dst.append(analyzer.getSpace());
-				dst.append(word);
-				analyzer.next();
-				word = analyzer.getWord();
-			}
-			dst.append("\n");
-			afterNewLine = true;
-			analyzer.next();
-			word = analyzer.getWord();
-		}
-		
-		return level;
-	}
-	private static String getIndent(StyledText widget, int pos)
-	{
-		String text = widget.getText().substring(pos);
-		for (int i = 0; i < text.length(); i++)
-		{
-			char c = text.charAt(i);
-			if (!isSpace(c))
-				return text.substring(0, i);
-		}
-		return text;
-	}
-	private static boolean isBlockBegin(String str)
-	{
-		return str.equals("begin") || str.equals("fork") || str.equals("generate");
-	}
-	private static boolean isBlockEnd(String str)
-	{
-		return str.equals("end") || str.equals("join") || str.equals("endgenerate");
-	}
-	private static boolean isCaseBegin(String str)
-	{
-		return str.equals("case") || str.equals("casex");
-	}
-	private static boolean isCaseEnd(String str)
-	{
-		return str.equals("endcase");
-	}
-	private static boolean isIdentChar(char ch)
-	{
-		return Character.isLetterOrDigit(ch) || ch == '_';
-	}
-	private static boolean isSpace(char c)
-	{
-		return c == ' ' || c == '\t';
-	}
-	
-	private static class TokenAnalyzer
-	{
-		private Map<TokenKey,Token> tokens = new HashMap<TokenKey,Token>();
-	
-		private int pos;
-		private String src;
-		private String space;
-		private int context;
-		private int nestingLevel;
-		private int afterSpace, beforeSpace;
-		private Token currentToken = new Token();
-		private TokenKey workKey = new TokenKey("");
-		
-		public TokenAnalyzer()
-		{
-		}
-		public void setText(String src)
-		{
-			this.src = src;
-			context = CONTEXT_NORMAL;
-			nestingLevel = 0;
-			pos = 0;
-			afterSpace = -1;
-			beforeSpace = -1;
-		}
-		public void next()
-		{
-			beforeSpace = -1;
-			afterSpace = -1;
-
-			if (skipSpace() == false)
-				return;
-
-			char c = src.charAt(pos);
-			if (c == '\"')
-			{
-				parseStringLiteral();
-				return;
-			}
-			
-			StringBuffer buf = new StringBuffer();
-			boolean ident = isIdentChar(c);
-			buf.append(c);
-			pos++;
-			
-			while (pos < src.length())
-			{
-				c = src.charAt(pos);
-				if (ident != isIdentChar(c))
-					break;
-				if (isSpace(c))
-					break;
-				buf.append(c);
-				pos++;
-			}
-			
-			if (ident == false)
-			{
-				// match longest token
-				StringBuffer remains = new StringBuffer();
-				while (buf.length() >= 2)
-				{
-					if (findToken(buf.toString()) != null)
-						break;
-					int len = buf.length() - 1;
-					remains.insert(0, buf.charAt(len));
-					buf.setLength(len);
-					pos--;
-				}
-			}
-			String word = buf.toString();
-			currentToken.set(word);
-			
-			if (word.equals("[") || word.equals("{"))
-				nestingLevel++;
-			if (word.equals("]") || word.equals("}"))
-				nestingLevel--;
-			if (nestingLevel == 0)
-				context = CONTEXT_NORMAL;
-			else
-				context = CONTEXT_BRACKET;
-		}
-		
-		private void parseStringLiteral()
-		{
-			StringBuffer buf = new StringBuffer();
-			buf.append('\"');
-			pos++ ;
-			while (pos < src.length())
-			{
-				char c = src.charAt(pos);
-				if (c == '\n' || c == '\r')
-					break;
-				buf.append(c);
-				pos++;
-				if (c == '\"')
-					break;
-			}
-			currentToken.set(buf.toString());
-		}
-		
-		private boolean skipSpace()
-		{
-			StringBuffer buf = new StringBuffer();
-			while (pos < src.length())
-			{
-				char c = src.charAt(pos);
-				if (isSpace(c))
-					buf.append(c);
-				else
-					break;
-				pos++;
-			}
-			space = buf.toString();
-			if (pos == src.length())
-			{
-				currentToken.set("");
-				return false;
-			}
-			return true;
-		}
-		public void modifySpace(int before, int after)
-		{
-			beforeSpace = before;
-			afterSpace = after;
-		}
-
-		public String getSpace()
-		{
-			return space;
-		}
-		public String getWord()
-		{
-			return currentToken.toString();
-		}
-		public int getBeforeSpace()
-		{
-			if (beforeSpace == -1)
-				return getToken().getBeforeSpace();
-			else
-				return beforeSpace;
-		}
-		public int getAfterSpace()
-		{
-			if (afterSpace == -1)
-				return getToken().getAfterSpace();
-			else
-				return afterSpace;
-		}
-		public boolean isEos()
-		{
-			return (pos >= src.length());
-		}
-		public boolean equalsToCurrent(Object obj)
-		{
-			return getWord().equals(obj);
-		}
-		
-		private Token getToken()
-		{
-			Token token = findToken(getWord());
-			if (token == null)
-				return currentToken;
-			else
-				return token;
-		}
-		private Token findToken(String word)
-		{
-			// workKey is used for avoiding "new"
-			workKey.set(word, context);
-			return tokens.get(workKey);
-		}
-		
-		public void appendToken(String word, int before, int after, int context)
-		{
-			TokenKey key = new TokenKey(word, context);
-			tokens.put(key, new Token(key, before, after));
-		}
-		public void appendToken(String word, int before, int after)
-		{
-			appendToken(word, before, after, CONTEXT_ALL);
-		}
-	}
-	
-	/**
-	 * Key for Token database
-	 * It can be used by HashMap
-	 */
-	private static class TokenKey
-	{
-		private String word;
-		private int context;
-		
-		public TokenKey(String word, int context)
-		{
-			this.word = word;
-			this.context = context;
-		}
-		public TokenKey(String word)
-		{
-			this(word, CONTEXT_ALL);
-		}
-		
-		public void set(String word, int context)
-		{
-			this.word = word;
-			this.context = context;
-		}
-		public void set(String word)
-		{
-			set(word, CONTEXT_ALL);
-		}
-
-		public String toString()
-		{
-			return word;
-		}
-		
-		public boolean equals(Object o)
-		{
-			if (o instanceof TokenKey)
-			{
-				TokenKey key = (TokenKey) o;
-				if (word.equals(key.word))
-				{
-					if ((context & key.context) != 0)
-						return true;
-					else
-						return false;
-				}
-				else
-					return false;
-			}
-			return false;
-		}
-
-		public int hashCode()
-		{
-			return word.hashCode();
-		}
-	}
-	
-	/**
-	 * Token for inserting/deleting white space
-	 */
-	private static class Token
-	{
-		private TokenKey key;
-		private int beforeSpace;
-		private int afterSpace;
-
-		public Token(TokenKey key, int before, int after)
-		{
-			this.key = key;
-			this.beforeSpace = before;
-			this.afterSpace = after;
-		}
-		public Token()
-		{
-			this(new TokenKey(""), SP_NOCARE, SP_NOCARE);
-		}
-
-		public void set(String word)
-		{
-			key.set(word);
-		}
-		public int getBeforeSpace()
-		{
-			return beforeSpace;
-		}
-		public int getAfterSpace()
-		{
-			return afterSpace;
-		}
-		public String toString()
-		{
-			return key.toString();
-		}
-	}
-}
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.actions;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import com.elphel.vdt.veditor.VerilogPlugin;
+
+import org.eclipse.swt.custom.StyledText;
+import org.eclipse.swt.graphics.Point;
+
+/**
+ * format region action (Verilog only now)
+ * 
+ * preference
+ *   indent character
+ *       tab
+ *       n white spaces
+ *   indent rule
+ *       begin/end, fork/join, generate/endgenerate,
+ *       if, for, while, repeat
+ *       case, ":",
+ *       port list, parameter list,
+ *       wrapped expression
+ *   white space rule(before and after)
+ *       binary operator, unary operator, conditional operator,
+ *       assign, comma, (), [], {}
+ *       ":"(MSB:LSB), ";"(end of statement)
+ *       if, for, while, repeat
+ *   context
+ *       begin/end, in [], in {}
+ */
+
+public class VerilogFormatAction extends AbstractAction {
+	// preference
+	private String indentString = "\t";
+	private boolean noSpaceInBracket = true;
+	private boolean spaceBeforeOperator2 = true;
+	private boolean spaceAfterOperator2 = true;
+	private boolean spaceBeforeOperator1 = false;
+	private boolean spaceAfterOperator1 = false;
+	private boolean spaceBeforeComma = false;
+	private boolean spaceAfterComma = true;
+	private boolean spaceBeforeSemicolon = false;
+	private boolean spaceBeforeOpenParen = false;
+	private boolean spaceAfterOpenParen = false;
+	private boolean spaceBeforeCloseParen = false;
+	private boolean spaceBeforeOpenBracket = false;
+	private boolean spaceAfterOpenBracket = false;
+	private boolean spaceBeforeCloseBracket = false;
+	private boolean spaceBeforeOpenBrace = false;
+	private boolean spaceAfterOpenBrace = false;
+	private boolean spaceBeforeCloseBrace = false;
+	private boolean spaceBeforeCaseColon = false;
+	private boolean spaceAfterCaseColon = true;
+	private boolean spaceAfterIf = true;
+	private boolean spaceAfterFor = true;
+	private boolean spaceAfterWhile = true;
+	private boolean spaceAfterRepeat = true;
+
+	// context flag
+	private static final int CONTEXT_NORMAL = 1;
+	private static final int CONTEXT_BRACKET = 2;
+	private static final int CONTEXT_ALL = CONTEXT_NORMAL | CONTEXT_BRACKET;
+	
+	// space operation flag
+	private static final int SP_NOCARE = 0;
+	private static final int SP_1 = 1;
+	private static final int SP_0 = 2;
+	private static final int SP_MULTI = 3;
+	
+	private TokenAnalyzer analyzer = new TokenAnalyzer();
+	private StringBuffer dst = new StringBuffer();
+	private String indent;
+	private int reservedSpace;
+	private boolean afterNewLine;
+
+	public VerilogFormatAction()
+	{
+		super("VerilogFormatAction");
+	}
+	
+	private void setup()
+	{
+		loadPreference();
+
+		String operators2[] = {"+", "-", "*", "/", "%", "&", "|", "^", "&&",
+				"||", "<<", ">>", "==", "!=", "===", "!==", "<", ">", "<=",
+				">=", "?", ":", "=", "<="};
+		for (int i = 0; i < operators2.length; i++)
+		{
+			appendTokenRule(operators2[i], spaceBeforeOperator2,
+					spaceAfterOperator2);
+		}
+
+		String operators1[] = { "!", "~" };
+		for (int i = 0; i < operators1.length; i++)
+		{
+			appendTokenRule(operators1[i], spaceBeforeOperator1,
+					spaceAfterOperator1);
+		}
+
+		appendTokenRule(",", spaceBeforeComma, spaceAfterComma);
+		appendTokenRule(";", spaceBeforeSemicolon, true);
+
+		appendTokenRule("(", spaceBeforeOpenParen, spaceAfterOpenParen);
+		appendTokenRule(")", spaceBeforeCloseParen, false);
+		
+		appendTokenRule("[", spaceBeforeOpenBracket, spaceAfterOpenBracket);
+		appendTokenRule("]", spaceBeforeCloseBracket, false);
+		
+		appendTokenRule("{", spaceBeforeOpenBrace, spaceAfterOpenBrace);
+		appendTokenRule("}", spaceBeforeCloseBrace, false);
+		
+		analyzer.appendToken(".", SP_0, SP_0);
+		analyzer.appendToken("//", SP_MULTI, SP_MULTI);
+
+		appendWordRule("if", spaceAfterIf);
+		appendWordRule("for", spaceAfterFor);
+		appendWordRule("while", spaceAfterWhile);
+		appendWordRule("repeat", spaceAfterRepeat);
+		
+		analyzer.appendToken("begin", SP_1, SP_1);
+		analyzer.appendToken("end", SP_1, SP_1);
+		analyzer.appendToken("fork", SP_1, SP_1);
+		analyzer.appendToken("join", SP_1, SP_1);
+		analyzer.appendToken("else", SP_1, SP_1);
+	}
+	
+	private void loadPreference()
+	{
+		String indent = VerilogPlugin.getPreferenceString("Style.indent");
+		if (indent.equals("Tab"))
+			indentString = "\t";
+		else
+		{
+			String size = VerilogPlugin.getPreferenceString("Style.indentSize");
+			int n = Integer.parseInt(size);
+			StringBuffer buf = new StringBuffer(n);
+			for(int i = 0; i < n; i++)
+				buf.append(' ');
+			indentString = buf.toString();
+		}
+		
+		noSpaceInBracket = getSpacePreference("Style.noSpaceInBracket");
+		
+		spaceBeforeOperator2 = getSpacePreference("Style.spaceAfterOperator2");
+		spaceAfterOperator2 = getSpacePreference("Style.spaceAfterOperator2");
+		spaceBeforeOperator1 = getSpacePreference("Style.spaceBeforeOperator1");
+		spaceAfterOperator1 = getSpacePreference("Style.spaceAfterOperator1");
+		spaceBeforeComma = getSpacePreference("Style.spaceBeforeComma");
+		spaceAfterComma = getSpacePreference("Style.spaceAfterComma");
+		spaceBeforeSemicolon = getSpacePreference("Style.spaceBeforeSemicolon");
+		spaceBeforeOpenParen = getSpacePreference("Style.spaceBeforeOpenParen");
+		spaceAfterOpenParen = getSpacePreference("Style.spaceAfterOpenParen");
+		spaceBeforeCloseParen = getSpacePreference("Style.spaceBeforeCloseParen");
+		spaceBeforeOpenBracket = getSpacePreference("Style.spaceBeforeOpenBracket");
+		spaceAfterOpenBracket = getSpacePreference("Style.spaceAfterOpenBracket");
+		spaceBeforeCloseBracket = getSpacePreference("Style.spaceBeforeCloseBracket");
+		spaceBeforeOpenBrace = getSpacePreference("Style.spaceBeforeOpenBrace");
+		spaceAfterOpenBrace = getSpacePreference("Style.spaceAfterOpenBrace");
+		spaceBeforeCloseBrace = getSpacePreference("Style.spaceBeforeCloseBrace");
+		spaceBeforeCaseColon = getSpacePreference("Style.spaceBeforeCaseColon");
+		spaceAfterCaseColon = getSpacePreference("Style.spaceAfterCaseColon");
+		spaceAfterIf = getSpacePreference("Style.spaceAfterIf");
+		spaceAfterFor = getSpacePreference("Style.spaceAfterFor");
+		spaceAfterWhile = getSpacePreference("Style.spaceAfterWhile");
+		spaceAfterRepeat = getSpacePreference("Style.spaceAfterRepeat");
+	}
+	
+	private boolean getSpacePreference(String name)
+	{
+		return VerilogPlugin.getPreferenceBoolean(name);
+	}
+	
+	private void appendTokenRule(String word, boolean b, boolean a)
+	{
+		int before = b ? SP_1 : SP_0;
+		int after = a ? SP_1 : SP_0;
+		analyzer.appendToken(word, before, after, CONTEXT_NORMAL);
+		if (noSpaceInBracket)
+			analyzer.appendToken(word, SP_0, SP_0, CONTEXT_BRACKET);
+		else
+			analyzer.appendToken(word, before, after, CONTEXT_BRACKET);
+	}
+
+	private void appendWordRule(String word, boolean a)
+	{
+		int after = a ? SP_1 : SP_0;
+		analyzer.appendToken(word, SP_NOCARE, after);
+	}
+
+	public void run()
+	{
+		setup();
+
+		StyledText widget = getViewer().getTextWidget();
+
+		Point point = widget.getSelection();
+		int begin = point.x;
+		int end = point.y;
+		
+		//if nothing is selected
+		if(begin == end){
+			return;
+		}
+		
+		// begin index must be top of line
+		int line = widget.getLineAtOffset(begin);
+		begin = widget.getOffsetAtLine(line);
+		String region = widget.getText(begin, end - 1);
+
+		indent = getIndent(widget, begin);
+
+		// initialize instance variable
+		dst.setLength(0);
+		reservedSpace = SP_NOCARE;
+		afterNewLine = true;
+
+		analyzer.setText(region);
+		analyzer.next();
+
+		while(!analyzer.isEos())
+		{
+			execRegion(0);
+		}
+		dst.append(analyzer.getSpace());
+
+		widget.replaceTextRange(begin, end - begin, dst.toString());
+	}
+	
+	private void execRegion(int level)
+	{
+		boolean isStart = true;
+		while (!analyzer.isEos())
+		{
+			String word = analyzer.getWord();
+			if (isBlockBegin(word))
+			{
+				execToken(level);
+				execBlock(level+1);
+				break;
+			}
+			else if (isCaseBegin(word))
+			{
+				execCase(level);
+				break;
+			}
+			else if (word.equals("if"))
+			{
+				execIf(level);
+				break;
+			}
+			else if (word.equals("while") || word.equals("repeat") || word.equals("for"))
+			{
+				execToken(level);
+				execParen(level);
+				execStatement(level);
+				break;
+			}
+			else if (word.equals("reg") || word.equals("wire"))
+			{
+				execDeclaration(level);
+				break;
+			}
+			else if (word.equals(";"))
+			{
+				execToken(level);
+				break;
+			}
+
+			if (isStart)
+				execToken(level);
+			else
+				execToken(level + 1);	// line break causes indent
+			
+			isStart = false;
+		}
+	}
+
+	private void execBlock(int level)
+	{
+		while (!analyzer.isEos())
+		{
+			if (isBlockEnd(analyzer.getWord()))
+			{
+				execToken(level - 1);
+				break;
+			}
+			if (analyzer.equalsToCurrent(":"))
+			{
+				execToken(level);	// :
+				execToken(level);	// label
+			}
+			execRegion(level);
+		}
+	}
+	
+	private void execIf(int level)
+	{
+		execToken(level);	// if
+		execParen(level);	// (...)
+		
+		execStatement(level);
+		if (analyzer.equalsToCurrent("else"))
+		{
+			execToken(level);
+			if (isCaseBegin(analyzer.getWord()))
+				execCase(level);  // exception for "else case"
+			else if (analyzer.equalsToCurrent("if"))
+				execIf(level);  // exception for "else if"
+			else
+				execStatement(level);
+		}
+	}
+	private void execCase(int level)
+	{
+		execToken(level);	// case
+		execParen(level+1);	// (...)
+		
+		while (!isCaseEnd(analyzer.getWord()) && !analyzer.isEos())
+		{
+			while (!analyzer.equalsToCurrent(":") && !analyzer.isEos())
+			{
+				execToken(level + 1);
+			}
+
+			int before = spaceBeforeCaseColon ? SP_1 : SP_0;
+			int after = spaceAfterCaseColon ? SP_1 : SP_0;
+			analyzer.modifySpace(before, after);
+			execToken(level); // :
+			execStatement(level + 1);
+		}
+		execToken(level); // endcase
+	}
+
+	private void execParen(int level)
+	{
+		execToken(level); // (
+
+		int paren = 1;
+		while (paren >= 1 && !analyzer.isEos())
+		{
+			if (analyzer.equalsToCurrent("("))
+				paren++;
+			if (analyzer.equalsToCurrent(")"))
+				paren--;
+			execToken(level + paren);
+		}
+	}
+
+	private void execStatement(int level)
+	{
+		if (isBlockBegin(analyzer.getWord()))
+		{
+			execToken(level);
+			execBlock(level + 1);
+		}
+		else
+			execRegion(level + 1);
+	}
+	
+	private void execDeclaration(int level)
+	{
+		execToken(level); // reg/wire
+		if (analyzer.equalsToCurrent("["))
+		{
+			execToken(level + 1);
+			while (!analyzer.equalsToCurrent("]") && !analyzer.isEos())
+			{
+				execToken(level + 1);
+			}
+			execToken(level);	// "]"
+		}
+		reservedSpace = SP_1;
+		execRegion(level + 1);
+	}
+
+	private int execToken(int level)
+	{
+		String word = analyzer.getWord();
+
+		if (afterNewLine)
+		{
+			dst.append(indent);
+			for (int i = 0; i < level; i++)
+				dst.append(indentString);
+		}
+		else
+		{
+			int beforeSpace = analyzer.getBeforeSpace();
+			if (reservedSpace == SP_MULTI || beforeSpace == SP_MULTI)
+				dst.append(analyzer.getSpace());
+			else if (reservedSpace == SP_1 || beforeSpace == SP_1)
+				dst.append(" ");
+			else if (reservedSpace == SP_0 || beforeSpace == SP_0)
+				; // append no space
+			else
+				dst.append(analyzer.getSpace());
+		}
+		dst.append(word);
+		reservedSpace = analyzer.getAfterSpace();
+		afterNewLine = false;
+
+		analyzer.next();
+		word = analyzer.getWord();
+		while (word.equals("\r") || word.equals("\n") || word.equals("//"))
+		{
+			while (!word.equals("\n") && !analyzer.isEos())
+			{
+				dst.append(analyzer.getSpace());
+				dst.append(word);
+				analyzer.next();
+				word = analyzer.getWord();
+			}
+			dst.append("\n");
+			afterNewLine = true;
+			analyzer.next();
+			word = analyzer.getWord();
+		}
+		
+		return level;
+	}
+	private static String getIndent(StyledText widget, int pos)
+	{
+		String text = widget.getText().substring(pos);
+		for (int i = 0; i < text.length(); i++)
+		{
+			char c = text.charAt(i);
+			if (!isSpace(c))
+				return text.substring(0, i);
+		}
+		return text;
+	}
+	private static boolean isBlockBegin(String str)
+	{
+		return str.equals("begin") || str.equals("fork") || str.equals("generate");
+	}
+	private static boolean isBlockEnd(String str)
+	{
+		return str.equals("end") || str.equals("join") || str.equals("endgenerate");
+	}
+	private static boolean isCaseBegin(String str)
+	{
+		return str.equals("case") || str.equals("casex");
+	}
+	private static boolean isCaseEnd(String str)
+	{
+		return str.equals("endcase");
+	}
+	private static boolean isIdentChar(char ch)
+	{
+		return Character.isLetterOrDigit(ch) || ch == '_';
+	}
+	private static boolean isSpace(char c)
+	{
+		return c == ' ' || c == '\t';
+	}
+	
+	private static class TokenAnalyzer
+	{
+		private Map<TokenKey,Token> tokens = new HashMap<TokenKey,Token>();
+	
+		private int pos;
+		private String src;
+		private String space;
+		private int context;
+		private int nestingLevel;
+		private int afterSpace, beforeSpace;
+		private Token currentToken = new Token();
+		private TokenKey workKey = new TokenKey("");
+		
+		public TokenAnalyzer()
+		{
+		}
+		public void setText(String src)
+		{
+			this.src = src;
+			context = CONTEXT_NORMAL;
+			nestingLevel = 0;
+			pos = 0;
+			afterSpace = -1;
+			beforeSpace = -1;
+		}
+		public void next()
+		{
+			beforeSpace = -1;
+			afterSpace = -1;
+
+			if (skipSpace() == false)
+				return;
+
+			char c = src.charAt(pos);
+			if (c == '\"')
+			{
+				parseStringLiteral();
+				return;
+			}
+			
+			StringBuffer buf = new StringBuffer();
+			boolean ident = isIdentChar(c);
+			buf.append(c);
+			pos++;
+			
+			while (pos < src.length())
+			{
+				c = src.charAt(pos);
+				if (ident != isIdentChar(c))
+					break;
+				if (isSpace(c))
+					break;
+				buf.append(c);
+				pos++;
+			}
+			
+			if (ident == false)
+			{
+				// match longest token
+				StringBuffer remains = new StringBuffer();
+				while (buf.length() >= 2)
+				{
+					if (findToken(buf.toString()) != null)
+						break;
+					int len = buf.length() - 1;
+					remains.insert(0, buf.charAt(len));
+					buf.setLength(len);
+					pos--;
+				}
+			}
+			String word = buf.toString();
+			currentToken.set(word);
+			
+			if (word.equals("[") || word.equals("{"))
+				nestingLevel++;
+			if (word.equals("]") || word.equals("}"))
+				nestingLevel--;
+			if (nestingLevel == 0)
+				context = CONTEXT_NORMAL;
+			else
+				context = CONTEXT_BRACKET;
+		}
+		
+		private void parseStringLiteral()
+		{
+			StringBuffer buf = new StringBuffer();
+			buf.append('\"');
+			pos++ ;
+			while (pos < src.length())
+			{
+				char c = src.charAt(pos);
+				if (c == '\n' || c == '\r')
+					break;
+				buf.append(c);
+				pos++;
+				if (c == '\"')
+					break;
+			}
+			currentToken.set(buf.toString());
+		}
+		
+		private boolean skipSpace()
+		{
+			StringBuffer buf = new StringBuffer();
+			while (pos < src.length())
+			{
+				char c = src.charAt(pos);
+				if (isSpace(c))
+					buf.append(c);
+				else
+					break;
+				pos++;
+			}
+			space = buf.toString();
+			if (pos == src.length())
+			{
+				currentToken.set("");
+				return false;
+			}
+			return true;
+		}
+		public void modifySpace(int before, int after)
+		{
+			beforeSpace = before;
+			afterSpace = after;
+		}
+
+		public String getSpace()
+		{
+			return space;
+		}
+		public String getWord()
+		{
+			return currentToken.toString();
+		}
+		public int getBeforeSpace()
+		{
+			if (beforeSpace == -1)
+				return getToken().getBeforeSpace();
+			else
+				return beforeSpace;
+		}
+		public int getAfterSpace()
+		{
+			if (afterSpace == -1)
+				return getToken().getAfterSpace();
+			else
+				return afterSpace;
+		}
+		public boolean isEos()
+		{
+			return (pos >= src.length());
+		}
+		public boolean equalsToCurrent(Object obj)
+		{
+			return getWord().equals(obj);
+		}
+		
+		private Token getToken()
+		{
+			Token token = findToken(getWord());
+			if (token == null)
+				return currentToken;
+			else
+				return token;
+		}
+		private Token findToken(String word)
+		{
+			// workKey is used for avoiding "new"
+			workKey.set(word, context);
+			return tokens.get(workKey);
+		}
+		
+		public void appendToken(String word, int before, int after, int context)
+		{
+			TokenKey key = new TokenKey(word, context);
+			tokens.put(key, new Token(key, before, after));
+		}
+		public void appendToken(String word, int before, int after)
+		{
+			appendToken(word, before, after, CONTEXT_ALL);
+		}
+	}
+	
+	/**
+	 * Key for Token database
+	 * It can be used by HashMap
+	 */
+	private static class TokenKey
+	{
+		private String word;
+		private int context;
+		
+		public TokenKey(String word, int context)
+		{
+			this.word = word;
+			this.context = context;
+		}
+		public TokenKey(String word)
+		{
+			this(word, CONTEXT_ALL);
+		}
+		
+		public void set(String word, int context)
+		{
+			this.word = word;
+			this.context = context;
+		}
+		public void set(String word)
+		{
+			set(word, CONTEXT_ALL);
+		}
+
+		public String toString()
+		{
+			return word;
+		}
+		
+		public boolean equals(Object o)
+		{
+			if (o instanceof TokenKey)
+			{
+				TokenKey key = (TokenKey) o;
+				if (word.equals(key.word))
+				{
+					if ((context & key.context) != 0)
+						return true;
+					else
+						return false;
+				}
+				else
+					return false;
+			}
+			return false;
+		}
+
+		public int hashCode()
+		{
+			return word.hashCode();
+		}
+	}
+	
+	/**
+	 * Token for inserting/deleting white space
+	 */
+	private static class Token
+	{
+		private TokenKey key;
+		private int beforeSpace;
+		private int afterSpace;
+
+		public Token(TokenKey key, int before, int after)
+		{
+			this.key = key;
+			this.beforeSpace = before;
+			this.afterSpace = after;
+		}
+		public Token()
+		{
+			this(new TokenKey(""), SP_NOCARE, SP_NOCARE);
+		}
+
+		public void set(String word)
+		{
+			key.set(word);
+		}
+		public int getBeforeSpace()
+		{
+			return beforeSpace;
+		}
+		public int getAfterSpace()
+		{
+			return afterSpace;
+		}
+		public String toString()
+		{
+			return key.toString();
+		}
+	}
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/actions/VhdlFormatAction.java vdt/src/com/elphel/vdt/veditor/actions/VhdlFormatAction.java
--- vdt-veditor/src/com/elphel/vdt/veditor/actions/VhdlFormatAction.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/actions/VhdlFormatAction.java	2016-06-24 10:29:40.816496628 -0600
@@ -1,891 +1,902 @@
-/*******************************************************************************
- * Copyright (c) 2006 Ali Ghorashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    Ali Ghorashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.actions;
-
-import java.io.StringReader;
-import java.util.ArrayList;
-import java.util.HashMap;
-
-import net.sourceforge.veditor.VerilogPlugin;
-import net.sourceforge.veditor.editor.scanner.HdlScanner;
-import net.sourceforge.veditor.parser.vhdl.SimpleCharStream;
-import net.sourceforge.veditor.parser.vhdl.Token;
-import net.sourceforge.veditor.parser.vhdl.VhdlParserCoreTokenManager;
-import net.sourceforge.veditor.preference.PreferenceStrings;
-
-import org.eclipse.jface.text.TextUtilities;
-import org.eclipse.swt.custom.StyledText;
-import org.eclipse.swt.graphics.Point;
-
-public class VhdlFormatAction extends AbstractAction {
-	private boolean m_UseSpaceForTab;
-	private int     m_IndentSize=0;
-	private boolean m_PadOperators=true;
-	private boolean m_IndentLibrary=true;
-	private boolean m_KeywordsLowercase = true;
-	private boolean m_AlignOnArrowRight = true;
-	private boolean m_AlignOnArrowLeft = true;
-	private boolean m_AlignOnColon = true;
-	private boolean	m_AlignOnAssignment	= true;
-	private boolean	m_AlignOnComment	= true;
-	private boolean	m_AlignInOut		= true;
-	private String m_eol;
-	
-	/**
-	 * Class used to store stop and start points for 
-	 * fixing indents
-	 */
-	private class StartStop{
-		public int start;
-		public int indentAmount;
-	}
-	
-	public VhdlFormatAction(){
-		super("VhdlFormatAction");
-	}
-
-	@Override
-	public void run() {		
-		StyledText widget = getViewer().getTextWidget();
-		//mg
-		final int topLineIndex = widget.getTopIndex();
-		//mg------------------------
-
-		Point point = widget.getSelection();
-		int begin = point.x;
-		int end = point.y;
-		
-		//if nothing is selected
-		if(begin == end){
-			return;
-		}
-		// begin index must be top of line
-		int line = widget.getLineAtOffset(begin);
-		begin = widget.getOffsetAtLine(line);
-		String selectedText = widget.getText(begin, end - 1);		
-		//get the user preferences
-		getPreferences();
-		
-		selectedText = selectedText.replaceAll("\r\n","\n");
-		selectedText = selectedText.replaceAll("\r","\n");
-	
-		selectedText=fixIndentation(selectedText);	
-		selectedText=addSpacePadding(selectedText);
-		selectedText=convertTabs(selectedText);	
-		// adjust the case of key words
-		if(m_KeywordsLowercase){
-			selectedText=fixCase(selectedText);
-		}
-		// align on colons
-		if (m_AlignOnColon) {
-			selectedText=alignBefore(selectedText,new int[]{VhdlParserCoreTokenManager.COLON});
-		}
-		// do we need to align after direction assignments
-		if ( m_AlignInOut ) {			
-			selectedText=alignAfter(selectedText, 
-					new int[]{ VhdlParserCoreTokenManager.IN, 
-				               VhdlParserCoreTokenManager.OUT,
-				               VhdlParserCoreTokenManager.INOUT,
-				               VhdlParserCoreTokenManager.BUFFER	
-					          }
-			        );
-		}
-		if (m_AlignOnArrowRight) {
-			selectedText=alignBefore(selectedText,new int[]{VhdlParserCoreTokenManager.RARROW});
-		}
-		if (m_AlignOnArrowLeft) {
-			selectedText=alignBefore(selectedText,new int[]{VhdlParserCoreTokenManager.LE});
-		}
-		if ( m_AlignOnAssignment ) {
-			selectedText=alignBefore(selectedText,new int[]{VhdlParserCoreTokenManager.ASSIGN});
-		}		
-		if ( m_AlignOnComment ) {
-			selectedText=alignBefore(selectedText,new int[]{VhdlParserCoreTokenManager.COMMENT});
-		}
-		
-		
-		//replace the text
-		widget.replaceTextRange(begin, end - begin, selectedText);
-		
-		//set caret and the part shown in the editor
-		//mg
-		if ( topLineIndex <= widget.getLineCount() ) {
-			widget.setCaretOffset( widget.getOffsetAtLine( topLineIndex ) );
-			widget.setTopIndex( topLineIndex );
-		}
-		//mg-------------------------------
-	}
-	
-	/**
-	 * Gets the code style preferences
-	 */
-	private void getPreferences(){
-		String indent = VerilogPlugin.getPreferenceString("Style.indent");
-		if (indent.equals("Tab"))
-			m_UseSpaceForTab=false;
-		else
-		{
-			m_UseSpaceForTab=true;
-			String size = VerilogPlugin.getPreferenceString("Style.indentSize");
-			m_IndentSize= Integer.parseInt(size);			
-		}
-		
-		m_PadOperators=VerilogPlugin.getPreferenceBoolean(PreferenceStrings.PAD_OPERATORS);
-		m_IndentLibrary=VerilogPlugin.getPreferenceBoolean(PreferenceStrings.INDENT_LIBRARY);
-		m_KeywordsLowercase = VerilogPlugin.getPreferenceBoolean(PreferenceStrings.KEYWORDS_LOWERCASE);
-		m_AlignOnColon = VerilogPlugin.getPreferenceBoolean(PreferenceStrings.ALIGNONCOLON);
-		m_AlignOnArrowRight = VerilogPlugin	.getPreferenceBoolean(PreferenceStrings.ALIGNONARROWRIGHT);
-		m_AlignOnArrowLeft = VerilogPlugin	.getPreferenceBoolean(PreferenceStrings.ALIGNONARROWLEFT);
-		m_AlignOnAssignment = VerilogPlugin.getPreferenceBoolean( PreferenceStrings.ALIGNONASSIGNMENT );
-		m_AlignOnComment = VerilogPlugin.getPreferenceBoolean( PreferenceStrings.ALIGNONCOMMENT );
-		m_AlignInOut = VerilogPlugin.getPreferenceBoolean( PreferenceStrings.ALIGNINOUT );
-		
-		m_eol = TextUtilities.getDefaultLineDelimiter(getViewer().getDocument());
-	}
-	
-	/**
-	 * Increases or decreases the indent value of a given line by the specified adjustment
-	 * @param map The line to indent value mapping
-	 * @param line the Line to adjust
-	 * @param adjustment the amount of adjustment needed
-	 */
-	private void adjustLineIndentValue(HashMap<Integer,Integer> map,int line,int adjustment){
-		//if the line exists, we need to change it
-		if(map.containsKey(line)){
-			int value=map.get(line)+adjustment;			
-			map.put(line, value);
-		}
-		else{
-			//just add the adjustment
-			map.put(line, adjustment);
-		}
-	}
-	
-	/**
-	 * Scans the token list for the next occurrence of the given image 
-	 * @param image Token image
-	 * @param tokens Token list
-	 * @param startIdx starting index
-	 * @return the index of the next token with the given image. tokens.size() if not found
-	 */
-	private int skipTo(String image,ArrayList<Token> tokens,int startIdx){		
-		while(startIdx < tokens.size()){
-			if (tokens.get(startIdx).image.toUpperCase().equals(image.toUpperCase())){
-				break;
-			}
-			startIdx++;
-		}
-		return startIdx;
-	}	
-	/**
-	 * Scans the token list for the next matching close parenthesis 
-	 * @param tokens Token list
-	 * @param startIdx starting index
-	 * @return the index of the next token with the given image. tokens.size() if not found
-	 */
-	private int skipToCloseParan(ArrayList<Token> tokens,int startIdx){
-		int numOpen=1;
-		while(startIdx < tokens.size()){
-			if (tokens.get(startIdx).image.equals("(")){
-				numOpen++;
-			}else if (tokens.get(startIdx).image.equals(")")){
-				numOpen--;
-				if(numOpen == 0){
-					break;
-				}
-			}
-			
-			startIdx++;
-		}
-		return startIdx;
-	}
-	/**
-	 * Computes the amount of indentation that needs to be applied to a set of
-	 * lines based on the tokens
-	 * @param tokens Tokens in the lines
-	 * @return A map between lines numbers and the indentation adjustment
-	 */
-	private HashMap<Integer,Integer> computeIndentation(ArrayList<Token> tokens){
-		HashMap<Integer,Integer> results=new HashMap<Integer,Integer>();
-		//compute indentation
-		
-		// 'when' has another meaning when it is used inside or outside a case
-		// we keep a counter whether we are in a case structure or not
-		// (cases can be nested)
-		int incase = 0;
-		int use;
-		int EOS;
-		for(int i=0;i < tokens.size();i++){
-			Token token=tokens.get(i);
-			if(token.image.equals("(")) {
-				int openParan1=i;
-				int closeParan1=skipToCloseParan(tokens, openParan1+1);
-
-				// skip if there are no parameters
-				int semicolon=skipTo(";", tokens, i+1);
-				
-				//did we find what we were looking for?
-				if(openParan1>=semicolon || closeParan1 >= tokens.size()) {
-					break;
-				}
-
-				//if the open and close parentheses are on different lines
-				if(tokens.get(closeParan1).beginLine > tokens.get(openParan1).beginLine ){
-					adjustLineIndentValue(results,tokens.get(openParan1).beginLine+1, +1);
-					//move the line with close parenthesis only if it is the only token on that line
-					if(tokens.get(closeParan1-1).beginLine != tokens.get(closeParan1).beginLine){
-						adjustLineIndentValue(results,tokens.get(closeParan1).beginLine, -1);
-					}
-					else{
-						//otherwise, just adjust the following line
-						adjustLineIndentValue(results,tokens.get(closeParan1).beginLine+1, -1);
-					}
-				}
-				i=closeParan1;
-			}
-			switch(token.kind){
-			case VhdlParserCoreTokenManager.CASE:
-				adjustLineIndentValue(results,token.beginLine+1, +2);
-				incase++;
-				i = skipTo("is", tokens,i+1);
-				break;
-			case VhdlParserCoreTokenManager.LIBRARY:
-				i = skipTo(";", tokens, i + 1);
-				if (m_IndentLibrary) {
-					// skip to eos
-					use = skipTo("use", tokens, i + 1);
-					EOS = skipTo(";", tokens, i + 1);
-					if (use == tokens.size() || EOS == tokens.size()) {
-						break;
-					}
-					if (use < EOS) {
-						adjustLineIndentValue(results,tokens.get(use).beginLine, +1);
-					}
-					while (use < EOS) {
-						i = EOS;
-						use = skipTo("use", tokens, i + 1);
-						EOS = skipTo(";", tokens, i + 1);
-					}
-					adjustLineIndentValue(results, tokens.get(i).beginLine + 1,	-1);
-				}
-				break;
-			case VhdlParserCoreTokenManager.TYPE:
-				EOS=skipTo(";", tokens, i+1);
-				int record=skipTo("record", tokens, i+1);
-				//if a record was found before EOF, then indent
-				if(EOS > record){
-					i=record;
-					adjustLineIndentValue(results,tokens.get(record).beginLine+1, +1);
-				} else {
-					int semicolon=skipTo(";", tokens, i+1);
-					int isToken=skipTo("is", tokens, i+1);
-					if(isToken<semicolon) {
-						//breaks the "indent after 'is'" rule. 
-						i=isToken;
-					}
-				}
-				break;
-			case VhdlParserCoreTokenManager.ATTRIBUTE:
-			case VhdlParserCoreTokenManager.ALIAS:
-			case VhdlParserCoreTokenManager.FILE:
-			case VhdlParserCoreTokenManager.SUBTYPE:
-				//These tokens break the "indent after 'is'" rule. If
-				//One is encountered, just skip to EOS
-				i=skipTo(";", tokens, i+1);
-				break;
-			case VhdlParserCoreTokenManager.COMPONENT:
-				// component can be defined without an "is"
-				int isTokenPos=skipTo("is", tokens, i+1);
-				EOS = skipTo(";", tokens, i+1);
-				if(isTokenPos > EOS) {
-					results.put(token.beginLine+1, +1);
-				}
-				break;
-			case VhdlParserCoreTokenManager.PROCESS:
-				// process can be defined without an "is"
-				if(tokens.get(i+1).image.equals("(")) {
-					// process has sensitivity list, indent after ")"
-					int closeParan = skipToCloseParan(tokens, i+2);
-					if(!tokens.get(closeParan+1).image.equals("is")) {
-						adjustLineIndentValue(results,tokens.get(closeParan).beginLine+1, +1);
-					}
-				} else {
-					// no sensitivity list indent next line:
-					if(!tokens.get(i+1).image.equals("is")) {
-						adjustLineIndentValue(results,token.beginLine+1, +1);
-					}
-				}
-				break;
-			case VhdlParserCoreTokenManager.BLOCK:
-			case VhdlParserCoreTokenManager.GENERATE:
-			case VhdlParserCoreTokenManager.IS:
-			case VhdlParserCoreTokenManager.LOOP:
-			case VhdlParserCoreTokenManager.THEN:
-				adjustLineIndentValue(results,token.beginLine+1, +1);
-				break;			
-			case VhdlParserCoreTokenManager.ELSIF:
-				adjustLineIndentValue(results,token.beginLine, -1);
-				break;
-			case VhdlParserCoreTokenManager.BEGIN:
-			case VhdlParserCoreTokenManager.ELSE:
-				if (token.beginLine != tokens.get(i-1).beginLine) {
-					adjustLineIndentValue(results,token.beginLine, -1);
-					adjustLineIndentValue(results,token.beginLine+1 , +1);
-				}
-				break;
-			case VhdlParserCoreTokenManager.END:
-				if(i<tokens.size()-1 && tokens.get(i+1).kind==VhdlParserCoreTokenManager.CASE) {
-					adjustLineIndentValue(results,token.beginLine, -2);
-					if(incase>0) incase--;
-				} else {
-					if (token.beginLine == tokens.get(i-1).beginLine) {
-						// end is not the first token on this line
-						adjustLineIndentValue(results, token.beginLine + 1, -1);
-					} else {
-						adjustLineIndentValue(results, token.beginLine, -1);
-					}
-				}
-				//skip to eos
-				i=skipTo(";", tokens, i+1);				
-				break;
-			case VhdlParserCoreTokenManager.WITH:
-				int startToken=i;				
-				i=skipTo(";", tokens, i+1);
-				//if the with and the semicolon are on different lines
-				//indent the lines between;
-				if(tokens.get(i).beginLine > tokens.get(startToken).beginLine){
-					results.put(tokens.get(startToken).beginLine+1, +1);
-					results.put(tokens.get(i).beginLine+1, -1);
-				}
-				break;
-			case VhdlParserCoreTokenManager.PROCEDURE:
-			case VhdlParserCoreTokenManager.FUNCTION:
-			case VhdlParserCoreTokenManager.PORT:
-			case VhdlParserCoreTokenManager.GENERIC:
-			case VhdlParserCoreTokenManager.SIGNAL:
-			case VhdlParserCoreTokenManager.CONSTANT:
-			case VhdlParserCoreTokenManager.VARIABLE:
-				adjustLineIndentValue(results,tokens.get(i).beginLine, 0);
-				// code has been moved to "("
-				break;
-			case VhdlParserCoreTokenManager.WHEN:
-				if(incase>0) {
-					adjustLineIndentValue(results,token.beginLine, -1);
-					adjustLineIndentValue(results,token.beginLine+1, +1);
-				} else {
-					// ... <= ... when ... else ...;
-					i=skipTo(";", tokens, i+1);
-				}
-				break;
-			default:				
-				break;
-			}
-		}
-		return results;
-	}
-	 
-	/**
-	 * Fixes the line indentation for the given text block
-	 * @param text text block to examine
-	 * @return properly indented string
-	 */
-	private String fixIndentation(String text){		
-		String[] lines = text.split("\n");
-		//if there is only 1 line, bail
-		if(lines.length < 2){
-			return text;
-		}
-		ArrayList<Token> tokens=TokenizeText(text);
-		HashMap<Integer,Integer> lineIndentation=computeIndentation(tokens);
-
-		//adjust the lines
-		String indentString=getIndentString();		
-		String currentIndent=getLineIndent(lines[0]);
-		
-		for(int lineNum=0; lineNum < lines.length; lineNum++){			
-			//adjust the indentation. Need to add 1 since the token lines are zero based			
-			if(lineIndentation.containsKey(lineNum+1)){
-				int indentValue=lineIndentation.get(lineNum+1);
-				if(indentValue > 0){
-					for(int i=0;i<indentValue;i++){
-						currentIndent+=indentString;
-					}
-				}
-				else if (indentValue < 0){
-					for(int i=indentValue;i<0;i++){
-						//back up by one indent
-						int endLocation=currentIndent.length()-indentString.length();
-						if(endLocation >= 0){
-							currentIndent=currentIndent.substring(0, endLocation);
-						}
-					}									
-				}
-			}
-			
-			String prevline = lineNum>0?lines[lineNum-1]:"";
-			// trim comment at the end of the line:
-			int indexcomment=prevline.indexOf("--");
-			if(indexcomment>=0) prevline = prevline.substring(0,indexcomment).trim();
-			
-			// sometimes statements are written over multiple lines
-			// in that case, only adjust the first line.			
-			boolean linecontinuation =
-				!lineIndentation.containsKey(lineNum+1) &&//lineIndentation starts counting at 0!
-				!prevline.endsWith(",") &&
-				!prevline.endsWith(";") &&
-				prevline.trim().length()!=0;
-			if(!lines[lineNum].trim().startsWith("--") && !linecontinuation)
-				lines[lineNum]=currentIndent+lines[lineNum].trim();
-			else {
-				// remove <CR>
-				lines[lineNum] = lines[lineNum].replaceAll("\r", "");
-			}
-
-		}
-
-		StringBuffer buffer=new StringBuffer();
-		for(int lineNum=0; lineNum < lines.length; lineNum++){
-			if (lines[lineNum].trim().length() != 0){
-				buffer.append(lines[lineNum]);
-			}
-			buffer.append(m_eol);
-		}
-		return buffer.toString();
-	}
-	
-	/**
-	 * Converts the tabs to spaces 
-	 * @param text Text block to examine
-	 * @return Converted text
-	 */
-	private String convertTabs(String text){
-		String results=text;
-		if(m_UseSpaceForTab){
-			String indentString=getIndentString();
-			results=text.replaceAll("\t", indentString);
-		}
-		return results;
-	}
-	
-	/**
-	 * Adds a space location to a list of lines
-	 * @param list
-	 * @param line
-	 * @param col
-	 */
-	private void addSpace(HashMap<Integer,ArrayList<Integer>> list,int line,int col){
-		ArrayList<Integer> intList;
-		if(list.containsKey(line)){
-			intList=list.get(line);			
-		}
-		else{
-			intList=new ArrayList<Integer>();			
-			list.put(line, intList);
-		}
-		intList.add(col);
-	}
-	/**
-	 * Adds padding for spaces around the necessary elements
-	 * @param text Text block to examine
-	 * @return Padded text
-	 */
-	private String addSpacePadding(String text) {
-		
-		if(!m_PadOperators){
-			return text;
-		}
-		// get a list of lines
-		String[] lines = text.split("\n");
-		ArrayList<Token> tokens=TokenizeText(text);
-		HashMap<Integer,ArrayList<Integer>> spaceLocations=new HashMap<Integer,ArrayList<Integer>>();		
-		for(int i=0;i<tokens.size();i++){
-			Token token=tokens.get(i);
-			switch (token.kind) {			
-			case VhdlParserCoreTokenManager.CONCAT:
-			case VhdlParserCoreTokenManager.EQ:
-			case VhdlParserCoreTokenManager.NEQ:
-			case VhdlParserCoreTokenManager.GE:
-			case VhdlParserCoreTokenManager.LE:
-			case VhdlParserCoreTokenManager.GT:
-			case VhdlParserCoreTokenManager.LO:
-			case VhdlParserCoreTokenManager.COLON:
-			case VhdlParserCoreTokenManager.ASSIGN:
-			case VhdlParserCoreTokenManager.RARROW:
-				//remember, columns and lines are 1 based
-				addSpace(spaceLocations,token.beginLine-1,token.beginColumn-1);
-				addSpace(spaceLocations,token.beginLine-1,token.endColumn);
-				break;
-			case VhdlParserCoreTokenManager.SEMICOLON:
-				//remember, columns and lines are 1 based
-				addSpace(spaceLocations,token.beginLine-1,token.endColumn);
-				break;
-			default:
-				break;
-			}
-			
-		}
-		// reassemble the lines
-		StringBuffer buffer = new StringBuffer();
-		for (int lineNum = 0; lineNum < lines.length; lineNum++) {
-			String line;
-			//do we need to fix this line?
-			if(spaceLocations.containsKey(lineNum)){
-				ArrayList<Integer> spaces=spaceLocations.get(lineNum);
-				int spaceIdx=0;
-				StringBuffer buff=new StringBuffer();
-				//copy the line and add space when necessary
-				for(int i=0;i<lines[lineNum].length();i++){
-					if(spaceIdx < spaces.size() && i == spaces.get(spaceIdx)){
-						spaceIdx++;
-						if(Character.isWhitespace(lines[lineNum].charAt(i-1))==false &&
-						   Character.isWhitespace(lines[lineNum].charAt(i))==false){
-							buff.append(" ");
-						}
-					}
-					buff.append(lines[lineNum].charAt(i));					
-				}
-				line=buff.toString();
-			}
-			else{
-				line=lines[lineNum];
-			}
-			// remove <CR>
-			line = line.replaceAll("\r", "");
-			buffer.append(line);			
-			buffer.append(m_eol);
-		}
-		return buffer.toString();
-	}
-	
-	/**
-	 * A derived class to override the tab size
-	 *
-	 */
-	private class CharStream extends SimpleCharStream{
-
-		public CharStream(java.io.Reader dstream) {
-			super(dstream);			
-		}		
-		public void setTabSize(int i){
-			super.setTabSize(i);
-		}		
-	}
-	/**
-	 * Tokenizes the given text block using VHDL rules
-	 * 
-	 * @param text
-	 * @return A list of tokens in the given text
-	 */
-	private ArrayList<Token> TokenizeText(String text){
-		StringReader stringReader=new StringReader(text);
-		CharStream stream=new CharStream(stringReader);
-		stream.setTabSize(1); //set the tab size to 1 in order to match string index
-		VhdlParserCoreTokenManager tokenManager=new VhdlParserCoreTokenManager(stream);
-		Token token=null;
-		ArrayList <Token> results=new ArrayList<Token>();
-		
-		do{
-			token=tokenManager.getNextToken();
-			if(token.kind != VhdlParserCoreTokenManager.EOF){
-				results.add(token);
-			}
-		}while(token.kind != VhdlParserCoreTokenManager.EOF);
-		
-		return results;
-	}
-	
-	/**
-	 * Returns the string that is to be used for indenting
-	 * @return
-	 */
-	private String getIndentString(){
-		String results="";
-		if(m_UseSpaceForTab){			
-			for(int i=0;i<m_IndentSize;i++){
-				results+=" ";
-			}			
-		}
-		else{
-			results="\t";
-		}
-		return results;
-	}
-	
-	/**
-	 * Returns the indent string used before the first non white character
-	 * @param line line to be examined
-	 * @return
-	 */
-	private String getLineIndent(String line){
-		//find the indent of the first line
-		int firstNonSpace=0;
-		for(firstNonSpace=0;firstNonSpace < line.length();firstNonSpace++){
-			if(Character.isWhitespace(line.charAt(firstNonSpace))==false){
-				break;
-			}
-		}
-		return line.substring(0, firstNonSpace);
-	}
-
-		
-	/**
-	 * Create a string made up of the repetition of str
-	 * @param str The String to repeat
-	 * @param repeat Number of times to repeat
-	 * @return new String
-	 */
-	private String fillString(String str,int repeat){
-		StringBuffer results=new StringBuffer();
-		for(int i=0; i < repeat; i++){
-			results.append(str);
-		}
-		return results.toString();
-	}
-	
-	/**
-	 * Checks to see if the passed token is on list of tokens
-	 * @return true if the token is on the list, false if not
-	 */
-	private boolean isTokenOnList(int tokenId, int valid_tokens[]){
-		for(int i: valid_tokens){
-			if (tokenId == i){
-				return true;
-			}
-		}
-		return false;
-	}
-	
-	/**
-	 * Aligns the text before one or more tokens
-	 * @param text
-	 * @param valid_tokens An array of tokens to align on
-	 * @return String after alignment is done
-	 * @note The alignment value is only valid for a consecutive set of lines. If
-	 * a line without a token is encountered, the alignment value gets reset
-	 */
-	private String alignBefore(String text,int valid_tokens[]) {
-		// list of lines that need to be indented and the location of indent
-		HashMap<Integer,StartStop> indentSet = new HashMap<Integer,StartStop>();		
-		//grouping of indent level
-		ArrayList <HashMap<Integer,StartStop>> indentGroups = new ArrayList <HashMap<Integer,StartStop>>() ;	
-		ArrayList<Token> tokens=TokenizeText(text);
-		String[] lines=text.split(m_eol);
-		//if there is only 1 line, bail
-		if(lines.length < 2){
-			return text;
-		}
-		
-		//find the indent position following the direction directive
-		int maxPosAfterDirection=0;
-		int lastLineWithToken=0;		
-		for(int i=0;i < tokens.size();i++){
-			Token token=tokens.get(i);
-			if(isTokenOnList(token.kind,valid_tokens) ){		
-				lastLineWithToken =  token.beginLine;
-				//record the info about the tokens
-				StartStop indentInfo = new StartStop();
-				indentInfo.start = token.beginColumn;				
-				//token lines are one based
-				indentSet.put(token.beginLine -1, indentInfo);
-				//record the max indentation after the directive
-				if(tokens.get(i).beginColumn  > maxPosAfterDirection){
-					maxPosAfterDirection=tokens.get(i).beginColumn;
-				}				
-				
-			}
-			else{
-				//token not found
-				if (  token.beginLine > (lastLineWithToken+1) && lastLineWithToken!=0){
-					// we encounter a whole line without a valid token 
-					for( Integer line: indentSet.keySet()){
-						//set all the indent values to max encountered in this block
-						indentSet.get(line).indentAmount = maxPosAfterDirection;					
-					}
-					//file away the current group
-					indentGroups.add(indentSet);
-					//make a new group
-					indentSet = new HashMap<Integer,StartStop>();				
-					maxPosAfterDirection=0;
-					lastLineWithToken   =0;
-				}
-			}
-		}	
-		//add the last alignment set to the list
-		for( Integer line: indentSet.keySet()){
-			//set all the indent values to max encountered in this block
-			indentSet.get(line).indentAmount = maxPosAfterDirection;					
-		}
-		indentGroups.add(indentSet);
-		
-		
-		for(HashMap<Integer,StartStop> indentInfoSet : indentGroups){
-			//adjust alignment
-			for( Integer line: indentInfoSet.keySet()){
-				StartStop indentInfo=indentInfoSet.get(line);
-				String indentString = fillString(" ", indentInfo.indentAmount - indentInfo.start+1);
-				String str1 =  lines[line].substring(0,indentInfo.start-2);
-				String str2 =  lines[line].substring(indentInfo.start-1);
-				lines[line] = str1 + indentString + str2;
-			}
-		}
-		
-		//reassemble the lines
-		StringBuffer buffer=new StringBuffer();
-		for(int lineNum=0; lineNum < lines.length; lineNum++){
-			//skip the lines that consist only of white space 
-			if (lines[lineNum].trim().length() != 0){
-				buffer.append(lines[lineNum]);				
-			}
-			//do not append a new line to the last line
-			if(lineNum +1 !=  lines.length ){
-				buffer.append(m_eol);
-			}
-		}
-		return buffer.toString(); 
-	}
-
-	/**
-	 * Aligns the text after one or more tokens
-	 * @param text
-	 * @param valid_tokens An array of tokens to align on
-	 * @return String after alignment is done
-	 * @note The alignment value is only valid for a consecutive set of lines. If
-	 * a line without a token is encountered, the alignment value gets reset
-	 */
-	private String alignAfter(String text,int valid_tokens[]) {
-		// list of lines that need to be indented and the location of indent
-		HashMap<Integer,StartStop> indentSet = new HashMap<Integer,StartStop>();
-		//grouping of indent level
-		ArrayList <HashMap<Integer,StartStop>> indentGroups = new ArrayList <HashMap<Integer,StartStop>>() ;		
-		ArrayList<Token> tokens=TokenizeText(text);
-		String[] lines=text.split(m_eol);
-		//if there is only 1 line, bail
-		if(lines.length < 2){
-			return text;
-		}
-		
-		//find the indent position following the direction directive
-		int maxPosAfterDirection=0;
-		int lastLineWithToken=0;		
-		for(int i=0;i < tokens.size();i++){
-			Token token=tokens.get(i);					
-			 
-			if(isTokenOnList(token.kind,valid_tokens) ){				
-				lastLineWithToken =  token.beginLine;
-				//make sure there is another token on the same line
-				if( (i+1) < tokens.size() && token.beginLine == tokens.get(i+1).beginLine){
-					//record the info about the tokens
-					StartStop indentInfo = new StartStop();				
-					indentInfo.start  = tokens.get(i+1).beginColumn;
-					//token lines are one based
-					indentSet.put(token.beginLine -1, indentInfo);
-					//record the max indentation after the directive
-					if(tokens.get(i+1).beginColumn  > maxPosAfterDirection){
-						maxPosAfterDirection=tokens.get(i+1).beginColumn;
-					}					
-				}
-			}			
-			else{
-				//token not found
-				if (  token.beginLine > (lastLineWithToken+1) && lastLineWithToken!=0){
-					// we encounter a whole line without a valid token 
-					for( Integer line: indentSet.keySet()){
-						//set all the indent values to max encountered in this block
-						indentSet.get(line).indentAmount = maxPosAfterDirection;					
-					}
-					//file away the current group
-					indentGroups.add(indentSet);
-					//make a new group
-					indentSet = new HashMap<Integer,StartStop>();				
-					maxPosAfterDirection=0;
-					lastLineWithToken   =0;
-				}
-			}
-		}	
-		//add the last alignment set to the list
-		for( Integer line: indentSet.keySet()){
-			//set all the indent values to max encountered in this block
-			indentSet.get(line).indentAmount = maxPosAfterDirection;					
-		}
-		indentGroups.add(indentSet);
-		
-		for(HashMap<Integer,StartStop> indentInfoSet : indentGroups){
-			//adjust alignment
-			for( Integer line: indentInfoSet.keySet()){
-				StartStop indentInfo=indentInfoSet.get(line);
-				String indentString = fillString(" ", indentInfo.indentAmount - indentInfo.start+1);
-				String str1 =  lines[line].substring(0,indentInfo.start-2);
-				String str2 =  lines[line].substring(indentInfo.start-1);
-				lines[line] = str1 + indentString + str2;
-			}
-		}
-		
-		//reassemble the lines
-		StringBuffer buffer=new StringBuffer();
-		for(int lineNum=0; lineNum < lines.length; lineNum++){
-			//skip the lines that consist only of white space 
-			if (lines[lineNum].trim().length() != 0){
-				buffer.append(lines[lineNum]);				
-			}
-			buffer.append(m_eol);
-		}
-		return buffer.toString(); 
-	}
-	
-	/**
-	 * Converts all the keywords in the passed text to lower case
-	 * @param text Text to be formatted
-	 */
-	private String fixCase(String text) {
-		ArrayList<Token> tokens=TokenizeText(text);
-		String[] lines=text.split(m_eol);
-		//if there is only 1 line, bail
-		if(lines.length < 2){
-			return text;
-		}
-		
-		for (int tokennr = 0; tokennr < tokens.size(); tokennr++) {
-			Token token = tokens.get(tokennr);
-			for (int s = 0; s < HdlScanner.vhdlWords.length; s++) {
-
-				if (token.image.equalsIgnoreCase(HdlScanner.vhdlWords[s])) {
-
-					token.image = token.image.toLowerCase();
-					int l = token.beginLine - 1;
-					String curline = lines[l];
-
-					String sub1 = curline.substring(0, token.beginColumn - 1);
-					if (token.endColumn == lines[l].length()) {
-						;
-						lines[l] = "" + sub1 + HdlScanner.vhdlWords[s];
-					} else {
-						String sub2 = curline.substring(token.endColumn);
-						lines[l] = "" + sub1 + HdlScanner.vhdlWords[s] + sub2;
-					}
-				}
-			}
-		}
-		//reassemble the lines
-		StringBuffer buffer=new StringBuffer();
-		for(int lineNum=0; lineNum < lines.length; lineNum++){
-			//skip the lines that consist only of white space 
-			if (lines[lineNum].trim().length() != 0){
-				buffer.append(lines[lineNum]);				
-			}
-			//do not append a new line to the last line
-			if(lineNum +1 !=  lines.length ){
-				buffer.append(m_eol);
-			}
-		}
-		return buffer.toString(); 
-	}
-
-}
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2006 Ali Ghorashi and others.
+ *
+ * Contributors:
+ *    Ali Ghorashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.actions;
+
+import java.io.StringReader;
+import java.util.ArrayList;
+import java.util.HashMap;
+
+import com.elphel.vdt.veditor.VerilogPlugin;
+import com.elphel.vdt.veditor.editor.scanner.HdlScanner;
+import com.elphel.vdt.veditor.parser.vhdl.SimpleCharStream;
+import com.elphel.vdt.veditor.parser.vhdl.Token;
+import com.elphel.vdt.veditor.parser.vhdl.VhdlParserCoreTokenManager;
+import com.elphel.vdt.veditor.preference.PreferenceStrings;
+
+import org.eclipse.jface.text.TextUtilities;
+import org.eclipse.swt.custom.StyledText;
+import org.eclipse.swt.graphics.Point;
+
+public class VhdlFormatAction extends AbstractAction {
+	private boolean m_UseSpaceForTab;
+	private int     m_IndentSize=0;
+	private boolean m_PadOperators=true;
+	private boolean m_IndentLibrary=true;
+	private boolean m_KeywordsLowercase = true;
+	private boolean m_AlignOnArrowRight = true;
+	private boolean m_AlignOnArrowLeft = true;
+	private boolean m_AlignOnColon = true;
+	private boolean	m_AlignOnAssignment	= true;
+	private boolean	m_AlignOnComment	= true;
+	private boolean	m_AlignInOut		= true;
+	private String m_eol;
+	
+	/**
+	 * Class used to store stop and start points for 
+	 * fixing indents
+	 */
+	private class StartStop{
+		public int start;
+		public int indentAmount;
+	}
+	
+	public VhdlFormatAction(){
+		super("VhdlFormatAction");
+	}
+
+	@Override
+	public void run() {		
+		StyledText widget = getViewer().getTextWidget();
+		//mg
+		final int topLineIndex = widget.getTopIndex();
+		//mg------------------------
+
+		Point point = widget.getSelection();
+		int begin = point.x;
+		int end = point.y;
+		
+		//if nothing is selected
+		if(begin == end){
+			return;
+		}
+		// begin index must be top of line
+		int line = widget.getLineAtOffset(begin);
+		begin = widget.getOffsetAtLine(line);
+		String selectedText = widget.getText(begin, end - 1);		
+		//get the user preferences
+		getPreferences();
+		
+		selectedText = selectedText.replaceAll("\r\n","\n");
+		selectedText = selectedText.replaceAll("\r","\n");
+	
+		selectedText=fixIndentation(selectedText);	
+		selectedText=addSpacePadding(selectedText);
+		selectedText=convertTabs(selectedText);	
+		// adjust the case of key words
+		if(m_KeywordsLowercase){
+			selectedText=fixCase(selectedText);
+		}
+		// align on colons
+		if (m_AlignOnColon) {
+			selectedText=alignBefore(selectedText,new int[]{VhdlParserCoreTokenManager.COLON});
+		}
+		// do we need to align after direction assignments
+		if ( m_AlignInOut ) {			
+			selectedText=alignAfter(selectedText, 
+					new int[]{ VhdlParserCoreTokenManager.IN, 
+				               VhdlParserCoreTokenManager.OUT,
+				               VhdlParserCoreTokenManager.INOUT,
+				               VhdlParserCoreTokenManager.BUFFER	
+					          }
+			        );
+		}
+		if (m_AlignOnArrowRight) {
+			selectedText=alignBefore(selectedText,new int[]{VhdlParserCoreTokenManager.RARROW});
+		}
+		if (m_AlignOnArrowLeft) {
+			selectedText=alignBefore(selectedText,new int[]{VhdlParserCoreTokenManager.LE});
+		}
+		if ( m_AlignOnAssignment ) {
+			selectedText=alignBefore(selectedText,new int[]{VhdlParserCoreTokenManager.ASSIGN});
+		}		
+		if ( m_AlignOnComment ) {
+			selectedText=alignBefore(selectedText,new int[]{VhdlParserCoreTokenManager.COMMENT});
+		}
+		
+		
+		//replace the text
+		widget.replaceTextRange(begin, end - begin, selectedText);
+		
+		//set caret and the part shown in the editor
+		//mg
+		if ( topLineIndex <= widget.getLineCount() ) {
+			widget.setCaretOffset( widget.getOffsetAtLine( topLineIndex ) );
+			widget.setTopIndex( topLineIndex );
+		}
+		//mg-------------------------------
+	}
+	
+	/**
+	 * Gets the code style preferences
+	 */
+	private void getPreferences(){
+		String indent = VerilogPlugin.getPreferenceString("Style.indent");
+		if (indent.equals("Tab"))
+			m_UseSpaceForTab=false;
+		else
+		{
+			m_UseSpaceForTab=true;
+			String size = VerilogPlugin.getPreferenceString("Style.indentSize");
+			m_IndentSize= Integer.parseInt(size);			
+		}
+		
+		m_PadOperators=VerilogPlugin.getPreferenceBoolean(PreferenceStrings.PAD_OPERATORS);
+		m_IndentLibrary=VerilogPlugin.getPreferenceBoolean(PreferenceStrings.INDENT_LIBRARY);
+		m_KeywordsLowercase = VerilogPlugin.getPreferenceBoolean(PreferenceStrings.KEYWORDS_LOWERCASE);
+		m_AlignOnColon = VerilogPlugin.getPreferenceBoolean(PreferenceStrings.ALIGNONCOLON);
+		m_AlignOnArrowRight = VerilogPlugin	.getPreferenceBoolean(PreferenceStrings.ALIGNONARROWRIGHT);
+		m_AlignOnArrowLeft = VerilogPlugin	.getPreferenceBoolean(PreferenceStrings.ALIGNONARROWLEFT);
+		m_AlignOnAssignment = VerilogPlugin.getPreferenceBoolean( PreferenceStrings.ALIGNONASSIGNMENT );
+		m_AlignOnComment = VerilogPlugin.getPreferenceBoolean( PreferenceStrings.ALIGNONCOMMENT );
+		m_AlignInOut = VerilogPlugin.getPreferenceBoolean( PreferenceStrings.ALIGNINOUT );
+		
+		m_eol = TextUtilities.getDefaultLineDelimiter(getViewer().getDocument());
+	}
+	
+	/**
+	 * Increases or decreases the indent value of a given line by the specified adjustment
+	 * @param map The line to indent value mapping
+	 * @param line the Line to adjust
+	 * @param adjustment the amount of adjustment needed
+	 */
+	private void adjustLineIndentValue(HashMap<Integer,Integer> map,int line,int adjustment){
+		//if the line exists, we need to change it
+		if(map.containsKey(line)){
+			int value=map.get(line)+adjustment;			
+			map.put(line, value);
+		}
+		else{
+			//just add the adjustment
+			map.put(line, adjustment);
+		}
+	}
+	
+	/**
+	 * Scans the token list for the next occurrence of the given image 
+	 * @param image Token image
+	 * @param tokens Token list
+	 * @param startIdx starting index
+	 * @return the index of the next token with the given image. tokens.size() if not found
+	 */
+	private int skipTo(String image,ArrayList<Token> tokens,int startIdx){		
+		while(startIdx < tokens.size()){
+			if (tokens.get(startIdx).image.toUpperCase().equals(image.toUpperCase())){
+				break;
+			}
+			startIdx++;
+		}
+		return startIdx;
+	}	
+	/**
+	 * Scans the token list for the next matching close parenthesis 
+	 * @param tokens Token list
+	 * @param startIdx starting index
+	 * @return the index of the next token with the given image. tokens.size() if not found
+	 */
+	private int skipToCloseParan(ArrayList<Token> tokens,int startIdx){
+		int numOpen=1;
+		while(startIdx < tokens.size()){
+			if (tokens.get(startIdx).image.equals("(")){
+				numOpen++;
+			}else if (tokens.get(startIdx).image.equals(")")){
+				numOpen--;
+				if(numOpen == 0){
+					break;
+				}
+			}
+			
+			startIdx++;
+		}
+		return startIdx;
+	}
+	/**
+	 * Computes the amount of indentation that needs to be applied to a set of
+	 * lines based on the tokens
+	 * @param tokens Tokens in the lines
+	 * @return A map between lines numbers and the indentation adjustment
+	 */
+	private HashMap<Integer,Integer> computeIndentation(ArrayList<Token> tokens){
+		HashMap<Integer,Integer> results=new HashMap<Integer,Integer>();
+		//compute indentation
+		
+		// 'when' has another meaning when it is used inside or outside a case
+		// we keep a counter whether we are in a case structure or not
+		// (cases can be nested)
+		int incase = 0;
+		int use;
+		int EOS;
+		for(int i=0;i < tokens.size();i++){
+			Token token=tokens.get(i);
+			if(token.image.equals("(")) {
+				int openParan1=i;
+				int closeParan1=skipToCloseParan(tokens, openParan1+1);
+
+				// skip if there are no parameters
+				int semicolon=skipTo(";", tokens, i+1);
+				
+				//did we find what we were looking for?
+				if(openParan1>=semicolon || closeParan1 >= tokens.size()) {
+					break;
+				}
+
+				//if the open and close parentheses are on different lines
+				if(tokens.get(closeParan1).beginLine > tokens.get(openParan1).beginLine ){
+					adjustLineIndentValue(results,tokens.get(openParan1).beginLine+1, +1);
+					//move the line with close parenthesis only if it is the only token on that line
+					if(tokens.get(closeParan1-1).beginLine != tokens.get(closeParan1).beginLine){
+						adjustLineIndentValue(results,tokens.get(closeParan1).beginLine, -1);
+					}
+					else{
+						//otherwise, just adjust the following line
+						adjustLineIndentValue(results,tokens.get(closeParan1).beginLine+1, -1);
+					}
+				}
+				i=closeParan1;
+			}
+			switch(token.kind){
+			case VhdlParserCoreTokenManager.CASE:
+				adjustLineIndentValue(results,token.beginLine+1, +2);
+				incase++;
+				i = skipTo("is", tokens,i+1);
+				break;
+			case VhdlParserCoreTokenManager.LIBRARY:
+				i = skipTo(";", tokens, i + 1);
+				if (m_IndentLibrary) {
+					// skip to eos
+					use = skipTo("use", tokens, i + 1);
+					EOS = skipTo(";", tokens, i + 1);
+					if (use == tokens.size() || EOS == tokens.size()) {
+						break;
+					}
+					if (use < EOS) {
+						adjustLineIndentValue(results,tokens.get(use).beginLine, +1);
+					}
+					while (use < EOS) {
+						i = EOS;
+						use = skipTo("use", tokens, i + 1);
+						EOS = skipTo(";", tokens, i + 1);
+					}
+					adjustLineIndentValue(results, tokens.get(i).beginLine + 1,	-1);
+				}
+				break;
+			case VhdlParserCoreTokenManager.TYPE:
+				EOS=skipTo(";", tokens, i+1);
+				int record=skipTo("record", tokens, i+1);
+				//if a record was found before EOF, then indent
+				if(EOS > record){
+					i=record;
+					adjustLineIndentValue(results,tokens.get(record).beginLine+1, +1);
+				} else {
+					int semicolon=skipTo(";", tokens, i+1);
+					int isToken=skipTo("is", tokens, i+1);
+					if(isToken<semicolon) {
+						//breaks the "indent after 'is'" rule. 
+						i=isToken;
+					}
+				}
+				break;
+			case VhdlParserCoreTokenManager.ATTRIBUTE:
+			case VhdlParserCoreTokenManager.ALIAS:
+			case VhdlParserCoreTokenManager.FILE:
+			case VhdlParserCoreTokenManager.SUBTYPE:
+				//These tokens break the "indent after 'is'" rule. If
+				//One is encountered, just skip to EOS
+				i=skipTo(";", tokens, i+1);
+				break;
+			case VhdlParserCoreTokenManager.COMPONENT:
+				// component can be defined without an "is"
+				int isTokenPos=skipTo("is", tokens, i+1);
+				EOS = skipTo(";", tokens, i+1);
+				if(isTokenPos > EOS) {
+					results.put(token.beginLine+1, +1);
+				}
+				break;
+			case VhdlParserCoreTokenManager.PROCESS:
+				// process can be defined without an "is"
+				if(tokens.get(i+1).image.equals("(")) {
+					// process has sensitivity list, indent after ")"
+					int closeParan = skipToCloseParan(tokens, i+2);
+					if(!tokens.get(closeParan+1).image.equals("is")) {
+						adjustLineIndentValue(results,tokens.get(closeParan).beginLine+1, +1);
+					}
+				} else {
+					// no sensitivity list indent next line:
+					if(!tokens.get(i+1).image.equals("is")) {
+						adjustLineIndentValue(results,token.beginLine+1, +1);
+					}
+				}
+				break;
+			case VhdlParserCoreTokenManager.BLOCK:
+			case VhdlParserCoreTokenManager.GENERATE:
+			case VhdlParserCoreTokenManager.IS:
+			case VhdlParserCoreTokenManager.LOOP:
+			case VhdlParserCoreTokenManager.THEN:
+				adjustLineIndentValue(results,token.beginLine+1, +1);
+				break;			
+			case VhdlParserCoreTokenManager.ELSIF:
+				adjustLineIndentValue(results,token.beginLine, -1);
+				break;
+			case VhdlParserCoreTokenManager.BEGIN:
+			case VhdlParserCoreTokenManager.ELSE:
+				if (token.beginLine != tokens.get(i-1).beginLine) {
+					adjustLineIndentValue(results,token.beginLine, -1);
+					adjustLineIndentValue(results,token.beginLine+1 , +1);
+				}
+				break;
+			case VhdlParserCoreTokenManager.END:
+				if(i<tokens.size()-1 && tokens.get(i+1).kind==VhdlParserCoreTokenManager.CASE) {
+					adjustLineIndentValue(results,token.beginLine, -2);
+					if(incase>0) incase--;
+				} else {
+					if (token.beginLine == tokens.get(i-1).beginLine) {
+						// end is not the first token on this line
+						adjustLineIndentValue(results, token.beginLine + 1, -1);
+					} else {
+						adjustLineIndentValue(results, token.beginLine, -1);
+					}
+				}
+				//skip to eos
+				i=skipTo(";", tokens, i+1);				
+				break;
+			case VhdlParserCoreTokenManager.WITH:
+				int startToken=i;				
+				i=skipTo(";", tokens, i+1);
+				//if the with and the semicolon are on different lines
+				//indent the lines between;
+				if(tokens.get(i).beginLine > tokens.get(startToken).beginLine){
+					results.put(tokens.get(startToken).beginLine+1, +1);
+					results.put(tokens.get(i).beginLine+1, -1);
+				}
+				break;
+			case VhdlParserCoreTokenManager.PROCEDURE:
+			case VhdlParserCoreTokenManager.FUNCTION:
+			case VhdlParserCoreTokenManager.PORT:
+			case VhdlParserCoreTokenManager.GENERIC:
+			case VhdlParserCoreTokenManager.SIGNAL:
+			case VhdlParserCoreTokenManager.CONSTANT:
+			case VhdlParserCoreTokenManager.VARIABLE:
+				adjustLineIndentValue(results,tokens.get(i).beginLine, 0);
+				// code has been moved to "("
+				break;
+			case VhdlParserCoreTokenManager.WHEN:
+				if(incase>0) {
+					adjustLineIndentValue(results,token.beginLine, -1);
+					adjustLineIndentValue(results,token.beginLine+1, +1);
+				} else {
+					// ... <= ... when ... else ...;
+					i=skipTo(";", tokens, i+1);
+				}
+				break;
+			default:				
+				break;
+			}
+		}
+		return results;
+	}
+	 
+	/**
+	 * Fixes the line indentation for the given text block
+	 * @param text text block to examine
+	 * @return properly indented string
+	 */
+	private String fixIndentation(String text){		
+		String[] lines = text.split("\n");
+		//if there is only 1 line, bail
+		if(lines.length < 2){
+			return text;
+		}
+		ArrayList<Token> tokens=TokenizeText(text);
+		HashMap<Integer,Integer> lineIndentation=computeIndentation(tokens);
+
+		//adjust the lines
+		String indentString=getIndentString();		
+		String currentIndent=getLineIndent(lines[0]);
+		
+		for(int lineNum=0; lineNum < lines.length; lineNum++){			
+			//adjust the indentation. Need to add 1 since the token lines are zero based			
+			if(lineIndentation.containsKey(lineNum+1)){
+				int indentValue=lineIndentation.get(lineNum+1);
+				if(indentValue > 0){
+					for(int i=0;i<indentValue;i++){
+						currentIndent+=indentString;
+					}
+				}
+				else if (indentValue < 0){
+					for(int i=indentValue;i<0;i++){
+						//back up by one indent
+						int endLocation=currentIndent.length()-indentString.length();
+						if(endLocation >= 0){
+							currentIndent=currentIndent.substring(0, endLocation);
+						}
+					}									
+				}
+			}
+			
+			String prevline = lineNum>0?lines[lineNum-1]:"";
+			// trim comment at the end of the line:
+			int indexcomment=prevline.indexOf("--");
+			if(indexcomment>=0) prevline = prevline.substring(0,indexcomment).trim();
+			
+			// sometimes statements are written over multiple lines
+			// in that case, only adjust the first line.			
+			boolean linecontinuation =
+				!lineIndentation.containsKey(lineNum+1) &&//lineIndentation starts counting at 0!
+				!prevline.endsWith(",") &&
+				!prevline.endsWith(";") &&
+				prevline.trim().length()!=0;
+			if(!lines[lineNum].trim().startsWith("--") && !linecontinuation)
+				lines[lineNum]=currentIndent+lines[lineNum].trim();
+			else {
+				// remove <CR>
+				lines[lineNum] = lines[lineNum].replaceAll("\r", "");
+			}
+
+		}
+
+		StringBuffer buffer=new StringBuffer();
+		for(int lineNum=0; lineNum < lines.length; lineNum++){
+			if (lines[lineNum].trim().length() != 0){
+				buffer.append(lines[lineNum]);
+			}
+			buffer.append(m_eol);
+		}
+		return buffer.toString();
+	}
+	
+	/**
+	 * Converts the tabs to spaces 
+	 * @param text Text block to examine
+	 * @return Converted text
+	 */
+	private String convertTabs(String text){
+		String results=text;
+		if(m_UseSpaceForTab){
+			String indentString=getIndentString();
+			results=text.replaceAll("\t", indentString);
+		}
+		return results;
+	}
+	
+	/**
+	 * Adds a space location to a list of lines
+	 * @param list
+	 * @param line
+	 * @param col
+	 */
+	private void addSpace(HashMap<Integer,ArrayList<Integer>> list,int line,int col){
+		ArrayList<Integer> intList;
+		if(list.containsKey(line)){
+			intList=list.get(line);			
+		}
+		else{
+			intList=new ArrayList<Integer>();			
+			list.put(line, intList);
+		}
+		intList.add(col);
+	}
+	/**
+	 * Adds padding for spaces around the necessary elements
+	 * @param text Text block to examine
+	 * @return Padded text
+	 */
+	private String addSpacePadding(String text) {
+		
+		if(!m_PadOperators){
+			return text;
+		}
+		// get a list of lines
+		String[] lines = text.split("\n");
+		ArrayList<Token> tokens=TokenizeText(text);
+		HashMap<Integer,ArrayList<Integer>> spaceLocations=new HashMap<Integer,ArrayList<Integer>>();		
+		for(int i=0;i<tokens.size();i++){
+			Token token=tokens.get(i);
+			switch (token.kind) {			
+			case VhdlParserCoreTokenManager.CONCAT:
+			case VhdlParserCoreTokenManager.EQ:
+			case VhdlParserCoreTokenManager.NEQ:
+			case VhdlParserCoreTokenManager.GE:
+			case VhdlParserCoreTokenManager.LE:
+			case VhdlParserCoreTokenManager.GT:
+			case VhdlParserCoreTokenManager.LO:
+			case VhdlParserCoreTokenManager.COLON:
+			case VhdlParserCoreTokenManager.ASSIGN:
+			case VhdlParserCoreTokenManager.RARROW:
+				//remember, columns and lines are 1 based
+				addSpace(spaceLocations,token.beginLine-1,token.beginColumn-1);
+				addSpace(spaceLocations,token.beginLine-1,token.endColumn);
+				break;
+			case VhdlParserCoreTokenManager.SEMICOLON:
+				//remember, columns and lines are 1 based
+				addSpace(spaceLocations,token.beginLine-1,token.endColumn);
+				break;
+			default:
+				break;
+			}
+			
+		}
+		// reassemble the lines
+		StringBuffer buffer = new StringBuffer();
+		for (int lineNum = 0; lineNum < lines.length; lineNum++) {
+			String line;
+			//do we need to fix this line?
+			if(spaceLocations.containsKey(lineNum)){
+				ArrayList<Integer> spaces=spaceLocations.get(lineNum);
+				int spaceIdx=0;
+				StringBuffer buff=new StringBuffer();
+				//copy the line and add space when necessary
+				for(int i=0;i<lines[lineNum].length();i++){
+					if(spaceIdx < spaces.size() && i == spaces.get(spaceIdx)){
+						spaceIdx++;
+						if(Character.isWhitespace(lines[lineNum].charAt(i-1))==false &&
+						   Character.isWhitespace(lines[lineNum].charAt(i))==false){
+							buff.append(" ");
+						}
+					}
+					buff.append(lines[lineNum].charAt(i));					
+				}
+				line=buff.toString();
+			}
+			else{
+				line=lines[lineNum];
+			}
+			// remove <CR>
+			line = line.replaceAll("\r", "");
+			buffer.append(line);			
+			buffer.append(m_eol);
+		}
+		return buffer.toString();
+	}
+	
+	/**
+	 * A derived class to override the tab size
+	 *
+	 */
+	private class CharStream extends SimpleCharStream{
+
+		public CharStream(java.io.Reader dstream) {
+			super(dstream);			
+		}		
+		public void setTabSize(int i){
+			super.setTabSize(i);
+		}		
+	}
+	/**
+	 * Tokenizes the given text block using VHDL rules
+	 * 
+	 * @param text
+	 * @return A list of tokens in the given text
+	 */
+	private ArrayList<Token> TokenizeText(String text){
+		StringReader stringReader=new StringReader(text);
+		CharStream stream=new CharStream(stringReader);
+		stream.setTabSize(1); //set the tab size to 1 in order to match string index
+		VhdlParserCoreTokenManager tokenManager=new VhdlParserCoreTokenManager(stream);
+		Token token=null;
+		ArrayList <Token> results=new ArrayList<Token>();
+		
+		do{
+			token=tokenManager.getNextToken();
+			if(token.kind != VhdlParserCoreTokenManager.EOF){
+				results.add(token);
+			}
+		}while(token.kind != VhdlParserCoreTokenManager.EOF);
+		
+		return results;
+	}
+	
+	/**
+	 * Returns the string that is to be used for indenting
+	 * @return
+	 */
+	private String getIndentString(){
+		String results="";
+		if(m_UseSpaceForTab){			
+			for(int i=0;i<m_IndentSize;i++){
+				results+=" ";
+			}			
+		}
+		else{
+			results="\t";
+		}
+		return results;
+	}
+	
+	/**
+	 * Returns the indent string used before the first non white character
+	 * @param line line to be examined
+	 * @return
+	 */
+	private String getLineIndent(String line){
+		//find the indent of the first line
+		int firstNonSpace=0;
+		for(firstNonSpace=0;firstNonSpace < line.length();firstNonSpace++){
+			if(Character.isWhitespace(line.charAt(firstNonSpace))==false){
+				break;
+			}
+		}
+		return line.substring(0, firstNonSpace);
+	}
+
+		
+	/**
+	 * Create a string made up of the repetition of str
+	 * @param str The String to repeat
+	 * @param repeat Number of times to repeat
+	 * @return new String
+	 */
+	private String fillString(String str,int repeat){
+		StringBuffer results=new StringBuffer();
+		for(int i=0; i < repeat; i++){
+			results.append(str);
+		}
+		return results.toString();
+	}
+	
+	/**
+	 * Checks to see if the passed token is on list of tokens
+	 * @return true if the token is on the list, false if not
+	 */
+	private boolean isTokenOnList(int tokenId, int valid_tokens[]){
+		for(int i: valid_tokens){
+			if (tokenId == i){
+				return true;
+			}
+		}
+		return false;
+	}
+	
+	/**
+	 * Aligns the text before one or more tokens
+	 * @param text
+	 * @param valid_tokens An array of tokens to align on
+	 * @return String after alignment is done
+	 * @note The alignment value is only valid for a consecutive set of lines. If
+	 * a line without a token is encountered, the alignment value gets reset
+	 */
+	private String alignBefore(String text,int valid_tokens[]) {
+		// list of lines that need to be indented and the location of indent
+		HashMap<Integer,StartStop> indentSet = new HashMap<Integer,StartStop>();		
+		//grouping of indent level
+		ArrayList <HashMap<Integer,StartStop>> indentGroups = new ArrayList <HashMap<Integer,StartStop>>() ;	
+		ArrayList<Token> tokens=TokenizeText(text);
+		String[] lines=text.split(m_eol);
+		//if there is only 1 line, bail
+		if(lines.length < 2){
+			return text;
+		}
+		
+		//find the indent position following the direction directive
+		int maxPosAfterDirection=0;
+		int lastLineWithToken=0;		
+		for(int i=0;i < tokens.size();i++){
+			Token token=tokens.get(i);
+			if(isTokenOnList(token.kind,valid_tokens) ){		
+				lastLineWithToken =  token.beginLine;
+				//record the info about the tokens
+				StartStop indentInfo = new StartStop();
+				indentInfo.start = token.beginColumn;				
+				//token lines are one based
+				indentSet.put(token.beginLine -1, indentInfo);
+				//record the max indentation after the directive
+				if(tokens.get(i).beginColumn  > maxPosAfterDirection){
+					maxPosAfterDirection=tokens.get(i).beginColumn;
+				}				
+				
+			}
+			else{
+				//token not found
+				if (  token.beginLine > (lastLineWithToken+1) && lastLineWithToken!=0){
+					// we encounter a whole line without a valid token 
+					for( Integer line: indentSet.keySet()){
+						//set all the indent values to max encountered in this block
+						indentSet.get(line).indentAmount = maxPosAfterDirection;					
+					}
+					//file away the current group
+					indentGroups.add(indentSet);
+					//make a new group
+					indentSet = new HashMap<Integer,StartStop>();				
+					maxPosAfterDirection=0;
+					lastLineWithToken   =0;
+				}
+			}
+		}	
+		//add the last alignment set to the list
+		for( Integer line: indentSet.keySet()){
+			//set all the indent values to max encountered in this block
+			indentSet.get(line).indentAmount = maxPosAfterDirection;					
+		}
+		indentGroups.add(indentSet);
+		
+		
+		for(HashMap<Integer,StartStop> indentInfoSet : indentGroups){
+			//adjust alignment
+			for( Integer line: indentInfoSet.keySet()){
+				StartStop indentInfo=indentInfoSet.get(line);
+				String indentString = fillString(" ", indentInfo.indentAmount - indentInfo.start+1);
+				String str1 =  lines[line].substring(0,indentInfo.start-2);
+				String str2 =  lines[line].substring(indentInfo.start-1);
+				lines[line] = str1 + indentString + str2;
+			}
+		}
+		
+		//reassemble the lines
+		StringBuffer buffer=new StringBuffer();
+		for(int lineNum=0; lineNum < lines.length; lineNum++){
+			//skip the lines that consist only of white space 
+			if (lines[lineNum].trim().length() != 0){
+				buffer.append(lines[lineNum]);				
+			}
+			//do not append a new line to the last line
+			if(lineNum +1 !=  lines.length ){
+				buffer.append(m_eol);
+			}
+		}
+		return buffer.toString(); 
+	}
+
+	/**
+	 * Aligns the text after one or more tokens
+	 * @param text
+	 * @param valid_tokens An array of tokens to align on
+	 * @return String after alignment is done
+	 * @note The alignment value is only valid for a consecutive set of lines. If
+	 * a line without a token is encountered, the alignment value gets reset
+	 */
+	private String alignAfter(String text,int valid_tokens[]) {
+		// list of lines that need to be indented and the location of indent
+		HashMap<Integer,StartStop> indentSet = new HashMap<Integer,StartStop>();
+		//grouping of indent level
+		ArrayList <HashMap<Integer,StartStop>> indentGroups = new ArrayList <HashMap<Integer,StartStop>>() ;		
+		ArrayList<Token> tokens=TokenizeText(text);
+		String[] lines=text.split(m_eol);
+		//if there is only 1 line, bail
+		if(lines.length < 2){
+			return text;
+		}
+		
+		//find the indent position following the direction directive
+		int maxPosAfterDirection=0;
+		int lastLineWithToken=0;		
+		for(int i=0;i < tokens.size();i++){
+			Token token=tokens.get(i);					
+			 
+			if(isTokenOnList(token.kind,valid_tokens) ){				
+				lastLineWithToken =  token.beginLine;
+				//make sure there is another token on the same line
+				if( (i+1) < tokens.size() && token.beginLine == tokens.get(i+1).beginLine){
+					//record the info about the tokens
+					StartStop indentInfo = new StartStop();				
+					indentInfo.start  = tokens.get(i+1).beginColumn;
+					//token lines are one based
+					indentSet.put(token.beginLine -1, indentInfo);
+					//record the max indentation after the directive
+					if(tokens.get(i+1).beginColumn  > maxPosAfterDirection){
+						maxPosAfterDirection=tokens.get(i+1).beginColumn;
+					}					
+				}
+			}			
+			else{
+				//token not found
+				if (  token.beginLine > (lastLineWithToken+1) && lastLineWithToken!=0){
+					// we encounter a whole line without a valid token 
+					for( Integer line: indentSet.keySet()){
+						//set all the indent values to max encountered in this block
+						indentSet.get(line).indentAmount = maxPosAfterDirection;					
+					}
+					//file away the current group
+					indentGroups.add(indentSet);
+					//make a new group
+					indentSet = new HashMap<Integer,StartStop>();				
+					maxPosAfterDirection=0;
+					lastLineWithToken   =0;
+				}
+			}
+		}	
+		//add the last alignment set to the list
+		for( Integer line: indentSet.keySet()){
+			//set all the indent values to max encountered in this block
+			indentSet.get(line).indentAmount = maxPosAfterDirection;					
+		}
+		indentGroups.add(indentSet);
+		
+		for(HashMap<Integer,StartStop> indentInfoSet : indentGroups){
+			//adjust alignment
+			for( Integer line: indentInfoSet.keySet()){
+				StartStop indentInfo=indentInfoSet.get(line);
+				String indentString = fillString(" ", indentInfo.indentAmount - indentInfo.start+1);
+				String str1 =  lines[line].substring(0,indentInfo.start-2);
+				String str2 =  lines[line].substring(indentInfo.start-1);
+				lines[line] = str1 + indentString + str2;
+			}
+		}
+		
+		//reassemble the lines
+		StringBuffer buffer=new StringBuffer();
+		for(int lineNum=0; lineNum < lines.length; lineNum++){
+			//skip the lines that consist only of white space 
+			if (lines[lineNum].trim().length() != 0){
+				buffer.append(lines[lineNum]);				
+			}
+			buffer.append(m_eol);
+		}
+		return buffer.toString(); 
+	}
+	
+	/**
+	 * Converts all the keywords in the passed text to lower case
+	 * @param text Text to be formatted
+	 */
+	private String fixCase(String text) {
+		ArrayList<Token> tokens=TokenizeText(text);
+		String[] lines=text.split(m_eol);
+		//if there is only 1 line, bail
+		if(lines.length < 2){
+			return text;
+		}
+		
+		for (int tokennr = 0; tokennr < tokens.size(); tokennr++) {
+			Token token = tokens.get(tokennr);
+			for (int s = 0; s < HdlScanner.vhdlWords.length; s++) {
+
+				if (token.image.equalsIgnoreCase(HdlScanner.vhdlWords[s])) {
+
+					token.image = token.image.toLowerCase();
+					int l = token.beginLine - 1;
+					String curline = lines[l];
+
+					String sub1 = curline.substring(0, token.beginColumn - 1);
+					if (token.endColumn == lines[l].length()) {
+						;
+						lines[l] = "" + sub1 + HdlScanner.vhdlWords[s];
+					} else {
+						String sub2 = curline.substring(token.endColumn);
+						lines[l] = "" + sub1 + HdlScanner.vhdlWords[s] + sub2;
+					}
+				}
+			}
+		}
+		//reassemble the lines
+		StringBuffer buffer=new StringBuffer();
+		for(int lineNum=0; lineNum < lines.length; lineNum++){
+			//skip the lines that consist only of white space 
+			if (lines[lineNum].trim().length() != 0){
+				buffer.append(lines[lineNum]);				
+			}
+			//do not append a new line to the last line
+			if(lineNum +1 !=  lines.length ){
+				buffer.append(m_eol);
+			}
+		}
+		return buffer.toString(); 
+	}
+
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/builder/BuildConfig.java vdt/src/com/elphel/vdt/veditor/builder/BuildConfig.java
--- vdt-veditor/src/com/elphel/vdt/veditor/builder/BuildConfig.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/builder/BuildConfig.java	2016-06-24 10:29:40.816496628 -0600
@@ -1,168 +1,179 @@
-/*******************************************************************************
- * Copyright (c) 2006 Ali Ghorashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    Ali Ghorashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.builder;
-
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Map;
-
-import net.sourceforge.veditor.HdlNature;
-
-
-/**
- * Class encapsulating command arguments
- */
-public class BuildConfig extends Object{
-    static final String ENABLE_STR     = HdlNature.SIMULATOR_ID+".%s.enable";
-    static final String COMMAND_STR    = HdlNature.SIMULATOR_ID+".%s.command";
-    static final String CLEAN_CMD_STR  = HdlNature.SIMULATOR_ID+".%s.CleanCommand";
-    static final String PARSER_STR     = HdlNature.SIMULATOR_ID+".%s.parser";
-    static final String WORK_FOLDER_STR= HdlNature.SIMULATOR_ID+".%s.workFolder";
-    static final String BUILD_ORDER_STR= HdlNature.SIMULATOR_ID+".%s.buildOrder";
-    static final String NAME_STR       = HdlNature.SIMULATOR_ID+".%s.name";
-	
-	Boolean m_Enabled;
-	String  m_Name;
-	String  m_Command;
-	String  m_CleanCommand;
-	String  m_Parser;
-	String  m_WorkFolder;
-	Integer m_BuildOrder;		
-	
-	/**
-	 * Creates a copy of this class
-	 */
-	public BuildConfig clone(){
-		return new BuildConfig(m_Name,m_Enabled,m_BuildOrder,m_Command,m_CleanCommand,m_Parser,m_WorkFolder);
-	}
-	/**
-	 * Default constructor
-	 */		
-	public BuildConfig(){
-		m_Enabled=true;
-		m_Command="echo 'No Build Configuration Specified'";
-		m_CleanCommand="echo 'Clean'";
-		m_Parser="";
-		m_WorkFolder="";
-		m_BuildOrder=0;		
-		m_Name="Default";
-	}
-	/**
-	 * Constructor
-	 * @param enable Enable
-	 * @param buildOrder build order
-	 * @param cmd    Command
-	 * @param args   Command arguments
-	 * @param parser Error parser
-	 * @param folder Work folder
-	 */
-	public BuildConfig(String name,boolean enable,int buildOrder,String cmd, String cleanCmd, String parser,String folder){
-		m_Enabled=enable;
-		m_Command=cmd;
-		m_CleanCommand=cleanCmd;
-		m_Parser=parser;
-		m_WorkFolder=folder;
-		m_BuildOrder=buildOrder;
-		m_Name=name;
-	}
-	/**
-	 * Converts the values into a map of name-value pair
-	 * @return
-	 */
-	public void addValuesToMap(HashMap<String,String> map){
-		
-		String padded_BuildOrder=String.format("%08d", m_BuildOrder);
-			
-		map.put(String.format(ENABLE_STR,padded_BuildOrder+m_Name), m_Enabled.toString());
-		map.put(String.format(COMMAND_STR,padded_BuildOrder+m_Name), m_Command);
-		map.put(String.format(CLEAN_CMD_STR,padded_BuildOrder+m_Name), m_CleanCommand);
-		map.put(String.format(PARSER_STR,padded_BuildOrder+m_Name), m_Parser);
-		map.put(String.format(WORK_FOLDER_STR,padded_BuildOrder+m_Name), m_WorkFolder);
-		map.put(String.format(BUILD_ORDER_STR,padded_BuildOrder+m_Name), m_BuildOrder.toString());
-		map.put(String.format(NAME_STR,padded_BuildOrder+m_Name), m_Name);
-
-	}		
-	/**
-	 * Sets the internal parameters using the name-value pair
-	 * @param map
-	 * @param name the name of this element
-	 */
-	public void setValues(Map<String,String> map,String name){
-		m_Enabled=Boolean.parseBoolean(map.get(String.format(ENABLE_STR,name)));
-		m_Command=map.get(String.format(COMMAND_STR,name));
-		m_CleanCommand=map.get(String.format(CLEAN_CMD_STR,name));
-		m_Parser=map.get(String.format(PARSER_STR,name));
-		m_WorkFolder=map.get(String.format(WORK_FOLDER_STR,name));
-		m_BuildOrder=Integer.parseInt(map.get(String.format(BUILD_ORDER_STR,name)));
-		m_Name=map.get(String.format(NAME_STR,name));
-	}
-
-	public boolean isEnabled() {return m_Enabled;}
-	public String getCommand() {return m_Command; }
-	public String getCleanCommand() {return m_CleanCommand; }
-	public String getParser() {return m_Parser;	}
-	public String getWorkFolder() {	return m_WorkFolder;	}		
-	public int getBuildOrder(){ return m_BuildOrder;}
-	public String getName(){return m_Name;}
-	public void setEnabled(Boolean enabled) {m_Enabled = enabled;}
-	public void setName(String name) {m_Name = name;	}
-	public void setCommand(String command) {	m_Command = command;}
-	public void setCleanCommand(String command) {	m_CleanCommand = command;}
-	public void setParser(String parser) {m_Parser = parser;	}
-	public void setWorkFolder(String workFolder) {m_WorkFolder = workFolder;	}
-	public void setBuildOrder(Integer buildOrder) {m_BuildOrder = buildOrder;}
-	
-	
-	/**
-	 * Parses a projects argument list to commands
-	 * @param args
-	 * @return A map between configuration names and build configs
-	 */
-	public static Map<String,BuildConfig> parseCommandArguments(Map<String,String> args){
-		HashSet<String> names=new HashSet<String>();
-		Map<String,BuildConfig> configs=new HashMap<String,BuildConfig>();
-		
-		//loop though all the keys and pick out the names
-		for(String argName:args.keySet().toArray(new String[0])){
-			if(argName.startsWith(HdlNature.SIMULATOR_ID)){
-				String []fields=argName.split("\\.");
-				String name=fields[fields.length-2];
-				//have we seen this name?
-				if(names.contains(name) == false){
-					names.add(name);
-				}
-			}
-		}
-		//loop though all the names and create the items
-		for(String name:names){
-			BuildConfig command=new BuildConfig();
-			command.setValues(args, name);
-			configs.put(name, command);			
-		}
-		
-		return configs;
-	}
-	
-	/**
-	 * Encodes the list commands into one argument list
-	 * @param commands
-	 * @return
-	 */
-	public static Map<String,String> encodeArgs(BuildConfig []commands){
-		HashMap<String,String> results=new HashMap<String,String>();
-		
-		for(BuildConfig command:commands){
-			command.addValuesToMap(results);
-		}
-		
-		return results;
-	}
-}
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2006 Ali Ghorashi and others.
+ *
+ * Contributors:
+ *    Ali Ghorashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.builder;
+
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+
+import com.elphel.vdt.veditor.HdlNature;
+
+
+/**
+ * Class encapsulating command arguments
+ */
+public class BuildConfig extends Object{
+    static final String ENABLE_STR     = HdlNature.SIMULATOR_ID+".%s.enable";
+    static final String COMMAND_STR    = HdlNature.SIMULATOR_ID+".%s.command";
+    static final String CLEAN_CMD_STR  = HdlNature.SIMULATOR_ID+".%s.CleanCommand";
+    static final String PARSER_STR     = HdlNature.SIMULATOR_ID+".%s.parser";
+    static final String WORK_FOLDER_STR= HdlNature.SIMULATOR_ID+".%s.workFolder";
+    static final String BUILD_ORDER_STR= HdlNature.SIMULATOR_ID+".%s.buildOrder";
+    static final String NAME_STR       = HdlNature.SIMULATOR_ID+".%s.name";
+	
+	Boolean m_Enabled;
+	String  m_Name;
+	String  m_Command;
+	String  m_CleanCommand;
+	String  m_Parser;
+	String  m_WorkFolder;
+	Integer m_BuildOrder;		
+	
+	/**
+	 * Creates a copy of this class
+	 */
+	public BuildConfig clone(){
+		return new BuildConfig(m_Name,m_Enabled,m_BuildOrder,m_Command,m_CleanCommand,m_Parser,m_WorkFolder);
+	}
+	/**
+	 * Default constructor
+	 */		
+	public BuildConfig(){
+		m_Enabled=true;
+		m_Command="echo 'No Build Configuration Specified'";
+		m_CleanCommand="echo 'Clean'";
+		m_Parser="";
+		m_WorkFolder="";
+		m_BuildOrder=0;		
+		m_Name="Default";
+	}
+	/**
+	 * Constructor
+	 * @param enable Enable
+	 * @param buildOrder build order
+	 * @param cmd    Command
+	 * @param args   Command arguments
+	 * @param parser Error parser
+	 * @param folder Work folder
+	 */
+	public BuildConfig(String name,boolean enable,int buildOrder,String cmd, String cleanCmd, String parser,String folder){
+		m_Enabled=enable;
+		m_Command=cmd;
+		m_CleanCommand=cleanCmd;
+		m_Parser=parser;
+		m_WorkFolder=folder;
+		m_BuildOrder=buildOrder;
+		m_Name=name;
+	}
+	/**
+	 * Converts the values into a map of name-value pair
+	 * @return
+	 */
+	public void addValuesToMap(HashMap<String,String> map){
+		
+		String padded_BuildOrder=String.format("%08d", m_BuildOrder);
+			
+		map.put(String.format(ENABLE_STR,padded_BuildOrder+m_Name), m_Enabled.toString());
+		map.put(String.format(COMMAND_STR,padded_BuildOrder+m_Name), m_Command);
+		map.put(String.format(CLEAN_CMD_STR,padded_BuildOrder+m_Name), m_CleanCommand);
+		map.put(String.format(PARSER_STR,padded_BuildOrder+m_Name), m_Parser);
+		map.put(String.format(WORK_FOLDER_STR,padded_BuildOrder+m_Name), m_WorkFolder);
+		map.put(String.format(BUILD_ORDER_STR,padded_BuildOrder+m_Name), m_BuildOrder.toString());
+		map.put(String.format(NAME_STR,padded_BuildOrder+m_Name), m_Name);
+
+	}		
+	/**
+	 * Sets the internal parameters using the name-value pair
+	 * @param map
+	 * @param name the name of this element
+	 */
+	public void setValues(Map<String,String> map,String name){
+		m_Enabled=Boolean.parseBoolean(map.get(String.format(ENABLE_STR,name)));
+		m_Command=map.get(String.format(COMMAND_STR,name));
+		m_CleanCommand=map.get(String.format(CLEAN_CMD_STR,name));
+		m_Parser=map.get(String.format(PARSER_STR,name));
+		m_WorkFolder=map.get(String.format(WORK_FOLDER_STR,name));
+		m_BuildOrder=Integer.parseInt(map.get(String.format(BUILD_ORDER_STR,name)));
+		m_Name=map.get(String.format(NAME_STR,name));
+	}
+
+	public boolean isEnabled() {return m_Enabled;}
+	public String getCommand() {return m_Command; }
+	public String getCleanCommand() {return m_CleanCommand; }
+	public String getParser() {return m_Parser;	}
+	public String getWorkFolder() {	return m_WorkFolder;	}		
+	public int getBuildOrder(){ return m_BuildOrder;}
+	public String getName(){return m_Name;}
+	public void setEnabled(Boolean enabled) {m_Enabled = enabled;}
+	public void setName(String name) {m_Name = name;	}
+	public void setCommand(String command) {	m_Command = command;}
+	public void setCleanCommand(String command) {	m_CleanCommand = command;}
+	public void setParser(String parser) {m_Parser = parser;	}
+	public void setWorkFolder(String workFolder) {m_WorkFolder = workFolder;	}
+	public void setBuildOrder(Integer buildOrder) {m_BuildOrder = buildOrder;}
+	
+	
+	/**
+	 * Parses a projects argument list to commands
+	 * @param args
+	 * @return A map between configuration names and build configs
+	 */
+	public static Map<String,BuildConfig> parseCommandArguments(Map<String,String> args){
+		HashSet<String> names=new HashSet<String>();
+		Map<String,BuildConfig> configs=new HashMap<String,BuildConfig>();
+		
+		//loop though all the keys and pick out the names
+		for(String argName:args.keySet().toArray(new String[0])){
+			if(argName.startsWith(HdlNature.SIMULATOR_ID)){
+				String []fields=argName.split("\\.");
+				String name=fields[fields.length-2];
+				//have we seen this name?
+				if(names.contains(name) == false){
+					names.add(name);
+				}
+			}
+		}
+		//loop though all the names and create the items
+		for(String name:names){
+			BuildConfig command=new BuildConfig();
+			command.setValues(args, name);
+			configs.put(name, command);			
+		}
+		
+		return configs;
+	}
+	
+	/**
+	 * Encodes the list commands into one argument list
+	 * @param commands
+	 * @return
+	 */
+	public static Map<String,String> encodeArgs(BuildConfig []commands){
+		HashMap<String,String> results=new HashMap<String,String>();
+		
+		for(BuildConfig command:commands){
+			command.addValuesToMap(results);
+		}
+		
+		return results;
+	}
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/builder/ErrorParser.java vdt/src/com/elphel/vdt/veditor/builder/ErrorParser.java
--- vdt-veditor/src/com/elphel/vdt/veditor/builder/ErrorParser.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/builder/ErrorParser.java	2016-06-24 10:29:40.816496628 -0600
@@ -1,450 +1,515 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-
-package net.sourceforge.veditor.builder;
-
-import java.io.File;
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-import net.sourceforge.veditor.VerilogPlugin;
-
-import org.eclipse.core.resources.IContainer;
-import org.eclipse.core.resources.IFile;
-import org.eclipse.core.resources.IMarker;
-import org.eclipse.core.resources.IProject;
-import org.eclipse.core.resources.IResource;
-import org.eclipse.core.resources.ResourcesPlugin;
-import org.eclipse.core.runtime.CoreException;
-import org.eclipse.core.runtime.IPath;
-import org.eclipse.core.runtime.Path;
-import org.eclipse.debug.ui.console.FileLink;
-import org.eclipse.jface.text.BadLocationException;
-import org.eclipse.ui.console.IPatternMatchListener;
-import org.eclipse.ui.console.PatternMatchEvent;
-import org.eclipse.ui.console.TextConsole;
-
-public class ErrorParser
-{
-	private static final String DEFAULT_ERROR_PARSER_REGEX =
-		"ModelSim"
-		+ "\n" + "[#|\\*].*Error: ([^\\(]*)\\(([0-9]*)\\): (.*)"		
-		+ "\n" + "[#|\\*].*Warning: ([^\\(]*)\\(([0-9]*)\\): (.*)"		
-		+ "\n" + ""
-		+ "\n" + "ModelSimSimulation"
-		+ "\n" + "[#|\\*] Break in ([^\\#]*) at ([^\\(#]*) line ([0-9]*)"
-		+ "\n" + ""
-		+ "\n" + "[#|\\*](.*)File: ([^\\#]*) Line: ([0-9]*)"
-		+ "\n" + "Cver"
-		+ "\n" + "\\*\\*(.*)\\(([0-9]+)\\) ERROR\\*\\* (.*)"
-		+ "\n" + "\\*\\*(.*)\\(([0-9]+)\\) WARN\\*\\* (.*)"
-		+ "\n" + "--(.*)\\(([0-9]+)\\) INFORM-- (.*)" 
-		+ "\n" + "Icarus Verilog"
-		+ "\n" + "(.*):([0-9]+): [a-z ]*error: (.*)"
-		+ "\n" + "(.*):([0-9]+): warning: (.*)"
-		+ "\n" + ""
-		+ "\n" + "FreeHDL"
-		+ "\n" + "(.*):([0-9]+): error: (.*)" 
-		+ "\n" + "(.*):([0-9]+): warning: (.*)" 
-		+ "\n" + "";
-	
-	
-	private static final String PREFERENCE_NAME = "ErrorParser";
-	private static ErrorParser[] parsers = null;
-	private static String previousCompiler = "";
-	
-	public static ErrorParser[] getParsers()
-	{
-		if(parsers==null) {
-			// first add the default parsers:
-			String[] stringsdefault = DEFAULT_ERROR_PARSER_REGEX.split("\n",-1);
-			List<String> stringsuser = VerilogPlugin.getPreferenceStrings(PREFERENCE_NAME);
-			
-			// remove user parsers with the same name as a default parser:
-			for (int i = 0; i < stringsuser.size(); i += 4) {
-				String username = stringsuser.get(i);
-				boolean found=false;
-				for (int j = 0; j < stringsdefault.length; j += 4) {
-					String defaultname = stringsdefault[j];
-					if(defaultname.equals(username)) found=true;
-				}
-				if(found) {
-					stringsuser.remove(i+3);
-					stringsuser.remove(i+2);
-					stringsuser.remove(i+1);
-					stringsuser.remove(i);
-					i-=4;
-				}
-			}
-		
-			parsers = new ErrorParser[stringsdefault.length/4  + stringsuser.size() / 4];
-			
-			for (int i = 0; i < stringsdefault.length; i += 4) {
-				String name = stringsdefault[i];
-				String err = stringsdefault[i + 1];
-				String warn = stringsdefault[i + 2];
-				String info = stringsdefault[i + 3];
-				ErrorParser parser = new ErrorParser(name);
-				parser.setRegex(err, warn, info);
-				parser.editable = false;
-				parsers[i/4] = parser;
-			}
-			
-			for (int i = 0; i < stringsuser.size(); i += 4)
-		{
-				String name = stringsuser.get(i).toString();
-				String err = stringsuser.get(i + 1).toString();
-				String warn = stringsuser.get(i + 2).toString();
-				String info = stringsuser.get(i + 3).toString();
-				ErrorParser parser = new ErrorParser(name);
-				parser.setRegex(err, warn, info);
-				parser.editable = true;
-				parsers[stringsdefault.length/4 + i/4] = parser;
-			}
-		}
-		return parsers;
-	}
-	
-	public static List<ErrorParser> getParserList()
-	{
-		ErrorParser[] parsers = getParsers();
-		List<ErrorParser> list = new ArrayList<ErrorParser>();
-		for (ErrorParser parser:parsers)
-			{
-			list.add(parser);
-		}
-		return list;
-	}
-		
-	public static void installParser(BuildConfig buildconfig, IProject proj)
-		{
-		String compiler = buildconfig.getParser();
-		ErrorParser[] parsers = getParsers();
-		for (ErrorParser parse:parsers)
-			{
-			if (parse.getCompilerName().equals(compiler))
-			{
-				parse.project = proj;
-				parse.buildConfig=buildconfig;
-			}
-		}
-		
-		if(!compiler.equals(previousCompiler)) {
-			for (ErrorParser parse:parsers)
-			{
-				if (parse.getCompilerName().equals(compiler))
-				{
-					VerilogPlugin.addPatternMatchListener(parse.errParser);
-					VerilogPlugin.addPatternMatchListener(parse.warnParser);
-					VerilogPlugin.addPatternMatchListener(parse.infoParser);
-	}
-				if (parse.getCompilerName().equals(previousCompiler))
-	{
-					VerilogPlugin.removePatternMatchListener(parse.errParser);
-					VerilogPlugin.removePatternMatchListener(parse.warnParser);
-					VerilogPlugin.removePatternMatchListener(parse.infoParser);
-				}
-			}
-			previousCompiler = compiler;
-		}
-	}
-	
-	public static void setParsers(ErrorParser[] parsers)
-	{
-		List<String> strings = new ArrayList<String>();
-		for (int i = 0; i < parsers.length; i++)
-		{
-			if(!parsers[i].isEditable()) continue;
-			strings.add(parsers[i].compilerName);
-			strings.add(parsers[i].errRegex);
-			strings.add(parsers[i].warnRegex);
-			strings.add(parsers[i].infoRegex);
-		}
-		VerilogPlugin.setPreference(PREFERENCE_NAME, strings);
-		parsers = null;
-	}
-	
-	public static void setParserList(List<ErrorParser> list)
-	{
-		List<String> strings = new ArrayList<String>();
-		Iterator<ErrorParser> i = list.iterator();
-		while(i.hasNext())
-		{
-			ErrorParser parser = (ErrorParser)i.next();
-			if(!parser.isEditable()) continue;
-			strings.add(parser.compilerName);
-			strings.add(parser.errRegex);
-			strings.add(parser.warnRegex);
-			strings.add(parser.infoRegex);
-		}
-		VerilogPlugin.setPreference(PREFERENCE_NAME, strings);
-		parsers = null;
-	}
-	
-	public static void setDefaultParsers()
-	{
-		VerilogPlugin.setDefaultPreference(PREFERENCE_NAME);
-		parsers = null;
-	}
-
-	private IProject project;
-	private BuildConfig buildConfig;
-	private String compilerName;
-	private String errRegex;
-	private String warnRegex;
-	private String infoRegex;
-	private boolean editable;
-	ConsoleParser errParser;
-	ConsoleParser warnParser;
-	ConsoleParser infoParser;
-
-	public ErrorParser(String compilerName)
-	{
-		this.compilerName = compilerName;
-		editable = true;
-	}
-	
-	public String getCompilerName()
-	{
-		return compilerName;
-	}
-	
-	public boolean isEditable()
-	{
-		return editable;
-	}
-	
-	public void setRegex(String errRegex, String warnRegex, String infoRegex)
-	{
-		this.errRegex = errRegex;
-		this.warnRegex = warnRegex;
-		this.infoRegex = infoRegex;
-		errParser = new ConsoleParser(errRegex, IMarker.SEVERITY_ERROR);
-		warnParser = new ConsoleParser(warnRegex, IMarker.SEVERITY_WARNING);
-		infoParser = new ConsoleParser(infoRegex, IMarker.SEVERITY_INFO);
-	}
-	public void setRegex(int num, String regex)
-	{
-		switch(num)
-		{
-			case 0:
-				errRegex = regex;
-				break;
-			case 1:
-				warnRegex = regex;
-				break;
-			case 2:
-				infoRegex = regex;
-				break;
-		}
-	}
-	public String getErrorRegex()
-	{
-		return errRegex;
-	}
-	public String getWarningRegex()
-	{
-		return warnRegex;
-	}
-	public String getInfoRegex()
-	{
-		return infoRegex;
-	}
-	
-	private void reportMissingFile(String filename){
-		String message = new String();
-		message=String.format("\"%s\" is not found in the project. MS Windows users, check filename case!!!", filename);			
-		try{
-			IMarker marker=project.createMarker("net.sourceforge.veditor.builderproblemmarker");
-			marker.setAttribute(IMarker.SEVERITY, IMarker.SEVERITY_ERROR);			
-			marker.setAttribute(IMarker.MESSAGE, message);
-		}
-		catch (CoreException e)
-		{
-		}		
-	}
-
-	private void setProblemMarker(String filename, int level, int lineNumber, String msg)
-	{
-		IResource file = getFile(filename);
-		if (file != null && lineNumber > 0){
-			VerilogPlugin.setExternalProblemMarker(file, level, lineNumber, msg);
-		}
-		else{
-			reportMissingFile(filename);
-		}
-	}
-
-
-	private IFile getFileRecursive(IContainer cont, IPath path) {
-		try {
-			for(IResource res: cont.members()) {
-				if(res instanceof IContainer) {
-					IFile result = getFileRecursive((IContainer)res,path);
-					if(result!=null) return result;
-				} else if(res instanceof IFile) {					
-					IPath res_path = ((IFile)res).getLocation();					
-					if(res_path.equals(path)) 
-						return (IFile)res;
-		}
-		}
-		} catch (CoreException e) {
-		}
-		return null;
-	}
-	
-	// Christian R. aka supachris from http://www.mikrocontroller.net/topic/264288
-	// mg
-	private IResource getFile(String filename) {
-		File TestFile = new File(filename);
-		IResource test;
-		if(TestFile.isAbsolute())
-		{
-			IContainer project = ResourcesPlugin.getWorkspace().getRoot();
-			IPath projectPath = Path.fromOSString(TestFile.getAbsolutePath());
-			test = getFileRecursive(project, projectPath);
-		}
-		else
-	{
-		IPath projectPath = project.getLocation().append(buildConfig.getWorkFolder());
-		projectPath = projectPath.append(filename);	
-			IContainer project = ResourcesPlugin.getWorkspace().getRoot();
-			test = getFileRecursive(project,projectPath);
-		}
-
-		return test;
-	}
-	
-	public static class ParseErrorString {
-		private String regex;
-		// results of parse(String string);
-		public String filename;
-		public int linenr;
-		public String message;
-		public int startinmatchedstring;
-		public int endinmatchedstring;
-		
-		public ParseErrorString(String regexpr) {
-			regex = regexpr;
-		}
-
-		/**
-		 * Tries to parse string using regex
-		 * @return boolean: parse succeeded
-		 */
-		public boolean parse(String string) {
-			Pattern errPattern = Pattern.compile(regex);
-			Matcher m = errPattern.matcher(string);
-			if (!m.matches()) return false;
-
-			int groupCount=m.groupCount();
-			if(groupCount < 3) return false;
-			
-			int linenrindex = -1;
-		
-			for(int i=2;i<=groupCount;i++) {
-				String group = m.group(i);
-				try {
-					linenr = Integer.parseInt(group);
-					linenrindex = i;
-				}
-				catch (NumberFormatException e) {
-				}
-			}
-			if(linenrindex==-1) return false;
-			
-			// filename is now at linenrindex-1
-			filename = m.group(linenrindex-1);
-			
-			// now search for the longest string to capture the message:
-			int length_win=-1;
-			int messageindex=-1;
-			for(int i=1;i<=groupCount;i++) {
-				if(i==linenrindex-1) continue;
-				if(i==linenrindex) continue;
-				String group = m.group(i);
-				if(group.length()>length_win) {
-					length_win = group.length();
-					messageindex = i;
-				}
-			}
-			if(messageindex==-1) return false;
-			
-			message = m.group(messageindex);
-			startinmatchedstring = m.start(linenrindex-1);
-			endinmatchedstring = m.end(linenrindex);
-			
-			return true;
-		}
-	}
-	
-	public class ConsoleParser implements IPatternMatchListener {
-		private String regex;
-		private int problemlevel;
-		
-		ConsoleParser(String regexpr, int level) {
-			regex = regexpr;
-			problemlevel = level;
-		}
-		
-		public int getCompilerFlags() {
-			return 0;
-		}
-	
-		public String getLineQualifier() {
-			return null;
-		}
-	
-		public String getPattern() {
-			return regex;
-		}
-
-		public void connect(TextConsole console) {}
-		public void disconnect() {}
-	
-		public void matchFound(PatternMatchEvent event) {
-			int offset = event.getOffset();
-			int length = event.getLength();
-			
-			Object object = event.getSource();
-			if(! (object instanceof TextConsole)) return;
-			TextConsole console = (TextConsole)object;
-			
-			String consolecontent = console.getDocument().get();
-			String matchedstring = consolecontent.substring(offset, offset+length);
-			
-			ParseErrorString parser = new ParseErrorString(regex);
-			boolean success = parser.parse(matchedstring);
-			if (!success) return;
-				
-			setProblemMarker(parser.filename, problemlevel, parser.linenr, parser.message);			
-			
-			IResource resource = getFile(parser.filename);
-			if(resource instanceof IFile) {
-				IFile file = (IFile) resource;
-				FileLink hyperlink = new FileLink(file,null,-1,-1,parser.linenr);
-				try {
-					console.addHyperlink(hyperlink, offset+parser.startinmatchedstring,
-							parser.endinmatchedstring-parser.startinmatchedstring+1);
-				} catch (BadLocationException e) {
-				}
-			} else {
-				//VerilogPlugin.println("Not a filename!");
-			}
-		}
-	}
-
-}
-
-
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+
+package com.elphel.vdt.veditor.builder;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import com.elphel.vdt.core.launching.VDTErrorParser;
+import com.elphel.vdt.veditor.VerilogPlugin;
+import com.elphel.vdt.veditor.preference.PreferenceStrings;
+
+import org.eclipse.core.resources.IContainer;
+import org.eclipse.core.resources.IFile;
+import org.eclipse.core.resources.IMarker;
+import org.eclipse.core.resources.IProject;
+import org.eclipse.core.resources.IResource;
+import org.eclipse.core.resources.ResourcesPlugin;
+import org.eclipse.core.runtime.CoreException;
+import org.eclipse.core.runtime.IPath;
+import org.eclipse.core.runtime.Path;
+import org.eclipse.debug.ui.console.FileLink;
+import org.eclipse.jface.text.BadLocationException;
+import org.eclipse.jface.text.IDocument;
+import org.eclipse.ui.console.IPatternMatchListener;
+import org.eclipse.ui.console.PatternMatchEvent;
+import org.eclipse.ui.console.TextConsole;
+
+public class ErrorParser
+{
+	private static final String DEFAULT_ERROR_PARSER_REGEX =
+		"ModelSim"
+		+ "\n" + "[#|\\*].*Error: ([^\\(]*)\\(([0-9]*)\\): (.*)"		
+		+ "\n" + "[#|\\*].*Warning: ([^\\(]*)\\(([0-9]*)\\): (.*)"		
+		+ "\n" + ""
+		+ "\n" + "ModelSimSimulation"
+		+ "\n" + "[#|\\*] Break in ([^\\#]*) at ([^\\(#]*) line ([0-9]*)"
+		+ "\n" + ""
+		+ "\n" + "[#|\\*](.*)File: ([^\\#]*) Line: ([0-9]*)"
+		+ "\n" + "Cver"
+		+ "\n" + "\\*\\*(.*)\\(([0-9]+)\\) ERROR\\*\\* (.*)"
+		+ "\n" + "\\*\\*(.*)\\(([0-9]+)\\) WARN\\*\\* (.*)"
+		+ "\n" + "--(.*)\\(([0-9]+)\\) INFORM-- (.*)" 
+		+ "\n" + "Icarus Verilog"
+		+ "\n" + "(.*):([0-9]+): [a-z ]*error: (.*)"
+		+ "\n" + "(.*):([0-9]+): warning: (.*)"
+		+ "\n" + ""
+		+ "\n" + "FreeHDL"
+		+ "\n" + "(.*):([0-9]+): error: (.*)" 
+		+ "\n" + "(.*):([0-9]+): warning: (.*)" 
+		+ "\n" + "";
+	
+	
+	private static final String PREFERENCE_NAME = "ErrorParser";
+	private static ErrorParser[] parsers = null;
+	private static String previousCompiler = "";
+	
+	public static ErrorParser[] getParsers()
+	{
+		if(parsers==null) {
+			// first add the default parsers:
+			String[] stringsdefault = DEFAULT_ERROR_PARSER_REGEX.split("\n",-1);
+			List<String> stringsuser = VerilogPlugin.getPreferenceStrings(PREFERENCE_NAME);
+			
+			// remove user parsers with the same name as a default parser:
+			for (int i = 0; i < stringsuser.size(); i += 4) {
+				String username = stringsuser.get(i);
+				boolean found=false;
+				for (int j = 0; j < stringsdefault.length; j += 4) {
+					String defaultname = stringsdefault[j];
+					if(defaultname.equals(username)) found=true;
+				}
+				if(found) {
+					stringsuser.remove(i+3);
+					stringsuser.remove(i+2);
+					stringsuser.remove(i+1);
+					stringsuser.remove(i);
+					i-=4;
+				}
+			}
+		
+			parsers = new ErrorParser[stringsdefault.length/4  + stringsuser.size() / 4];
+			
+			for (int i = 0; i < stringsdefault.length; i += 4) {
+				String name = stringsdefault[i];
+				String err = stringsdefault[i + 1];
+				String warn = stringsdefault[i + 2];
+				String info = stringsdefault[i + 3];
+				ErrorParser parser = new ErrorParser(name);
+				parser.setRegex(err, warn, info);
+				parser.editable = false;
+				parsers[i/4] = parser;
+			}
+			
+			for (int i = 0; i < stringsuser.size(); i += 4)
+		{
+				String name = stringsuser.get(i).toString();
+				String err = stringsuser.get(i + 1).toString();
+				String warn = stringsuser.get(i + 2).toString();
+				String info = stringsuser.get(i + 3).toString();
+				ErrorParser parser = new ErrorParser(name);
+				parser.setRegex(err, warn, info);
+				parser.editable = true;
+				parsers[stringsdefault.length/4 + i/4] = parser;
+			}
+		}
+		return parsers;
+	}
+	
+	public static List<ErrorParser> getParserList()
+	{
+		ErrorParser[] parsers = getParsers();
+		List<ErrorParser> list = new ArrayList<ErrorParser>();
+		for (ErrorParser parser:parsers)
+			{
+			list.add(parser);
+		}
+		return list;
+	}
+		
+	public static void installParser(BuildConfig buildconfig, IProject proj)
+	{
+		String compiler = buildconfig.getParser();
+		ErrorParser[] parsers = getParsers();
+		for (ErrorParser parse:parsers)
+		{
+			if (parse.getCompilerName().equals(compiler))
+			{
+				parse.project = proj;
+				parse.buildConfig=buildconfig;
+			}
+		}
+
+		if(!compiler.equals(previousCompiler)) {
+			for (ErrorParser parse:parsers)
+			{
+				if (parse.getCompilerName().equals(compiler))
+				{
+					VerilogPlugin.addPatternMatchListener(parse.errParser);
+					VerilogPlugin.addPatternMatchListener(parse.warnParser);
+					VerilogPlugin.addPatternMatchListener(parse.infoParser);
+				}
+				if (parse.getCompilerName().equals(previousCompiler))
+				{
+					VerilogPlugin.removePatternMatchListener(parse.errParser);
+					VerilogPlugin.removePatternMatchListener(parse.warnParser);
+					VerilogPlugin.removePatternMatchListener(parse.infoParser);
+				}
+			}
+			previousCompiler = compiler;
+		}
+	}
+	
+	public static void setParsers(ErrorParser[] parsers)
+	{
+		List<String> strings = new ArrayList<String>();
+		for (int i = 0; i < parsers.length; i++)
+		{
+			if(!parsers[i].isEditable()) continue;
+			strings.add(parsers[i].compilerName);
+			strings.add(parsers[i].errRegex);
+			strings.add(parsers[i].warnRegex);
+			strings.add(parsers[i].infoRegex);
+		}
+		VerilogPlugin.setPreference(PREFERENCE_NAME, strings);
+		parsers = null;
+	}
+	
+	public static void setParserList(List<ErrorParser> list)
+	{
+		List<String> strings = new ArrayList<String>();
+		Iterator<ErrorParser> i = list.iterator();
+		while(i.hasNext())
+		{
+			ErrorParser parser = (ErrorParser)i.next();
+			if(!parser.isEditable()) continue;
+			strings.add(parser.compilerName);
+			strings.add(parser.errRegex);
+			strings.add(parser.warnRegex);
+			strings.add(parser.infoRegex);
+		}
+		VerilogPlugin.setPreference(PREFERENCE_NAME, strings);
+		parsers = null;
+	}
+	
+	public static void setDefaultParsers()
+	{
+		VerilogPlugin.setDefaultPreference(PREFERENCE_NAME);
+		parsers = null;
+	}
+
+	private IProject project;
+	private BuildConfig buildConfig;
+	private String compilerName;
+	private String errRegex;
+	private String warnRegex;
+	private String infoRegex;
+	private boolean editable;
+	ConsoleParser errParser;
+	ConsoleParser warnParser;
+	ConsoleParser infoParser;
+
+	public ErrorParser(String compilerName)
+	{
+		this.compilerName = compilerName;
+		editable = true;
+	}
+	
+	public String getCompilerName()
+	{
+		return compilerName;
+	}
+	
+	public boolean isEditable()
+	{
+		return editable;
+	}
+	
+	public void setRegex(String errRegex, String warnRegex, String infoRegex)
+	{
+		this.errRegex = errRegex;
+		this.warnRegex = warnRegex;
+		this.infoRegex = infoRegex;
+		errParser = new ConsoleParser(errRegex, IMarker.SEVERITY_ERROR);
+		warnParser = new ConsoleParser(warnRegex, IMarker.SEVERITY_WARNING);
+		infoParser = new ConsoleParser(infoRegex, IMarker.SEVERITY_INFO);
+	}
+	public void setRegex(int num, String regex)
+	{
+		switch(num)
+		{
+			case 0:
+				errRegex = regex;
+				break;
+			case 1:
+				warnRegex = regex;
+				break;
+			case 2:
+				infoRegex = regex;
+				break;
+		}
+	}
+	public String getErrorRegex()
+	{
+		return errRegex;
+	}
+	public String getWarningRegex()
+	{
+		return warnRegex;
+	}
+	public String getInfoRegex()
+	{
+		return infoRegex;
+	}
+	
+	private void reportMissingFile(String filename){
+		String message = new String();
+		message=String.format("\"%s\" is not found in the project. MS Windows users, check filename case!!!", filename);			
+		try{
+			IMarker marker=project.createMarker("com.elphel.vdt.veditor.builderproblemmarker");
+			marker.setAttribute(IMarker.SEVERITY, IMarker.SEVERITY_ERROR);			
+			marker.setAttribute(IMarker.MESSAGE, message);
+		}
+		catch (CoreException e)
+		{
+		}		
+	}
+
+	private void setProblemMarker(String filename, int level, int lineNumber, String msg)
+	{
+		IResource file = getFile(filename);
+		if (file != null && lineNumber > 0){
+			VerilogPlugin.setExternalProblemMarker(file, level, lineNumber, msg);
+		}
+		else{
+			reportMissingFile(filename);
+		}
+	}
+
+
+	private IFile getFileRecursive(IContainer cont, IPath path) {
+		try {
+			for(IResource res: cont.members()) {
+				if(res instanceof IContainer) {
+					IFile result = getFileRecursive((IContainer)res,path);
+					if(result!=null) return result;
+				} else if(res instanceof IFile) {					
+					IPath res_path = ((IFile)res).getLocation();					
+					if(res_path.equals(path)) 
+						return (IFile)res;
+		}
+		}
+		} catch (CoreException e) {
+		}
+		return null;
+	}
+	
+	// Christian R. aka supachris from http://www.mikrocontroller.net/topic/264288
+	// mg
+	private IResource getFile(String filename) {
+		File TestFile = new File(filename);
+		IResource test;
+		if(TestFile.isAbsolute())
+		{
+			IContainer project = ResourcesPlugin.getWorkspace().getRoot();
+			IPath projectPath = Path.fromOSString(TestFile.getAbsolutePath());
+			test = getFileRecursive(project, projectPath);
+		}
+		else
+	{
+		IPath projectPath = project.getLocation().append(buildConfig.getWorkFolder());
+		projectPath = projectPath.append(filename);	
+			IContainer project = ResourcesPlugin.getWorkspace().getRoot();
+			test = getFileRecursive(project,projectPath);
+		}
+
+		return test;
+	}
+	
+	public static class ParseErrorString {
+		private String regex;
+		// results of parse(String string);
+		public String filename;
+		public int linenr;
+		public String message;
+		public int startinmatchedstring;
+		public int endinmatchedstring;
+		
+		public ParseErrorString(String regexpr) {
+			regex = regexpr;
+		}
+
+		/**
+		 * Tries to parse string using regex
+		 * @return boolean: parse succeeded
+		 */
+		public boolean parse(String string) {
+			Pattern errPattern = Pattern.compile(regex);
+			Matcher m = errPattern.matcher(string);
+			if (!m.matches()) return false;
+
+			int groupCount=m.groupCount();
+			if(groupCount < 3) return false;
+			
+			int linenrindex = -1;
+		
+			for(int i=2;i<=groupCount;i++) {
+				String group = m.group(i);
+				try {
+					linenr = Integer.parseInt(group);
+					linenrindex = i;
+				}
+				catch (NumberFormatException e) {
+				}
+			}
+			if(linenrindex==-1) return false;
+			
+			// filename is now at linenrindex-1
+			filename = m.group(linenrindex-1);
+			
+			// now search for the longest string to capture the message:
+			int length_win=-1;
+			int messageindex=-1;
+			for(int i=1;i<=groupCount;i++) {
+				if(i==linenrindex-1) continue;
+				if(i==linenrindex) continue;
+				String group = m.group(i);
+				if(group.length()>length_win) {
+					length_win = group.length();
+					messageindex = i;
+				}
+			}
+			if(messageindex==-1) return false;
+			
+			message = m.group(messageindex); /* error message (w/o "error") */
+			startinmatchedstring = m.start(linenrindex-1); /* start of link */
+			endinmatchedstring = m.end(linenrindex); /* end of link */ 
+			
+			return true;
+		}
+	}
+	
+	public class ConsoleParser implements IPatternMatchListener {
+		private String regex;
+		private int problemlevel;
+		
+		ConsoleParser(String regexpr, int level) {
+			regex = regexpr;
+			problemlevel = level;
+//			System.out.println("New ConsoleParser(>"+regex+"<, "+level);
+		}
+		
+		public int getCompilerFlags() {
+			return 0;
+		}
+	
+		public String getLineQualifier() {
+			return null;
+		}
+	
+		public String getPattern() {
+			return regex;
+		}
+
+		public void connect(TextConsole console) {
+//			System.out.println("connect");
+		}
+		public void disconnect() {
+//			System.out.println("disconnect");
+		}
+		private String readResourceString(IFile file, int lineNo){
+			if (lineNo<1) return null;
+			BufferedReader br;
+			String line;
+			try{
+				br = new BufferedReader(new InputStreamReader (file.getContents()));
+			} catch (CoreException e) {
+				return null;
+			}
+			for (int i=1;i<lineNo;i++){
+				try {
+					br.readLine();
+				} catch (IOException e){
+					return null; // no need to close(), EOF is not an error
+				}
+			}
+			try {
+				line=br.readLine();
+				br.close();
+				return line;
+			} catch (IOException e){
+				return null;
+			}
+		}
+		
+		public void matchFound(PatternMatchEvent event) {
+			int offset = event.getOffset();
+			int length = event.getLength();
+			
+			Object object = event.getSource();
+			if(! (object instanceof TextConsole)) return;
+			TextConsole console = (TextConsole)object;
+			
+			String consolecontent = console.getDocument().get();
+			String matchedstring = consolecontent.substring(offset, offset+length); /* matchstring - full matched string in console */
+			
+			ParseErrorString parser = new ParseErrorString(regex);
+			boolean success = parser.parse(matchedstring);
+			if (!success) return;
+				
+			setProblemMarker(parser.filename, problemlevel, parser.linenr, parser.message);		/* liner - line in file */	
+			
+			IResource resource = getFile(parser.filename);
+			if(resource instanceof IFile) {
+				IFile file = (IFile) resource;
+				if (!VerilogPlugin.getPreferenceBoolean(PreferenceStrings.IGNORE_SUPPRESS_WARNINGS)) {
+
+					String previousLine=readResourceString(file, parser.linenr-1);
+					if (previousLine!=null){
+						if (previousLine.contains(VDTErrorParser.SUPPRESS_WARNINGS) && (previousLine.toLowerCase().contains("veditor") || previousLine.contains("all"))){
+							if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_PARSING))
+								System.out.println(parser.filename+":"+(parser.linenr-1)+" -> "+previousLine);
+							return;
+						}
+					}
+					String thisLine=readResourceString(file, parser.linenr);
+					if (thisLine!=null){
+						if (thisLine.contains(VDTErrorParser.SUPPRESS_THIS_WARNING) && (thisLine.toLowerCase().contains("veditor") || thisLine.contains("all"))){
+							if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_PARSING))
+								System.out.println(parser.filename+":"+(parser.linenr)+" -> "+thisLine);
+							return;
+						}
+					}
+				}				
+				FileLink hyperlink = new FileLink(file,null,-1,-1,parser.linenr);
+				try {
+					console.addHyperlink(hyperlink, offset+parser.startinmatchedstring, /* here makes console blue (in debug mode it lags as is not redrawn immediately */
+							parser.endinmatchedstring-parser.startinmatchedstring+1);
+				} catch (BadLocationException e) {
+				}
+			} else {
+				//VerilogPlugin.println("Not a filename!");
+			}
+		}
+	}
+
+}
+
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/builder/ExternalLauncher.java vdt/src/com/elphel/vdt/veditor/builder/ExternalLauncher.java
--- vdt-veditor/src/com/elphel/vdt/veditor/builder/ExternalLauncher.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/builder/ExternalLauncher.java	2016-06-24 10:29:40.816496628 -0600
@@ -1,175 +1,186 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *    Ken Horn - added patch
- *******************************************************************************/
-
-package net.sourceforge.veditor.builder;
-
-import java.io.BufferedInputStream;
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.Reader;
-
-import net.sourceforge.veditor.VerilogPlugin;
-
-import org.eclipse.core.resources.IContainer;
-
-/**
- * Launch child process
- * @author tadashi
- */
-public class ExternalLauncher extends Thread
-{
-	private IContainer folder;
-	private String command;
-	private StringBuffer message;
-
-	public ExternalLauncher(IContainer folder, String command)
-	{
-		this.folder = folder;
-		this.command = command;
-		message = new StringBuffer();
-	}
-	public void run()
-	{
-		//System.out.println(command);
-		
-		//is the command valid
-		command=command.trim();
-		if(command.equals(""))
-		{
-			String msg = "Compile command is empty!";
-			VerilogPlugin.println(msg);	
-		}
-		else{
-			File dir = folder.getLocation().toFile();
-			if (!dir.exists())
-			{
-				VerilogPlugin.println("working dir: " + dir.getAbsolutePath()
-						+ " does not exist");
-			}
-			else
-			{
-				if (!dir.isDirectory())
-				{
-					VerilogPlugin.println("working dir: " + dir.getAbsolutePath()
-							+ " is not a directory");
-				}
-				else
-				{
-					if (!dir.canWrite())
-					{
-						VerilogPlugin.println("working dir: "
-								+ dir.getAbsolutePath() + " no write access");
-					}
-				}
-			}
-	
-			Runtime runtime = Runtime.getRuntime();
-			try
-			{
-				Process process = runtime.exec(command, null, dir);
-				MessageThread stderr = new MessageThread(process.getErrorStream());
-				MessageThread stdout = new MessageThread(process.getInputStream());
-				stderr.start();
-				stdout.start();
-				
-				try
-				{
-					process.waitFor();
-				}
-				catch (InterruptedException e)
-				{
-					process.destroy();
-				}
-			}
-			catch (IOException e)
-			{
-				String msg = "Runtime error: cannot execute " + command;
-				VerilogPlugin.println(msg);
-			}
-		}
-	}
-
-	public void waitFor()
-	{
-		waitFor(0);
-	}
-
-	public void waitFor(int msec)
-	{
-		try
-		{
-			if (msec == 0)
-			{
-				while(isAlive())
-				{
-					join(500);
-				}
-			}
-			else
-			{
-				if (isAlive())
-				{
-					join(msec);
-				}
-			}
-		}
-		catch (InterruptedException e)
-		{
-			e.printStackTrace();
-		}
-	}
-	
-	public String getMessage()
-	{
-		return message.toString();
-	}
-	
-	private class MessageThread extends Thread
-	{
-		private Reader reader;
-
-		public MessageThread(InputStream is)
-		{
-			reader = new InputStreamReader(new BufferedInputStream(is));
-		}
-
-		public void run()
-		{
-			int c;
-			StringBuffer buffer = new StringBuffer();
-			try
-			{
-				c = reader.read();
-				while (c != -1)
-				{
-					if (c == '\n')
-					{
-						VerilogPlugin.println(buffer.toString());
-						message.append(buffer);
-						message.append('\n');
-						buffer.setLength(0);
-					}
-					else
-						buffer.append((char) c);
-					c = reader.read();
-				}
-			}
-			catch (IOException e)
-			{
-			}
-		}
-	}
-}
-
-
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *    Ken Horn - added patch
+ *******************************************************************************/
+
+package com.elphel.vdt.veditor.builder;
+
+import java.io.BufferedInputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.Reader;
+
+import com.elphel.vdt.veditor.VerilogPlugin;
+
+import org.eclipse.core.resources.IContainer;
+
+/**
+ * Launch child process
+ * @author tadashi
+ */
+public class ExternalLauncher extends Thread
+{
+	private IContainer folder;
+	private String command;
+	private StringBuffer message;
+
+	public ExternalLauncher(IContainer folder, String command)
+	{
+		this.folder = folder;
+		this.command = command;
+		message = new StringBuffer();
+	}
+	public void run()
+	{
+		//System.out.println(command);
+		
+		//is the command valid
+		command=command.trim();
+		if(command.equals(""))
+		{
+			String msg = "Compile command is empty!";
+			VerilogPlugin.println(msg);	
+		}
+		else{
+			File dir = folder.getLocation().toFile();
+			if (!dir.exists())
+			{
+				VerilogPlugin.println("working dir: " + dir.getAbsolutePath()
+						+ " does not exist");
+			}
+			else
+			{
+				if (!dir.isDirectory())
+				{
+					VerilogPlugin.println("working dir: " + dir.getAbsolutePath()
+							+ " is not a directory");
+				}
+				else
+				{
+					if (!dir.canWrite())
+					{
+						VerilogPlugin.println("working dir: "
+								+ dir.getAbsolutePath() + " no write access");
+					}
+				}
+			}
+	
+			Runtime runtime = Runtime.getRuntime();
+			try
+			{
+				Process process = runtime.exec(command, null, dir);
+				MessageThread stderr = new MessageThread(process.getErrorStream());
+				MessageThread stdout = new MessageThread(process.getInputStream());
+				stderr.start();
+				stdout.start();
+				
+				try
+				{
+					process.waitFor();
+				}
+				catch (InterruptedException e)
+				{
+					process.destroy();
+				}
+			}
+			catch (IOException e)
+			{
+				String msg = "Runtime error: cannot execute " + command;
+				VerilogPlugin.println(msg);
+			}
+		}
+	}
+
+	public void waitFor()
+	{
+		waitFor(0);
+	}
+
+	public void waitFor(int msec)
+	{
+		try
+		{
+			if (msec == 0)
+			{
+				while(isAlive())
+				{
+					join(500);
+				}
+			}
+			else
+			{
+				if (isAlive())
+				{
+					join(msec);
+				}
+			}
+		}
+		catch (InterruptedException e)
+		{
+			e.printStackTrace();
+		}
+	}
+	
+	public String getMessage()
+	{
+		return message.toString();
+	}
+	
+	private class MessageThread extends Thread
+	{
+		private Reader reader;
+
+		public MessageThread(InputStream is)
+		{
+			reader = new InputStreamReader(new BufferedInputStream(is));
+		}
+
+		public void run()
+		{
+			int c;
+			StringBuffer buffer = new StringBuffer();
+			try
+			{
+				c = reader.read();
+				while (c != -1)
+				{
+					if (c == '\n')
+					{
+						VerilogPlugin.println(buffer.toString());
+						message.append(buffer);
+						message.append('\n');
+						buffer.setLength(0);
+					}
+					else
+						buffer.append((char) c);
+					c = reader.read();
+				}
+			}
+			catch (IOException e)
+			{
+			}
+		}
+	}
+}
+
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/builder/NewBuildConfigDialog.java vdt/src/com/elphel/vdt/veditor/builder/NewBuildConfigDialog.java
--- vdt-veditor/src/com/elphel/vdt/veditor/builder/NewBuildConfigDialog.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/builder/NewBuildConfigDialog.java	2016-06-24 10:29:40.816496628 -0600
@@ -1,176 +1,187 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    Ali Ghorashi - initial implementation
- *******************************************************************************/
-package net.sourceforge.veditor.builder;
-
-import net.sourceforge.veditor.builder.BuildConfig;
-import org.eclipse.jface.dialogs.Dialog;
-import org.eclipse.swt.SWT;
-import org.eclipse.swt.events.SelectionAdapter;
-import org.eclipse.swt.events.SelectionEvent;
-import org.eclipse.swt.layout.GridData;
-import org.eclipse.swt.layout.GridLayout;
-import org.eclipse.swt.widgets.Button;
-import org.eclipse.swt.widgets.Combo;
-import org.eclipse.swt.widgets.Composite;
-import org.eclipse.swt.widgets.Control;
-import org.eclipse.swt.widgets.Label;
-import org.eclipse.swt.widgets.Shell;
-import org.eclipse.swt.widgets.Text;
-
-public class NewBuildConfigDialog extends Dialog {
-	private Text m_Name;
-	private Combo m_CopyFrom;
-	private Button m_UseDefault;
-	BuildConfig [] m_Configs;
-	boolean m_OkPressed,m_bUseDefault;
-	BuildConfig m_SelectedConfig;
-	String m_NewName;
-	
-	public NewBuildConfigDialog(Shell parentShell,BuildConfig []configs) {
-		super(parentShell);
-		m_Configs=configs;
-		m_OkPressed=false;
-	}
-	
-	/**
-	 * Creates the dialog area
-	 */
-	protected Control createDialogArea(Composite parent){
-		final int labelWidth=40;		
-		final int textWidth=260;
-		final int comboWidth=100;
-		final int checkButtonWidth=200;
-		Composite top=createComposite(parent, 1, SWT.NONE);
-		
-		Composite composite=createComposite(top, 2, SWT.NONE);
-		Label label=new Label(composite,SWT.NONE);
-		label.setText("Name");
-		label.setLayoutData(new GridData(labelWidth,SWT.DEFAULT));		
-		m_Name=new Text(composite,SWT.BORDER | SWT.LEFT);
-		m_Name.setLayoutData(new GridData(textWidth,SWT.DEFAULT));
-		
-		Composite radioSection=createComposite(top, 2, SWT.NONE);
-		m_UseDefault=new Button(radioSection,SWT.CHECK);
-		m_UseDefault.setLayoutData(new GridData(checkButtonWidth,SWT.DEFAULT));
-		m_UseDefault.setText("Use Default Default Configuration");
-		m_UseDefault.setSelection(true);
-		createNull(radioSection);
-		label=new Label(radioSection,SWT.NONE);
-		label.setText("Copy Configuation From");
-		label.setLayoutData(new GridData(120,SWT.DEFAULT));
-		
-		m_CopyFrom=new Combo(radioSection,SWT.READ_ONLY);
-		m_CopyFrom.setLayoutData(new GridData(comboWidth,SWT.DEFAULT));
-		m_CopyFrom.addSelectionListener(new CopyFromListener());
-		//fill the combo
-		for(BuildConfig buildConfig:m_Configs){
-			m_CopyFrom.add(buildConfig.getName());
-			m_CopyFrom.setData(buildConfig.getName(), buildConfig);
-		}
-		
-		return top;
-	}
-	
-	
-	/**
-	 * Greates a composite group
-	 * @param parent parent control
-	 * @param column number of columns
-	 * @param style Additional styles
-	 * @return the created composite
-	 */
-	private Composite createComposite(Composite parent, int column,int style)
-	{
-		Composite group = new Composite(parent, style);
-		group.setLayout(new GridLayout(column, false));
-		GridData gd = new GridData();
-		gd.horizontalAlignment = GridData.FILL;
-		gd.grabExcessHorizontalSpace = true;
-		group.setLayoutData(gd);
-		return group;
-	}
-	
-	/**
-	 * creates an empty section used to fill a cell
-	 * @param parent
-	 */
-	private void createNull(Composite parent)
-	{
-		Composite group = new Composite(parent, SWT.NONE);
-		GridData gd = new GridData();
-		gd.heightHint = 0;
-		gd.widthHint = 0;
-		group.setLayoutData(gd);
-	}
-	
-   protected void configureShell(Shell newShell) {
-	      super.configureShell(newShell);
-	      newShell.setText("Create a new configuraion..");
-	   }
-   
-   /**
-    * Called when the OK button is pressed
-    */
-   protected void okPressed() {
-	   m_NewName=m_Name.getText();
-	   
-	   if( m_CopyFrom.getSelectionIndex()!=-1){
-		   m_SelectedConfig=(BuildConfig)m_CopyFrom.getData(m_CopyFrom.getText());		  
-	   }
-	   else{
-		   m_bUseDefault=true;
-	   }
-	   super.okPressed();
-	   m_OkPressed=true;		
-	}
-   
-   /**
-    * Returns true if the OK button was pressed
-    * @return
-    */
-   public boolean isOkPressed(){return m_OkPressed;}
-   
-   /**
-    * Called when the cancel button is pressed
-    */
-   protected void cancelPressed(){
-	   super.cancelPressed();
-   }
-   
-   /**
-    * Returns a build configuration based on the user input
-    * @return
-    */
-   public BuildConfig getBuildConfig(){
-	   BuildConfig results=null;
-	   if(m_bUseDefault){
-		   //default configuraion
-		   results=new BuildConfig();
-		   results.setName(m_NewName);
-	   }
-	   else{
-		   //copy a configuration
-		   BuildConfig source=m_SelectedConfig.clone();
-		   results=source.clone();
-		   results.setName(m_NewName);
-	   }
-	   
-	   return results;
-   }
-   
-   private class CopyFromListener extends SelectionAdapter{
-	   public void widgetSelected(SelectionEvent e)
-		{
-		   m_UseDefault.setSelection(false);
-		   m_bUseDefault=false;
-		}
-   }
-}
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    Ali Ghorashi - initial implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.builder;
+
+import com.elphel.vdt.veditor.builder.BuildConfig;
+import org.eclipse.jface.dialogs.Dialog;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.SelectionAdapter;
+import org.eclipse.swt.events.SelectionEvent;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.Combo;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Label;
+import org.eclipse.swt.widgets.Shell;
+import org.eclipse.swt.widgets.Text;
+
+public class NewBuildConfigDialog extends Dialog {
+	private Text m_Name;
+	private Combo m_CopyFrom;
+	private Button m_UseDefault;
+	BuildConfig [] m_Configs;
+	boolean m_OkPressed,m_bUseDefault;
+	BuildConfig m_SelectedConfig;
+	String m_NewName;
+	
+	public NewBuildConfigDialog(Shell parentShell,BuildConfig []configs) {
+		super(parentShell);
+		m_Configs=configs;
+		m_OkPressed=false;
+	}
+	
+	/**
+	 * Creates the dialog area
+	 */
+	protected Control createDialogArea(Composite parent){
+		final int labelWidth=40;		
+		final int textWidth=260;
+		final int comboWidth=100;
+		final int checkButtonWidth=200;
+		Composite top=createComposite(parent, 1, SWT.NONE);
+		
+		Composite composite=createComposite(top, 2, SWT.NONE);
+		Label label=new Label(composite,SWT.NONE);
+		label.setText("Name");
+		label.setLayoutData(new GridData(labelWidth,SWT.DEFAULT));		
+		m_Name=new Text(composite,SWT.BORDER | SWT.LEFT);
+		m_Name.setLayoutData(new GridData(textWidth,SWT.DEFAULT));
+		
+		Composite radioSection=createComposite(top, 2, SWT.NONE);
+		m_UseDefault=new Button(radioSection,SWT.CHECK);
+		m_UseDefault.setLayoutData(new GridData(checkButtonWidth,SWT.DEFAULT));
+		m_UseDefault.setText("Use Default Default Configuration");
+		m_UseDefault.setSelection(true);
+		createNull(radioSection);
+		label=new Label(radioSection,SWT.NONE);
+		label.setText("Copy Configuation From");
+		label.setLayoutData(new GridData(120,SWT.DEFAULT));
+		
+		m_CopyFrom=new Combo(radioSection,SWT.READ_ONLY);
+		m_CopyFrom.setLayoutData(new GridData(comboWidth,SWT.DEFAULT));
+		m_CopyFrom.addSelectionListener(new CopyFromListener());
+		//fill the combo
+		for(BuildConfig buildConfig:m_Configs){
+			m_CopyFrom.add(buildConfig.getName());
+			m_CopyFrom.setData(buildConfig.getName(), buildConfig);
+		}
+		
+		return top;
+	}
+	
+	
+	/**
+	 * Greates a composite group
+	 * @param parent parent control
+	 * @param column number of columns
+	 * @param style Additional styles
+	 * @return the created composite
+	 */
+	private Composite createComposite(Composite parent, int column,int style)
+	{
+		Composite group = new Composite(parent, style);
+		group.setLayout(new GridLayout(column, false));
+		GridData gd = new GridData();
+		gd.horizontalAlignment = GridData.FILL;
+		gd.grabExcessHorizontalSpace = true;
+		group.setLayoutData(gd);
+		return group;
+	}
+	
+	/**
+	 * creates an empty section used to fill a cell
+	 * @param parent
+	 */
+	private void createNull(Composite parent)
+	{
+		Composite group = new Composite(parent, SWT.NONE);
+		GridData gd = new GridData();
+		gd.heightHint = 0;
+		gd.widthHint = 0;
+		group.setLayoutData(gd);
+	}
+	
+   protected void configureShell(Shell newShell) {
+	      super.configureShell(newShell);
+	      newShell.setText("Create a new configuraion..");
+	   }
+   
+   /**
+    * Called when the OK button is pressed
+    */
+   protected void okPressed() {
+	   m_NewName=m_Name.getText();
+	   
+	   if( m_CopyFrom.getSelectionIndex()!=-1){
+		   m_SelectedConfig=(BuildConfig)m_CopyFrom.getData(m_CopyFrom.getText());		  
+	   }
+	   else{
+		   m_bUseDefault=true;
+	   }
+	   super.okPressed();
+	   m_OkPressed=true;		
+	}
+   
+   /**
+    * Returns true if the OK button was pressed
+    * @return
+    */
+   public boolean isOkPressed(){return m_OkPressed;}
+   
+   /**
+    * Called when the cancel button is pressed
+    */
+   protected void cancelPressed(){
+	   super.cancelPressed();
+   }
+   
+   /**
+    * Returns a build configuration based on the user input
+    * @return
+    */
+   public BuildConfig getBuildConfig(){
+	   BuildConfig results=null;
+	   if(m_bUseDefault){
+		   //default configuraion
+		   results=new BuildConfig();
+		   results.setName(m_NewName);
+	   }
+	   else{
+		   //copy a configuration
+		   BuildConfig source=m_SelectedConfig.clone();
+		   results=source.clone();
+		   results.setName(m_NewName);
+	   }
+	   
+	   return results;
+   }
+   
+   private class CopyFromListener extends SelectionAdapter{
+	   public void widgetSelected(SelectionEvent e)
+		{
+		   m_UseDefault.setSelection(false);
+		   m_bUseDefault=false;
+		}
+   }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/builder/SimulateBuilder.java vdt/src/com/elphel/vdt/veditor/builder/SimulateBuilder.java
--- vdt-veditor/src/com/elphel/vdt/veditor/builder/SimulateBuilder.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/builder/SimulateBuilder.java	2016-06-24 10:29:40.816496628 -0600
@@ -1,198 +1,222 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-
-package net.sourceforge.veditor.builder;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Map;
-
-import net.sourceforge.veditor.HdlNature;
-import net.sourceforge.veditor.VerilogPlugin;
-
-import org.eclipse.core.resources.IContainer;
-import org.eclipse.core.resources.IProject;
-import org.eclipse.core.resources.IncrementalProjectBuilder;
-import org.eclipse.core.runtime.CoreException;
-import org.eclipse.core.runtime.IProgressMonitor;
-import org.eclipse.core.variables.VariablesPlugin;
-
-
-public class SimulateBuilder extends IncrementalProjectBuilder
-{
-	public static final String BUILDER_ID = "net.sourceforge.veditor.simulateBuilder";
-
-	@SuppressWarnings("unchecked")
-	protected IProject[] build(int kind, Map args, IProgressMonitor monitor)
-	{
-		Map<String,BuildConfig> buildConfigs=BuildConfig.parseCommandArguments(args);
-		IProject project = getProject();
-		IContainer folder;
-		boolean bInterrupted=false;
-		
-		VerilogPlugin.deleteExternalMarkers(project);
-		ArrayList<String> keyList=new ArrayList<String>();
-		keyList.addAll(buildConfigs.keySet());
-		Collections.sort(keyList);
-		//set the bounds for the progress monitor
-		monitor.beginTask("Building HDL Files", keyList.size());
-		for(String name : keyList.toArray(new String[0])){
-			BuildConfig buildConfig=buildConfigs.get(name);
-			//mg
-			try {
-				buildConfig.m_Command = VariablesPlugin.getDefault()
-						.getStringVariableManager()
-						.performStringSubstitution( buildConfig.m_Command );
-				buildConfig.m_CleanCommand = VariablesPlugin.getDefault()
-						.getStringVariableManager()
-						.performStringSubstitution( buildConfig.m_CleanCommand );
-			} catch ( final CoreException e ) {
-				e.printStackTrace();
-			}
-			//mg--------------
-			
-			//is this configuration enabled?
-			if(buildConfig.isEnabled() == false){
-				continue;
-			}
-			monitor.subTask("Building Configuration: "+buildConfig.getName());
-
-			//get the real path
-			if (buildConfig.getWorkFolder().equals("") || 
-					buildConfig.getWorkFolder().equals("./") || 
-					buildConfig.getWorkFolder().equals(".\\")){
-				folder = project;
-			}
-			else{
-				folder = project.getFolder(buildConfig.getWorkFolder());
-			}
-			
-			VerilogPlugin.deleteExternalMarkers(project);
-			
-			//print a banner
-			VerilogPlugin.clear();		
-			ErrorParser.installParser(buildConfig,project);
-			
-			VerilogPlugin.println("----------------------------------------");
-			VerilogPlugin.println("veditor using \"" + buildConfig.getName() + 
-					"\" in \"" 
-					+ folder.getLocation().toOSString() 
-					+ "\" : " 
-					+  buildConfig.getCommand());
-			VerilogPlugin.println("----------------------------------------");
-			//kick off the launcher
-			ExternalLauncher launcher = new ExternalLauncher(folder, buildConfig.m_Command);
-			launcher.start();
-			//monitor launcher
-			while(launcher.isAlive())
-			{
-				launcher.waitFor(500);
-				if (monitor.isCanceled())
-				{
-					launcher.interrupt();
-					bInterrupted=true;
-					break;
-				}
-			}
-			//if the user killed the launcher
-			if(bInterrupted){
-				break;
-			}
-			monitor.worked(1);
-		}
-		monitor.done();
-		//for now we don't do delta builds
-		forgetLastBuiltState();
-		return null;
-	}
-	
-	/**
-	 * Performs the clean operations
-	 */
- 	protected void clean(IProgressMonitor monitor) throws CoreException
-	{
-		Map<String,BuildConfig> buildConfigs=null;
-		IProject project = getProject();
-		IContainer folder;
-		boolean bInterrupted=false;
-		
-		HdlNature nature;
-		try {
-			//here, we hope there is a project nature
-			nature = (HdlNature)project.getNature(HdlNature.NATURE_ID);			
-		} catch (CoreException e) {
-			e.printStackTrace();
-			return;
-		}
-		 
-		//if there is no nature, bail 
-		if(nature == null){
-			return;
-		}
-		
-		buildConfigs=nature.getCommands();
-		
-		VerilogPlugin.deleteExternalMarkers(project);
-		ArrayList<String> keyList=new ArrayList<String>();
-		keyList.addAll(buildConfigs.keySet());
-		Collections.sort(keyList);
-		//set the bounds for the progress monitor
-		monitor.beginTask("Cleaning HDL Files", keyList.size());
-		for(String name : keyList.toArray(new String[0])){
-			BuildConfig buildConfig=buildConfigs.get(name);
-			
-			//is this configuration enabled?
-			if(buildConfig.isEnabled() == false){
-				continue;
-			}
-			monitor.subTask("Cleaning Configuration: "+buildConfig.getName());
-
-			//get the real path
-			if (buildConfig.getWorkFolder().equals("") || 
-					buildConfig.getWorkFolder().equals("./") || 
-					buildConfig.getWorkFolder().equals(".\\")){
-				folder = project;
-			}
-			else{
-				folder = project.getFolder(buildConfig.getWorkFolder());
-			}
-			//print a banner			
-			VerilogPlugin.println("----------------------------------------");
-			VerilogPlugin.println("veditor clean operation \"" + buildConfig.getName() + 
-					"\" in \"" 
-					+ folder.getLocation().toOSString() 
-					+ "\" : " 
-					+  buildConfig.getCleanCommand());
-			VerilogPlugin.println("----------------------------------------");
-			//kick off the launcher
-			ExternalLauncher launcher = new ExternalLauncher(folder, buildConfig.getCleanCommand());
-			launcher.start();
-			//monitor launcher
-			while(launcher.isAlive())
-			{
-				launcher.waitFor(500);
-				if (monitor.isCanceled())
-				{
-					launcher.interrupt();
-					bInterrupted=true;
-					break;
-				}
-			}			
-			//if the user killed the launcher
-			if(bInterrupted){
-				break;
-			}
-			monitor.worked(1);
-		}
-		monitor.done();
-
-	}
-}
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+
+package com.elphel.vdt.veditor.builder;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Map;
+
+import com.elphel.vdt.veditor.HdlNature;
+import com.elphel.vdt.veditor.VerilogPlugin;
+import com.elphel.vdt.veditor.preference.PreferenceStrings;
+
+import org.eclipse.core.resources.IContainer;
+import org.eclipse.core.resources.IProject;
+import org.eclipse.core.resources.IncrementalProjectBuilder;
+import org.eclipse.core.runtime.CoreException;
+import org.eclipse.core.runtime.IProgressMonitor;
+import org.eclipse.core.variables.VariablesPlugin;
+
+
+public class SimulateBuilder extends IncrementalProjectBuilder
+{
+	public static final String BUILDER_ID = "com.elphel.vdt.veditor.simulateBuilder";
+
+	@SuppressWarnings("unchecked")
+	protected IProject[] build(int kind, Map args, IProgressMonitor monitor)
+	{
+		Map<String,BuildConfig> buildConfigs=BuildConfig.parseCommandArguments(args);
+		IProject project = getProject();
+		IContainer folder;
+		boolean bInterrupted=false;
+		
+		VerilogPlugin.deleteExternalMarkers(project);
+		ArrayList<String> keyList=new ArrayList<String>();
+		keyList.addAll(buildConfigs.keySet());
+		Collections.sort(keyList);
+		//set the bounds for the progress monitor
+		
+		/*just to be able to disable w/o erasing Icarus build configuration */
+		
+		if (keyList.size()<2){
+	        if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_OTHER))
+	        	System.out.println("Bypassing initialization of build configurations in SimulatorBuilder.java");
+			return null;
+		} else {
+	        if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_OTHER))
+	        	System.out.println("Proceeding with initialization of build configurations in SimulatorBuilder.java");
+		}
+		
+		monitor.beginTask("Building HDL Files", keyList.size());
+		for(String name : keyList.toArray(new String[0])){
+			BuildConfig buildConfig=buildConfigs.get(name);
+			//mg
+			try {
+				buildConfig.m_Command = VariablesPlugin.getDefault()
+						.getStringVariableManager()
+						.performStringSubstitution( buildConfig.m_Command );
+				buildConfig.m_CleanCommand = VariablesPlugin.getDefault()
+						.getStringVariableManager()
+						.performStringSubstitution( buildConfig.m_CleanCommand );
+			} catch ( final CoreException e ) {
+				e.printStackTrace();
+			}
+			//mg--------------
+			
+			//is this configuration enabled?
+			if(buildConfig.isEnabled() == false){
+				continue;
+			}
+			monitor.subTask("Building Configuration: "+buildConfig.getName());
+
+			//get the real path
+			if (buildConfig.getWorkFolder().equals("") || 
+					buildConfig.getWorkFolder().equals("./") || 
+					buildConfig.getWorkFolder().equals(".\\")){
+				folder = project;
+			}
+			else{
+				folder = project.getFolder(buildConfig.getWorkFolder());
+			}
+			
+			VerilogPlugin.deleteExternalMarkers(project);
+			
+			//print a banner
+			VerilogPlugin.clear();		
+			ErrorParser.installParser(buildConfig,project);
+			
+			VerilogPlugin.println("----------------------------------------");
+			VerilogPlugin.println("veditor using \"" + buildConfig.getName() + 
+					"\" in \"" 
+					+ folder.getLocation().toOSString() 
+					+ "\" : " 
+					+  buildConfig.getCommand());
+			VerilogPlugin.println("----------------------------------------");
+			//kick off the launcher
+			ExternalLauncher launcher = new ExternalLauncher(folder, buildConfig.m_Command);
+			launcher.start();
+			//monitor launcher
+			while(launcher.isAlive())
+			{
+				launcher.waitFor(500);
+				if (monitor.isCanceled())
+				{
+					launcher.interrupt();
+					bInterrupted=true;
+					break;
+				}
+			}
+			//if the user killed the launcher
+			if(bInterrupted){
+				break;
+			}
+			monitor.worked(1);
+		}
+		monitor.done();
+		//for now we don't do delta builds
+		forgetLastBuiltState();
+		return null;
+	}
+	
+	/**
+	 * Performs the clean operations
+	 */
+ 	protected void clean(IProgressMonitor monitor) throws CoreException
+	{
+		Map<String,BuildConfig> buildConfigs=null;
+		IProject project = getProject();
+		IContainer folder;
+		boolean bInterrupted=false;
+		
+		HdlNature nature;
+		try {
+			//here, we hope there is a project nature
+			nature = (HdlNature)project.getNature(HdlNature.NATURE_ID);			
+		} catch (CoreException e) {
+			e.printStackTrace();
+			return;
+		}
+		 
+		//if there is no nature, bail 
+		if(nature == null){
+			return;
+		}
+		
+		buildConfigs=nature.getCommands();
+		
+		VerilogPlugin.deleteExternalMarkers(project);
+		ArrayList<String> keyList=new ArrayList<String>();
+		keyList.addAll(buildConfigs.keySet());
+		Collections.sort(keyList);
+		//set the bounds for the progress monitor
+		monitor.beginTask("Cleaning HDL Files", keyList.size());
+		for(String name : keyList.toArray(new String[0])){
+			BuildConfig buildConfig=buildConfigs.get(name);
+			
+			//is this configuration enabled?
+			if(buildConfig.isEnabled() == false){
+				continue;
+			}
+			monitor.subTask("Cleaning Configuration: "+buildConfig.getName());
+
+			//get the real path
+			if (buildConfig.getWorkFolder().equals("") || 
+					buildConfig.getWorkFolder().equals("./") || 
+					buildConfig.getWorkFolder().equals(".\\")){
+				folder = project;
+			}
+			else{
+				folder = project.getFolder(buildConfig.getWorkFolder());
+			}
+			//print a banner			
+			VerilogPlugin.println("----------------------------------------");
+			VerilogPlugin.println("veditor clean operation \"" + buildConfig.getName() + 
+					"\" in \"" 
+					+ folder.getLocation().toOSString() 
+					+ "\" : " 
+					+  buildConfig.getCleanCommand());
+			VerilogPlugin.println("----------------------------------------");
+			//kick off the launcher
+			ExternalLauncher launcher = new ExternalLauncher(folder, buildConfig.getCleanCommand());
+			launcher.start();
+			//monitor launcher
+			while(launcher.isAlive())
+			{
+				launcher.waitFor(500);
+				if (monitor.isCanceled())
+				{
+					launcher.interrupt();
+					bInterrupted=true;
+					break;
+				}
+			}			
+			//if the user killed the launcher
+			if(bInterrupted){
+				break;
+			}
+			monitor.worked(1);
+		}
+		monitor.done();
+
+	}
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/builder/SimulatorPropertyPage.java vdt/src/com/elphel/vdt/veditor/builder/SimulatorPropertyPage.java
--- vdt-veditor/src/com/elphel/vdt/veditor/builder/SimulatorPropertyPage.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/builder/SimulatorPropertyPage.java	2016-06-24 10:29:40.816496628 -0600
@@ -1,631 +1,642 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-
-package net.sourceforge.veditor.builder;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Map;
-import java.util.Vector;
-
-import net.sourceforge.veditor.HdlNature;
-
-import org.eclipse.core.resources.IProject;
-import org.eclipse.core.resources.IProjectDescription;
-import org.eclipse.core.runtime.CoreException;
-import org.eclipse.core.runtime.IAdaptable;
-import org.eclipse.core.runtime.Path;
-import org.eclipse.debug.ui.StringVariableSelectionDialog;
-import org.eclipse.swt.SWT;
-import org.eclipse.swt.events.FocusAdapter;
-import org.eclipse.swt.events.FocusEvent;
-import org.eclipse.swt.events.KeyAdapter;
-import org.eclipse.swt.events.KeyEvent;
-import org.eclipse.swt.events.SelectionAdapter;
-import org.eclipse.swt.events.SelectionEvent;
-import org.eclipse.swt.layout.GridData;
-import org.eclipse.swt.layout.GridLayout;
-import org.eclipse.swt.widgets.Button;
-import org.eclipse.swt.widgets.Combo;
-import org.eclipse.swt.widgets.Composite;
-import org.eclipse.swt.widgets.Control;
-import org.eclipse.swt.widgets.Label;
-import org.eclipse.swt.widgets.Table;
-import org.eclipse.swt.widgets.TableColumn;
-import org.eclipse.swt.widgets.TableItem;
-import org.eclipse.swt.widgets.Text;
-import org.eclipse.ui.PlatformUI;
-import org.eclipse.ui.dialogs.ContainerSelectionDialog;
-import org.eclipse.ui.dialogs.ISelectionValidator;
-import org.eclipse.ui.dialogs.PropertyPage;
-
-public class SimulatorPropertyPage extends PropertyPage
-{
-	static final int CONFIG_NAME_COL_IDX=1;
-	private Text m_BuildCommand,m_CleanCommand;
-	private Text m_WorkFolder,m_Name;
-	private Combo m_ErrorParser;
-	private Table m_ConfigTable;
-
-	
-	private void updateTableItem(TableItem item){
-		BuildConfig buildConfig=(BuildConfig)item.getData();
-		item.setChecked(buildConfig.isEnabled());
-		item.setText(CONFIG_NAME_COL_IDX,buildConfig.getName());		
-	}
-	/**
-	 * Creates and returns a new table item in the configuration table
-	 */
-	private TableItem createTableItem(BuildConfig buildConfig){
-		TableItem item=new TableItem(m_ConfigTable,SWT.NONE,buildConfig.getBuildOrder());		
-		item.setData(buildConfig);
-		updateTableItem(item);
-		return item;
-	}
-	/**
-	 * Creates the config table
-	 * @param parent
-	 */
-	private void createTable(Composite parent){
-		GridData gd;
-		final int tableWidth=250;
-		final int tableHight=150;
-		final int enableColumnWidth=60;
-		
-		Label label=new Label(parent,SWT.NONE);
-		label.setText("Configurations");
-		m_ConfigTable=new Table (parent, 
-				SWT.BORDER | SWT.SINGLE | SWT.FULL_SELECTION | SWT.V_SCROLL|SWT.CHECK);
-		gd = new GridData(GridData.FILL_HORIZONTAL|GridData.GRAB_HORIZONTAL);
-		gd.horizontalAlignment = GridData.FILL;
-		gd.grabExcessHorizontalSpace = true;
-		gd.widthHint=tableWidth;
-		gd.heightHint=tableHight;
-		m_ConfigTable.setLayoutData(gd);
-		TableColumn column=new TableColumn(m_ConfigTable,SWT.CENTER);
-		column.setText("Enabled");
-		column.setWidth(enableColumnWidth);
-		column=new TableColumn(m_ConfigTable,SWT.LEFT);
-		column.setText("Configuration Name");
-		column.setWidth(tableWidth-enableColumnWidth);
-		m_ConfigTable.setHeaderVisible(true);
-		m_ConfigTable.setLinesVisible(true);
-		m_ConfigTable.addSelectionListener(new ConfigTableSelectionListener());
-	}
-	
-	private void createUpper(Composite parent){
-		GridData gd;
-		final int buttonWidth=80;
-		final int buttonHeight=SWT.DEFAULT;
-		
-		Composite composite=createGroup(parent,2,SWT.BORDER);
-		////////////////////
-		//table area
-		Composite leftSide=new Composite(composite,SWT.NONE);
-		leftSide.setLayout(new GridLayout(1,false));
-		////////////////////
-		//table
-		createTable(leftSide);
-		////////////////////
-		//buttons area
-		Composite buttons=new Composite(composite,SWT.NONE);
-		buttons.setLayout(new GridLayout(1,false));
-		////////////////////
-		//new button
-		Button button=new Button(buttons,SWT.PUSH);		
-		button.setText("New");
-		gd = new GridData(buttonWidth,buttonHeight);				
-		button.setLayoutData(gd);
-		button.addSelectionListener(new NewConfigurationListener());
-		////////////////////
-		//delete button
-		button=new Button(buttons,SWT.PUSH);
-		button.setText("Delete");
-		button.setLayoutData(gd);
-		button.addSelectionListener(new DeleteConfigurationListener());
-		/////////////////////
-		//up button
-		button=new Button(buttons, SWT.ARROW | SWT.UP);
-		button.setLayoutData(gd);
-		button.addSelectionListener(new UpListener());
-		////////////////////
-		//down button
-		button=new Button(buttons, SWT.ARROW | SWT.DOWN);
-		button.setLayoutData(gd);
-		button.addSelectionListener(new DownListener());
-	}
-	
-	
-	private void createLower(Composite parent){
-		final int labelWidth=100;
-		final int textWidth=100;
-		Label label;
-		Button button;
-		
-		GridData gd;
-		Composite composite=createGroup(parent,1,SWT.BORDER);		
-		//////////////////////
-		//Name
-		Composite row1=createGroup(composite,2,SWT.NONE);
-		label=new Label(row1,SWT.NONE);
-		label.setText("Name");
-		label.setLayoutData(new GridData(labelWidth,SWT.DEFAULT));
-		m_Name=new Text(row1,SWT.SINGLE | SWT.BORDER);
-		m_Name.setLayoutData(new GridData(textWidth,SWT.DEFAULT));
-		m_Name.addFocusListener(new FieldsFocusListener());
-		m_Name.addKeyListener(new NameInputListener());
-		//////////////////////
-		//Working folder
-		Composite row2=createGroup(composite,3,SWT.NONE);		
-		label=new Label(row2,SWT.NONE);
-		label.setText("Working Folder");
-		gd = new GridData();
-		gd.widthHint=labelWidth;
-		label.setLayoutData(gd);
-		m_WorkFolder= new Text(row2,SWT.SINGLE | SWT.BORDER);
-		gd = new GridData();
-		gd.widthHint=textWidth;
-		m_WorkFolder.setLayoutData(gd);
-		m_WorkFolder.addFocusListener(new FieldsFocusListener());
-		button= new Button(row2,SWT.PUSH);
-		button.setText("Browse...");
-		button.addSelectionListener(new BrowseListener());
-		row2.pack();		
-		//////////////////////
-		//Parser
-		Composite row3=createGroup(composite,2,SWT.NONE);	
-		label=new Label(row3,SWT.NONE);
-		label.setText("Parser");		
-		gd = new GridData();
-		gd.widthHint=labelWidth;
-		label.setLayoutData(gd);
-		m_ErrorParser= new Combo(row3,SWT.READ_ONLY);
-		m_ErrorParser.addFocusListener(new FieldsFocusListener());
-		gd = new GridData();
-		gd.widthHint=textWidth;
-		m_ErrorParser.setLayoutData(gd);
-		row3.pack();		
-		//////////////////////
-		//Command
-		Composite row4=createGroup(composite,2,SWT.NONE);	
-		label=new Label(row4,SWT.NONE);
-		label.setText("Command");		
-		gd = new GridData();
-		gd.widthHint=labelWidth;
-		label.setLayoutData(gd);
-		m_BuildCommand = new Text(row4, SWT.BORDER);
-		m_BuildCommand.addFocusListener(new FieldsFocusListener());
-		gd = new GridData();
-		gd.widthHint=textWidth*2;
-		m_BuildCommand.setLayoutData(gd);
-		
-		//mg
-		createCommandButton(row4, m_BuildCommand);
-		//mg-----------------
-		
-		row4.pack();
-		//////////////////////
-		//Clean Command
-		Composite row5=createGroup(composite,2,SWT.NONE);	
-		label=new Label(row5,SWT.NONE);
-		label.setText("Clean Command");		
-		gd = new GridData();
-		gd.widthHint=labelWidth;
-		label.setLayoutData(gd);
-		m_CleanCommand = new Text(row5, SWT.BORDER);
-		m_CleanCommand.addFocusListener(new FieldsFocusListener());
-		gd = new GridData();
-		gd.widthHint=textWidth*2;
-		m_CleanCommand.setLayoutData(gd);
-		
-		//mg
-		createCommandButton(row5, m_CleanCommand);		
-		//mg-----------
-
-		composite.pack();
-	}
-		
-	//mg
-		private void createCommandButton( final Composite parent,
-				final Text commandText ) {
-			final Button button = new Button( parent, SWT.NONE );
-		button.addSelectionListener(new SelectionAdapter() {
-				
-				public void widgetSelected( final SelectionEvent e ) {
-					final StringVariableSelectionDialog dialog = new StringVariableSelectionDialog(
-							PlatformUI.getWorkbench().getActiveWorkbenchWindow()
-									.getShell() );
-				dialog.open();
-					final String var = dialog.getVariableExpression();
-				commandText.insert(var);
-			}
-		});
-		button.setText("Variables...");
-	}
-		//mg------------------
-	
-	protected Control createContents(Composite parent)
-	{
-		Composite top;
-		
-		top = new Composite(parent, SWT.NONE);
-		top.setLayout(new GridLayout(1, false));
-		
-		createUpper(top);
-		createLower(top);
-		top.pack();
-	    
-		initContents();
-        return top;
-	}
-	
-	
-
-	
-	private Composite createGroup(Composite parent, int column,int style)
-	{
-		Composite group = new Composite(parent, style);
-		group.setLayout(new GridLayout(column, false));
-		GridData gd = new GridData();
-		gd.horizontalAlignment = GridData.FILL;
-		gd.grabExcessHorizontalSpace = true;
-		group.setLayoutData(gd);
-		return group;
-	}
-	
-	private IProject getProject()
-	{
-		IAdaptable element = getElement();
-		if (element != null && element instanceof IProject)
-			return (IProject)element;
-		else
-			return null;
-	}
-	private String getProjectPath()
-	{
-		return "/" + getProject().getName();
-	}
-	
-	/**
-	 * Initializes the contents of the dialog
-	 */
-	private void initContents()
-	{
-		HdlNature nature;
-		try {
-			nature = getNature();
-		} catch (CoreException e) {
-			e.printStackTrace();
-			return;
-		}
-		
-		ErrorParser[] parsers = ErrorParser.getParsers();
-		for(int i = 0; i < parsers.length; i++)
-		{
-			m_ErrorParser.add(parsers[i].getCompilerName());
-		}
-		 
-		Map<String,BuildConfig> commands=nature.getCommands();
-		//if the list is empty, create a command with default settings
-		if(commands==null || commands.size() == 0){
-			setDefaults();
-		}
-		else{			
-			ArrayList<String> keyList=new ArrayList<String>();
-			keyList.addAll(commands.keySet());
-			Collections.sort(keyList);
-			for(String name : keyList.toArray(new String[0])){
-				createTableItem(commands.get(name));
-			}
-		}		
-	}
-	
-	/**
-	 * Updates the selected command with the values in the fields
-	 */
-	private void saveFields(){
-		TableItem[] selectedItems=m_ConfigTable.getSelection();
-		
-		//there should be only one selected item
-		if(selectedItems.length > 0){
-			BuildConfig buildConfig=(BuildConfig)selectedItems[0].getData();
-			buildConfig.setName(m_Name.getText());
-			buildConfig.setCommand(m_BuildCommand.getText());
-			buildConfig.setCleanCommand(m_CleanCommand.getText());
-			buildConfig.setParser(m_ErrorParser.getText());
-			buildConfig.setWorkFolder(m_WorkFolder.getText());			
-		}
-	}
-	/**
-	 * Saves the data to the nature
-	 */
-	private void saveData(){
-		
-		HdlNature nature;
-		try {
-			nature = getNature();
-		} catch (CoreException e) {			
-			e.printStackTrace();
-			return;
-		}
-				
-		Vector<BuildConfig> commands=new Vector<BuildConfig>();
-		int buildOrder=0;
-		saveFields();
-		for(TableItem tableItem:m_ConfigTable.getItems()){
-			BuildConfig command=(BuildConfig)tableItem.getData();
-			command.setBuildOrder(buildOrder++);
-			command.setEnabled(tableItem.getChecked());
-			commands.add(command);
-		}
-			
-		nature.setCommands(commands.toArray(new BuildConfig[0]));
-	}
-	
-	/**
-	 * Sets the default values
-	 */
-	private void setDefaults(){
-//		BuildConfig command=new BuildConfig();
-//		createTableItem(command);
-	}
-
-	/**
-	 * Creates or retrieves a project's nature
-	 * @return
-	 * @throws CoreException 
-	 */
-	private HdlNature getNature() throws CoreException {
-		IProject project=getProject();		
-		HdlNature hdlNature=null;
-		IProjectDescription projectDescription;	
-		projectDescription = project.getDescription();	
-		boolean bNatureFound=false;
-		ArrayList<String> natureList=new ArrayList<String>();
-			
-		for(String nature:projectDescription.getNatureIds()){
-			if(HdlNature.NATURE_ID.equals(nature)){
-				bNatureFound=true;
-				continue;
-			}
-			natureList.add(nature);
-		}
-		
-		if(bNatureFound==false){
-			//add the nature
-			natureList.add(HdlNature.NATURE_ID);
-			projectDescription.setNatureIds(natureList.toArray(new String[0]));
-			project.setDescription(projectDescription, null);			
-		}
-
-		hdlNature=(HdlNature) project.getNature(HdlNature.NATURE_ID);
-		return hdlNature;		
-	}
-	
-	/**
-	 * Called when the user clicks OK
-	 */
-	public boolean performOk()
-	{
-		saveData();
-		super.performOk();		
-		return true;
-	}
-	
-	/**
-	 * Called when the user clicks apply
-	 */	
-	 protected void performApply() {
-		 saveData();
-	 }
-	 
-	 /**
-	  * Called when the user clicks defaults
-	  */
-	protected void performDefaults()
-	{
-		super.performDefaults();
-		m_ConfigTable.clearAll();
-		setDefaults();		
-	}
-	
-	/**
-	 * Class called when the user presses the new button
-	 *
-	 */
-	private class NewConfigurationListener extends SelectionAdapter{
-		public void widgetSelected(SelectionEvent e)
-		{
-			ArrayList<BuildConfig> buildConfigList=new ArrayList<BuildConfig>();
-			TableItem []tableItems=m_ConfigTable.getItems();
-			
-			//gather a list of items
-			for(TableItem item:tableItems){
-				buildConfigList.add((BuildConfig)item.getData());
-			}
-			
-			NewBuildConfigDialog dialog=new NewBuildConfigDialog(getControl().getShell(),
-					buildConfigList.toArray(new BuildConfig[0]));
-			dialog.open();
-			if(dialog.isOkPressed()){
-				createTableItem(dialog.getBuildConfig());
-			}
-		}
-	}
-	
-	/**
-	 * Class called when the user presses the delete button
-	 * @author gho18481
-	 *
-	 */
-	private class DeleteConfigurationListener extends SelectionAdapter{
-		public void widgetSelected(SelectionEvent e)
-		{
-			int selectedIdx=m_ConfigTable.getSelectionIndex();		
-			//there should be only one selected item
-			if(selectedIdx != -1){			
-				m_ConfigTable.remove(selectedIdx);
-			}
-		}
-	}
-	
-	/**
-	 * Class called when the user presses the delete button
-	 * @author gho18481
-	 *
-	 */
-	private class UpListener extends SelectionAdapter{
-		public void widgetSelected(SelectionEvent e)
-		{
-			int selectedIdx=m_ConfigTable.getSelectionIndex();		
-			//there should be only one selected item
-			if(selectedIdx > 0 ){			
-				TableItem upperItem=m_ConfigTable.getItem(selectedIdx-1);
-				TableItem lowerItem=m_ConfigTable.getItem(selectedIdx);
-				BuildConfig upperConfig=(BuildConfig)upperItem.getData();
-				BuildConfig lowerConfig=(BuildConfig)lowerItem.getData();
-				
-				m_ConfigTable.setRedraw(false);
-				upperConfig.setBuildOrder(selectedIdx);
-				lowerConfig.setBuildOrder(selectedIdx-1);				
-				createTableItem(upperConfig);
-				createTableItem(lowerConfig);
-				upperItem.dispose();
-				lowerItem.dispose();
-				m_ConfigTable.setRedraw(true);
-				m_ConfigTable.setSelection(selectedIdx-1);
-				m_ConfigTable.setFocus();
-			}
-		}
-	}
-	
-	/**
-	 * Class called when the user presses the delete button
-	 * @author gho18481
-	 *
-	 */
-	private class DownListener extends SelectionAdapter{
-		public void widgetSelected(SelectionEvent e)
-		{
-			int selectedIdx=m_ConfigTable.getSelectionIndex();		
-			//as long at its not the last one
-			if(selectedIdx!= -1 && selectedIdx < m_ConfigTable.getItemCount()-1){			
-				TableItem upperItem=m_ConfigTable.getItem(selectedIdx);
-				TableItem lowerItem=m_ConfigTable.getItem(selectedIdx+1);
-				BuildConfig upperConfig=(BuildConfig)upperItem.getData();
-				BuildConfig lowerConfig=(BuildConfig)lowerItem.getData();
-				
-				m_ConfigTable.setRedraw(false);
-				upperConfig.setBuildOrder(selectedIdx+1);
-				lowerConfig.setBuildOrder(selectedIdx);				
-				createTableItem(upperConfig);
-				createTableItem(lowerConfig);
-				upperItem.dispose();
-				lowerItem.dispose();
-				m_ConfigTable.setRedraw(true);
-				m_ConfigTable.setSelection(selectedIdx+1);
-				m_ConfigTable.setFocus();
-			}
-		}
-	}
-	
-	/**
-	 * Class called whenever the browse button is pressed
-	 *
-	 */
-	private class BrowseListener extends SelectionAdapter
-	{
-		public void widgetSelected(SelectionEvent e)
-		{
-			ContainerSelectionDialog dialog = new ContainerSelectionDialog(
-					getShell(), getProject(), false, "Select a working folder");
-			dialog.setValidator(new ISelectionValidator()
-			{
-				public String isValid(Object selection)
-				{
-					if (selection.toString().indexOf(getProjectPath()) == 0)
-						return null;
-					else
-						return "Cannot select a folder in other projects";
-				}
-				
-			});
-			if (dialog.open() == ContainerSelectionDialog.OK)
-			{
-				Object[] result = dialog.getResult();
-				if (result.length == 1)
-				{
-					String path = ((Path)result[0]).toString();
-					path = path.substring(getProjectPath().length() + 1);
-					m_WorkFolder.setText(path);
-				}
-			}
-		}
-	}
-	
-	/**
-	 * Used to listen for selection changes
-	 */
-	private class ConfigTableSelectionListener extends SelectionAdapter{
-		public void widgetSelected(SelectionEvent e)
-		{
-			if (e.item instanceof TableItem) {
-				TableItem item = (TableItem) e.item;
-				BuildConfig command=(BuildConfig)item.getData();
-				
-				m_Name.setText(command.getName());
-				m_WorkFolder.setText(command.getWorkFolder());
-				m_CleanCommand.setText(command.getCleanCommand());
-				m_BuildCommand.setText(command.getCommand());
-				int idx=0;
-				m_ErrorParser.select(-1);
-				for(String errorParser: m_ErrorParser.getItems()){
-					if(errorParser.equals(command.getParser())){
-						m_ErrorParser.select(idx);
-					}
-					idx++;
-				}
-			}
-		}
-	}
-	
-	/**
-	 * Used to listen to focus changes in order to save the users input
-	 *
-	 */
-	private class FieldsFocusListener extends FocusAdapter{
-		public void	focusLost(FocusEvent e){
-			saveFields();
-		}
-	}
-	
-	/**
-	 * Called when the user types something in the name list
-	 *
-	 */
-	private class NameInputListener extends KeyAdapter{
-		public void keyReleased(KeyEvent e){
-			TableItem[] selectedItems=m_ConfigTable.getSelection();
-			
-			//there should be only one selected item
-			if(selectedItems.length > 0){
-				//update the item name
-				selectedItems[0].setText(CONFIG_NAME_COL_IDX,m_Name.getText());
-			}
-		}
-	}
-}
-
-
-	
-
-
-
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+
+package com.elphel.vdt.veditor.builder;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Map;
+import java.util.Vector;
+
+import com.elphel.vdt.veditor.HdlNature;
+
+import org.eclipse.core.resources.IProject;
+import org.eclipse.core.resources.IProjectDescription;
+import org.eclipse.core.runtime.CoreException;
+import org.eclipse.core.runtime.IAdaptable;
+import org.eclipse.core.runtime.Path;
+import org.eclipse.debug.ui.StringVariableSelectionDialog;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.FocusAdapter;
+import org.eclipse.swt.events.FocusEvent;
+import org.eclipse.swt.events.KeyAdapter;
+import org.eclipse.swt.events.KeyEvent;
+import org.eclipse.swt.events.SelectionAdapter;
+import org.eclipse.swt.events.SelectionEvent;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.Combo;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Label;
+import org.eclipse.swt.widgets.Table;
+import org.eclipse.swt.widgets.TableColumn;
+import org.eclipse.swt.widgets.TableItem;
+import org.eclipse.swt.widgets.Text;
+import org.eclipse.ui.PlatformUI;
+import org.eclipse.ui.dialogs.ContainerSelectionDialog;
+import org.eclipse.ui.dialogs.ISelectionValidator;
+import org.eclipse.ui.dialogs.PropertyPage;
+
+public class SimulatorPropertyPage extends PropertyPage
+{
+	static final int CONFIG_NAME_COL_IDX=1;
+	private Text m_BuildCommand,m_CleanCommand;
+	private Text m_WorkFolder,m_Name;
+	private Combo m_ErrorParser;
+	private Table m_ConfigTable;
+
+	
+	private void updateTableItem(TableItem item){
+		BuildConfig buildConfig=(BuildConfig)item.getData();
+		item.setChecked(buildConfig.isEnabled());
+		item.setText(CONFIG_NAME_COL_IDX,buildConfig.getName());		
+	}
+	/**
+	 * Creates and returns a new table item in the configuration table
+	 */
+	private TableItem createTableItem(BuildConfig buildConfig){
+		TableItem item=new TableItem(m_ConfigTable,SWT.NONE,buildConfig.getBuildOrder());		
+		item.setData(buildConfig);
+		updateTableItem(item);
+		return item;
+	}
+	/**
+	 * Creates the config table
+	 * @param parent
+	 */
+	private void createTable(Composite parent){
+		GridData gd;
+		final int tableWidth=250;
+		final int tableHight=150;
+		final int enableColumnWidth=60;
+		
+		Label label=new Label(parent,SWT.NONE);
+		label.setText("Configurations");
+		m_ConfigTable=new Table (parent, 
+				SWT.BORDER | SWT.SINGLE | SWT.FULL_SELECTION | SWT.V_SCROLL|SWT.CHECK);
+		gd = new GridData(GridData.FILL_HORIZONTAL|GridData.GRAB_HORIZONTAL);
+		gd.horizontalAlignment = GridData.FILL;
+		gd.grabExcessHorizontalSpace = true;
+		gd.widthHint=tableWidth;
+		gd.heightHint=tableHight;
+		m_ConfigTable.setLayoutData(gd);
+		TableColumn column=new TableColumn(m_ConfigTable,SWT.CENTER);
+		column.setText("Enabled");
+		column.setWidth(enableColumnWidth);
+		column=new TableColumn(m_ConfigTable,SWT.LEFT);
+		column.setText("Configuration Name");
+		column.setWidth(tableWidth-enableColumnWidth);
+		m_ConfigTable.setHeaderVisible(true);
+		m_ConfigTable.setLinesVisible(true);
+		m_ConfigTable.addSelectionListener(new ConfigTableSelectionListener());
+	}
+	
+	private void createUpper(Composite parent){
+		GridData gd;
+		final int buttonWidth=80;
+		final int buttonHeight=SWT.DEFAULT;
+		
+		Composite composite=createGroup(parent,2,SWT.BORDER);
+		////////////////////
+		//table area
+		Composite leftSide=new Composite(composite,SWT.NONE);
+		leftSide.setLayout(new GridLayout(1,false));
+		////////////////////
+		//table
+		createTable(leftSide);
+		////////////////////
+		//buttons area
+		Composite buttons=new Composite(composite,SWT.NONE);
+		buttons.setLayout(new GridLayout(1,false));
+		////////////////////
+		//new button
+		Button button=new Button(buttons,SWT.PUSH);		
+		button.setText("New");
+		gd = new GridData(buttonWidth,buttonHeight);				
+		button.setLayoutData(gd);
+		button.addSelectionListener(new NewConfigurationListener());
+		////////////////////
+		//delete button
+		button=new Button(buttons,SWT.PUSH);
+		button.setText("Delete");
+		button.setLayoutData(gd);
+		button.addSelectionListener(new DeleteConfigurationListener());
+		/////////////////////
+		//up button
+		button=new Button(buttons, SWT.ARROW | SWT.UP);
+		button.setLayoutData(gd);
+		button.addSelectionListener(new UpListener());
+		////////////////////
+		//down button
+		button=new Button(buttons, SWT.ARROW | SWT.DOWN);
+		button.setLayoutData(gd);
+		button.addSelectionListener(new DownListener());
+	}
+	
+	
+	private void createLower(Composite parent){
+		final int labelWidth=100;
+		final int textWidth=100;
+		Label label;
+		Button button;
+		
+		GridData gd;
+		Composite composite=createGroup(parent,1,SWT.BORDER);		
+		//////////////////////
+		//Name
+		Composite row1=createGroup(composite,2,SWT.NONE);
+		label=new Label(row1,SWT.NONE);
+		label.setText("Name");
+		label.setLayoutData(new GridData(labelWidth,SWT.DEFAULT));
+		m_Name=new Text(row1,SWT.SINGLE | SWT.BORDER);
+		m_Name.setLayoutData(new GridData(textWidth,SWT.DEFAULT));
+		m_Name.addFocusListener(new FieldsFocusListener());
+		m_Name.addKeyListener(new NameInputListener());
+		//////////////////////
+		//Working folder
+		Composite row2=createGroup(composite,3,SWT.NONE);		
+		label=new Label(row2,SWT.NONE);
+		label.setText("Working Folder");
+		gd = new GridData();
+		gd.widthHint=labelWidth;
+		label.setLayoutData(gd);
+		m_WorkFolder= new Text(row2,SWT.SINGLE | SWT.BORDER);
+		gd = new GridData();
+		gd.widthHint=textWidth;
+		m_WorkFolder.setLayoutData(gd);
+		m_WorkFolder.addFocusListener(new FieldsFocusListener());
+		button= new Button(row2,SWT.PUSH);
+		button.setText("Browse...");
+		button.addSelectionListener(new BrowseListener());
+		row2.pack();		
+		//////////////////////
+		//Parser
+		Composite row3=createGroup(composite,2,SWT.NONE);	
+		label=new Label(row3,SWT.NONE);
+		label.setText("Parser");		
+		gd = new GridData();
+		gd.widthHint=labelWidth;
+		label.setLayoutData(gd);
+		m_ErrorParser= new Combo(row3,SWT.READ_ONLY);
+		m_ErrorParser.addFocusListener(new FieldsFocusListener());
+		gd = new GridData();
+		gd.widthHint=textWidth;
+		m_ErrorParser.setLayoutData(gd);
+		row3.pack();		
+		//////////////////////
+		//Command
+		Composite row4=createGroup(composite,2,SWT.NONE);	
+		label=new Label(row4,SWT.NONE);
+		label.setText("Command");		
+		gd = new GridData();
+		gd.widthHint=labelWidth;
+		label.setLayoutData(gd);
+		m_BuildCommand = new Text(row4, SWT.BORDER);
+		m_BuildCommand.addFocusListener(new FieldsFocusListener());
+		gd = new GridData();
+		gd.widthHint=textWidth*2;
+		m_BuildCommand.setLayoutData(gd);
+		
+		//mg
+		createCommandButton(row4, m_BuildCommand);
+		//mg-----------------
+		
+		row4.pack();
+		//////////////////////
+		//Clean Command
+		Composite row5=createGroup(composite,2,SWT.NONE);	
+		label=new Label(row5,SWT.NONE);
+		label.setText("Clean Command");		
+		gd = new GridData();
+		gd.widthHint=labelWidth;
+		label.setLayoutData(gd);
+		m_CleanCommand = new Text(row5, SWT.BORDER);
+		m_CleanCommand.addFocusListener(new FieldsFocusListener());
+		gd = new GridData();
+		gd.widthHint=textWidth*2;
+		m_CleanCommand.setLayoutData(gd);
+		
+		//mg
+		createCommandButton(row5, m_CleanCommand);		
+		//mg-----------
+
+		composite.pack();
+	}
+		
+	//mg
+		private void createCommandButton( final Composite parent,
+				final Text commandText ) {
+			final Button button = new Button( parent, SWT.NONE );
+		button.addSelectionListener(new SelectionAdapter() {
+				
+				public void widgetSelected( final SelectionEvent e ) {
+					final StringVariableSelectionDialog dialog = new StringVariableSelectionDialog(
+							PlatformUI.getWorkbench().getActiveWorkbenchWindow()
+									.getShell() );
+				dialog.open();
+					final String var = dialog.getVariableExpression();
+				commandText.insert(var);
+			}
+		});
+		button.setText("Variables...");
+	}
+		//mg------------------
+	
+	protected Control createContents(Composite parent)
+	{
+		Composite top;
+		
+		top = new Composite(parent, SWT.NONE);
+		top.setLayout(new GridLayout(1, false));
+		
+		createUpper(top);
+		createLower(top);
+		top.pack();
+	    
+		initContents();
+        return top;
+	}
+	
+	
+
+	
+	private Composite createGroup(Composite parent, int column,int style)
+	{
+		Composite group = new Composite(parent, style);
+		group.setLayout(new GridLayout(column, false));
+		GridData gd = new GridData();
+		gd.horizontalAlignment = GridData.FILL;
+		gd.grabExcessHorizontalSpace = true;
+		group.setLayoutData(gd);
+		return group;
+	}
+	
+	private IProject getProject()
+	{
+		IAdaptable element = getElement();
+		if (element != null && element instanceof IProject)
+			return (IProject)element;
+		else
+			return null;
+	}
+	private String getProjectPath()
+	{
+		return "/" + getProject().getName();
+	}
+	
+	/**
+	 * Initializes the contents of the dialog
+	 */
+	private void initContents()
+	{
+		HdlNature nature;
+		try {
+			nature = getNature();
+		} catch (CoreException e) {
+			e.printStackTrace();
+			return;
+		}
+		
+		ErrorParser[] parsers = ErrorParser.getParsers();
+		for(int i = 0; i < parsers.length; i++)
+		{
+			m_ErrorParser.add(parsers[i].getCompilerName());
+		}
+		 
+		Map<String,BuildConfig> commands=nature.getCommands();
+		//if the list is empty, create a command with default settings
+		if(commands==null || commands.size() == 0){
+			setDefaults();
+		}
+		else{			
+			ArrayList<String> keyList=new ArrayList<String>();
+			keyList.addAll(commands.keySet());
+			Collections.sort(keyList);
+			for(String name : keyList.toArray(new String[0])){
+				createTableItem(commands.get(name));
+			}
+		}		
+	}
+	
+	/**
+	 * Updates the selected command with the values in the fields
+	 */
+	private void saveFields(){
+		TableItem[] selectedItems=m_ConfigTable.getSelection();
+		
+		//there should be only one selected item
+		if(selectedItems.length > 0){
+			BuildConfig buildConfig=(BuildConfig)selectedItems[0].getData();
+			buildConfig.setName(m_Name.getText());
+			buildConfig.setCommand(m_BuildCommand.getText());
+			buildConfig.setCleanCommand(m_CleanCommand.getText());
+			buildConfig.setParser(m_ErrorParser.getText());
+			buildConfig.setWorkFolder(m_WorkFolder.getText());			
+		}
+	}
+	/**
+	 * Saves the data to the nature
+	 */
+	private void saveData(){
+		
+		HdlNature nature;
+		try {
+			nature = getNature();
+		} catch (CoreException e) {			
+			e.printStackTrace();
+			return;
+		}
+				
+		Vector<BuildConfig> commands=new Vector<BuildConfig>();
+		int buildOrder=0;
+		saveFields();
+		for(TableItem tableItem:m_ConfigTable.getItems()){
+			BuildConfig command=(BuildConfig)tableItem.getData();
+			command.setBuildOrder(buildOrder++);
+			command.setEnabled(tableItem.getChecked());
+			commands.add(command);
+		}
+			
+		nature.setCommands(commands.toArray(new BuildConfig[0]));
+	}
+	
+	/**
+	 * Sets the default values
+	 */
+	private void setDefaults(){
+//		BuildConfig command=new BuildConfig();
+//		createTableItem(command);
+	}
+
+	/**
+	 * Creates or retrieves a project's nature
+	 * @return
+	 * @throws CoreException 
+	 */
+	private HdlNature getNature() throws CoreException {
+		IProject project=getProject();		
+		HdlNature hdlNature=null;
+		IProjectDescription projectDescription;	
+		projectDescription = project.getDescription();	
+		boolean bNatureFound=false;
+		ArrayList<String> natureList=new ArrayList<String>();
+			
+		for(String nature:projectDescription.getNatureIds()){
+			if(HdlNature.NATURE_ID.equals(nature)){
+				bNatureFound=true;
+				continue;
+			}
+			natureList.add(nature);
+		}
+		
+		if(bNatureFound==false){
+			//add the nature
+			natureList.add(HdlNature.NATURE_ID);
+			projectDescription.setNatureIds(natureList.toArray(new String[0]));
+			project.setDescription(projectDescription, null);			
+		}
+
+		hdlNature=(HdlNature) project.getNature(HdlNature.NATURE_ID);
+		return hdlNature;		
+	}
+	
+	/**
+	 * Called when the user clicks OK
+	 */
+	public boolean performOk()
+	{
+		saveData();
+		super.performOk();		
+		return true;
+	}
+	
+	/**
+	 * Called when the user clicks apply
+	 */	
+	 protected void performApply() {
+		 saveData();
+	 }
+	 
+	 /**
+	  * Called when the user clicks defaults
+	  */
+	protected void performDefaults()
+	{
+		super.performDefaults();
+		m_ConfigTable.clearAll();
+		setDefaults();		
+	}
+	
+	/**
+	 * Class called when the user presses the new button
+	 *
+	 */
+	private class NewConfigurationListener extends SelectionAdapter{
+		public void widgetSelected(SelectionEvent e)
+		{
+			ArrayList<BuildConfig> buildConfigList=new ArrayList<BuildConfig>();
+			TableItem []tableItems=m_ConfigTable.getItems();
+			
+			//gather a list of items
+			for(TableItem item:tableItems){
+				buildConfigList.add((BuildConfig)item.getData());
+			}
+			
+			NewBuildConfigDialog dialog=new NewBuildConfigDialog(getControl().getShell(),
+					buildConfigList.toArray(new BuildConfig[0]));
+			dialog.open();
+			if(dialog.isOkPressed()){
+				createTableItem(dialog.getBuildConfig());
+			}
+		}
+	}
+	
+	/**
+	 * Class called when the user presses the delete button
+	 * @author gho18481
+	 *
+	 */
+	private class DeleteConfigurationListener extends SelectionAdapter{
+		public void widgetSelected(SelectionEvent e)
+		{
+			int selectedIdx=m_ConfigTable.getSelectionIndex();		
+			//there should be only one selected item
+			if(selectedIdx != -1){			
+				m_ConfigTable.remove(selectedIdx);
+			}
+		}
+	}
+	
+	/**
+	 * Class called when the user presses the delete button
+	 * @author gho18481
+	 *
+	 */
+	private class UpListener extends SelectionAdapter{
+		public void widgetSelected(SelectionEvent e)
+		{
+			int selectedIdx=m_ConfigTable.getSelectionIndex();		
+			//there should be only one selected item
+			if(selectedIdx > 0 ){			
+				TableItem upperItem=m_ConfigTable.getItem(selectedIdx-1);
+				TableItem lowerItem=m_ConfigTable.getItem(selectedIdx);
+				BuildConfig upperConfig=(BuildConfig)upperItem.getData();
+				BuildConfig lowerConfig=(BuildConfig)lowerItem.getData();
+				
+				m_ConfigTable.setRedraw(false);
+				upperConfig.setBuildOrder(selectedIdx);
+				lowerConfig.setBuildOrder(selectedIdx-1);				
+				createTableItem(upperConfig);
+				createTableItem(lowerConfig);
+				upperItem.dispose();
+				lowerItem.dispose();
+				m_ConfigTable.setRedraw(true);
+				m_ConfigTable.setSelection(selectedIdx-1);
+				m_ConfigTable.setFocus();
+			}
+		}
+	}
+	
+	/**
+	 * Class called when the user presses the delete button
+	 * @author gho18481
+	 *
+	 */
+	private class DownListener extends SelectionAdapter{
+		public void widgetSelected(SelectionEvent e)
+		{
+			int selectedIdx=m_ConfigTable.getSelectionIndex();		
+			//as long at its not the last one
+			if(selectedIdx!= -1 && selectedIdx < m_ConfigTable.getItemCount()-1){			
+				TableItem upperItem=m_ConfigTable.getItem(selectedIdx);
+				TableItem lowerItem=m_ConfigTable.getItem(selectedIdx+1);
+				BuildConfig upperConfig=(BuildConfig)upperItem.getData();
+				BuildConfig lowerConfig=(BuildConfig)lowerItem.getData();
+				
+				m_ConfigTable.setRedraw(false);
+				upperConfig.setBuildOrder(selectedIdx+1);
+				lowerConfig.setBuildOrder(selectedIdx);				
+				createTableItem(upperConfig);
+				createTableItem(lowerConfig);
+				upperItem.dispose();
+				lowerItem.dispose();
+				m_ConfigTable.setRedraw(true);
+				m_ConfigTable.setSelection(selectedIdx+1);
+				m_ConfigTable.setFocus();
+			}
+		}
+	}
+	
+	/**
+	 * Class called whenever the browse button is pressed
+	 *
+	 */
+	private class BrowseListener extends SelectionAdapter
+	{
+		public void widgetSelected(SelectionEvent e)
+		{
+			ContainerSelectionDialog dialog = new ContainerSelectionDialog(
+					getShell(), getProject(), false, "Select a working folder");
+			dialog.setValidator(new ISelectionValidator()
+			{
+				public String isValid(Object selection)
+				{
+					if (selection.toString().indexOf(getProjectPath()) == 0)
+						return null;
+					else
+						return "Cannot select a folder in other projects";
+				}
+				
+			});
+			if (dialog.open() == ContainerSelectionDialog.OK)
+			{
+				Object[] result = dialog.getResult();
+				if (result.length == 1)
+				{
+					String path = ((Path)result[0]).toString();
+					path = path.substring(getProjectPath().length() + 1);
+					m_WorkFolder.setText(path);
+				}
+			}
+		}
+	}
+	
+	/**
+	 * Used to listen for selection changes
+	 */
+	private class ConfigTableSelectionListener extends SelectionAdapter{
+		public void widgetSelected(SelectionEvent e)
+		{
+			if (e.item instanceof TableItem) {
+				TableItem item = (TableItem) e.item;
+				BuildConfig command=(BuildConfig)item.getData();
+				
+				m_Name.setText(command.getName());
+				m_WorkFolder.setText(command.getWorkFolder());
+				m_CleanCommand.setText(command.getCleanCommand());
+				m_BuildCommand.setText(command.getCommand());
+				int idx=0;
+				m_ErrorParser.select(-1);
+				for(String errorParser: m_ErrorParser.getItems()){
+					if(errorParser.equals(command.getParser())){
+						m_ErrorParser.select(idx);
+					}
+					idx++;
+				}
+			}
+		}
+	}
+	
+	/**
+	 * Used to listen to focus changes in order to save the users input
+	 *
+	 */
+	private class FieldsFocusListener extends FocusAdapter{
+		public void	focusLost(FocusEvent e){
+			saveFields();
+		}
+	}
+	
+	/**
+	 * Called when the user types something in the name list
+	 *
+	 */
+	private class NameInputListener extends KeyAdapter{
+		public void keyReleased(KeyEvent e){
+			TableItem[] selectedItems=m_ConfigTable.getSelection();
+			
+			//there should be only one selected item
+			if(selectedItems.length > 0){
+				//update the item name
+				selectedItems[0].setText(CONFIG_NAME_COL_IDX,m_Name.getText());
+			}
+		}
+	}
+}
+
+
+	
+
+
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/cdt/LineBackgroundPainter.java vdt/src/com/elphel/vdt/veditor/cdt/LineBackgroundPainter.java
--- vdt-veditor/src/com/elphel/vdt/veditor/cdt/LineBackgroundPainter.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/cdt/LineBackgroundPainter.java	2016-06-24 10:29:40.816496628 -0600
@@ -1,9 +1,21 @@
 /*******************************************************************************
+ * Notice: This file when combined with VDT project DOES NOT have a valid
+ * distribution license and has to be re-generated by a user.
+ *
+ * This file is made of the original code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+/*******************************************************************************
  * Copyright (c) 2007, 2011 Wind River Systems, Inc. and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
+ * All rights reserved. 
  *
  * Contributors:
  *     Anton Leherbauer (Wind River Systems) - initial API and implementation
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/document/HdlDocument.java vdt/src/com/elphel/vdt/veditor/document/HdlDocument.java
--- vdt-veditor/src/com/elphel/vdt/veditor/document/HdlDocument.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/document/HdlDocument.java	2016-06-24 10:29:40.816496628 -0600
@@ -1,237 +1,456 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.document;
-
-import java.util.Vector;
-
-import net.sourceforge.veditor.VerilogPlugin;
-import net.sourceforge.veditor.editor.scanner.HdlPartitionScanner;
-import net.sourceforge.veditor.parser.HdlParserException;
-import net.sourceforge.veditor.parser.IParser;
-import net.sourceforge.veditor.parser.OutlineContainer;
-import net.sourceforge.veditor.parser.OutlineDatabase;
-import net.sourceforge.veditor.parser.OutlineElement;
-import org.eclipse.core.resources.IFile;
-import org.eclipse.core.resources.IProject;
-import org.eclipse.core.runtime.CoreException;
-import org.eclipse.jface.text.BadLocationException;
-import org.eclipse.jface.text.Document;
-import org.eclipse.jface.text.DocumentEvent;
-import org.eclipse.jface.text.IDocumentListener;
-
-abstract public class HdlDocument extends Document
-{
-	/**
-	 * project which has this verilog source file
-	 */
-	private IProject m_Project;
-	private IFile m_File;	
-	private boolean m_NeedToRefresh;
-
-	public HdlDocument(IProject project, IFile file)
-	{
-		super();
-		m_Project = project;
-		m_File = file;
-		m_NeedToRefresh=true;
-		addDocumentListener(new HdlDocumentListner());		
-	}
-
-	public IProject getProject()
-	{
-		return m_Project;
-	}
-
-	public IFile getFile()
-	{
-		return m_File;
-	}
-
-	/**
-	 * Gets the outline database object for this project	 
-	 * @return
-	 */
-	public OutlineDatabase getOutlineDatabase(){	
-			OutlineDatabase database = null;
-			IProject project = getProject();
-			if(project != null){
-				try {
-					database = (OutlineDatabase) project
-							.getSessionProperty(VerilogPlugin.getOutlineDatabaseId());
-					if(database == null){
-						database=CreateOutlineDatabase(project);
-					}
-				} catch (CoreException e) {
-					// TODO Auto-generated catch block
-					e.printStackTrace();
-				}
-			}
-			return database;
-		}
-	
-	/**
-	 * Same as  getOutlineContainer(true);
-	 * @return
-	 * @throws HdlParserException 
-	 */
-	public OutlineContainer getOutlineContainer() throws HdlParserException{
-		return getOutlineContainer(true);
-	}
-	/**
-	 * @param bRefreshIfNeeded if true the outline will be if the data is stale
-	 * @return The outline container for this document
-	 * @throws HdlParserException 
-	 */
-	public OutlineContainer getOutlineContainer(boolean bRefreshIfNeeded) throws HdlParserException{
-		OutlineDatabase database=getOutlineDatabase();
-		if (database == null){
-			return null;
-		}
-		OutlineContainer results=database.getOutlineContainer(getFile());
-		if(results==null || bRefreshIfNeeded){
-			refreshOutline();
-		}
-		
-		return database.getOutlineContainer(getFile());
-	}
-	
-	/**
-	 * Refreshes the outline database if necessary
-	 * @return true if a refresh was required
-	 * @throws HdlParserException 
-	 */
-	public boolean refreshOutline() throws HdlParserException{
-		if(m_NeedToRefresh){
-			m_NeedToRefresh=false;
-			getOutlineContainer(false).clear();
-			IParser parser = createParser(get());
-			VerilogPlugin.deleteMarkers(getFile());
-			try{
-				parser.parse();
-			}
-			catch (HdlParserException e){
-				throw e;
-			}
-			OutlineDatabase database = OutlineDatabase.getProjectsDatabase(getProject());
-			database.scanTree(getFile());
-			return true;
-		}		
-		return false;
-	}
-	
-	/**
-	 * Used to listen for document changes
-	 *
-	 */
-	private class HdlDocumentListner implements IDocumentListener{
-
-		public void documentAboutToBeChanged(DocumentEvent event) {
-			// TODO Auto-generated method stub
-			
-		}
-
-		public void documentChanged(DocumentEvent event) {
-			//skip over the first modification because it is usually fired when a save occurs
-			if(m_NeedToRefresh==false && event.getModificationStamp() > 1){
-				m_NeedToRefresh=true;				
-			}
-		}
-		
-	}
-	
-		
-	/**
-	 * Returns the element near the given document offset
-	 * @param document
-	 * @param doRefresh If set to true, the document will be 
-	 * parsed (if dirty) before an attempt is made to find the element
-	 * @return
-	 * @throws HdlParserException 
-	 */
-	public OutlineElement getElementAt(int documentOffset,boolean doRefresh)  throws BadLocationException, HdlParserException{
-		int line=getLineOfOffset(documentOffset);
-		int col=documentOffset-getLineOffset(line);
-		
-		return getOutlineContainer(doRefresh).getLineContext(line, col);
-	}
-	
-	
-	/**
-	 * Creates an outline database and adds it to the project
-	 * if one does not exist. This function will do useful work
-	 * once per project	 
-	 * @param project Project to owning the data base	
-	 *   
-	 */
-	private OutlineDatabase CreateOutlineDatabase(IProject project){
-		// do we already have an outline database?
-		OutlineDatabase database=null;
-		try {
-			database = (OutlineDatabase)project.getSessionProperty(VerilogPlugin.getOutlineDatabaseId());			
-		} catch (CoreException e) {			
-			e.printStackTrace();
-		}
-		//if not created yet, make one
-		if(database == null){
-			database=new OutlineDatabase(project);
-			try {
-				project.setSessionProperty(VerilogPlugin.getOutlineDatabaseId(), database);
-				database.scanProject();
-			} catch (CoreException e) {
-				// TODO Auto-generated catch block
-				e.printStackTrace();
-			}
-		}
-		return database;
-	}
-	
-	/**
-	 * Gets the indent string of the line that contains the offset
-	 * @param documentOffset offset from the beginning of the document
-	 * @return Indent string
-	 */
-	public  String getIndentString(int documentOffset)
-	{
-		try
-		{
-			int line = getLineOfOffset(documentOffset);
-			int pos = getLineOffset(line);
-			StringBuffer buf = new StringBuffer();
-			for (;;)
-			{
-				char c = getChar(pos++);
-				if (!Character.isSpaceChar(c) && c != '\t')
-					break;
-				buf.append(c);
-			}
-			return buf.toString();
-		}
-		catch (BadLocationException e)
-		{
-			e.printStackTrace();
-		}
-		return null;
-	}
-	
-	abstract public HdlPartitionScanner createPartitionScanner();
-	abstract protected IParser createParser(String text);
-	public abstract Vector<OutlineElement> getDefinitionList(String name,int offset);	
-	/**
-	 * returns the context of the given offset
-	 * @param documentOffset
-	 * @return
-	 */
-	public abstract int getContext(int documentOffset) throws BadLocationException;
-
-}
-
-
-
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.document;
+
+import java.util.Map;
+import java.util.Vector;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import com.elphel.vdt.veditor.VerilogPlugin;
+import com.elphel.vdt.veditor.editor.HdlEditor;
+import com.elphel.vdt.veditor.editor.scanner.HdlPartitionScanner;
+import com.elphel.vdt.veditor.parser.HdlParserException;
+import com.elphel.vdt.veditor.parser.IParser;
+import com.elphel.vdt.veditor.parser.OutlineContainer;
+import com.elphel.vdt.veditor.parser.OutlineDatabase;
+import com.elphel.vdt.veditor.parser.OutlineElement;
+import com.elphel.vdt.veditor.parser.verilog.VariableStore;
+import com.elphel.vdt.veditor.parser.verilog.VerilogParser;
+import com.elphel.vdt.veditor.preference.PreferenceStrings;
+
+import org.eclipse.core.resources.IFile;
+import org.eclipse.core.resources.IProject;
+import org.eclipse.core.runtime.CoreException;
+import org.eclipse.core.runtime.IProgressMonitor;
+import org.eclipse.core.runtime.IStatus;
+import org.eclipse.core.runtime.Status;
+import org.eclipse.core.runtime.jobs.Job;
+import org.eclipse.jface.text.BadLocationException;
+import org.eclipse.jface.text.Document;
+import org.eclipse.jface.text.DocumentEvent;
+import org.eclipse.jface.text.IDocumentListener;
+import org.eclipse.swt.widgets.Display;
+abstract public class HdlDocument extends Document
+{
+	/**
+	 * project which has this verilog source file
+	 */
+	private IProject m_Project;
+	private IFile m_File;	
+	private boolean m_NeedToRefresh;
+	private long m_dueParseTime=0;
+	private Job timerJob;
+	private final AtomicBoolean timerSceduled;
+	private static int maxRetries=10;
+	private int retries=0;
+	private HdlEditor f_editor = null; // change to list - same document can be opened in multiple editor windows
+	private HdlDocumentListner hdlDocumentListener = null; // just to be able to "wake up" (re-parse) document
+	                                                       // from the editor (like getting focus)
+	
+	public void setEditor(HdlEditor editor){ // set first time editor gets into focus
+		f_editor = editor;
+		markDisabledCode();
+		if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_DISABLED)) {
+			System.out.println("HdlDocument.setEditor();");
+		}
+	}
+	
+	public void sendDocumentModificationEvent(String txt){
+		DocumentEvent event = new DocumentEvent (this, 0,txt.length(), txt);
+		event.fModificationStamp=2;
+		hdlDocumentListener.documentChanged(event);
+	}
+	/*
+	private HdlDocumentListner hdlDocumentListener = null; // just to be able to "wake up" (re-parse) document
+	                                                       // from the editor (like getting focus)
+DocumentEvent(IDocument doc, int offset, int length, String text)	                                                        * 
+
+	 */
+	public HdlDocument(IProject project, IFile file)
+	{
+		super();
+		m_Project = project;
+		m_File = file;
+		m_NeedToRefresh=true;
+		m_dueParseTime=0;
+		hdlDocumentListener = new HdlDocumentListner();
+		addDocumentListener (hdlDocumentListener);
+		if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR)) {
+			System.out.println("HdlDocument("+m_File.getFullPath()+")");
+		}
+		try {
+			project.setSessionProperty(VerilogPlugin.getHdlDocumentId(), this);
+		} catch (CoreException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+		timerJob=new Job ("Timer Job"){
+			@Override
+			protected IStatus run(IProgressMonitor monitor) {
+//				System.out.println("Timer Job threadID="+Thread.currentThread().getId());
+				Display.getDefault().syncExec(new Runnable() {
+					public void run() {
+//						System.out.println("Timer Job syncExec threadID="+Thread.currentThread().getId());
+						timerSceduled.set(false);
+						mainThreadTimerExpired();
+						// here may re-start timer or start parsing
+					}
+				});
+				return Status.OK_STATUS;
+			}
+		};
+		timerSceduled=new AtomicBoolean(false);
+	}
+	public boolean launchTimer(long delay){
+//		System.out.println("launchTimer("+delay+")");
+		if (!timerSceduled.compareAndSet(false, true)){
+			return false; // timer is still not done
+		}
+//		System.out.println("launchTimer("+delay+")");
+		timerJob.schedule(delay); // 2 seconds
+		return true;
+	}
+	public void finalize() throws Throwable{
+		if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR)) {
+			System.out.println("HdlDocument.finalize("+m_File.getFullPath()+")");
+		}
+		super.finalize();
+	}
+
+	public IProject getProject()
+	{
+		return m_Project;
+	}
+
+	public IFile getFile()
+	{
+		return m_File;
+	}
+
+	/**
+	 * Gets the outline database object for this project	 
+	 * @return
+	 */
+	public OutlineDatabase getOutlineDatabase(){	
+			OutlineDatabase database = null;
+			IProject project = getProject();
+			if(project != null){
+				try {
+					database = (OutlineDatabase) project
+							.getSessionProperty(VerilogPlugin.getOutlineDatabaseId());
+					if(database == null){
+						database=CreateOutlineDatabase(project);
+					}
+				} catch (CoreException e) {
+					// TODO Auto-generated catch block
+					e.printStackTrace();
+				}
+			}
+			return database;
+		}
+	
+	/**
+	 * Same as  getOutlineContainer(true);
+	 * @return
+	 * @throws HdlParserException 
+	 */
+	public OutlineContainer getOutlineContainer() throws HdlParserException{
+		return getOutlineContainer(true);
+	}
+	/**
+	 * @param bRefreshIfNeeded if true the outline will be if the data is stale
+	 * @return The outline container for this document
+	 * @throws HdlParserException 
+	 */
+	public OutlineContainer getOutlineContainer(boolean bRefreshIfNeeded) throws HdlParserException{
+		OutlineDatabase database=getOutlineDatabase();
+		if (database == null){
+			return null;
+		}
+		OutlineContainer results=database.getOutlineContainer(getFile());
+		if(results==null || bRefreshIfNeeded){
+			refreshOutline();
+		}
+		
+		return database.getOutlineContainer(getFile());
+	}
+	public void markDisabledCode(){
+		if (f_editor != null) {
+			// Update disabled code indication in the editor window
+			f_editor.markDisabledCode();
+    		if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_DISABLED)) {
+    			System.out.println("markDisabledCode() - done "+getFile());
+    		}
+		} else {
+    		if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_DISABLED)) {
+    			System.out.println("markDisabledCode() - skipped as f_editor is null: "+getFile());
+    		}
+		}
+	}
+	
+	/**
+	 * Refreshes the outline database if necessary
+	 * @return true if a refresh was required
+	 * @throws HdlParserException 
+	 */
+	public void uncondRefreshOutline() throws HdlParserException {
+		m_NeedToRefresh=true;
+		refreshOutline();
+	}
+	public boolean refreshOutline() throws HdlParserException{
+		if(m_NeedToRefresh){
+			m_NeedToRefresh=false;
+			getOutlineContainer(false).clear();
+			IParser parser = createParser(get());
+			VerilogPlugin.deleteMarkers(getFile());
+			try{
+				parser.parse(1);
+			}
+			catch (HdlParserException e){
+				markDisabledCode(); // still update after failed parsing?				
+				throw e;
+			}
+			OutlineDatabase database = OutlineDatabase.getProjectsDatabase(getProject());
+			database.scanTree(getFile());
+			markDisabledCode();
+			
+			// Second pass so module instances are known before processing assignments (current
+			// order is opposite. First pass creates warning markers and later defines instances.
+			// Second pass erases markers and uses hierarchical access to instances
+			// Andrey
+//			if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR)) {
+//				System.out.println(" refreshOutline() - reparsing...");
+//				MessageUI.error("turn on breakpoints");
+//			}
+			
+/*
+	public Map<String,VariableStore> getVariableStoreMap(){
+		return variableStoreMap;
+	}
+	public void setLastVariableStoreMap( Map<String,VariableStore> storeMap){
+			
+ */
+			int maxPass=2;
+			for (int numPass=2;numPass<=maxPass;numPass++){
+				// for Verilog only - save/restore variable store between parser passes (for parameters assigned after use)
+				if (parser instanceof VerilogParser) {
+					Map<String,VariableStore> variableStoreMap=((VerilogParser) parser).getVariableStoreMap();
+					parser = createParser(get());
+					((VerilogParser) parser).setLastVariableStoreMap(variableStoreMap);
+				} else {
+					parser = createParser(get());
+				}
+
+				VerilogPlugin.deleteMarkers(getFile());
+				if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR))
+					System.out.println("********* Parser pass "+numPass+" ****************");
+
+				try{
+					parser.parse(numPass); // second pass, pass used only in bit range errors (invalid int)
+				}
+				catch (HdlParserException e){
+					throw e;
+				}
+				if (parser instanceof VerilogParser) {
+					VerilogParser vparser= (VerilogParser) parser;
+					if (numPass==2){
+						int rank=vparser.getParametersRank();
+						if (rank>=0) maxPass= rank+2;
+					}
+					if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR)) {
+						System.out.println("refreshOutline() pass "+numPass+" getDepsResolved()=    "+vparser.getDepsResolved());
+						System.out.println("refreshOutline() pass "+numPass+" getParsResolved()=    "+vparser.getParsResolved());
+						System.out.println("refreshOutline() pass "+numPass+" getExpressionsValid()="+vparser.getExpressionsValid());
+						System.out.println("refreshOutline() pass "+numPass+" getPortsValid()=      "+vparser.getPortsValid());
+					}
+					if (vparser.getExpressionsValid() || (numPass == maxPass)) {
+						vparser.setParametricPorts();
+						break; // all done
+					}
+				}				
+			}			
+			return true;
+		}		
+		return false;
+	}
+	
+	/**
+	 * Used to listen for document changes
+	 *
+	 */
+	private class HdlDocumentListner implements IDocumentListener{
+
+		public void documentAboutToBeChanged(DocumentEvent event) {
+			// TODO Auto-generated method stub
+			
+		}
+
+		public void documentChanged(DocumentEvent event) {
+			//event.getModificationStamp()==1 when document is opened, increments each new edit, decrements on cntrl-Z
+			//skip over the first modification because it is usually fired when a save occurs
+//			if(m_NeedToRefresh==false && event.getModificationStamp() > 1){
+			if(event.getModificationStamp() > 1){
+				m_NeedToRefresh=true;
+				if ((VerilogPlugin.getPreferenceBoolean(PreferenceStrings.REPARSE_ON_TYPE))|| event.getText().equals("\n\n\n")){
+					int delay=VerilogPlugin.getPreferenceInt(PreferenceStrings.MIN_REPARSE_TIME);
+					String txt=event.getText(); // System.out.println(txt.length()+"'"+txt+"'");
+					if ((txt!=null) && (txt.contains("\n"))){
+//						System.out.println("New line");
+						m_dueParseTime=(System.nanoTime()/1000000);
+						//	mainThreadTimerExpired(); // This was causing some text not displayed after pressing "Enter".
+						// Starting thread async fixed the problem
+						Display.getDefault().asyncExec(new Runnable() {
+							public void run() {
+								timerSceduled.set(false);
+								mainThreadTimerExpired(); // re-parse
+							}
+						});
+						return;
+					}
+					m_dueParseTime=(System.nanoTime()/1000000)+delay;
+					retries=maxRetries; //When exception happens in parse, it will never finish
+					launchTimer(delay);
+				} else {
+					m_dueParseTime=0;
+				}
+			}
+		}
+		
+	}
+	private void mainThreadTimerExpired(){
+		long currentTime=System.nanoTime()/1000000;
+		if (m_dueParseTime==0){
+			return; // parsing while editing is disabled
+		}
+		if (currentTime < m_dueParseTime) {
+			launchTimer(m_dueParseTime-currentTime);  // wait longer
+			return;
+		}
+		// try to parse if not busy
+		boolean updated=HdlEditor.current().updatePagesIfFree(false);
+//		System.out.println("updated="+updated);
+		if (!updated){ // Was busy - try again later
+			retries--;
+			if (retries>=0) {
+				launchTimer(VerilogPlugin.getPreferenceInt(PreferenceStrings.MIN_REPARSE_TIME));
+			} else {
+				System.out.println("mainThreadTimerExpired(): "+maxRetries+"parse attempts failed, giving up");
+			}
+		}
+		
+	}
+	
+		
+	/**
+	 * Returns the element near the given document offset
+	 * @param document
+	 * @param doRefresh If set to true, the document will be 
+	 * parsed (if dirty) before an attempt is made to find the element
+	 * @return
+	 * @throws HdlParserException 
+	 */
+	public OutlineElement getElementAt(int documentOffset,boolean doRefresh)  throws BadLocationException, HdlParserException{
+		int line=getLineOfOffset(documentOffset); // zero-based
+		int col=documentOffset-getLineOffset(line); // zero-base
+		
+		return getOutlineContainer(doRefresh).getLineContext(line+1, col+1); //one-based
+	}
+	
+	
+	/**
+	 * Creates an outline database and adds it to the project
+	 * if one does not exist. This function will do useful work
+	 * once per project	 
+	 * @param project Project to owning the data base	
+	 *   
+	 */
+	private OutlineDatabase CreateOutlineDatabase(IProject project){
+		// do we already have an outline database?
+		OutlineDatabase database=null;
+		try {
+			database = (OutlineDatabase)project.getSessionProperty(VerilogPlugin.getOutlineDatabaseId());			
+		} catch (CoreException e) {			
+			e.printStackTrace();
+		}
+		//if not created yet, make one
+		if(database == null){
+			database=new OutlineDatabase(project);
+			try {
+				project.setSessionProperty(VerilogPlugin.getOutlineDatabaseId(), database);
+				database.scanProject();
+			} catch (CoreException e) {
+				// TODO Auto-generated catch block
+				e.printStackTrace();
+			}
+		}
+		return database;
+	}
+	
+	/**
+	 * Gets the indent string of the line that contains the offset
+	 * @param documentOffset offset from the beginning of the document
+	 * @return Indent string
+	 */
+	public  String getIndentString(int documentOffset)
+	{
+		try
+		{
+			int line = getLineOfOffset(documentOffset);
+			int pos = getLineOffset(line);
+			StringBuffer buf = new StringBuffer();
+			for (;;)
+			{
+				char c = getChar(pos++);
+				if (!Character.isSpaceChar(c) && c != '\t')
+					break;
+				buf.append(c);
+			}
+			return buf.toString();
+		}
+		catch (BadLocationException e)
+		{
+			e.printStackTrace();
+		}
+		return null;
+	}
+	
+	abstract public HdlPartitionScanner createPartitionScanner();
+	abstract protected IParser createParser(String text);
+	public abstract Vector<OutlineElement> getDefinitionList(String name,int offset);	
+	/**
+	 * returns the context of the given offset
+	 * @param documentOffset
+	 * @return
+	 */
+	public abstract int getContext(int documentOffset) throws BadLocationException;
+
+	/**
+	 * Applies background for disabled (by `ifdef) portions of the code
+	 * @param documentOffset offset from the beginning of the document
+	 * @return Indent string
+	 */
+	
+	
+}
+
+
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/document/HdlDocumentProvider.java vdt/src/com/elphel/vdt/veditor/document/HdlDocumentProvider.java
--- vdt-veditor/src/com/elphel/vdt/veditor/document/HdlDocumentProvider.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/document/HdlDocumentProvider.java	2016-06-24 10:29:40.816496628 -0600
@@ -1,179 +1,190 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-
-package net.sourceforge.veditor.document;
-
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.InputStream;
-import java.net.URI;
-import java.util.HashMap;
-import java.util.Map;
-
-import net.sourceforge.veditor.editor.scanner.HdlPartitionScanner;
-
-import org.eclipse.core.filebuffers.FileBuffers;
-import org.eclipse.core.filebuffers.ITextFileBuffer;
-import org.eclipse.core.filesystem.EFS;
-import org.eclipse.core.filesystem.IFileInfo;
-import org.eclipse.core.filesystem.IFileStore;
-import org.eclipse.core.resources.IContainer;
-import org.eclipse.core.resources.IFile;
-import org.eclipse.core.resources.IFolder;
-import org.eclipse.core.resources.IProject;
-import org.eclipse.core.runtime.CoreException;
-import org.eclipse.core.runtime.IProgressMonitor;
-import org.eclipse.jface.text.IDocument;
-import org.eclipse.jface.text.IDocumentPartitioner;
-import org.eclipse.jface.text.rules.FastPartitioner;
-import org.eclipse.ui.IFileEditorInput;
-import org.eclipse.ui.IPathEditorInput;
-import org.eclipse.ui.IStorageEditorInput;
-import org.eclipse.ui.editors.text.FileDocumentProvider;
-import org.eclipse.ui.ide.FileStoreEditorInput;
-
-public abstract class HdlDocumentProvider extends FileDocumentProvider
-{
-	private Map<Object, IFileInfo> fileInfoMap = new HashMap<Object, IFileInfo>();
-	
-	protected IDocument createDocument(Object element) throws CoreException {
-		HdlDocument document = null;
-
-		if (element instanceof IFileEditorInput) {
-
-			// a file is in the current workspace
-			IFileEditorInput input = (IFileEditorInput) element;
-			IFile file = input.getFile();
-			IContainer parent = file.getParent();
-			
-			// find project
-			while (parent instanceof IFolder) {
-				parent = parent.getParent();
-			}
-
-			if (parent instanceof IProject) {
-				document = createHdlDocument((IProject) parent, file);
-				if (!setDocumentContent(document, input, getEncoding(element)))
-					document = null;
-			}
-
-		} else if (element instanceof IStorageEditorInput) {
-
-			// a file is in Repository Exploring Perspective (or others?)
-			IStorageEditorInput input = (IStorageEditorInput) element;
-			document = createHdlDocument(null, null);
-			InputStream stream = input.getStorage().getContents();
-			setDocumentContent(document, stream, getEncoding(element));
-
-		} else if (element instanceof IPathEditorInput) {
-
-			// Maybe this is not executed on Eclipse 3.3 or later
-			// Eclipse 3.2 executed for a file outside of workspace
-			IPathEditorInput input = (IPathEditorInput) element;
-			document = createHdlDocument(null, null);
-			FileInputStream contentStream = null;
-			try {
-				contentStream = new FileInputStream(input.getPath().toFile());
-				setDocumentContent(document, contentStream,
-						getEncoding(element));
-			} catch (FileNotFoundException e) {
-				e.printStackTrace();
-				document = null;
-			}
-
-		} else if (element instanceof FileStoreEditorInput) {
-
-			// a file that is not part of the current workspace
-			FileStoreEditorInput fileStoreEditorInput = (FileStoreEditorInput) element;
-			document = createHdlDocument(null, null);
-			FileInputStream contentStream = null;
-			URI uri = fileStoreEditorInput.getURI();
-			if (uri != null && uri.getScheme().equals("file")) {
-				String filename = uri.getPath();
-				try {
-					contentStream = new FileInputStream(filename);
-					setDocumentContent(document, contentStream,
-							getEncoding(element));
-					fileInfoMap.put(element, EFS.getStore(uri).fetchInfo());
-				} catch (FileNotFoundException e) {
-					e.printStackTrace();
-					document = null;
-				}
-			}
-
-		}
-		if (document != null) {
-			HdlPartitionScanner scanner = document.createPartitionScanner();
-			IDocumentPartitioner partitioner = new FastPartitioner(scanner,
-					HdlPartitionScanner.getContentTypes());
-			partitioner.connect(document);
-			document.setDocumentPartitioner(partitioner);
-		}
-		return document;
-	}
-	
-	abstract HdlDocument createHdlDocument(IProject project, IFile file);
-
-	public boolean isModifiable(Object element) {
-		if (element instanceof FileStoreEditorInput)
-			return !isReadOnly(element);
-		else
-			return super.isModifiable(element);
-	}
-
-	public boolean isReadOnly(Object element) {
-		if (element instanceof FileStoreEditorInput) {
-			IFileInfo info = fileInfoMap.get(element);
-			if (info == null)
-				return true;	// fail safe
-			return info.getAttribute(EFS.ATTRIBUTE_READ_ONLY);
-		} else
-			return super.isReadOnly(element);
-	}
-
-	protected void doSaveDocument(IProgressMonitor monitor, Object element,
-			IDocument document, boolean overwrite) throws CoreException {
-
-		if (element instanceof FileStoreEditorInput) {
-
-			// This is same as TextFileDocumentProvider#saveDocument
-			// I don't know exactly :-)
-			FileStoreEditorInput input = (FileStoreEditorInput) element;
-			IFileStore fileStore = EFS.getStore(input.getURI());
-			FileBuffers.getTextFileBufferManager().connectFileStore(fileStore,
-					monitor);
-			ITextFileBuffer buffer = FileBuffers.getTextFileBufferManager()
-					.getFileStoreTextFileBuffer(fileStore);
-			buffer.getDocument().set(document.get());
-			buffer.commit(monitor, true);
-			FileBuffers.getTextFileBufferManager().disconnectFileStore(
-					fileStore, monitor);
-		}
-		else
-		{
-			super.doSaveDocument(monitor, element, document, overwrite);
-		}
-	}
-
-	
-//	Don't use special encoding.
-//	Set encoding in Project Properties page
-//	protected String getPersistedEncoding(Object element)
-//	{
-//		String encoding = VerilogPlugin.getPreferenceString("Encoding");
-//		if (encoding == null || encoding.equals(""))
-//			return super.getPersistedEncoding(element);
-//		else
-//			return encoding;
-//	}
-
-}
-
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+
+package com.elphel.vdt.veditor.document;
+
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.InputStream;
+import java.net.URI;
+import java.util.HashMap;
+import java.util.Map;
+
+import com.elphel.vdt.veditor.editor.scanner.HdlPartitionScanner;
+
+import org.eclipse.core.filebuffers.FileBuffers;
+import org.eclipse.core.filebuffers.ITextFileBuffer;
+import org.eclipse.core.filesystem.EFS;
+import org.eclipse.core.filesystem.IFileInfo;
+import org.eclipse.core.filesystem.IFileStore;
+import org.eclipse.core.resources.IContainer;
+import org.eclipse.core.resources.IFile;
+import org.eclipse.core.resources.IFolder;
+import org.eclipse.core.resources.IProject;
+import org.eclipse.core.runtime.CoreException;
+import org.eclipse.core.runtime.IProgressMonitor;
+import org.eclipse.jface.text.IDocument;
+import org.eclipse.jface.text.IDocumentPartitioner;
+import org.eclipse.jface.text.rules.FastPartitioner;
+import org.eclipse.ui.IFileEditorInput;
+import org.eclipse.ui.IPathEditorInput;
+import org.eclipse.ui.IStorageEditorInput;
+import org.eclipse.ui.editors.text.FileDocumentProvider;
+import org.eclipse.ui.ide.FileStoreEditorInput;
+
+public abstract class HdlDocumentProvider extends FileDocumentProvider
+{
+	private Map<Object, IFileInfo> fileInfoMap = new HashMap<Object, IFileInfo>();
+	
+	protected IDocument createDocument(Object element) throws CoreException {
+		HdlDocument document = null;
+
+		if (element instanceof IFileEditorInput) {
+
+			// a file is in the current workspace
+			IFileEditorInput input = (IFileEditorInput) element;
+			IFile file = input.getFile();
+			IContainer parent = file.getParent();
+			
+			// find project
+			while (parent instanceof IFolder) {
+				parent = parent.getParent();
+			}
+
+			if (parent instanceof IProject) {
+				document = createHdlDocument((IProject) parent, file);
+				if (!setDocumentContent(document, input, getEncoding(element)))
+					document = null;
+			}
+
+		} else if (element instanceof IStorageEditorInput) {
+
+			// a file is in Repository Exploring Perspective (or others?)
+			IStorageEditorInput input = (IStorageEditorInput) element;
+			document = createHdlDocument(null, null);
+			InputStream stream = input.getStorage().getContents();
+			setDocumentContent(document, stream, getEncoding(element));
+
+		} else if (element instanceof IPathEditorInput) {
+
+			// Maybe this is not executed on Eclipse 3.3 or later
+			// Eclipse 3.2 executed for a file outside of workspace
+			IPathEditorInput input = (IPathEditorInput) element;
+			document = createHdlDocument(null, null);
+			FileInputStream contentStream = null;
+			try {
+				contentStream = new FileInputStream(input.getPath().toFile());
+				setDocumentContent(document, contentStream,
+						getEncoding(element));
+			} catch (FileNotFoundException e) {
+				e.printStackTrace();
+				document = null;
+			}
+
+		} else if (element instanceof FileStoreEditorInput) {
+
+			// a file that is not part of the current workspace
+			FileStoreEditorInput fileStoreEditorInput = (FileStoreEditorInput) element;
+			document = createHdlDocument(null, null);
+			FileInputStream contentStream = null;
+			URI uri = fileStoreEditorInput.getURI();
+			if (uri != null && uri.getScheme().equals("file")) {
+				String filename = uri.getPath();
+				try {
+					contentStream = new FileInputStream(filename);
+					setDocumentContent(document, contentStream,
+							getEncoding(element));
+					fileInfoMap.put(element, EFS.getStore(uri).fetchInfo());
+				} catch (FileNotFoundException e) {
+					e.printStackTrace();
+					document = null;
+				}
+			}
+
+		}
+		if (document != null) {
+			HdlPartitionScanner scanner = document.createPartitionScanner();
+			IDocumentPartitioner partitioner = new FastPartitioner(scanner,
+					HdlPartitionScanner.getContentTypes());
+			partitioner.connect(document);
+			document.setDocumentPartitioner(partitioner);
+		}
+		return document;
+	}
+	
+	abstract HdlDocument createHdlDocument(IProject project, IFile file);
+
+	public boolean isModifiable(Object element) {
+		if (element instanceof FileStoreEditorInput)
+			return !isReadOnly(element);
+		else
+			return super.isModifiable(element);
+	}
+
+	public boolean isReadOnly(Object element) {
+		if (element instanceof FileStoreEditorInput) {
+			IFileInfo info = fileInfoMap.get(element);
+			if (info == null)
+				return true;	// fail safe
+			return info.getAttribute(EFS.ATTRIBUTE_READ_ONLY);
+		} else
+			return super.isReadOnly(element);
+	}
+
+	protected void doSaveDocument(IProgressMonitor monitor, Object element,
+			IDocument document, boolean overwrite) throws CoreException {
+
+		if (element instanceof FileStoreEditorInput) {
+
+			// This is same as TextFileDocumentProvider#saveDocument
+			// I don't know exactly :-)
+			FileStoreEditorInput input = (FileStoreEditorInput) element;
+			IFileStore fileStore = EFS.getStore(input.getURI());
+			FileBuffers.getTextFileBufferManager().connectFileStore(fileStore,
+					monitor);
+			ITextFileBuffer buffer = FileBuffers.getTextFileBufferManager()
+					.getFileStoreTextFileBuffer(fileStore);
+			buffer.getDocument().set(document.get());
+			buffer.commit(monitor, true);
+			FileBuffers.getTextFileBufferManager().disconnectFileStore(
+					fileStore, monitor);
+		}
+		else
+		{
+			super.doSaveDocument(monitor, element, document, overwrite);
+		}
+	}
+
+	
+//	Don't use special encoding.
+//	Set encoding in Project Properties page
+//	protected String getPersistedEncoding(Object element)
+//	{
+//		String encoding = VerilogPlugin.getPreferenceString("Encoding");
+//		if (encoding == null || encoding.equals(""))
+//			return super.getPersistedEncoding(element);
+//		else
+//			return encoding;
+//	}
+
+}
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/document/VerilogDocument.java vdt/src/com/elphel/vdt/veditor/document/VerilogDocument.java
--- vdt-veditor/src/com/elphel/vdt/veditor/document/VerilogDocument.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/document/VerilogDocument.java	2016-06-24 10:29:40.816496628 -0600
@@ -1,96 +1,180 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.document;
-
-import java.util.Vector;
-
-import net.sourceforge.veditor.editor.scanner.HdlPartitionScanner;
-import net.sourceforge.veditor.editor.scanner.verilog.VerilogPartitionScanner;
-import net.sourceforge.veditor.parser.HdlParserException;
-import net.sourceforge.veditor.parser.IParser;
-import net.sourceforge.veditor.parser.OutlineDatabase;
-import net.sourceforge.veditor.parser.OutlineElement;
-import net.sourceforge.veditor.parser.ParserFactory;
-import net.sourceforge.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogModuleElement;
-
-import org.eclipse.core.resources.IFile;
-import org.eclipse.core.resources.IProject;
-import org.eclipse.jface.text.BadLocationException;
-
-public class VerilogDocument extends HdlDocument
-{
-	public VerilogDocument(IProject project, IFile file)
-	{
-		super(project, file);
-	}
-
-	public HdlPartitionScanner createPartitionScanner()
-	{
-		return new VerilogPartitionScanner();
-	}
-	
-	protected IParser createParser(String text)
-	{
-		return ParserFactory.createVerilogParser(text, getProject(), getFile());
-	}
-	
-	public Vector<OutlineElement> getDefinitionList(String name, int offset) {
-		Vector<OutlineElement> results=new Vector<OutlineElement>();
-		OutlineElement   currentElement;
-		
-		try {			
-			currentElement= getElementAt(offset,true);
-			//work backwards
-			while (currentElement!= null){
-				OutlineElement[] children=currentElement.getChildren();
-				for(int i=0;i<children.length;i++){
-					if(children[i].getName().equalsIgnoreCase(name)){
-						results.add(children[i]);
-					}
-				}
-				currentElement=currentElement.getParent();
-			}
-			//Global definitions
-			OutlineDatabase database=getOutlineDatabase();
-			for(OutlineElement element: database.findTopLevelElements(name, true)){
-				if (element instanceof VerilogModuleElement &&						
-						//do not add the same thing twice
-						results.contains(element)==false){
-						
-					results.add(element);
-				}
-			}
-			
-		} catch (BadLocationException e) {
-		}
-		catch (HdlParserException e){
-			e.printStackTrace();
-		}
-		
-		return results;
-	}
-	
-	/**
-	 * returns the context of the given offset
-	 * @param documentOffset
-	 * @return
-	 */
-	public int getContext(int documentOffset) throws BadLocationException {
-		String text = get(0, documentOffset);
-		IParser parser = ParserFactory.createVerilogParser(text, null, getFile());
-		try {
-			parser.parse();
-		} catch (HdlParserException e) {
-		}
-
-		return parser.getContext();
-	}
-}
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.document;
+
+import java.util.Vector;
+
+import com.elphel.vdt.veditor.VerilogPlugin;
+import com.elphel.vdt.veditor.editor.scanner.HdlPartitionScanner;
+import com.elphel.vdt.veditor.editor.scanner.verilog.VerilogPartitionScanner;
+import com.elphel.vdt.veditor.parser.HdlParserException;
+import com.elphel.vdt.veditor.parser.IParser;
+import com.elphel.vdt.veditor.parser.OutlineDatabase;
+import com.elphel.vdt.veditor.parser.OutlineElement;
+import com.elphel.vdt.veditor.parser.ParserFactory;
+import com.elphel.vdt.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogModuleElement;
+import com.elphel.vdt.veditor.preference.PreferenceStrings;
+
+import org.eclipse.core.resources.IFile;
+import org.eclipse.core.resources.IProject;
+import org.eclipse.jface.text.BadLocationException;
+
+public class VerilogDocument extends HdlDocument
+{
+//	public static final String identChars="$_0123456789abcdefghijklmnopqrstuvwABCDEFGHIJKLMNOPQRSTUVWXYZ";
+	public static final String identChars="$_0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"; // Why it did not include "xyz"?
+	public VerilogDocument(IProject project, IFile file)
+	{
+		super(project, file);
+	}
+
+	public HdlPartitionScanner createPartitionScanner()
+	{
+		return new VerilogPartitionScanner();
+	}
+	
+	protected IParser createParser(String text)
+	{
+		return ParserFactory.createVerilogParser(text, getProject(), getFile());
+	}
+	// Andrey
+	public String  getQualifiedElementName(String name, int offset) throws BadLocationException{
+		int line,col;
+		line=getLineOfOffset(offset);
+		col=offset-getLineOffset(line);
+		String lineStr=get(offset-col,col);
+		if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR)) {
+			System.out.println("Line to element="+lineStr);
+		}
+		if (!lineStr.endsWith(".")) return null;
+		int index;
+		String identOrDot=identChars+".";
+		for (index=lineStr.length()-1;(index>=0) && identOrDot.contains(lineStr.substring(index,index+1));index--);
+//		while (lineStr.substring(index+1).startsWith(".")) index++; port starts with .
+		//		String [] qn=(lineStr.substring(index+1)+name).split("\\.");
+		if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR)) {
+			System.out.println("Full identifier="+(lineStr.substring(index+1)+name));
+		}
+		return lineStr.substring(index+1)+name; //qn;
+	}
+		
+	
+	public Vector<OutlineElement> getDefinitionList(String name, int offset) {
+		Vector<OutlineElement> results=new Vector<OutlineElement>();
+		OutlineElement   currentElement;
+//		String [] hierName=null;
+		String  hierName=null;
+		try {
+			hierName=getQualifiedElementName(name,offset); // Andrey
+			currentElement= getElementAt(offset,true); // got top level - module HDL exc
+			boolean isPort=(hierName!=null) && hierName.startsWith(".");
+			if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR)) {
+				System.out.println("getDefinitionList("+name+","+offset+"): hierName="+hierName+
+            		" currentElement="+currentElement+" isPort="+isPort);
+			}
+			
+			if (hierName!=null){ // here currentElement - instance, hierName - ".port"
+				if (currentElement!=null) {
+					OutlineElement [] ee=currentElement.findHierarchicalChildren(hierName, getOutlineDatabase());
+					if (ee!=null) for (int i=0;i<ee.length;i++){
+						results.add(ee[i]);
+					}
+				}
+				if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR)) {
+					System.out.println("getDefinitionList() results.size() = "+results.size());
+				}
+				if (results.size() >0 ) return results;
+			}
+			//work backwards
+			// If hierName is null, port is not acceptable 05/29/2016
+			while (currentElement!= null){
+				OutlineElement[] children=currentElement.getChildren();
+				if ((currentElement.getType().split("#")[0].equals("port")) || // is instance port
+						(currentElement.getType().split("#")[0].equals("parameter") &&
+								(currentElement.getParent()!=null) && (currentElement.getParent().getType().split("#")[0].equals("instance"))) // is instance parameter
+						){ // should be just one child
+//				if(currentElement.getType().split("#")[0].equals("port") && isPort){ // should be just one child
+					if (children.length>0) {
+						if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR)) {
+							System.out.println("getDefinitionList() currentElement="+currentElement+"children[0]="+children[0]);
+						}
+						results.add(children[0]); // module port (parent - module definition)
+						return results;
+					}
+				}
+				for(int i=0;i<children.length;i++){
+//					if(children[i].getName().equalsIgnoreCase(name)){
+					if(children[i].getName().equals(name)){ // Why was it "equalsIgnoreCase()" ?
+						boolean isParentInstance = (children[i].getParent()!=null) && children[i].getParent().getType().split("#")[0].equals("instance"); 
+//						if (isPort || !children[i].getType().split("#")[0].equals("port")) {
+						if ((isPort && isParentInstance) || (!isPort && !isParentInstance)) {
+							if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR)) {
+								System.out.println("getDefinitionList() children["+i+"]="+children[i]+" :"+children[i].getType());
+							}
+							results.add(children[i]);
+						}
+					}
+				}
+				currentElement=currentElement.getParent();
+			}
+			// Exit here if already not empty?
+			//Global definitions
+			OutlineDatabase database=getOutlineDatabase();
+			for(OutlineElement element: database.findTopLevelElements(name, true)){
+				if (element instanceof VerilogModuleElement &&						
+						//do not add the same thing twice
+						results.contains(element)==false){
+					if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR)) {
+						System.out.println("getDefinitionList() element="+element);
+					}
+					results.add(element);
+				}
+			}
+			
+		} catch (BadLocationException e) {
+			System.out.println("Got BadLocationException="+e+" in getDefinitionList("+name+","+offset+")");
+		}
+		catch (HdlParserException e){
+			System.out.println("Failed to getDefinitionList(), e="+e);
+			return null;
+//			e.printStackTrace();
+		}
+		
+		return results;
+	}
+	
+	/**
+	 * returns the context of the given offset
+	 * @param documentOffset
+	 * @return
+	 */
+	public int getContext(int documentOffset) throws BadLocationException {
+		String text = get(0, documentOffset);
+		IParser parser = ParserFactory.createVerilogParser(text, null, getFile());
+		try {
+			parser.parse();
+		} catch (HdlParserException e) {
+		}
+
+		return parser.getContext();
+	}
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/document/VerilogDocumentProvider.java vdt/src/com/elphel/vdt/veditor/document/VerilogDocumentProvider.java
--- vdt-veditor/src/com/elphel/vdt/veditor/document/VerilogDocumentProvider.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/document/VerilogDocumentProvider.java	2016-06-24 10:29:40.816496628 -0600
@@ -1,23 +1,34 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.document;
-
-import org.eclipse.core.resources.IFile;
-import org.eclipse.core.resources.IProject;
-
-public class VerilogDocumentProvider extends HdlDocumentProvider
-{
-	public HdlDocument createHdlDocument(IProject project, IFile file)
-	{
-		return new VerilogDocument(project, file);
-	}
-}
-
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.document;
+
+import org.eclipse.core.resources.IFile;
+import org.eclipse.core.resources.IProject;
+
+public class VerilogDocumentProvider extends HdlDocumentProvider
+{
+	public HdlDocument createHdlDocument(IProject project, IFile file)
+	{
+		return new VerilogDocument(project, file);
+	}
+}
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/document/VhdlDocument.java vdt/src/com/elphel/vdt/veditor/document/VhdlDocument.java
--- vdt-veditor/src/com/elphel/vdt/veditor/document/VhdlDocument.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/document/VhdlDocument.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,127 +1,138 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.document;
-
-import java.util.Vector;
-
-import net.sourceforge.veditor.editor.scanner.HdlPartitionScanner;
-import net.sourceforge.veditor.editor.scanner.vhdl.VhdlPartitionScanner;
-import net.sourceforge.veditor.parser.HdlParserException;
-import net.sourceforge.veditor.parser.IParser;
-import net.sourceforge.veditor.parser.OutlineContainer;
-import net.sourceforge.veditor.parser.OutlineDatabase;
-import net.sourceforge.veditor.parser.OutlineElement;
-import net.sourceforge.veditor.parser.ParserFactory;
-import net.sourceforge.veditor.parser.vhdl.VhdlOutlineElementFactory.ArchitectureElement;
-import net.sourceforge.veditor.parser.vhdl.VhdlOutlineElementFactory.EntityDeclElement;
-import net.sourceforge.veditor.parser.vhdl.VhdlOutlineElementFactory.PackageDeclElement;
-
-import org.eclipse.core.resources.IFile;
-import org.eclipse.core.resources.IProject;
-import org.eclipse.jface.text.BadLocationException;
-
-public class VhdlDocument extends HdlDocument
-{
-	public final static int VHDL_GLOBAL_CONTEXT=1;
-	
-	public VhdlDocument(IProject project, IFile file)
-	{
-		super(project, file);
-	}
-
-	public HdlPartitionScanner createPartitionScanner()
-	{
-		return new VhdlPartitionScanner();
-	}
-	
-	protected IParser createParser(String text)
-	{
-		return ParserFactory.createVhdlParser(text, getProject(), getFile());
-	}
-
-	@Override
-	public Vector<OutlineElement> getDefinitionList(String name, int offset) {
-		Vector<OutlineElement> results=new Vector<OutlineElement>();		
-		OutlineElement   currentElement;
-		String entityName=null;
-		
-		try {
-			currentElement=getElementAt(offset,true);
-			//work backwards
-			while (currentElement!= null){
-				OutlineElement[] children=currentElement.getChildren();
-				for(int i=0;i<children.length;i++){
-					if(children[i].getName().equalsIgnoreCase(name)){
-						results.add(children[i]);
-					}
-				}
-				if (currentElement instanceof ArchitectureElement) {
-					ArchitectureElement arch = (ArchitectureElement) currentElement;
-					entityName=arch.GetEntityName();
-					
-				}				
-				currentElement=currentElement.getParent();
-			}			
-			
-		} catch (BadLocationException e) {
-		} catch (HdlParserException e) {
-			e.printStackTrace();			
-		}
-
-		if (entityName != null){
-			OutlineDatabase database = getOutlineDatabase();
-			OutlineContainer outline = database.getOutlineContainer(getFile());
-			Object[] children= outline.getTopLevelElements();
-			
-			for (int i=0;i<children.length;i++){
-				if (children[i] instanceof EntityDeclElement) {
-					EntityDeclElement entityDecl = (EntityDeclElement) children[i];			
-					//if we find an entity declaration, add the ports and generics
-					if (entityDecl.getName().equalsIgnoreCase(entityName)) {				
-						//get the entity's children
-						OutlineElement[] enitityChildren=entityDecl.getChildren();
-						for(int entChildIdx=0;entChildIdx<enitityChildren.length;entChildIdx++){
-							if(	enitityChildren[entChildIdx].getName().equalsIgnoreCase(name)){
-								results.add(enitityChildren[entChildIdx]);
-							}
-						}				
-					}
-				}
-			}
-		}
-		
-		{
-			OutlineDatabase database = getOutlineDatabase();
-			PackageDeclElement packs[] = database.findTopLevelPackages();
-			for (int p=0;p<packs.length;p++){
-				PackageDeclElement packDecl = packs[p];
-				OutlineElement[] enitityChildren=packDecl.getChildren();
-				for(int entChildIdx=0;entChildIdx<enitityChildren.length;entChildIdx++){
-					if(	enitityChildren[entChildIdx].getName().equalsIgnoreCase(name)){
-						results.add(enitityChildren[entChildIdx]);
-					}
-				}
-			}
-		}
-		
-		return results;
-	}
-	/**
-	 * returns the context of the given offset
-	 * @param documentOffset
-	 * @return
-	 */
-	public int getContext(int documentOffset) throws BadLocationException{
-		return VHDL_GLOBAL_CONTEXT;
-	}
-
-
-}
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.document;
+
+import java.util.Vector;
+
+import com.elphel.vdt.veditor.editor.scanner.HdlPartitionScanner;
+import com.elphel.vdt.veditor.editor.scanner.vhdl.VhdlPartitionScanner;
+import com.elphel.vdt.veditor.parser.HdlParserException;
+import com.elphel.vdt.veditor.parser.IParser;
+import com.elphel.vdt.veditor.parser.OutlineContainer;
+import com.elphel.vdt.veditor.parser.OutlineDatabase;
+import com.elphel.vdt.veditor.parser.OutlineElement;
+import com.elphel.vdt.veditor.parser.ParserFactory;
+import com.elphel.vdt.veditor.parser.vhdl.VhdlOutlineElementFactory.ArchitectureElement;
+import com.elphel.vdt.veditor.parser.vhdl.VhdlOutlineElementFactory.EntityDeclElement;
+import com.elphel.vdt.veditor.parser.vhdl.VhdlOutlineElementFactory.PackageDeclElement;
+
+import org.eclipse.core.resources.IFile;
+import org.eclipse.core.resources.IProject;
+import org.eclipse.jface.text.BadLocationException;
+
+public class VhdlDocument extends HdlDocument
+{
+	public final static int VHDL_GLOBAL_CONTEXT=1;
+	
+	public VhdlDocument(IProject project, IFile file)
+	{
+		super(project, file);
+	}
+
+	public HdlPartitionScanner createPartitionScanner()
+	{
+		return new VhdlPartitionScanner();
+	}
+	
+	protected IParser createParser(String text)
+	{
+		return ParserFactory.createVhdlParser(text, getProject(), getFile());
+	}
+
+	@Override
+	public Vector<OutlineElement> getDefinitionList(String name, int offset) {
+		Vector<OutlineElement> results=new Vector<OutlineElement>();		
+		OutlineElement   currentElement;
+		String entityName=null;
+		
+		try {
+			currentElement=getElementAt(offset,true);
+			//work backwards
+			while (currentElement!= null){
+				OutlineElement[] children=currentElement.getChildren();
+				for(int i=0;i<children.length;i++){
+					if(children[i].getName().equalsIgnoreCase(name)){
+						results.add(children[i]);
+					}
+				}
+				if (currentElement instanceof ArchitectureElement) {
+					ArchitectureElement arch = (ArchitectureElement) currentElement;
+					entityName=arch.GetEntityName();
+					
+				}				
+				currentElement=currentElement.getParent();
+			}			
+			
+		} catch (BadLocationException e) {
+		} catch (HdlParserException e) {
+			e.printStackTrace();			
+		}
+
+		if (entityName != null){
+			OutlineDatabase database = getOutlineDatabase();
+			OutlineContainer outline = database.getOutlineContainer(getFile());
+			Object[] children= outline.getTopLevelElements();
+			
+			for (int i=0;i<children.length;i++){
+				if (children[i] instanceof EntityDeclElement) {
+					EntityDeclElement entityDecl = (EntityDeclElement) children[i];			
+					//if we find an entity declaration, add the ports and generics
+					if (entityDecl.getName().equalsIgnoreCase(entityName)) {				
+						//get the entity's children
+						OutlineElement[] enitityChildren=entityDecl.getChildren();
+						for(int entChildIdx=0;entChildIdx<enitityChildren.length;entChildIdx++){
+							if(	enitityChildren[entChildIdx].getName().equalsIgnoreCase(name)){
+								results.add(enitityChildren[entChildIdx]);
+							}
+						}				
+					}
+				}
+			}
+		}
+		
+		{
+			OutlineDatabase database = getOutlineDatabase();
+			PackageDeclElement packs[] = database.findTopLevelPackages();
+			for (int p=0;p<packs.length;p++){
+				PackageDeclElement packDecl = packs[p];
+				OutlineElement[] enitityChildren=packDecl.getChildren();
+				for(int entChildIdx=0;entChildIdx<enitityChildren.length;entChildIdx++){
+					if(	enitityChildren[entChildIdx].getName().equalsIgnoreCase(name)){
+						results.add(enitityChildren[entChildIdx]);
+					}
+				}
+			}
+		}
+		
+		return results;
+	}
+	/**
+	 * returns the context of the given offset
+	 * @param documentOffset
+	 * @return
+	 */
+	public int getContext(int documentOffset) throws BadLocationException{
+		return VHDL_GLOBAL_CONTEXT;
+	}
+
+
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/document/VhdlDocumentProvider.java vdt/src/com/elphel/vdt/veditor/document/VhdlDocumentProvider.java
--- vdt-veditor/src/com/elphel/vdt/veditor/document/VhdlDocumentProvider.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/document/VhdlDocumentProvider.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,22 +1,33 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.document;
-
-import org.eclipse.core.resources.IFile;
-import org.eclipse.core.resources.IProject;
-
-public class VhdlDocumentProvider extends HdlDocumentProvider
-{
-	public HdlDocument createHdlDocument(IProject project, IFile file)
-	{
-		return new VhdlDocument(project, file);
-	}
-}
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.document;
+
+import org.eclipse.core.resources.IFile;
+import org.eclipse.core.resources.IProject;
+
+public class VhdlDocumentProvider extends HdlDocumentProvider
+{
+	public HdlDocument createHdlDocument(IProject project, IFile file)
+	{
+		return new VhdlDocument(project, file);
+	}
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/editor/ColorManager.java vdt/src/com/elphel/vdt/veditor/editor/ColorManager.java
--- vdt-veditor/src/com/elphel/vdt/veditor/editor/ColorManager.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/editor/ColorManager.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,44 +1,55 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-
-package net.sourceforge.veditor.editor;
-
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.Map;
-
-import org.eclipse.swt.graphics.Color;
-import org.eclipse.swt.graphics.RGB;
-import org.eclipse.swt.widgets.Display;
-
-public class ColorManager
-{
-	private Map<RGB,Color> colorMap = new HashMap<RGB,Color>(10);
-
-	public void dispose()
-	{
-		Iterator<Color> e = colorMap.values().iterator();
-		while (e.hasNext())
-		{
-			((Color)e.next()).dispose();
-		}
-	}
-	public Color getColor(RGB rgb)
-	{
-		Color color = (Color)colorMap.get(rgb);
-		if (color == null)
-		{
-			color = new Color(Display.getCurrent(), rgb);
-			colorMap.put(rgb, color);
-		}
-		return color;
-	}
-}
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+
+package com.elphel.vdt.veditor.editor;
+
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+
+import org.eclipse.swt.graphics.Color;
+import org.eclipse.swt.graphics.RGB;
+import org.eclipse.swt.widgets.Display;
+
+public class ColorManager
+{
+	private Map<RGB,Color> colorMap = new HashMap<RGB,Color>(10);
+
+	public void dispose()
+	{
+		Iterator<Color> e = colorMap.values().iterator();
+		while (e.hasNext())
+		{
+			((Color)e.next()).dispose();
+		}
+	}
+	public Color getColor(RGB rgb)
+	{
+		Color color = (Color)colorMap.get(rgb);
+		if (color == null)
+		{
+			color = new Color(Display.getCurrent(), rgb);
+			colorMap.put(rgb, color);
+		}
+		return color;
+	}
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/editor/completionProposals/CompletionProposal.java vdt/src/com/elphel/vdt/veditor/editor/completionProposals/CompletionProposal.java
--- vdt-veditor/src/com/elphel/vdt/veditor/editor/completionProposals/CompletionProposal.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/editor/completionProposals/CompletionProposal.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,77 +1,88 @@
-/*******************************************************************************
- * Copyright (c) 2007 Ali Ghorashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    Ali Ghorashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.editor.completionProposals;
-
-
-import org.eclipse.jface.text.BadLocationException;
-import org.eclipse.jface.text.IDocument;
-import org.eclipse.jface.text.contentassist.IContextInformation;
-import org.eclipse.swt.graphics.Image;
-import org.eclipse.swt.graphics.Point;
-
-public class CompletionProposal implements IComparableCompletionProposal
-{
-	private String replace;
-	private int offset, length;
-
-	public CompletionProposal(String replace, int offset, int length)
-	{
-		this.replace = replace;
-		this.offset = offset;
-		this.length = length;
-	}
-	public void apply(IDocument document)
-	{
-		try
-		{
-			document.replace(offset - length, length, replace.toString());
-		}
-		catch (BadLocationException e)
-		{
-		}
-	}
-	public Point getSelection(IDocument document)
-	{
-		return null;
-	}
-	public String getAdditionalProposalInfo()
-	{
-		return null;
-	}
-	public Image getImage()
-	{
-		return null;
-	}
-	public IContextInformation getContextInformation()
-	{
-		return null;
-	}
-	public String toString()
-	{
-		return getDisplayString();
-	}
-	public int compareTo(Object arg)
-	{
-		return toString().compareTo(arg.toString());
-	}
-	public String getDisplayString()
-	{
-		return replace;
-	}
-	public int getLength()
-	{
-		return length;
-	}
-	public int getOffset()
-	{
-		return offset;
-	}
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2007 Ali Ghorashi and others.
+ *
+ * Contributors:
+ *    Ali Ghorashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.editor.completionProposals;
+
+
+import org.eclipse.jface.text.BadLocationException;
+import org.eclipse.jface.text.IDocument;
+import org.eclipse.jface.text.contentassist.IContextInformation;
+import org.eclipse.swt.graphics.Image;
+import org.eclipse.swt.graphics.Point;
+
+public class CompletionProposal implements IComparableCompletionProposal
+{
+	private String replace;
+	private int offset, length;
+
+	public CompletionProposal(String replace, int offset, int length)
+	{
+		this.replace = replace;
+		this.offset = offset;
+		this.length = length;
+	}
+	public void apply(IDocument document)
+	{
+		try
+		{
+			document.replace(offset - length, length, replace.toString());
+		}
+		catch (BadLocationException e)
+		{
+		}
+	}
+	public Point getSelection(IDocument document)
+	{
+		return null;
+	}
+	public String getAdditionalProposalInfo()
+	{
+		return null;
+	}
+	public Image getImage()
+	{
+		return null;
+	}
+	public IContextInformation getContextInformation()
+	{
+		return null;
+	}
+	public String toString()
+	{
+		return getDisplayString();
+	}
+	public int compareTo(Object arg)
+	{
+		return toString().compareTo(arg.toString());
+	}
+	public String getDisplayString()
+	{
+		return replace;
+	}
+	public int getLength()
+	{
+		return length;
+	}
+	public int getOffset()
+	{
+		return offset;
+	}
 }
\ No newline at end of file
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/editor/completionProposals/DynamicProposalProvider.java vdt/src/com/elphel/vdt/veditor/editor/completionProposals/DynamicProposalProvider.java
--- vdt-veditor/src/com/elphel/vdt/veditor/editor/completionProposals/DynamicProposalProvider.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/editor/completionProposals/DynamicProposalProvider.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,83 +1,83 @@
-package net.sourceforge.veditor.editor.completionProposals;
-
-import net.sourceforge.veditor.VerilogPlugin;
-import net.sourceforge.veditor.document.HdlDocument;
-import net.sourceforge.veditor.parser.OutlineElement;
-import net.sourceforge.veditor.templates.TemplateWithIndent;
-import net.sourceforge.veditor.templates.VhdlGlobalContext;
-
-import org.eclipse.jface.text.Region;
-import org.eclipse.jface.text.templates.DocumentTemplateContext;
-import org.eclipse.jface.text.templates.Template;
-import org.eclipse.swt.graphics.Image;
-
-public abstract class DynamicProposalProvider {
-	HdlDocument m_Doc;
-	OutlineElement m_Element;
-	int m_Offset;
-	int m_Length;
-	
-	/**
-	 * Constructor
-	 * @param doc
-	 * @param element
-	 * @param offset
-	 * @param length
-	 */
-	protected DynamicProposalProvider(HdlDocument doc,
-			OutlineElement element, int offset, int length){
-		m_Doc=doc;
-		m_Element=element;
-		//move the offset to the beginning of of the replaced string 
-		m_Offset=offset-length;
-		//length of the string being replace
-		m_Length=length;
-	}
-	
-	/**
-	 * This function creates a new proposal
-	 * @return
-	 */
-	public HdlTemplateProposal createProposal() {
-		Region region = null;
-		Image image;
-		int relevance = 0;
-		TemplateWithIndent templateX = null;
-		DocumentTemplateContext context = null;
-		Template template = null;
-
-		image = VerilogPlugin.getPlugin().getImage(m_Element.GetImageName());
-		context = new DocumentTemplateContext(new VhdlGlobalContext(), m_Doc,
-				m_Offset, m_Length);
-		//set the region to cover the text begin replaced
-		region = new Region(m_Offset, m_Length);
-
-		template = new Template(
-				m_Element.getShortName(), 
-			    getDescription(),
-			    VhdlGlobalContext.CONTEXT_TYPE,
-				getString(),
-				false);
-		
-		templateX = new TemplateWithIndent(template, m_Doc.getIndentString(m_Offset));
-
-		return new HdlTemplateProposal(
-				templateX, 
-				context, 
-				region, 
-				image,
-				relevance);
-
-	}
-	/**
-	 * Returns a string used for completing this proposal
-	 * @return
-	 */
-	protected abstract String getString();
-	/**
-	 * Returns a string describing this proposal
-	 * @return
-	 */
-	protected abstract String getDescription();
-	
-}
+package com.elphel.vdt.veditor.editor.completionProposals;
+
+import com.elphel.vdt.veditor.VerilogPlugin;
+import com.elphel.vdt.veditor.document.HdlDocument;
+import com.elphel.vdt.veditor.parser.OutlineElement;
+import com.elphel.vdt.veditor.templates.TemplateWithIndent;
+import com.elphel.vdt.veditor.templates.VhdlGlobalContext;
+
+import org.eclipse.jface.text.Region;
+import org.eclipse.jface.text.templates.DocumentTemplateContext;
+import org.eclipse.jface.text.templates.Template;
+import org.eclipse.swt.graphics.Image;
+
+public abstract class DynamicProposalProvider {
+	HdlDocument m_Doc;
+	OutlineElement m_Element;
+	int m_Offset;
+	int m_Length;
+	
+	/**
+	 * Constructor
+	 * @param doc
+	 * @param element
+	 * @param offset
+	 * @param length
+	 */
+	protected DynamicProposalProvider(HdlDocument doc,
+			OutlineElement element, int offset, int length){
+		m_Doc=doc;
+		m_Element=element;
+		//move the offset to the beginning of of the replaced string 
+		m_Offset=offset-length;
+		//length of the string being replace
+		m_Length=length;
+	}
+	
+	/**
+	 * This function creates a new proposal
+	 * @return
+	 */
+	public HdlTemplateProposal createProposal() {
+		Region region = null;
+		Image image;
+		int relevance = 0;
+		TemplateWithIndent templateX = null;
+		DocumentTemplateContext context = null;
+		Template template = null;
+
+		image = VerilogPlugin.getPlugin().getImage(m_Element.GetImageName());
+		context = new DocumentTemplateContext(new VhdlGlobalContext(), m_Doc,
+				m_Offset, m_Length);
+		//set the region to cover the text begin replaced
+		region = new Region(m_Offset, m_Length);
+
+		template = new Template(
+				m_Element.getShortName(), 
+			    getDescription(),
+			    VhdlGlobalContext.CONTEXT_TYPE,
+				getString(),
+				false);
+		
+		templateX = new TemplateWithIndent(template, m_Doc.getIndentString(m_Offset));
+
+		return new HdlTemplateProposal(
+				templateX, 
+				context, 
+				region, 
+				image,
+				relevance);
+
+	}
+	/**
+	 * Returns a string used for completing this proposal
+	 * @return
+	 */
+	protected abstract String getString();
+	/**
+	 * Returns a string describing this proposal
+	 * @return
+	 */
+	protected abstract String getDescription();
+	
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/editor/completionProposals/HdlTemplateProposal.java vdt/src/com/elphel/vdt/veditor/editor/completionProposals/HdlTemplateProposal.java
--- vdt-veditor/src/com/elphel/vdt/veditor/editor/completionProposals/HdlTemplateProposal.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/editor/completionProposals/HdlTemplateProposal.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,47 +1,58 @@
-/*******************************************************************************
- * Copyright (c) 2007 Ali Ghorashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    Ali Ghorashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.editor.completionProposals;
-
-import org.eclipse.jface.text.IRegion;
-import org.eclipse.jface.text.templates.Template;
-import org.eclipse.jface.text.templates.TemplateContext;
-import org.eclipse.jface.text.templates.TemplateProposal;
-import org.eclipse.swt.graphics.Image;
-import net.sourceforge.veditor.editor.completionProposals.IComparableCompletionProposal;
-
-/**
- * This class extends the Template proposal class in order to add a compareTo function
- *
- */
-public class HdlTemplateProposal extends TemplateProposal implements IComparableCompletionProposal
-{
-	protected final String templateName;
-	
-	public int compareTo(Object object) {
-		int results=0;
-		if (object instanceof HdlTemplateProposal) {
-			HdlTemplateProposal operand = (HdlTemplateProposal) object;
-			results=getRelevance()-operand.getRelevance();		
-			
-			//if the two templates are equal, then compare names
-			if(results == 0)
-			{
-				results=templateName.compareTo(operand.templateName);
-			}			
-		}			
-		
-		return results;
-	}
-	public HdlTemplateProposal(Template template, TemplateContext context, IRegion region, Image image, int relevance){
-		super(template,context,region,image,relevance);
-		templateName=template.getName();			
-	}
-}
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2007 Ali Ghorashi and others.
+ *
+ * Contributors:
+ *    Ali Ghorashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.editor.completionProposals;
+
+import org.eclipse.jface.text.IRegion;
+import org.eclipse.jface.text.templates.Template;
+import org.eclipse.jface.text.templates.TemplateContext;
+import org.eclipse.jface.text.templates.TemplateProposal;
+import org.eclipse.swt.graphics.Image;
+import com.elphel.vdt.veditor.editor.completionProposals.IComparableCompletionProposal;
+
+/**
+ * This class extends the Template proposal class in order to add a compareTo function
+ *
+ */
+public class HdlTemplateProposal extends TemplateProposal implements IComparableCompletionProposal
+{
+	protected final String templateName;
+	
+	public int compareTo(Object object) {
+		int results=0;
+		if (object instanceof HdlTemplateProposal) {
+			HdlTemplateProposal operand = (HdlTemplateProposal) object;
+			results=getRelevance()-operand.getRelevance();		
+			
+			//if the two templates are equal, then compare names
+			if(results == 0)
+			{
+				results=templateName.compareTo(operand.templateName);
+			}			
+		}			
+		
+		return results;
+	}
+	public HdlTemplateProposal(Template template, TemplateContext context, IRegion region, Image image, int relevance){
+		super(template,context,region,image,relevance);
+		templateName=template.getName();			
+	}
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/editor/completionProposals/IComparableCompletionProposal.java vdt/src/com/elphel/vdt/veditor/editor/completionProposals/IComparableCompletionProposal.java
--- vdt-veditor/src/com/elphel/vdt/veditor/editor/completionProposals/IComparableCompletionProposal.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/editor/completionProposals/IComparableCompletionProposal.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,18 +1,29 @@
-/*******************************************************************************
- * Copyright (c) 2007 Ali Ghorashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    Ali Ghorashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.editor.completionProposals;
-
-import org.eclipse.jface.text.contentassist.ICompletionProposal;
-
-/** an interface that is both a CompletionPropsal and a Comparable */
-public interface IComparableCompletionProposal extends ICompletionProposal,Comparable<Object>{
-	
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2007 Ali Ghorashi and others.
+ *
+ * Contributors:
+ *    Ali Ghorashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.editor.completionProposals;
+
+import org.eclipse.jface.text.contentassist.ICompletionProposal;
+
+/** an interface that is both a CompletionPropsal and a Comparable */
+public interface IComparableCompletionProposal extends ICompletionProposal,Comparable<Object>{
+	
 };
\ No newline at end of file
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/editor/completionProposals/InstanceCompletionProposal.java vdt/src/com/elphel/vdt/veditor/editor/completionProposals/InstanceCompletionProposal.java
--- vdt-veditor/src/com/elphel/vdt/veditor/editor/completionProposals/InstanceCompletionProposal.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/editor/completionProposals/InstanceCompletionProposal.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,61 +1,72 @@
-/*******************************************************************************
- * Copyright (c) 2007 Ali Ghorashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    Ali Ghorashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.editor.completionProposals;
-
-import net.sourceforge.veditor.document.HdlDocument;
-import net.sourceforge.veditor.editor.completionProposals.CompletionProposal;
-
-import org.eclipse.core.resources.IProject;
-import org.eclipse.jface.text.IDocument;
-import org.eclipse.jface.text.TextUtilities;
-
-public abstract  class InstanceCompletionProposal extends	CompletionProposal
-{
-	protected IProject proj;
-	protected String name;
-	protected String indentString;
-	protected String eol;
-	
-	/**
-	 * Class constructor 
-	 * @param doc Document where the proposal is being made
-	 * @param name Name of the proposal
-	 * @param offset Offset of replace string from the beginning of the document
-	 * @param length Length of the replace string
-	 */
-	public InstanceCompletionProposal(
-		HdlDocument doc,
-		String name,
-		int offset,
-		int length)
-	{
-		super("", offset, length);
-		this.proj = doc.getProject();
-		this.name = name;
-		this.indentString = doc.getIndentString(offset);
-		this.eol = TextUtilities.getDefaultLineDelimiter(doc);
-	}
-
-	/* (non-Javadoc)
-	 * @see net.sourceforge.veditor.editor.HdlCompletionProcessor.CompletionProposal#apply(org.eclipse.jface.text.IDocument)
-	 */
-	abstract public void apply(IDocument document);
-	
-	/**
-	 * @return The string used to display this proposal
-	 */
-	public String getDisplayString(){ return name; }
-	/**
-	 * @return The string containing the space characters where the proposal is being made
-	 * All inserted lines should start with this string
-	 */
-	public String getIndentString(){ return indentString; }
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2007 Ali Ghorashi and others.
+ *
+ * Contributors:
+ *    Ali Ghorashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.editor.completionProposals;
+
+import com.elphel.vdt.veditor.document.HdlDocument;
+import com.elphel.vdt.veditor.editor.completionProposals.CompletionProposal;
+
+import org.eclipse.core.resources.IProject;
+import org.eclipse.jface.text.IDocument;
+import org.eclipse.jface.text.TextUtilities;
+
+public abstract  class InstanceCompletionProposal extends	CompletionProposal
+{
+	protected IProject proj;
+	protected String name;
+	protected String indentString;
+	protected String eol;
+	
+	/**
+	 * Class constructor 
+	 * @param doc Document where the proposal is being made
+	 * @param name Name of the proposal
+	 * @param offset Offset of replace string from the beginning of the document
+	 * @param length Length of the replace string
+	 */
+	public InstanceCompletionProposal(
+		HdlDocument doc,
+		String name,
+		int offset,
+		int length)
+	{
+		super("", offset, length);
+		this.proj = doc.getProject();
+		this.name = name;
+		this.indentString = doc.getIndentString(offset);
+		this.eol = TextUtilities.getDefaultLineDelimiter(doc);
+	}
+
+	/* (non-Javadoc)
+	 * @see com.elphel.vdt.veditor.editor.HdlCompletionProcessor.CompletionProposal#apply(org.eclipse.jface.text.IDocument)
+	 */
+	abstract public void apply(IDocument document);
+	
+	/**
+	 * @return The string used to display this proposal
+	 */
+	public String getDisplayString(){ return name; }
+	/**
+	 * @return The string containing the space characters where the proposal is being made
+	 * All inserted lines should start with this string
+	 */
+	public String getIndentString(){ return indentString; }
 }
\ No newline at end of file
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/editor/completionProposals/TemplateCompletionProposal.java vdt/src/com/elphel/vdt/veditor/editor/completionProposals/TemplateCompletionProposal.java
--- vdt-veditor/src/com/elphel/vdt/veditor/editor/completionProposals/TemplateCompletionProposal.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/editor/completionProposals/TemplateCompletionProposal.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,42 +1,53 @@
-/*******************************************************************************
- * Copyright (c) 2007 Ali Ghorashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    Ali Ghorashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.editor.completionProposals;
-
-
-import org.eclipse.jface.text.IDocument;
-import org.eclipse.swt.graphics.Point;
-
-public class TemplateCompletionProposal extends CompletionProposal
-{
-	private int cursor;
-	private String display;
-
-	public TemplateCompletionProposal(
-		String replace,
-		int offset,
-		int length,
-		int cursor,
-		String display)
-	{
-		super(replace, offset, length);
-		this.cursor = cursor;
-		this.display = display;
-	}
-	public String getDisplayString()
-	{
-		return display;
-	}
-	public Point getSelection(IDocument document)
-	{
-		return new Point(getOffset() - getLength() + cursor, 0);
-	}
-}
-
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2007 Ali Ghorashi and others.
+ *
+ * Contributors:
+ *    Ali Ghorashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.editor.completionProposals;
+
+
+import org.eclipse.jface.text.IDocument;
+import org.eclipse.swt.graphics.Point;
+
+public class TemplateCompletionProposal extends CompletionProposal
+{
+	private int cursor;
+	private String display;
+
+	public TemplateCompletionProposal(
+		String replace,
+		int offset,
+		int length,
+		int cursor,
+		String display)
+	{
+		super(replace, offset, length);
+		this.cursor = cursor;
+		this.display = display;
+	}
+	public String getDisplayString()
+	{
+		return display;
+	}
+	public Point getSelection(IDocument document)
+	{
+		return new Point(getOffset() - getLength() + cursor, 0);
+	}
+}
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/editor/completionProposals/VerilogCompletionProposal.java vdt/src/com/elphel/vdt/veditor/editor/completionProposals/VerilogCompletionProposal.java
--- vdt-veditor/src/com/elphel/vdt/veditor/editor/completionProposals/VerilogCompletionProposal.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/editor/completionProposals/VerilogCompletionProposal.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,41 +1,52 @@
-/*******************************************************************************
- * Copyright (c) 2007 Ali Ghorashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    Ali Ghorashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.editor.completionProposals;
-
-import net.sourceforge.veditor.VerilogPlugin;
-import net.sourceforge.veditor.parser.OutlineElement;
-import net.sourceforge.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogOutlineElement;
-
-import org.eclipse.swt.graphics.Image;
-
-/**
- * Simple completion proposal with an image
- * @author ali
- *
- */
-public class VerilogCompletionProposal extends CompletionProposal{
-	OutlineElement m_Element;
-	public VerilogCompletionProposal(OutlineElement element, int offset, int length) {
-		super(element.getName(), offset, length);		
-		m_Element=element;
-	}
-	/**
-	 * Gets the element's image
-	 */
-	public Image getImage()
-	{
-		if (m_Element instanceof VerilogOutlineElement) {
-			VerilogOutlineElement e = (VerilogOutlineElement) m_Element;
-			return VerilogPlugin.getPlugin().getImage(e.GetImageName());
-		}
-		return null;
-	}
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2007 Ali Ghorashi and others.
+ *
+ * Contributors:
+ *    Ali Ghorashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.editor.completionProposals;
+
+import com.elphel.vdt.veditor.VerilogPlugin;
+import com.elphel.vdt.veditor.parser.OutlineElement;
+import com.elphel.vdt.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogOutlineElement;
+
+import org.eclipse.swt.graphics.Image;
+
+/**
+ * Simple completion proposal with an image
+ * @author ali
+ *
+ */
+public class VerilogCompletionProposal extends CompletionProposal{
+	OutlineElement m_Element;
+	public VerilogCompletionProposal(OutlineElement element, int offset, int length) {
+		super(element.getName(), offset, length);		
+		m_Element=element;
+	}
+	/**
+	 * Gets the element's image
+	 */
+	public Image getImage()
+	{
+		if (m_Element instanceof VerilogOutlineElement) {
+			VerilogOutlineElement e = (VerilogOutlineElement) m_Element;
+			return VerilogPlugin.getPlugin().getImage(e.GetImageName());
+		}
+		return null;
+	}
 }
\ No newline at end of file
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/editor/completionProposals/VerilogInstanceCompletionProposal.java vdt/src/com/elphel/vdt/veditor/editor/completionProposals/VerilogInstanceCompletionProposal.java
--- vdt-veditor/src/com/elphel/vdt/veditor/editor/completionProposals/VerilogInstanceCompletionProposal.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/editor/completionProposals/VerilogInstanceCompletionProposal.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,125 +1,136 @@
-/*******************************************************************************
- * Copyright (c) 2007 Ali Ghorashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    Ali Ghorashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.editor.completionProposals;
-
-import java.util.ArrayList;
-
-import net.sourceforge.veditor.VerilogPlugin;
-import net.sourceforge.veditor.document.HdlDocument;
-import net.sourceforge.veditor.parser.OutlineElement;
-import net.sourceforge.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogModuleElement;
-import net.sourceforge.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogOutlineElement;
-import net.sourceforge.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogParameterElement;
-import net.sourceforge.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogPortElement;
-
-import org.eclipse.jface.text.BadLocationException;
-import org.eclipse.jface.text.IDocument;
-import org.eclipse.swt.graphics.Image;
-
-public class VerilogInstanceCompletionProposal extends
-InstanceCompletionProposal 
-{
-	protected OutlineElement m_Element;
-	public VerilogInstanceCompletionProposal(
-		HdlDocument doc,
-		OutlineElement element,
-		int offset,
-		int length)
-	{
-		super(doc, element.getName(), offset, length);
-		m_Element=element;
-	}
-	
-	public void apply(IDocument document)
-	{			
-		String replace = getReplaceString();
-
-		try
-		{
-			document.replace(getOffset() - getLength(), getLength(),
-					replace);
-		}
-		catch (BadLocationException e)
-		{
-		}
-	}
-	
-	public Image getImage()
-	{
-		if (m_Element instanceof VerilogOutlineElement) {
-			VerilogOutlineElement e = (VerilogOutlineElement) m_Element;
-			return VerilogPlugin.getPlugin().getImage(e.GetImageName());
-		}
-		return null;
-	}
-	
-	protected String getReplaceString()
-	{
-		//default behavior
-		StringBuffer replace=new StringBuffer(m_Element.getName());
-		
-		if(m_Element instanceof VerilogModuleElement){
-			VerilogModuleElement module = (VerilogModuleElement) m_Element;
-			String name = module.getName();
-			String indent = "\n" + getIndentString();
-			boolean isParams = VerilogPlugin
-					.getPreferenceBoolean("ContentAssist.ModuleParameter");
-			
-			ArrayList<VerilogParameterElement> parameters=new ArrayList<VerilogParameterElement>();
-			ArrayList<VerilogPortElement> ports=new ArrayList<VerilogPortElement>();
-			for(OutlineElement child : module.getChildren()){
-				if (child instanceof VerilogParameterElement) {
-					VerilogParameterElement p = (VerilogParameterElement) child;
-
-					// localparam is not included parameter list
-					if (!p.isLocal())
-						parameters.add(p);						
-				}
-				if (child instanceof VerilogPortElement) {
-					VerilogPortElement p = (VerilogPortElement) child;
-					ports.add(p);
-				}
-			}
-							
-			isParams = isParams && (parameters.size() > 0);
-
-			replace = new StringBuffer(name + " ");
-			
-			if (isParams)
-			{
-				replace.append("#(");
-				for (int i = 0; i < parameters.size(); i++)
-				{
-					replace.append(indent + "\t");			
-					replace.append("." + parameters.get(i).getName() + "(" + parameters.get(i).GetValue() + ")");
-					if (i < parameters.size() - 1)
-						replace.append(",");
-				}
-				replace.append(indent + ")" + indent);
-			}
-			
-			replace.append(name + "(");
-			for (int i = 0; i < ports.size(); i++)
-			{
-				replace.append(indent + "\t");
-
-				
-				replace.append("." + ports.get(i).getName() + "(" + ports.get(i).getName() + ")");
-
-				if (i < ports.size() - 1)
-					replace.append(",");
-			}
-			replace.append(indent + ");");
-		}
-		
-		return replace.toString();
-	}
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2007 Ali Ghorashi and others.
+ *
+ * Contributors:
+ *    Ali Ghorashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.editor.completionProposals;
+
+import java.util.ArrayList;
+
+import com.elphel.vdt.veditor.VerilogPlugin;
+import com.elphel.vdt.veditor.document.HdlDocument;
+import com.elphel.vdt.veditor.parser.OutlineElement;
+import com.elphel.vdt.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogModuleElement;
+import com.elphel.vdt.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogOutlineElement;
+import com.elphel.vdt.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogParameterElement;
+import com.elphel.vdt.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogPortElement;
+
+import org.eclipse.jface.text.BadLocationException;
+import org.eclipse.jface.text.IDocument;
+import org.eclipse.swt.graphics.Image;
+
+public class VerilogInstanceCompletionProposal extends
+InstanceCompletionProposal 
+{
+	protected OutlineElement m_Element;
+	public VerilogInstanceCompletionProposal(
+		HdlDocument doc,
+		OutlineElement element,
+		int offset,
+		int length)
+	{
+		super(doc, element.getName(), offset, length);
+		m_Element=element;
+	}
+	
+	public void apply(IDocument document)
+	{			
+		String replace = getReplaceString();
+
+		try
+		{
+			document.replace(getOffset() - getLength(), getLength(),
+					replace);
+		}
+		catch (BadLocationException e)
+		{
+		}
+	}
+	
+	public Image getImage()
+	{
+		if (m_Element instanceof VerilogOutlineElement) {
+			VerilogOutlineElement e = (VerilogOutlineElement) m_Element;
+			return VerilogPlugin.getPlugin().getImage(e.GetImageName());
+		}
+		return null;
+	}
+	
+	protected String getReplaceString()
+	{
+		//default behavior
+		StringBuffer replace=new StringBuffer(m_Element.getName());
+		
+		if(m_Element instanceof VerilogModuleElement){
+			VerilogModuleElement module = (VerilogModuleElement) m_Element;
+			String name = module.getName();
+			String indent = "\n" + getIndentString();
+			boolean isParams = VerilogPlugin
+					.getPreferenceBoolean("ContentAssist.ModuleParameter");
+			
+			ArrayList<VerilogParameterElement> parameters=new ArrayList<VerilogParameterElement>();
+			ArrayList<VerilogPortElement> ports=new ArrayList<VerilogPortElement>();
+			for(OutlineElement child : module.getChildren()){
+				if (child instanceof VerilogParameterElement) {
+					VerilogParameterElement p = (VerilogParameterElement) child;
+
+					// localparam is not included parameter list
+					if (!p.isLocal())
+						parameters.add(p);						
+				}
+				if (child instanceof VerilogPortElement) {
+					VerilogPortElement p = (VerilogPortElement) child;
+					ports.add(p);
+				}
+			}
+							
+			isParams = isParams && (parameters.size() > 0);
+
+			replace = new StringBuffer(name + " ");
+			
+			if (isParams)
+			{
+				replace.append("#(");
+				for (int i = 0; i < parameters.size(); i++)
+				{
+					replace.append(indent + "\t");			
+					replace.append("." + parameters.get(i).getName() + "(" + parameters.get(i).GetValue() + ")");
+					if (i < parameters.size() - 1)
+						replace.append(",");
+				}
+				replace.append(indent + ")" + indent);
+			}
+			
+			replace.append(name + "(");
+			for (int i = 0; i < ports.size(); i++)
+			{
+				replace.append(indent + "\t");
+
+				
+				replace.append("." + ports.get(i).getName() + "(" + ports.get(i).getName() + ")");
+
+				if (i < ports.size() - 1)
+					replace.append(",");
+			}
+			replace.append(indent + ");");
+		}
+		
+		return replace.toString();
+	}
 }
\ No newline at end of file
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/editor/completionProposals/VhdlInstanceCompletionProposal.java vdt/src/com/elphel/vdt/veditor/editor/completionProposals/VhdlInstanceCompletionProposal.java
--- vdt-veditor/src/com/elphel/vdt/veditor/editor/completionProposals/VhdlInstanceCompletionProposal.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/editor/completionProposals/VhdlInstanceCompletionProposal.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,156 +1,167 @@
-/*******************************************************************************
- * Copyright (c) 2007 Ali Ghorashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    Ali Ghorashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.editor.completionProposals;
-
-import net.sourceforge.veditor.VerilogPlugin;
-import net.sourceforge.veditor.document.HdlDocument;
-import net.sourceforge.veditor.parser.OutlineElement;
-import net.sourceforge.veditor.parser.vhdl.VhdlOutlineElementFactory.*;
-
-import org.eclipse.jface.text.BadLocationException;
-import org.eclipse.jface.text.IDocument;
-import org.eclipse.swt.graphics.Image;
-import org.eclipse.swt.widgets.Display;
-
-/**
- * Class to implement an instance completion proposal
- *
- */
-public class VhdlInstanceCompletionProposal extends
-		InstanceCompletionProposal {
-	/**
-	 * Outline element object
-	 */
-	private OutlineElement m_Element;
-
-	/**
-	 * Class constructor
-	 * @param doc Document instance
-	 * @param element Outline element associated with this proposal
-	 * @param offset Offset line of the replace string from the beginning of the document??
-	 * @param length length of the replace string
-	 */
-	public VhdlInstanceCompletionProposal(HdlDocument doc,
-			OutlineElement element, int offset, int length) {
-
-		super(doc, element.getName(), offset, length);
-			
-		if (element instanceof VhdlOutlineElement) {
-			VhdlOutlineElement vhdlElement = (VhdlOutlineElement) element;
-			name=vhdlElement.getShortName();				
-		}
-		
-		m_Element = element;			
-	}
-	
-	public Image getImage()
-	{
-		if (m_Element instanceof VhdlOutlineElement) {
-			VhdlOutlineElement e = (VhdlOutlineElement) m_Element;
-			return VerilogPlugin.getPlugin().getImage(e.GetImageName());
-		}
-		return null;
-	}
-	
-	public static boolean canHandle(OutlineElement outlineElement) {
-		if(outlineElement instanceof EntityDeclElement) return true;
-		if(outlineElement instanceof ComponentDeclElement) return true;
-		if(outlineElement instanceof VhdlSignalElement) return true;
-		if(outlineElement instanceof VariableElement) return true;
-		if(outlineElement instanceof ConstantElement) return true;
-		if(outlineElement instanceof TypeDecl) return true;
-
-		return false;
-	}
-
-	/**
-	 * Called when the user selects a proposal
-	 */
-	public void apply(IDocument document) {
-		if (m_Element == null) {
-			Display.getCurrent().beep();
-			return;
-		}
-
-		String replace = getReplaceString();
-
-		try {
-			document.replace(getOffset() - getLength(), getLength(),
-					replace);
-		} catch (BadLocationException e) {
-		}
-	}
-	
-	/**
-	 * Gets the replace string for a component or entity declaration
-	 * @return
-	 */
-	private String getComponentReplaceString(){
-		String replaceString="",generics="",ports = "";
-		
-		Object obj[] = m_Element.getChildren();
-		
-		for (int i = 0; i < obj.length; i++){
-			//do the generics
-			if (obj[i] instanceof GenericElement) {
-				GenericElement generic = (GenericElement) obj[i];
-				generics += "\n " + generic.getName() + " => "+generic.getName()+",";
-			}
-			//do the ports
-			if (obj[i] instanceof VhdlPortElement) {
-				VhdlPortElement port = (VhdlPortElement) obj[i];
-				ports += "\n " + port.getName() + " => "	
-					+ port.getName()+",";
-			}							
-		}
-		//assemble the replace string
-		if (m_Element instanceof EntityDeclElement) {
-			replaceString += "entity work.";
-		}
-		replaceString += m_Element.getName();
-		//do we have any generics
-		if(generics.length() > 0){
-			replaceString+="\ngeneric map(";					
-			//trim the last comma
-			int lastComma=generics.lastIndexOf(',');
-			replaceString+=generics.substring(0, lastComma)+generics.substring(lastComma+1);					
-			replaceString+="\n)";
-		}
-		if(ports.length() > 0){
-			replaceString+="\nport map(";					
-			//trim the last comma
-			int lastComma=ports.lastIndexOf(',');
-			replaceString+=ports.substring(0, lastComma)+ports.substring(lastComma+1);
-			replaceString+="\n)";
-		}
-		replaceString+=";";				
-		//align the string
-		replaceString = VerilogPlugin.alignOnChar(replaceString, '=', 1);				
-		// add the indent string
-		replaceString = replaceString.replace("\n ", "\n\t");
-		String indentationstring = VerilogPlugin.getIndentationString();	
-		replaceString = replaceString.replace("\t", indentationstring);
-		return  replaceString.replace("\n", eol + getIndentString());
-	}
-		
-	/**
-	 * Gets the replacement string based on the outline element associated
-	 * with this proposal
-	 * @return
-	 */
-	public String getReplaceString() {
-		if (m_Element instanceof EntityDeclElement || m_Element instanceof ComponentDeclElement) {
-			return getComponentReplaceString();
-		} else {
-			return m_Element.getName();
-		}
-	}
-}
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2007 Ali Ghorashi and others.
+ *
+ * Contributors:
+ *    Ali Ghorashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.editor.completionProposals;
+
+import com.elphel.vdt.veditor.VerilogPlugin;
+import com.elphel.vdt.veditor.document.HdlDocument;
+import com.elphel.vdt.veditor.parser.OutlineElement;
+import com.elphel.vdt.veditor.parser.vhdl.VhdlOutlineElementFactory.*;
+
+import org.eclipse.jface.text.BadLocationException;
+import org.eclipse.jface.text.IDocument;
+import org.eclipse.swt.graphics.Image;
+import org.eclipse.swt.widgets.Display;
+
+/**
+ * Class to implement an instance completion proposal
+ *
+ */
+public class VhdlInstanceCompletionProposal extends
+		InstanceCompletionProposal {
+	/**
+	 * Outline element object
+	 */
+	private OutlineElement m_Element;
+
+	/**
+	 * Class constructor
+	 * @param doc Document instance
+	 * @param element Outline element associated with this proposal
+	 * @param offset Offset line of the replace string from the beginning of the document??
+	 * @param length length of the replace string
+	 */
+	public VhdlInstanceCompletionProposal(HdlDocument doc,
+			OutlineElement element, int offset, int length) {
+
+		super(doc, element.getName(), offset, length);
+			
+		if (element instanceof VhdlOutlineElement) {
+			VhdlOutlineElement vhdlElement = (VhdlOutlineElement) element;
+			name=vhdlElement.getShortName();				
+		}
+		
+		m_Element = element;			
+	}
+	
+	public Image getImage()
+	{
+		if (m_Element instanceof VhdlOutlineElement) {
+			VhdlOutlineElement e = (VhdlOutlineElement) m_Element;
+			return VerilogPlugin.getPlugin().getImage(e.GetImageName());
+		}
+		return null;
+	}
+	
+	public static boolean canHandle(OutlineElement outlineElement) {
+		if(outlineElement instanceof EntityDeclElement) return true;
+		if(outlineElement instanceof ComponentDeclElement) return true;
+		if(outlineElement instanceof VhdlSignalElement) return true;
+		if(outlineElement instanceof VariableElement) return true;
+		if(outlineElement instanceof ConstantElement) return true;
+		if(outlineElement instanceof TypeDecl) return true;
+
+		return false;
+	}
+
+	/**
+	 * Called when the user selects a proposal
+	 */
+	public void apply(IDocument document) {
+		if (m_Element == null) {
+			Display.getCurrent().beep();
+			return;
+		}
+
+		String replace = getReplaceString();
+
+		try {
+			document.replace(getOffset() - getLength(), getLength(),
+					replace);
+		} catch (BadLocationException e) {
+		}
+	}
+	
+	/**
+	 * Gets the replace string for a component or entity declaration
+	 * @return
+	 */
+	private String getComponentReplaceString(){
+		String replaceString="",generics="",ports = "";
+		
+		Object obj[] = m_Element.getChildren();
+		
+		for (int i = 0; i < obj.length; i++){
+			//do the generics
+			if (obj[i] instanceof GenericElement) {
+				GenericElement generic = (GenericElement) obj[i];
+				generics += "\n " + generic.getName() + " => "+generic.getName()+",";
+			}
+			//do the ports
+			if (obj[i] instanceof VhdlPortElement) {
+				VhdlPortElement port = (VhdlPortElement) obj[i];
+				ports += "\n " + port.getName() + " => "	
+					+ port.getName()+",";
+			}							
+		}
+		//assemble the replace string
+		if (m_Element instanceof EntityDeclElement) {
+			replaceString += "entity work.";
+		}
+		replaceString += m_Element.getName();
+		//do we have any generics
+		if(generics.length() > 0){
+			replaceString+="\ngeneric map(";					
+			//trim the last comma
+			int lastComma=generics.lastIndexOf(',');
+			replaceString+=generics.substring(0, lastComma)+generics.substring(lastComma+1);					
+			replaceString+="\n)";
+		}
+		if(ports.length() > 0){
+			replaceString+="\nport map(";					
+			//trim the last comma
+			int lastComma=ports.lastIndexOf(',');
+			replaceString+=ports.substring(0, lastComma)+ports.substring(lastComma+1);
+			replaceString+="\n)";
+		}
+		replaceString+=";";				
+		//align the string
+		replaceString = VerilogPlugin.alignOnChar(replaceString, '=', 1);				
+		// add the indent string
+		replaceString = replaceString.replace("\n ", "\n\t");
+		String indentationstring = VerilogPlugin.getIndentationString();	
+		replaceString = replaceString.replace("\t", indentationstring);
+		return  replaceString.replace("\n", eol + getIndentString());
+	}
+		
+	/**
+	 * Gets the replacement string based on the outline element associated
+	 * with this proposal
+	 * @return
+	 */
+	public String getReplaceString() {
+		if (m_Element instanceof EntityDeclElement || m_Element instanceof ComponentDeclElement) {
+			return getComponentReplaceString();
+		} else {
+			return m_Element.getName();
+		}
+	}
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/editor/completionProposals/VhdlRecordCompletionProposal.java vdt/src/com/elphel/vdt/veditor/editor/completionProposals/VhdlRecordCompletionProposal.java
--- vdt-veditor/src/com/elphel/vdt/veditor/editor/completionProposals/VhdlRecordCompletionProposal.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/editor/completionProposals/VhdlRecordCompletionProposal.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,10 +1,10 @@
-package net.sourceforge.veditor.editor.completionProposals;
+package com.elphel.vdt.veditor.editor.completionProposals;
 
 import org.eclipse.jface.text.IDocument;
 import org.eclipse.swt.graphics.Image;
 import org.eclipse.swt.graphics.Point;
 
-import net.sourceforge.veditor.VerilogPlugin;
+import com.elphel.vdt.veditor.VerilogPlugin;
 
 public class VhdlRecordCompletionProposal extends CompletionProposal {
 	private int cursor;
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/editor/completionProposals/VhdlSubprogramProposalProvider.java vdt/src/com/elphel/vdt/veditor/editor/completionProposals/VhdlSubprogramProposalProvider.java
--- vdt-veditor/src/com/elphel/vdt/veditor/editor/completionProposals/VhdlSubprogramProposalProvider.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/editor/completionProposals/VhdlSubprogramProposalProvider.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,95 +1,95 @@
-package net.sourceforge.veditor.editor.completionProposals;
-
-import net.sourceforge.veditor.VerilogPlugin;
-import net.sourceforge.veditor.document.HdlDocument;
-import net.sourceforge.veditor.parser.vhdl.VhdlOutlineElementFactory.VhdlSubprogram;
-
-public class VhdlSubprogramProposalProvider extends DynamicProposalProvider {
-	private final static int MAX_LENGTH=80;
-	
-	public VhdlSubprogramProposalProvider(HdlDocument doc,
-			VhdlSubprogram element, int offset, int length){
-		super(doc,element,offset,length);
-	}
-
-	@Override
-	protected String getString(){		
-		//attempt to get a short string
-		String results=getStringShort();
-		//if the results is too long, use the tall version
-		if(results.length() > MAX_LENGTH){
-			return getStringTall();
-		}
-		return results;
-	}
-	
-	private String getStringShort(){
-		VhdlSubprogram sub = (VhdlSubprogram) m_Element;
-
-		StringBuffer buff = new StringBuffer(sub.getShortName());
-		String replaceString;
-		VhdlSubprogram.Parameter[] params = sub.getParameters();
-		int lastComma = 0;
-
-		if (params.length > 0) {
-			buff.append("(");
-			for (VhdlSubprogram.Parameter param : params) {				
-				buff.append(param.m_Name);
-				buff.append(" => ${");
-				buff.append(param.m_Name+"_"+param.m_Direction);
-				buff.append("}");
-				lastComma = buff.length();
-				buff.append(", ");				
-			}
-			// erase the last comma
-			buff.replace(lastComma, lastComma + 1, " ");
-			buff.append(")");
-		}
-
-		buff.append(";");
-		replaceString = buff.toString();
-		return replaceString;
-	}
-	
-	private String getStringTall() {
-		VhdlSubprogram sub = (VhdlSubprogram) m_Element;
-
-		StringBuffer buff = new StringBuffer(sub.getShortName());
-		String replaceString;
-		VhdlSubprogram.Parameter[] params = sub.getParameters();
-		int lastComma = 0;
-
-		if (params.length > 0) {
-			buff.append("(\n");
-			for (VhdlSubprogram.Parameter param : params) {
-				buff.append("    ");
-				buff.append(param.m_Name);
-				buff.append(" => ${");
-				buff.append(param.m_Name);
-				buff.append("}");
-				lastComma = buff.length();
-				buff.append(", --");
-				buff.append(param.m_Direction);
-				buff.append("\n");
-			}
-			// erase the last comma
-			buff.replace(lastComma, lastComma + 1, " ");
-			buff.append(")");
-		}
-
-		buff.append(";");
-		replaceString = buff.toString();
-		// align the string
-		replaceString = VerilogPlugin.alignOnChar(replaceString, '=', 1);
-		replaceString = VerilogPlugin.alignOnChar(replaceString, ',', 1);
-		replaceString = VerilogPlugin.alignOnChar(replaceString, '-', 1);
-		// add the indent string
-		return replaceString;
-	}
-	
-	@Override
-	protected String getDescription() {
-		return m_Element.getLongName();
-	}
-
-}
+package com.elphel.vdt.veditor.editor.completionProposals;
+
+import com.elphel.vdt.veditor.VerilogPlugin;
+import com.elphel.vdt.veditor.document.HdlDocument;
+import com.elphel.vdt.veditor.parser.vhdl.VhdlOutlineElementFactory.VhdlSubprogram;
+
+public class VhdlSubprogramProposalProvider extends DynamicProposalProvider {
+	private final static int MAX_LENGTH=80;
+	
+	public VhdlSubprogramProposalProvider(HdlDocument doc,
+			VhdlSubprogram element, int offset, int length){
+		super(doc,element,offset,length);
+	}
+
+	@Override
+	protected String getString(){		
+		//attempt to get a short string
+		String results=getStringShort();
+		//if the results is too long, use the tall version
+		if(results.length() > MAX_LENGTH){
+			return getStringTall();
+		}
+		return results;
+	}
+	
+	private String getStringShort(){
+		VhdlSubprogram sub = (VhdlSubprogram) m_Element;
+
+		StringBuffer buff = new StringBuffer(sub.getShortName());
+		String replaceString;
+		VhdlSubprogram.Parameter[] params = sub.getParameters();
+		int lastComma = 0;
+
+		if (params.length > 0) {
+			buff.append("(");
+			for (VhdlSubprogram.Parameter param : params) {				
+				buff.append(param.m_Name);
+				buff.append(" => ${");
+				buff.append(param.m_Name+"_"+param.m_Direction);
+				buff.append("}");
+				lastComma = buff.length();
+				buff.append(", ");				
+			}
+			// erase the last comma
+			buff.replace(lastComma, lastComma + 1, " ");
+			buff.append(")");
+		}
+
+		buff.append(";");
+		replaceString = buff.toString();
+		return replaceString;
+	}
+	
+	private String getStringTall() {
+		VhdlSubprogram sub = (VhdlSubprogram) m_Element;
+
+		StringBuffer buff = new StringBuffer(sub.getShortName());
+		String replaceString;
+		VhdlSubprogram.Parameter[] params = sub.getParameters();
+		int lastComma = 0;
+
+		if (params.length > 0) {
+			buff.append("(\n");
+			for (VhdlSubprogram.Parameter param : params) {
+				buff.append("    ");
+				buff.append(param.m_Name);
+				buff.append(" => ${");
+				buff.append(param.m_Name);
+				buff.append("}");
+				lastComma = buff.length();
+				buff.append(", --");
+				buff.append(param.m_Direction);
+				buff.append("\n");
+			}
+			// erase the last comma
+			buff.replace(lastComma, lastComma + 1, " ");
+			buff.append(")");
+		}
+
+		buff.append(";");
+		replaceString = buff.toString();
+		// align the string
+		replaceString = VerilogPlugin.alignOnChar(replaceString, '=', 1);
+		replaceString = VerilogPlugin.alignOnChar(replaceString, ',', 1);
+		replaceString = VerilogPlugin.alignOnChar(replaceString, '-', 1);
+		// add the indent string
+		return replaceString;
+	}
+	
+	@Override
+	protected String getDescription() {
+		return m_Element.getLongName();
+	}
+
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/editor/EditorMessages.java vdt/src/com/elphel/vdt/veditor/editor/EditorMessages.java
--- vdt-veditor/src/com/elphel/vdt/veditor/editor/EditorMessages.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/editor/EditorMessages.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,45 +1,56 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-
-package net.sourceforge.veditor.editor;
-
-import java.util.MissingResourceException;
-import java.util.ResourceBundle;
-
-public final class EditorMessages
-{
-	private static final String RESOURCE_BUNDLE =
-		"net.sourceforge.veditor.editor.EditorMessages";
-
-	private static ResourceBundle resourceBundle =
-		ResourceBundle.getBundle(RESOURCE_BUNDLE);
-
-	private EditorMessages()
-	{
-	}
-
-	public static String getString(String key)
-	{
-		try
-		{
-			return resourceBundle.getString(key);
-		}
-		catch (MissingResourceException e)
-		{
-			return "!" + key + "!";
-		}
-	}
-
-	public static ResourceBundle getResourceBundle()
-	{
-		return resourceBundle;
-	}
-}
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+
+package com.elphel.vdt.veditor.editor;
+
+import java.util.MissingResourceException;
+import java.util.ResourceBundle;
+
+public final class EditorMessages
+{
+	private static final String RESOURCE_BUNDLE =
+		"com.elphel.vdt.veditor.editor.EditorMessages";
+
+	private static ResourceBundle resourceBundle =
+		ResourceBundle.getBundle(RESOURCE_BUNDLE);
+
+	private EditorMessages()
+	{
+	}
+
+	public static String getString(String key)
+	{
+		try
+		{
+			return resourceBundle.getString(key);
+		}
+		catch (MissingResourceException e)
+		{
+			return "!" + key + "!";
+		}
+	}
+
+	public static ResourceBundle getResourceBundle()
+	{
+		return resourceBundle;
+	}
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/editor/EditorMessages.properties vdt/src/com/elphel/vdt/veditor/editor/EditorMessages.properties
--- vdt-veditor/src/com/elphel/vdt/veditor/editor/EditorMessages.properties	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/editor/EditorMessages.properties	2016-06-24 10:29:40.820496516 -0600
@@ -1,22 +1,25 @@
-
-ContentAssistProposal.label=Content Assist
-GotoMatchingBracket.label=Matching Bracket
-OpenDeclaration.label=Open Declaration
-CollapseAll.label=Collapse All
-ExpandAll.label=Expand All
-Format.label=Format
-VhdlFormatAction.label=Format
-VerilogFormatAction.label=Format
-Compile.label=Compile File
-Synthesize.label=Synthesize Files
-Comment.label=Comment
-Uncomment.label=Uncomment
-ShowInHierarchy.label=Show In Hierarchy
-ShowInOutline.label=Show In Outline
-ShowInNavigator.label=Show In Navigator
-ClearErrorMarkers.label=Clear Problem Markers
-
-CompletionProcessor.ContextInfo.display.pattern=proposal {0} at position {1}
-CompletionProcessor.ContextInfo.value.pattern=proposal {0} valid from {1} to {2}
-CompletionProcessor.Proposal.ContextInfo.pattern={0} valid 5 characters around insertion point
-CompletionProcessor.Proposal.hoverinfo.pattern=Java keyword: {0}
\ No newline at end of file
+
+ContentAssistProposal.label=Content Assist
+GotoMatchingBracket.label=Matching Bracket
+OpenDeclaration.label=Open Declaration
+GotoDriver.label=Goto Driver
+CollapseAll.label=Collapse All
+ExpandAll.label=Expand All
+Format.label=Format
+VhdlFormatAction.label=Format
+VerilogFormatAction.label=Format
+Compile.label=Compile File
+Synthesize.label=Synthesize Files
+Comment.label=Comment
+Uncomment.label=Uncomment
+ShowInHierarchy.label=Show In Hierarchy
+ShowInOutline.label=Show In Outline
+ShowInNavigator.label=Show In Navigator
+ClearErrorMarkers.label=Clear Problem Markers
+
+CompletionProcessor.ContextInfo.display.pattern=proposal {0} at position {1}
+CompletionProcessor.ContextInfo.value.pattern=proposal {0} valid from {1} to {2}
+CompletionProcessor.Proposal.ContextInfo.pattern={0} valid 5 characters around insertion point
+CompletionProcessor.Proposal.hoverinfo.pattern=Java keyword: {0}
+
+InactiveCodeHighlighting_job.label= Inactive Code Highlighting
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/editor/HdlActionContributor.java vdt/src/com/elphel/vdt/veditor/editor/HdlActionContributor.java
--- vdt-veditor/src/com/elphel/vdt/veditor/editor/HdlActionContributor.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/editor/HdlActionContributor.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,184 +1,199 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-
-package net.sourceforge.veditor.editor;
-
-import java.util.ResourceBundle;
-
-import net.sourceforge.veditor.actions.CollapseAll;
-import net.sourceforge.veditor.actions.CompileAction;
-import net.sourceforge.veditor.actions.ExpandAll;
-import net.sourceforge.veditor.actions.FormatAction;
-import net.sourceforge.veditor.actions.GotoMatchingBracketAction;
-import net.sourceforge.veditor.actions.OpenDeclarationAction;
-import net.sourceforge.veditor.actions.CommentAction;
-import net.sourceforge.veditor.actions.ShowInHierarchy;
-import net.sourceforge.veditor.actions.ShowInOutline;
-import net.sourceforge.veditor.actions.SynthesizeAction;
-import net.sourceforge.veditor.actions.UnCommentAction;
-
-import org.eclipse.jface.action.IAction;
-import org.eclipse.jface.action.IContributionItem;
-import org.eclipse.jface.action.IMenuManager;
-import org.eclipse.jface.action.MenuManager;
-import org.eclipse.jface.action.Separator;
-import org.eclipse.ui.IActionBars;
-import org.eclipse.ui.IEditorPart;
-import org.eclipse.ui.IWorkbenchActionConstants;
-import org.eclipse.ui.editors.text.TextEditorActionContributor;
-import org.eclipse.ui.texteditor.ITextEditor;
-import org.eclipse.ui.texteditor.ITextEditorActionDefinitionIds;
-import org.eclipse.ui.texteditor.RetargetTextEditorAction;
-
-public class HdlActionContributor extends TextEditorActionContributor
-{
-	private RetargetTextEditorAction contentAssistProposal;
-	private IAction gotoMatchingBracket;
-	private IAction openDeclaration;
-	private IAction collapseAllAction;
-	private IAction expandAllAction;
-	private IAction format;
-	private IAction compile;
-	private IAction synthesize;
-	private IAction comment;
-	private IAction uncomment;
-	private IAction showInHierarchy;
-	private IAction showInOutline;
-
-	private static final String CONTENT_ASSIST_PROPOSAL = "ContentAssistProposal";
-
-	private ResourceBundle resource;
-
-	public HdlActionContributor()
-	{
-		super();
-
-		resource = EditorMessages.getResourceBundle();
-
-		contentAssistProposal =
-			createAction(
-				CONTENT_ASSIST_PROPOSAL,
-				ITextEditorActionDefinitionIds.CONTENT_ASSIST_PROPOSALS);
-		
-		gotoMatchingBracket = new GotoMatchingBracketAction();
-		openDeclaration = new OpenDeclarationAction();
-		collapseAllAction = new CollapseAll();
-		expandAllAction   = new ExpandAll();
-		format = new FormatAction();
-		compile = new CompileAction(); 
-		synthesize = new SynthesizeAction();
-		comment = new CommentAction();
-		uncomment = new UnCommentAction();
-		showInHierarchy=new ShowInHierarchy();
-		showInOutline=new ShowInOutline();
-		
-	}
-
-	private RetargetTextEditorAction createAction(String name, String id)
-	{
-		RetargetTextEditorAction action = new RetargetTextEditorAction(
-				resource, name + ".");
-		action.setActionDefinitionId(id);
-		return action;
-	}
-
-	public void init(IActionBars bars)
-	{
-		super.init(bars);
-
-		IMenuManager menuManager = bars.getMenuManager();
-
-		IMenuManager editMenu = menuManager
-				.findMenuUsingPath(IWorkbenchActionConstants.M_EDIT);
-		if (editMenu != null)
-		{
-			editMenu.add(new Separator());
-			editMenu.add(contentAssistProposal);
-			editMenu.add(format);
-			editMenu.add(comment);
-			editMenu.add(uncomment);
-		}
-
-		IMenuManager projectMenu = menuManager
-		.findMenuUsingPath(IWorkbenchActionConstants.M_PROJECT);
-		if (projectMenu != null)
-		{			
-			projectMenu.insertAfter("buildProject", compile);
-			projectMenu.insertAfter(compile.getId(), synthesize);
-		}
-
-		IMenuManager navigateMenu = menuManager
-				.findMenuUsingPath(IWorkbenchActionConstants.M_NAVIGATE);
-		if (navigateMenu != null)
-		{
-			MenuManager showIn=null;
-			IMenuManager gotoMenu = navigateMenu
-					.findMenuUsingPath(IWorkbenchActionConstants.GO_TO);
-			gotoMenu.add(gotoMatchingBracket);
-
-			navigateMenu.add(openDeclaration);
-			navigateMenu.add(collapseAllAction);
-			navigateMenu.add(expandAllAction);
-						
-			IContributionItem[] contributionItems=navigateMenu.getItems();
-			for(IContributionItem item: contributionItems){
-				if (item instanceof MenuManager) {
-					MenuManager menu = (MenuManager) item;
-					if(menu.getMenuText().startsWith("Sho&w In")){
-						showIn=menu;
-						break;
-					}
-				}
-			}
-			if(showIn!=null){
-				//FIXME Need to figure out how to properly add stuff to the "Show In"
-				showIn.removeAll();
-				showIn.add(showInHierarchy);
-				showIn.add(showInOutline);
-			}
-			
-		}
-		
-	}
-
-	private void setEditorAction(ITextEditor editor,
-			final RetargetTextEditorAction action, String id)
-	{
-		action.setAction(getAction(editor, id));
-	}
-
-	private void doSetActiveEditor(IEditorPart part)
-	{
-		super.setActiveEditor(part);
-
-		ITextEditor editor = null;
-		if (part instanceof ITextEditor)
-			editor = (ITextEditor)part;
-
-		setEditorAction(editor, contentAssistProposal, CONTENT_ASSIST_PROPOSAL);
-	}
-
-	public void setActiveEditor(IEditorPart part)
-	{
-		super.setActiveEditor(part);
-		doSetActiveEditor(part);
-	}
-
-	public void dispose()
-	{
-		doSetActiveEditor(null);
-		super.dispose();
-	}
-}
-
-
-
-
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+
+package com.elphel.vdt.veditor.editor;
+
+import java.util.ResourceBundle;
+
+import com.elphel.vdt.veditor.actions.CollapseAll;
+import com.elphel.vdt.veditor.actions.CompileAction;
+import com.elphel.vdt.veditor.actions.ExpandAll;
+import com.elphel.vdt.veditor.actions.FormatAction;
+import com.elphel.vdt.veditor.actions.GotoMatchingBracketAction;
+import com.elphel.vdt.veditor.actions.OpenDeclarationAction;
+import com.elphel.vdt.veditor.actions.GotoDriverAction;
+import com.elphel.vdt.veditor.actions.CommentAction;
+import com.elphel.vdt.veditor.actions.ShowInHierarchy;
+import com.elphel.vdt.veditor.actions.ShowInOutline;
+import com.elphel.vdt.veditor.actions.SynthesizeAction;
+import com.elphel.vdt.veditor.actions.UnCommentAction;
+
+import org.eclipse.jface.action.IAction;
+import org.eclipse.jface.action.IContributionItem;
+import org.eclipse.jface.action.IMenuManager;
+import org.eclipse.jface.action.MenuManager;
+import org.eclipse.jface.action.Separator;
+import org.eclipse.ui.IActionBars;
+import org.eclipse.ui.IEditorPart;
+import org.eclipse.ui.IWorkbenchActionConstants;
+import org.eclipse.ui.editors.text.TextEditorActionContributor;
+import org.eclipse.ui.texteditor.ITextEditor;
+import org.eclipse.ui.texteditor.ITextEditorActionDefinitionIds;
+import org.eclipse.ui.texteditor.RetargetTextEditorAction;
+
+public class HdlActionContributor extends TextEditorActionContributor
+{
+	private RetargetTextEditorAction contentAssistProposal;
+	private IAction gotoMatchingBracket;
+	private IAction openDeclaration;
+	private IAction gotoDriver;
+	private IAction collapseAllAction;
+	private IAction expandAllAction;
+	private IAction format;
+	private IAction compile;
+	private IAction synthesize;
+	private IAction comment;
+	private IAction uncomment;
+	private IAction showInHierarchy;
+	private IAction showInOutline;
+
+	private static final String CONTENT_ASSIST_PROPOSAL = "ContentAssistProposal";
+
+	private ResourceBundle resource;
+
+	public HdlActionContributor()
+	{
+		super();
+
+		resource = EditorMessages.getResourceBundle();
+
+		contentAssistProposal =
+			createAction(
+				CONTENT_ASSIST_PROPOSAL,
+				ITextEditorActionDefinitionIds.CONTENT_ASSIST_PROPOSALS);
+		
+		gotoMatchingBracket = new GotoMatchingBracketAction();
+		openDeclaration = new OpenDeclarationAction();
+		gotoDriver = new GotoDriverAction();
+		collapseAllAction = new CollapseAll();
+		expandAllAction   = new ExpandAll();
+		format = new FormatAction();
+		compile = new CompileAction(); 
+		synthesize = new SynthesizeAction();
+		comment = new CommentAction();
+		uncomment = new UnCommentAction();
+		showInHierarchy=new ShowInHierarchy();
+		showInOutline=new ShowInOutline();
+		
+	}
+
+	private RetargetTextEditorAction createAction(String name, String id)
+	{
+		RetargetTextEditorAction action = new RetargetTextEditorAction(
+				resource, name + ".");
+		action.setActionDefinitionId(id);
+		return action;
+	}
+
+	public void init(IActionBars bars)
+	{
+		super.init(bars);
+
+		IMenuManager menuManager = bars.getMenuManager();
+
+		IMenuManager editMenu = menuManager
+				.findMenuUsingPath(IWorkbenchActionConstants.M_EDIT);
+		if (editMenu != null)
+		{
+			editMenu.add(new Separator());
+			editMenu.add(contentAssistProposal);
+			editMenu.add(format);
+			editMenu.add(comment);
+			editMenu.add(uncomment);
+		}
+
+		IMenuManager projectMenu = menuManager
+		.findMenuUsingPath(IWorkbenchActionConstants.M_PROJECT);
+		if (projectMenu != null)
+		{			
+			projectMenu.insertAfter("buildProject", compile);
+			projectMenu.insertAfter(compile.getId(), synthesize);
+		}
+
+		IMenuManager navigateMenu = menuManager
+				.findMenuUsingPath(IWorkbenchActionConstants.M_NAVIGATE);
+		if (navigateMenu != null)
+		{
+			MenuManager showIn=null;
+			IMenuManager gotoMenu = navigateMenu
+					.findMenuUsingPath(IWorkbenchActionConstants.GO_TO);
+			gotoMenu.add(gotoMatchingBracket);
+
+			navigateMenu.add(openDeclaration);
+			navigateMenu.add(showInHierarchy); // duplicate to show in
+			navigateMenu.add(collapseAllAction);
+			navigateMenu.add(expandAllAction);
+						
+			IContributionItem[] contributionItems=navigateMenu.getItems();
+			for(IContributionItem item: contributionItems){
+				if (item instanceof MenuManager) {
+					MenuManager menu = (MenuManager) item;
+					if(menu.getMenuText().startsWith("Sho&w In")){
+						showIn=menu;
+						break;
+					}
+				}
+			}
+			if(showIn!=null){
+				//FIXME Need to figure out how to properly add stuff to the "Show In"
+				showIn.removeAll();
+				showIn.add(showInHierarchy);
+				showIn.add(showInOutline);
+			}
+			
+		}
+		
+	}
+
+	private void setEditorAction(ITextEditor editor,
+			final RetargetTextEditorAction action, String id)
+	{
+		action.setAction(getAction(editor, id));
+	}
+
+	private void doSetActiveEditor(IEditorPart part)
+	{
+		super.setActiveEditor(part);
+
+		ITextEditor editor = null;
+		if (part instanceof ITextEditor)
+			editor = (ITextEditor)part;
+
+		setEditorAction(editor, contentAssistProposal, CONTENT_ASSIST_PROPOSAL);
+	}
+
+	public void setActiveEditor(IEditorPart part)
+	{
+		super.setActiveEditor(part);
+		doSetActiveEditor(part);
+	}
+
+	public void dispose()
+	{
+		doSetActiveEditor(null);
+		super.dispose();
+	}
+}
+
+
+
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/editor/HdlCompletionProcessor.java vdt/src/com/elphel/vdt/veditor/editor/HdlCompletionProcessor.java
--- vdt-veditor/src/com/elphel/vdt/veditor/editor/HdlCompletionProcessor.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/editor/HdlCompletionProcessor.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,281 +1,292 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-
-package net.sourceforge.veditor.editor;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import net.sourceforge.veditor.VerilogPlugin;
-import net.sourceforge.veditor.document.HdlDocument;
-import net.sourceforge.veditor.editor.completionProposals.CompletionProposal;
-import net.sourceforge.veditor.editor.completionProposals.HdlTemplateProposal;
-import net.sourceforge.veditor.editor.completionProposals.IComparableCompletionProposal;
-import net.sourceforge.veditor.editor.completionProposals.TemplateCompletionProposal;
-import net.sourceforge.veditor.templates.TemplateWithIndent;
-
-import org.eclipse.jface.text.BadLocationException;
-import org.eclipse.jface.text.ITextSelection;
-import org.eclipse.jface.text.ITextViewer;
-import org.eclipse.jface.text.Region;
-import org.eclipse.jface.text.TextUtilities;
-import org.eclipse.jface.text.contentassist.ICompletionProposal;
-import org.eclipse.jface.text.contentassist.IContentAssistProcessor;
-import org.eclipse.jface.text.contentassist.IContextInformation;
-import org.eclipse.jface.text.contentassist.IContextInformationValidator;
-import org.eclipse.jface.text.templates.DocumentTemplateContext;
-import org.eclipse.jface.text.templates.Template;
-import org.eclipse.jface.text.templates.TemplateContextType;
-import org.eclipse.jface.text.templates.TemplateException;
-import org.eclipse.swt.graphics.Image;
-
-/**
- * content assist<p/>
- * simple templates and module instantiation
- */
-abstract public class HdlCompletionProcessor implements IContentAssistProcessor
-{
-	protected static final String TEMPLATE_IMAGE= "$nl$/icons/template.gif";
-	
-	/* (non-Javadoc)
-	 * @see org.eclipse.jface.text.contentassist.IContentAssistProcessor#computeCompletionProposals(org.eclipse.jface.text.ITextViewer, int)
-	 */
-	abstract public ICompletionProposal[] computeCompletionProposals(
-		ITextViewer viewer,
-		int documentOffset);
-	
-	/** This should return the relevance of the template which will be used to sort
-	 * the suggestions
-	 * @param template
-	 * @param prefix
-	 * @return scalar relevance of the template in the given context
-	 */
-	abstract protected int getRelevance(Template template, String prefix);
-	
-	/**
-	 * This function should return a context string for the given context.
-	 * This value will be used to lookup the templates in the TemplateStore
-	 * @param context
-	 * @return Context string used to lookup the templates in the TemplateStore
-	 */
-	abstract protected String getTemplateContextString(int context);
-	
-	
-	
-	protected static void addProposals(List<IComparableCompletionProposal> matchList, int offset,
-			String replace, Object[] vars)
-	{
-		for (int i = 0; i < vars.length; i++)
-		{
-			String word = vars[i].toString();
-			if (isMatch(replace, word))
-			{
-				matchList.add(new CompletionProposal(word, offset, replace
-						.length()));
-			}
-		}
-	}
-		
-
-	protected static boolean isMatch(String replace, String name)
-	{
-		int length = replace.length();
-		if (name.length() < length)
-			return false;
-
-		String ref = name.substring(0, length);
-		return ref.toLowerCase().equals(replace.toLowerCase());
-	}
-
-	protected static String getMatchingWord(String text, int offset)
-	{
-		int start = offset;
-		while (start > 0)
-		{
-			start--;
-			char c = text.charAt(start);
-			if (!Character.isJavaIdentifierPart(c))
-				return text.substring(start + 1, offset);
-		}
-		return text.substring(0, offset);
-	}
-	protected static String getMatchingWordWithdot(String text, int offset)
-	{
-		int start = offset;
-		while (start > 0)
-		{
-			start--;
-			char c = text.charAt(start);
-			if (!Character.isJavaIdentifierPart(c)&&c!='.')
-				return text.substring(start + 1, offset);
-		}
-		return text.substring(0, offset);
-	}
-	
-	protected static String getCurrentLineUpToOffset(String text, int offset)
-	{
-		int start = offset;
-		while (start > 0)
-		{
-			start--;
-			char c = text.charAt(start);
-			if(c==10)
-				return text.substring(start + 1, offset);
-		}
-		return text.substring(0, offset);
-	}
-	
-	
-
-	protected static IComparableCompletionProposal getSimpleProposal(String word,
-			int offset, int length)
-	{
-		return getCompletionProposal(word, offset, length, word.length(), word);
-	}
-
-	protected static IComparableCompletionProposal getCompletionProposal(String replace,
-			int offset, int length, int cursor, String display)
-	{
-		return new TemplateCompletionProposal(replace, offset, length, cursor,
-				display);
-	}
-
-	public char[] getCompletionProposalAutoActivationCharacters()
-	{
-		return new char[] { '.' };
-	}
-
-	public String getErrorMessage()
-	{
-		return null;
-	}
-
-	//  ContentInformation is not supported
-	public IContextInformation[] computeContextInformation(ITextViewer viewer,
-			int documentOffset)
-	{
-		return null;
-	}
-
-	public char[] getContextInformationAutoActivationCharacters()
-	{
-		return null;
-	}
-
-	public IContextInformationValidator getContextInformationValidator()
-	{
-		return null;
-	}
-	
-		
-	/**
-	 * Creates a list of template proposals
-	 * @param viewer
-	 * @param offset
-	 * @return
-	 */
-	@SuppressWarnings("deprecation")
-	protected List<HdlTemplateProposal> getTemplates(ITextViewer viewer, int offset,int context){		
-		List<HdlTemplateProposal> results=new ArrayList<HdlTemplateProposal>();
-		
-		ITextSelection selection= (ITextSelection) viewer.getSelectionProvider().getSelection();
-
-		// adjust offset to end of normalized selection
-		if (selection.getOffset() == offset)
-			offset= selection.getOffset() + selection.getLength();
-		
-		//walk backwards to find the beginning of the word we are replacing
-		int beginning= offset;
-
-		if (viewer.getDocument() instanceof HdlDocument) {
-			HdlDocument doc = (HdlDocument) viewer.getDocument();
-			
-			String indentationstring = VerilogPlugin.getIndentationString();
-			String eol = TextUtilities.getDefaultLineDelimiter(doc);
-			
-			while (beginning > 0) {
-				try{
-					char ch= doc.getChar(beginning - 1);
-					if (!Character.isJavaIdentifierPart(ch))
-						break;
-					beginning--;			
-				}
-				catch (BadLocationException e)
-				{
-					//empty list
-					return results;
-				}
-			}
-			
-			Region region= new Region(beginning, offset-beginning);
-			String prefix=null;
-			try{
-				prefix=doc.get(beginning, offset-beginning);
-			}
-			catch (BadLocationException e)
-			{
-				//empty list
-				return results;
-			}
-			//get a list of templates
-			String contextString=getTemplateContextString(context);
-			TemplateContextType contextType=VerilogPlugin.getPlugin().getContextTypeRegistry().getContextType(contextString);
-			Template[] templates= VerilogPlugin.getPlugin().getTemplateStore().getTemplates(contextType.getId());
-			DocumentTemplateContext documnetTemplateContext= new DocumentTemplateContext(contextType, doc, region.getOffset(), region.getLength());
-			//find a matching template
-			for (int i= 0; i < templates.length; i++) {
-				Template template= templates[i];
-				String pattern = template.getPattern();
-				pattern = pattern.replace("\t", indentationstring);
-				pattern = pattern.replace("\r", "");
-				pattern = pattern.replace("\n", eol);
-				template.setPattern(pattern);
-				
-				try {
-					contextType.validate(template.getPattern());
-				} catch (TemplateException e) {
-					continue;
-				}			
-				
-				if (template.matches(prefix, contextType.getId()) && template.getName().startsWith(prefix)){
-					String indent = doc.getIndentString(offset);
-					template = new TemplateWithIndent(template, indent);
-					HdlTemplateProposal hdlTemplateProposal=new HdlTemplateProposal(template,
-																documnetTemplateContext, 
-																region, 
-																getTemplateImage(template),
-																getRelevance(template, prefix));
-					results.add(hdlTemplateProposal);
-				}
-			}	
-		}
-		return results;
-	}
-	
-	/**
-	 * Returns an image used for template suggestions
-	 * 
-	 * @param template the template, ignored in this implementation
-	 * @return the default template image
-	 */
-	protected Image getTemplateImage(Template template) {		
-		VerilogPlugin plugin=VerilogPlugin.getPlugin();
-		
-		return plugin.getImage(TEMPLATE_IMAGE);				
-	}
-}
-
-
-
-
-
-
-
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+
+package com.elphel.vdt.veditor.editor;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import com.elphel.vdt.veditor.VerilogPlugin;
+import com.elphel.vdt.veditor.document.HdlDocument;
+import com.elphel.vdt.veditor.editor.completionProposals.CompletionProposal;
+import com.elphel.vdt.veditor.editor.completionProposals.HdlTemplateProposal;
+import com.elphel.vdt.veditor.editor.completionProposals.IComparableCompletionProposal;
+import com.elphel.vdt.veditor.editor.completionProposals.TemplateCompletionProposal;
+import com.elphel.vdt.veditor.templates.TemplateWithIndent;
+
+import org.eclipse.jface.text.BadLocationException;
+import org.eclipse.jface.text.ITextSelection;
+import org.eclipse.jface.text.ITextViewer;
+import org.eclipse.jface.text.Region;
+import org.eclipse.jface.text.TextUtilities;
+import org.eclipse.jface.text.contentassist.ICompletionProposal;
+import org.eclipse.jface.text.contentassist.IContentAssistProcessor;
+import org.eclipse.jface.text.contentassist.IContextInformation;
+import org.eclipse.jface.text.contentassist.IContextInformationValidator;
+import org.eclipse.jface.text.templates.DocumentTemplateContext;
+import org.eclipse.jface.text.templates.Template;
+import org.eclipse.jface.text.templates.TemplateContextType;
+import org.eclipse.jface.text.templates.TemplateException;
+import org.eclipse.swt.graphics.Image;
+
+/**
+ * content assist<p/>
+ * simple templates and module instantiation
+ */
+abstract public class HdlCompletionProcessor implements IContentAssistProcessor
+{
+	protected static final String TEMPLATE_IMAGE= "$nl$/icons/template.gif";
+	
+	/* (non-Javadoc)
+	 * @see org.eclipse.jface.text.contentassist.IContentAssistProcessor#computeCompletionProposals(org.eclipse.jface.text.ITextViewer, int)
+	 */
+	abstract public ICompletionProposal[] computeCompletionProposals(
+		ITextViewer viewer,
+		int documentOffset);
+	
+	/** This should return the relevance of the template which will be used to sort
+	 * the suggestions
+	 * @param template
+	 * @param prefix
+	 * @return scalar relevance of the template in the given context
+	 */
+	abstract protected int getRelevance(Template template, String prefix);
+	
+	/**
+	 * This function should return a context string for the given context.
+	 * This value will be used to lookup the templates in the TemplateStore
+	 * @param context
+	 * @return Context string used to lookup the templates in the TemplateStore
+	 */
+	abstract protected String getTemplateContextString(int context);
+	
+	
+	
+	protected static void addProposals(List<IComparableCompletionProposal> matchList, int offset,
+			String replace, Object[] vars)
+	{
+		for (int i = 0; i < vars.length; i++)
+		{
+			String word = vars[i].toString();
+			if (isMatch(replace, word))
+			{
+				matchList.add(new CompletionProposal(word, offset, replace
+						.length()));
+			}
+		}
+	}
+		
+
+	protected static boolean isMatch(String replace, String name)
+	{
+		int length = replace.length();
+		if (name.length() < length)
+			return false;
+
+		String ref = name.substring(0, length);
+		return ref.toLowerCase().equals(replace.toLowerCase());
+	}
+
+	protected static String getMatchingWord(String text, int offset)
+	{
+		int start = offset;
+		while (start > 0)
+		{
+			start--;
+			char c = text.charAt(start);
+			if (!Character.isJavaIdentifierPart(c))
+				return text.substring(start + 1, offset);
+		}
+		return text.substring(0, offset);
+	}
+	protected static String getMatchingWordWithdot(String text, int offset)
+	{
+		int start = offset;
+		while (start > 0)
+		{
+			start--;
+			char c = text.charAt(start);
+			if (!Character.isJavaIdentifierPart(c)&&c!='.')
+				return text.substring(start + 1, offset);
+		}
+		return text.substring(0, offset);
+	}
+	
+	protected static String getCurrentLineUpToOffset(String text, int offset)
+	{
+		int start = offset;
+		while (start > 0)
+		{
+			start--;
+			char c = text.charAt(start);
+			if(c==10)
+				return text.substring(start + 1, offset);
+		}
+		return text.substring(0, offset);
+	}
+	
+	
+
+	protected static IComparableCompletionProposal getSimpleProposal(String word,
+			int offset, int length)
+	{
+		return getCompletionProposal(word, offset, length, word.length(), word);
+	}
+
+	protected static IComparableCompletionProposal getCompletionProposal(String replace,
+			int offset, int length, int cursor, String display)
+	{
+		return new TemplateCompletionProposal(replace, offset, length, cursor,
+				display);
+	}
+
+	public char[] getCompletionProposalAutoActivationCharacters()
+	{
+		return new char[] { '.' };
+	}
+
+	public String getErrorMessage()
+	{
+		return null;
+	}
+
+	//  ContentInformation is not supported
+	public IContextInformation[] computeContextInformation(ITextViewer viewer,
+			int documentOffset)
+	{
+		return null;
+	}
+
+	public char[] getContextInformationAutoActivationCharacters()
+	{
+		return null;
+	}
+
+	public IContextInformationValidator getContextInformationValidator()
+	{
+		return null;
+	}
+	
+		
+	/**
+	 * Creates a list of template proposals
+	 * @param viewer
+	 * @param offset
+	 * @return
+	 */
+	@SuppressWarnings("deprecation")
+	protected List<HdlTemplateProposal> getTemplates(ITextViewer viewer, int offset,int context){		
+		List<HdlTemplateProposal> results=new ArrayList<HdlTemplateProposal>();
+		
+		ITextSelection selection= (ITextSelection) viewer.getSelectionProvider().getSelection();
+
+		// adjust offset to end of normalized selection
+		if (selection.getOffset() == offset)
+			offset= selection.getOffset() + selection.getLength();
+		
+		//walk backwards to find the beginning of the word we are replacing
+		int beginning= offset;
+
+		if (viewer.getDocument() instanceof HdlDocument) {
+			HdlDocument doc = (HdlDocument) viewer.getDocument();
+			
+			String indentationstring = VerilogPlugin.getIndentationString();
+			String eol = TextUtilities.getDefaultLineDelimiter(doc);
+			
+			while (beginning > 0) {
+				try{
+					char ch= doc.getChar(beginning - 1);
+					if (!Character.isJavaIdentifierPart(ch))
+						break;
+					beginning--;			
+				}
+				catch (BadLocationException e)
+				{
+					//empty list
+					return results;
+				}
+			}
+			
+			Region region= new Region(beginning, offset-beginning);
+			String prefix=null;
+			try{
+				prefix=doc.get(beginning, offset-beginning);
+			}
+			catch (BadLocationException e)
+			{
+				//empty list
+				return results;
+			}
+			//get a list of templates
+			String contextString=getTemplateContextString(context);
+			TemplateContextType contextType=VerilogPlugin.getPlugin().getContextTypeRegistry().getContextType(contextString);
+			Template[] templates= VerilogPlugin.getPlugin().getTemplateStore().getTemplates(contextType.getId());
+			DocumentTemplateContext documnetTemplateContext= new DocumentTemplateContext(contextType, doc, region.getOffset(), region.getLength());
+			//find a matching template
+			for (int i= 0; i < templates.length; i++) {
+				Template template= templates[i];
+				String pattern = template.getPattern();
+				pattern = pattern.replace("\t", indentationstring);
+				pattern = pattern.replace("\r", "");
+				pattern = pattern.replace("\n", eol);
+				template.setPattern(pattern);
+				
+				try {
+					contextType.validate(template.getPattern());
+				} catch (TemplateException e) {
+					continue;
+				}			
+				
+				if (template.matches(prefix, contextType.getId()) && template.getName().startsWith(prefix)){
+					String indent = doc.getIndentString(offset);
+					template = new TemplateWithIndent(template, indent);
+					HdlTemplateProposal hdlTemplateProposal=new HdlTemplateProposal(template,
+																documnetTemplateContext, 
+																region, 
+																getTemplateImage(template),
+																getRelevance(template, prefix));
+					results.add(hdlTemplateProposal);
+				}
+			}	
+		}
+		return results;
+	}
+	
+	/**
+	 * Returns an image used for template suggestions
+	 * 
+	 * @param template the template, ignored in this implementation
+	 * @return the default template image
+	 */
+	protected Image getTemplateImage(Template template) {		
+		VerilogPlugin plugin=VerilogPlugin.getPlugin();
+		
+		return plugin.getImage(TEMPLATE_IMAGE);				
+	}
+}
+
+
+
+
+
+
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/editor/HdlContentOutlinePage.java vdt/src/com/elphel/vdt/veditor/editor/HdlContentOutlinePage.java
--- vdt-veditor/src/com/elphel/vdt/veditor/editor/HdlContentOutlinePage.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/editor/HdlContentOutlinePage.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,470 +1,529 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-
-package net.sourceforge.veditor.editor;
-
-
-import net.sourceforge.veditor.VerilogPlugin;
-import net.sourceforge.veditor.editor.VhdlHierarchyProvider;
-import net.sourceforge.veditor.document.VhdlDocument;
-import net.sourceforge.veditor.parser.OutlineElement;
-import net.sourceforge.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogFunctionElement;
-import net.sourceforge.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogInstanceElement;
-import net.sourceforge.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogModuleElement;
-import net.sourceforge.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogParameterElement;
-import net.sourceforge.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogPortElement;
-import net.sourceforge.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogRegElement;
-import net.sourceforge.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogSignalElement;
-import net.sourceforge.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogTaskElement;
-import net.sourceforge.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogWireElement;
-import net.sourceforge.veditor.parser.vhdl.VhdlOutlineElementFactory.AliasElement;
-import net.sourceforge.veditor.parser.vhdl.VhdlOutlineElementFactory.ArchitectureElement;
-import net.sourceforge.veditor.parser.vhdl.VhdlOutlineElementFactory.ComponentDeclElement;
-import net.sourceforge.veditor.parser.vhdl.VhdlOutlineElementFactory.ComponentInstElement;
-import net.sourceforge.veditor.parser.vhdl.VhdlOutlineElementFactory.ConstantElement;
-import net.sourceforge.veditor.parser.vhdl.VhdlOutlineElementFactory.EntityDeclElement;
-import net.sourceforge.veditor.parser.vhdl.VhdlOutlineElementFactory.EntityInstElement;
-import net.sourceforge.veditor.parser.vhdl.VhdlOutlineElementFactory.GenericElement;
-import net.sourceforge.veditor.parser.vhdl.VhdlOutlineElementFactory.PackageBodyElement;
-import net.sourceforge.veditor.parser.vhdl.VhdlOutlineElementFactory.PackageDeclElement;
-import net.sourceforge.veditor.parser.vhdl.VhdlOutlineElementFactory.ProcedureElement;
-import net.sourceforge.veditor.parser.vhdl.VhdlOutlineElementFactory.ProcessElement;
-import net.sourceforge.veditor.parser.vhdl.VhdlOutlineElementFactory.VhdlPortElement;
-import net.sourceforge.veditor.parser.vhdl.VhdlOutlineElementFactory.VhdlSignalElement;
-
-import org.eclipse.jface.action.Action;
-import org.eclipse.jface.action.IMenuListener;
-import org.eclipse.jface.action.IMenuManager;
-import org.eclipse.jface.action.IToolBarManager;
-import org.eclipse.jface.action.MenuManager;
-import org.eclipse.jface.resource.ImageDescriptor;
-import org.eclipse.jface.text.IDocument;
-import org.eclipse.jface.viewers.DoubleClickEvent;
-import org.eclipse.jface.viewers.IDoubleClickListener;
-import org.eclipse.jface.viewers.ISelection;
-import org.eclipse.jface.viewers.IStructuredSelection;
-import org.eclipse.jface.viewers.ITreeContentProvider;
-import org.eclipse.jface.viewers.SelectionChangedEvent;
-import org.eclipse.jface.viewers.TreeViewer;
-import org.eclipse.jface.viewers.Viewer;
-import org.eclipse.jface.viewers.ViewerFilter;
-import org.eclipse.jface.viewers.ViewerSorter;
-import org.eclipse.swt.widgets.Composite;
-import org.eclipse.swt.widgets.Control;
-import org.eclipse.swt.widgets.Menu;
-import org.eclipse.swt.widgets.TreeItem;
-import org.eclipse.ui.views.contentoutline.ContentOutlinePage;
-
-public class HdlContentOutlinePage extends ContentOutlinePage implements IDoubleClickListener
-{
-	private HdlEditor editor;
-	private static final String FILTER_SIGNAL_ACTION_IMAGE="$nl$/icons/filter_signal.gif";
-	private static final String FILTER_PORT_ACTION_IMAGE="$nl$/icons/filter_port.gif";
-	private static final String ENABLE_SORT_ACTION_IMAGE="$nl$/icons/sort.gif";
-	
-	private boolean m_bFilterSignals;
-	private boolean m_bPortSignals;
-	private boolean enableSort;
-
-	public HdlContentOutlinePage(HdlEditor editor) {
-		super();
-		this.editor = editor;
-		m_bFilterSignals = VerilogPlugin.getPreferenceBoolean("Outline.FilterSignals");
-		m_bPortSignals = VerilogPlugin.getPreferenceBoolean("Outline.FilterPorts");
-		enableSort = VerilogPlugin.getPreferenceBoolean("Outline.Sort");
-	}
-
-	public void createControl(Composite parent) {
-		super.createControl(parent);
-
-		TreeViewer viewer = getTreeViewer();
-		viewer.setContentProvider(new HdlContentOutlineProvider());
-		viewer.setLabelProvider(editor.getOutlineLabelProvider());
-		viewer.addSelectionChangedListener(this);
-		viewer.addDoubleClickListener(this);
-		viewer.addFilter(new SignalFilter());
-		viewer.addFilter(new PortFilter());
-		if (enableSort) {
-			viewer.setSorter(new Sorter());
-		}
-		createToolbar();
-		createContextMenu(viewer.getTree());
-
-		IDocument doc = editor.getDocument();
-		if (doc != null) {
-			viewer.setInput(doc);
-		}
-
-	}
-
-	
-	private void createToolbar(){
-		IToolBarManager mgr = getSite().getActionBars().getToolBarManager();
-		mgr.add(new EnableSortAction());
-        mgr.add(new SignalFilterAction());
-        mgr.add(new PortFilterAction());
-        mgr.add(new CollapseAllAction());
-	}
-	
-	/**
-	 * Creates a context menu for this view
-	 * @param control
-	 */
-	private void createContextMenu(Control control)
-	{
-		MenuManager menuManager = new MenuManager();
-		menuManager.setRemoveAllWhenShown(true);
-		menuManager.addMenuListener(new IMenuListener() {
-			public void menuAboutToShow(IMenuManager menu)
-			{			
-				menu.add(new CollapseAllAction());
-			}
-		});
-		Menu menu = menuManager.createContextMenu(control);		
-		control.setMenu(menu);			
-	}
-	
-	public void selectionChanged(SelectionChangedEvent event)
-	{
-		super.selectionChanged(event);
-
-		ISelection selection = event.getSelection();
-
-		if (!selection.isEmpty())
-		{
-			OutlineElement outlineElement =
-				(OutlineElement) ((IStructuredSelection)selection).getFirstElement();			
-					
-			editor.showElement(outlineElement);						
-		}
-	}
-
-	public void doubleClick(DoubleClickEvent event)
-	{
-		//VerilogPlugin.println("doubleclicked in ContentPage\n");
-		ISelection selection = event.getSelection();
-		//VerilogPlugin.println("selection "+selection.toString());
-		
-		if (selection instanceof IStructuredSelection)
-		{
-			IStructuredSelection elements = (IStructuredSelection)selection;
-			if (elements.size() == 1)
-			{
-				Object element = elements.getFirstElement();
-				//VerilogPlugin.println("element "+element.toString());
-				if (element instanceof OutlineElement) {
-					OutlineElement outlineElement = (OutlineElement) element;
-					
-					//VerilogPlugin.println("outlineElement "+outlineElement.toString());
-					
-					//ITreeContentProvider prov = editor.getHirarchyProvider();
-					ITreeContentProvider prov = HdlEditor.current().getHirarchyProvider();
-					
-					if(prov instanceof VhdlHierarchyProvider) {
-						String componenttype = outlineElement.getType();
-						((VhdlHierarchyProvider)(prov)).scanOutline(new VhdlDocument(editor.getHdlDocument().getProject(),outlineElement.getFile()));
-						//VerilogPlugin.println("VhdlHierarchyProvider!!! "+ componenttype);
-						if(componenttype.startsWith("componentInst#")) {
-							componenttype = componenttype.substring(14);
-							//VerilogPlugin.println("comptype: "+ componenttype);
-							ArchitectureElement el = ((VhdlHierarchyProvider)(prov)).getArchElement(componenttype);
-							if(el!=null) {
-								//VerilogPlugin.println("showelement "+el);
-								editor.showElement(el);
-							}
-						}
-						if(componenttype.startsWith("entityInst#")) {
-							EntityInstElement entityInst = (EntityInstElement)outlineElement;
-							
-							ArchitectureElement el = ((VhdlHierarchyProvider)(prov)).getArchElement(entityInst.GetEntityName());
-							if(el!=null) {
-								editor.showElement(el);
-							}
-						}
-					}
-				}
-			}
-		}
-	}
-	
-	/**
-	 * Searches throught the tree item recursively and looks the specified element
-	 * @paaram element
-	 * @param item
-	 * @return
-	 */
-	protected TreeItem findTreeItem(TreeItem item,OutlineElement element){
-		if (item.getData() instanceof OutlineElement) {
-			OutlineElement e = (OutlineElement) item.getData();
-			if(e.equals(element)){
-				return item;
-			}			
-		}
-		//look through the children
-		for(TreeItem child:item.getItems()){
-			TreeItem temp=findTreeItem(child,element);
-			if(temp!=null){
-				return temp;
-			}
-		}
-		
-		return null;
-	}
-	
-	/**
-	 * Searches for the given element and if found, makes it visible
-	 * @param element
-	 */
-	public void showElement(OutlineElement element){
-		if(element == null)
-			return;
-		TreeViewer viewer = getTreeViewer();		
-		viewer.reveal(element);				
-		TreeItem[] treeItems=viewer.getTree().getItems();
-		
-		viewer.getControl().setRedraw(false);
-		Object[] expandedElements=viewer.getExpandedElements();
-		//force all the elements to be scanned in
-		viewer.expandAll();		
-		viewer.setExpandedElements(expandedElements);
-		viewer.getControl().setRedraw(true);
-		
-		for(TreeItem item: treeItems){
-			TreeItem target=findTreeItem(item, element);
-			if(target!=null){
-				viewer.getTree().setSelection(target);
-				viewer.reveal(element);
-				break;
-			}
-		}				
-		
-	}
-	
-	public void setInput(Object input)
-	{
-		//update();
-	}
-
-	public void update()
-	{
-		TreeViewer viewer = getTreeViewer();
-
-		if (viewer != null)
-		{
-			if (enableSort)
-				viewer.setSorter(new Sorter());
-			else
-				viewer.setSorter(null);
-
-			Control control = viewer.getControl();
-			if (control != null && !control.isDisposed())
-			{				
-				Object expanded[]=viewer.getExpandedElements();
-				control.setRedraw(false);				 
-				viewer.setInput(editor.getDocument());					
-				if(expanded.length >0){
-					viewer.setExpandedElements(expanded);
-				}
-				else{
-					viewer.collapseAll();
-				}
-				control.setRedraw(true);
-			}
-		}
-	}
-	
-	private class SignalFilter extends ViewerFilter {
-
-		public boolean select(Viewer viewer, Object parentElement,
-				Object element) {
-
-			if (m_bFilterSignals) {
-				if (element instanceof VhdlSignalElement) {
-					return false;
-				}
-				if (element instanceof VerilogSignalElement) {
-					return false;
-				}
-			}
-			return true;
-		}
-
-	}
-
-	private class PortFilter extends ViewerFilter {
-
-		public boolean select(Viewer viewer, Object parentElement,
-				Object element) {
-
-			if (m_bPortSignals) {
-				if (element instanceof VhdlPortElement) {
-					return false;
-				}
-				if (element instanceof VerilogPortElement) {
-					return false;
-				}
-			}
-			return true;
-		}
-
-	}
-	
-	/**
-	 * Class used to sort the outline elements
-	 *
-	 */
-	private class Sorter extends ViewerSorter{
-		/**
-		 * Called to determine whether an object is sortable or not
-		 */
-		public boolean isSorterProperty(Object element, String property) {
-			return super.isSorterProperty(element, property);
-		}
-		public int compare(Viewer viewer, Object e1, Object e2) {
-			return super.compare(viewer,e1,e2);
-		}
-		public int category(Object element) {
-			//vhdl categories			
-			if (element instanceof PackageDeclElement) return 10;
-			if (element instanceof PackageBodyElement) return 15;
-			if (element instanceof EntityDeclElement) return 20;
-			if (element instanceof ComponentDeclElement) return 20;
-			if (element instanceof EntityDeclElement) return 20;
-			if (element instanceof ArchitectureElement) return 30;
-			if (element instanceof GenericElement) return 40;
-			if (element instanceof VhdlPortElement) return 45;
-			if (element instanceof ConstantElement) return 50;
-			if (element instanceof AliasElement) return 60;
-			if (element instanceof VhdlSignalElement) return 70;
-			if (element instanceof EntityInstElement) return 80;
-			if (element instanceof ComponentInstElement) return 80;
-			if (element instanceof VerilogFunctionElement) return 90;
-			if (element instanceof ProcedureElement) return 90;
-			if (element instanceof ProcessElement) return 100;
-			
-			
-			//verilog elements can go here			
-			if (element instanceof VerilogModuleElement) return 10;
-			if (element instanceof VerilogFunctionElement) return 14;
-			if (element instanceof VerilogTaskElement) return 15;			
-			if (element instanceof VerilogParameterElement) return 20;
-			if (element instanceof VerilogPortElement) return 30;
-			if (element instanceof VerilogRegElement) return 40;
-			if (element instanceof VerilogWireElement) return 50;			
-			if (element instanceof VerilogSignalElement) return 60;
-			if (element instanceof VerilogInstanceElement) return 70;
-			//default sort
-			return 100000;
-		}
-	}
-	
-	private class SignalFilterAction extends Action {
-		public SignalFilterAction() {
-			super();
-			setText("Filter Signal");
-			setChecked(m_bFilterSignals);
-		}
-
-		public void run() {
-			m_bFilterSignals = !m_bFilterSignals;
-			update();
-		}
-
-		public ImageDescriptor getImageDescriptor() {
-			return VerilogPlugin.getPlugin().getImageDescriptor(
-					FILTER_SIGNAL_ACTION_IMAGE);
-		}
-
-		public int getStyle() {
-			return AS_CHECK_BOX;
-		}
-
-		public String getToolTipText() {
-			return "Filter signals";
-		}
-	}
-
-	private class PortFilterAction extends Action {
-		public PortFilterAction() {
-			super();
-			setText("Filter Port");
-			setChecked(m_bPortSignals);
-		}
-
-		public void run() {
-			m_bPortSignals = !m_bPortSignals;
-			update();
-		}
-
-		public ImageDescriptor getImageDescriptor() {
-			return VerilogPlugin.getPlugin().getImageDescriptor(
-					FILTER_PORT_ACTION_IMAGE);
-		}
-
-		public int getStyle() {
-			return AS_CHECK_BOX;
-		}
-
-		public String getToolTipText() {
-			return "Filter ports";
-		}
-	}
-
-	private class EnableSortAction extends Action {
-		public EnableSortAction() {
-			super();
-			setText("Sort");
-			setChecked(enableSort);
-		}
-
-		public void run() {
-			enableSort = !enableSort;
-			update();
-		}
-
-		public ImageDescriptor getImageDescriptor() {
-			return VerilogPlugin.getPlugin().getImageDescriptor(
-					ENABLE_SORT_ACTION_IMAGE);
-		}
-
-		public int getStyle() {
-			return AS_CHECK_BOX;
-		}
-
-		public String getToolTipText() {
-			return "Sort";
-		}
-	}
-	
-	private class CollapseAllAction extends Action	
-	{
-		private static final String COLLAPSE_ALL_ACTION_IMAGE="$nl$/icons/collapse_all.gif";
-		public CollapseAllAction()
-		{
-			super();
-			setText("Collapse All");
-		}
-		public void run()
-		{
-			TreeViewer viewer = getTreeViewer();
-			viewer.collapseAll();
-		}
-		public ImageDescriptor getImageDescriptor(){
-			return VerilogPlugin.getPlugin().getImageDescriptor(COLLAPSE_ALL_ACTION_IMAGE);
-		}
-		public int getStyle(){
-			return AS_PUSH_BUTTON;
-		}
-		public String getToolTipText(){
-			return "Collapse all";
-		}
-	}
-}
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+
+package com.elphel.vdt.veditor.editor;
+
+
+import com.elphel.vdt.veditor.VerilogPlugin;
+import com.elphel.vdt.veditor.editor.VhdlHierarchyProvider;
+import com.elphel.vdt.veditor.document.VhdlDocument;
+import com.elphel.vdt.veditor.parser.OutlineElement;
+import com.elphel.vdt.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogFunctionElement;
+import com.elphel.vdt.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogInstanceElement;
+import com.elphel.vdt.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogModuleElement;
+import com.elphel.vdt.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogParameterElement;
+import com.elphel.vdt.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogPortElement;
+import com.elphel.vdt.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogRegElement;
+import com.elphel.vdt.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogSignalElement;
+import com.elphel.vdt.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogTaskElement;
+import com.elphel.vdt.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogWireElement;
+import com.elphel.vdt.veditor.parser.vhdl.VhdlOutlineElementFactory.AliasElement;
+import com.elphel.vdt.veditor.parser.vhdl.VhdlOutlineElementFactory.ArchitectureElement;
+import com.elphel.vdt.veditor.parser.vhdl.VhdlOutlineElementFactory.ComponentDeclElement;
+import com.elphel.vdt.veditor.parser.vhdl.VhdlOutlineElementFactory.ComponentInstElement;
+import com.elphel.vdt.veditor.parser.vhdl.VhdlOutlineElementFactory.ConstantElement;
+import com.elphel.vdt.veditor.parser.vhdl.VhdlOutlineElementFactory.EntityDeclElement;
+import com.elphel.vdt.veditor.parser.vhdl.VhdlOutlineElementFactory.EntityInstElement;
+import com.elphel.vdt.veditor.parser.vhdl.VhdlOutlineElementFactory.GenericElement;
+import com.elphel.vdt.veditor.parser.vhdl.VhdlOutlineElementFactory.PackageBodyElement;
+import com.elphel.vdt.veditor.parser.vhdl.VhdlOutlineElementFactory.PackageDeclElement;
+import com.elphel.vdt.veditor.parser.vhdl.VhdlOutlineElementFactory.ProcedureElement;
+import com.elphel.vdt.veditor.parser.vhdl.VhdlOutlineElementFactory.ProcessElement;
+import com.elphel.vdt.veditor.parser.vhdl.VhdlOutlineElementFactory.VhdlPortElement;
+import com.elphel.vdt.veditor.parser.vhdl.VhdlOutlineElementFactory.VhdlSignalElement;
+
+import org.eclipse.jface.action.Action;
+import org.eclipse.jface.action.IMenuListener;
+import org.eclipse.jface.action.IMenuManager;
+import org.eclipse.jface.action.IToolBarManager;
+import org.eclipse.jface.action.MenuManager;
+import org.eclipse.jface.resource.ImageDescriptor;
+import org.eclipse.jface.text.IDocument;
+import org.eclipse.jface.viewers.DoubleClickEvent;
+import org.eclipse.jface.viewers.IDoubleClickListener;
+import org.eclipse.jface.viewers.ISelection;
+import org.eclipse.jface.viewers.IStructuredSelection;
+import org.eclipse.jface.viewers.ITreeContentProvider;
+import org.eclipse.jface.viewers.SelectionChangedEvent;
+import org.eclipse.jface.viewers.TreeViewer;
+import org.eclipse.jface.viewers.Viewer;
+import org.eclipse.jface.viewers.ViewerFilter;
+import org.eclipse.jface.viewers.ViewerSorter;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Menu;
+import org.eclipse.swt.widgets.TreeItem;
+import org.eclipse.ui.views.contentoutline.ContentOutlinePage;
+
+public class HdlContentOutlinePage extends ContentOutlinePage implements IDoubleClickListener
+{
+	private HdlEditor editor;
+	private static final String FILTER_SIGNAL_ACTION_IMAGE="$nl$/icons/filter_signal.gif";
+	private static final String FILTER_PORT_ACTION_IMAGE="$nl$/icons/filter_port.gif";
+	private static final String FILTER_PARAMETER_ACTION_IMAGE="$nl$/icons/filter_parameter.png";
+	
+	
+	private static final String ENABLE_SORT_ACTION_IMAGE="$nl$/icons/sort.gif";
+	
+	private boolean m_bFilterSignals;
+	private boolean m_bPortSignals;
+	private boolean m_bParameterSignals;
+	private boolean enableSort;
+
+	public HdlContentOutlinePage(HdlEditor editor) {
+		super();
+		this.editor = editor;
+		m_bFilterSignals = VerilogPlugin.getPreferenceBoolean("Outline.FilterSignals");
+		m_bPortSignals = VerilogPlugin.getPreferenceBoolean("Outline.FilterPorts");
+		m_bParameterSignals = VerilogPlugin.getPreferenceBoolean("Outline.FilterParameters");
+		enableSort = VerilogPlugin.getPreferenceBoolean("Outline.Sort");
+	}
+
+	public void createControl(Composite parent) {
+		super.createControl(parent);
+
+		TreeViewer viewer = getTreeViewer();
+		viewer.setContentProvider(new HdlContentOutlineProvider());
+		viewer.setLabelProvider(editor.getOutlineLabelProvider());
+		viewer.addSelectionChangedListener(this);
+		viewer.addDoubleClickListener(this);
+		viewer.addFilter(new SignalFilter());
+		viewer.addFilter(new PortFilter());
+		viewer.addFilter(new ParameterFilter());
+		if (enableSort) {
+			viewer.setSorter(new Sorter());
+		}
+		createToolbar();
+		createContextMenu(viewer.getTree());
+
+		IDocument doc = editor.getDocument();
+		if (doc != null) {
+			viewer.setInput(doc);
+		}
+
+	}
+
+	
+	private void createToolbar(){
+		IToolBarManager mgr = getSite().getActionBars().getToolBarManager();
+		mgr.add(new EnableSortAction());
+        mgr.add(new SignalFilterAction());
+        mgr.add(new PortFilterAction());
+        mgr.add(new ParameterFilterAction());
+        mgr.add(new CollapseAllAction());
+	}
+	
+	/**
+	 * Creates a context menu for this view
+	 * @param control
+	 */
+	private void createContextMenu(Control control)
+	{
+		MenuManager menuManager = new MenuManager();
+		menuManager.setRemoveAllWhenShown(true);
+		menuManager.addMenuListener(new IMenuListener() {
+			public void menuAboutToShow(IMenuManager menu)
+			{			
+				menu.add(new CollapseAllAction());
+			}
+		});
+		Menu menu = menuManager.createContextMenu(control);		
+		control.setMenu(menu);			
+	}
+	
+	public void selectionChanged(SelectionChangedEvent event)
+	{
+		super.selectionChanged(event);
+
+		ISelection selection = event.getSelection();
+
+		if (!selection.isEmpty())
+		{
+			OutlineElement outlineElement =
+				(OutlineElement) ((IStructuredSelection)selection).getFirstElement();			
+					
+			editor.showElement(outlineElement);						
+		}
+	}
+
+	public void doubleClick(DoubleClickEvent event)
+	{
+		//VerilogPlugin.println("doubleclicked in ContentPage\n");
+		ISelection selection = event.getSelection();
+		//VerilogPlugin.println("selection "+selection.toString());
+		
+		if (selection instanceof IStructuredSelection)
+		{
+			IStructuredSelection elements = (IStructuredSelection)selection;
+			if (elements.size() == 1)
+			{
+				Object element = elements.getFirstElement();
+				//VerilogPlugin.println("element "+element.toString());
+				if (element instanceof OutlineElement) {
+					OutlineElement outlineElement = (OutlineElement) element;
+					
+					//VerilogPlugin.println("outlineElement "+outlineElement.toString());
+					
+					//ITreeContentProvider prov = editor.getHirarchyProvider();
+					ITreeContentProvider prov = HdlEditor.current().getHirarchyProvider();
+					
+					if(prov instanceof VhdlHierarchyProvider) {
+						String componenttype = outlineElement.getType();
+						((VhdlHierarchyProvider)(prov)).scanOutline(new VhdlDocument(editor.getHdlDocument().getProject(),outlineElement.getFile()));
+						//VerilogPlugin.println("VhdlHierarchyProvider!!! "+ componenttype);
+						if(componenttype.startsWith("componentInst#")) {
+							componenttype = componenttype.substring(14);
+							//VerilogPlugin.println("comptype: "+ componenttype);
+							ArchitectureElement el = ((VhdlHierarchyProvider)(prov)).getArchElement(componenttype);
+							if(el!=null) {
+								//VerilogPlugin.println("showelement "+el);
+								editor.showElement(el);
+							}
+						}
+						if(componenttype.startsWith("entityInst#")) {
+							EntityInstElement entityInst = (EntityInstElement)outlineElement;
+							
+							ArchitectureElement el = ((VhdlHierarchyProvider)(prov)).getArchElement(entityInst.GetEntityName());
+							if(el!=null) {
+								editor.showElement(el);
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+	
+	/**
+	 * Searches through the tree item recursively and looks the specified element
+	 * @param element
+	 * @param item
+	 * @return
+	 */
+	protected TreeItem findTreeItem(TreeItem item,OutlineElement element){
+		if (item.getData() instanceof OutlineElement) {
+			OutlineElement e = (OutlineElement) item.getData();
+			if(e.equals(element)){
+				return item;
+			}			
+		}
+		//look through the children
+		for(TreeItem child:item.getItems()){
+			TreeItem temp=findTreeItem(child,element);
+			if(temp!=null){
+				return temp;
+			}
+		}
+		
+		return null;
+	}
+	
+	/**
+	 * Searches for the given element and if found, makes it visible
+	 * @param element
+	 */
+	public void showElement(OutlineElement element){
+		if(element == null)
+			return;
+		TreeViewer viewer = getTreeViewer();		
+		viewer.reveal(element);				
+		TreeItem[] treeItems=viewer.getTree().getItems();
+		
+		viewer.getControl().setRedraw(false);
+		Object[] expandedElements=viewer.getExpandedElements();
+		//force all the elements to be scanned in
+		viewer.expandAll();		
+		viewer.setExpandedElements(expandedElements);
+		viewer.getControl().setRedraw(true);
+		
+		for(TreeItem item: treeItems){
+			TreeItem target=findTreeItem(item, element);
+			if(target!=null){
+				viewer.getTree().setSelection(target);
+				viewer.reveal(element);
+				break;
+			}
+		}				
+		
+	}
+	
+	public void setInput(Object input)
+	{
+		//update();
+	}
+
+	public void update()
+	{
+		TreeViewer viewer = getTreeViewer();
+
+		if (viewer != null)
+		{
+			if (enableSort)
+				viewer.setSorter(new Sorter());
+			else
+				viewer.setSorter(null);
+
+			Control control = viewer.getControl();
+			if (control != null && !control.isDisposed())
+			{				
+				Object expanded[]=viewer.getExpandedElements();
+				control.setRedraw(false);				 
+				viewer.setInput(editor.getDocument());					
+				if(expanded.length >0){
+					viewer.setExpandedElements(expanded);
+				}
+				else{
+					viewer.collapseAll();
+				}
+				control.setRedraw(true);
+			}
+		}
+	}
+	
+	private class SignalFilter extends ViewerFilter {
+
+		public boolean select(Viewer viewer, Object parentElement,
+				Object element) {
+
+			if (m_bFilterSignals) {
+				if (element instanceof VhdlSignalElement) {
+					return false;
+				}
+				if (element instanceof VerilogSignalElement) {
+					return false;
+				}
+			}
+			return true;
+		}
+
+	}
+
+	private class PortFilter extends ViewerFilter {
+
+		public boolean select(Viewer viewer, Object parentElement,
+				Object element) {
+
+			if (m_bPortSignals) {
+				if (element instanceof VhdlPortElement) {
+					return false;
+				}
+				if (element instanceof VerilogPortElement) {
+					return false;
+				}
+			}
+			return true;
+		}
+
+	}
+	private class ParameterFilter extends ViewerFilter {
+
+		public boolean select(Viewer viewer, Object parentElement,
+				Object element) {
+
+			if (m_bParameterSignals) {
+				if (element instanceof VerilogParameterElement) {
+					return false;
+				}
+			}
+			return true;
+		}
+
+	}
+	
+	/**
+	 * Class used to sort the outline elements
+	 *
+	 */
+	private class Sorter extends ViewerSorter{
+		/**
+		 * Called to determine whether an object is sortable or not
+		 */
+		public boolean isSorterProperty(Object element, String property) {
+			return super.isSorterProperty(element, property);
+		}
+		public int compare(Viewer viewer, Object e1, Object e2) {
+			return super.compare(viewer,e1,e2);
+		}
+		public int category(Object element) {
+			//vhdl categories			
+			if (element instanceof PackageDeclElement) return 10;
+			if (element instanceof PackageBodyElement) return 15;
+			if (element instanceof EntityDeclElement) return 20;
+			if (element instanceof ComponentDeclElement) return 20;
+			if (element instanceof EntityDeclElement) return 20;
+			if (element instanceof ArchitectureElement) return 30;
+			if (element instanceof GenericElement) return 40;
+			if (element instanceof VhdlPortElement) return 45;
+			if (element instanceof ConstantElement) return 50;
+			if (element instanceof AliasElement) return 60;
+			if (element instanceof VhdlSignalElement) return 70;
+			if (element instanceof EntityInstElement) return 80;
+			if (element instanceof ComponentInstElement) return 80;
+			if (element instanceof VerilogFunctionElement) return 90;
+			if (element instanceof ProcedureElement) return 90;
+			if (element instanceof ProcessElement) return 100;
+			
+			
+			//verilog elements can go here			
+			if (element instanceof VerilogModuleElement) return 10;
+			if (element instanceof VerilogFunctionElement) return 14;
+			if (element instanceof VerilogTaskElement) return 15;			
+			if (element instanceof VerilogParameterElement) return 20;
+			if (element instanceof VerilogPortElement) return 30;
+			if (element instanceof VerilogRegElement) return 40;
+			if (element instanceof VerilogWireElement) return 50;			
+			if (element instanceof VerilogSignalElement) return 60;
+			if (element instanceof VerilogInstanceElement) return 70;
+			//default sort
+			return 100000;
+		}
+	}
+	
+	private class SignalFilterAction extends Action {
+		public SignalFilterAction() {
+			super();
+			setText("Filter Signal");
+			setChecked(m_bFilterSignals);
+		}
+
+		public void run() {
+			m_bFilterSignals = !m_bFilterSignals;
+			update();
+		}
+
+		public ImageDescriptor getImageDescriptor() {
+			return VerilogPlugin.getPlugin().getImageDescriptor(
+					FILTER_SIGNAL_ACTION_IMAGE);
+		}
+
+		public int getStyle() {
+			return AS_CHECK_BOX;
+		}
+
+		public String getToolTipText() {
+			return "Filter signals";
+		}
+	}
+
+	private class PortFilterAction extends Action {
+		public PortFilterAction() {
+			super();
+			setText("Filter Port");
+			setChecked(m_bPortSignals);
+		}
+
+		public void run() {
+			m_bPortSignals = !m_bPortSignals;
+			update();
+		}
+
+		public ImageDescriptor getImageDescriptor() {
+			return VerilogPlugin.getPlugin().getImageDescriptor(
+					FILTER_PORT_ACTION_IMAGE);
+		}
+
+		public int getStyle() {
+			return AS_CHECK_BOX;
+		}
+
+		public String getToolTipText() {
+			return "Filter ports";
+		}
+	}
+
+	private class ParameterFilterAction extends Action {
+		public ParameterFilterAction() {
+			super();
+			setText("Filter Parameters");
+			setChecked(m_bParameterSignals);
+		}
+
+		public void run() {
+			m_bParameterSignals = !m_bParameterSignals;
+			update();
+		}
+
+		public ImageDescriptor getImageDescriptor() {
+			return VerilogPlugin.getPlugin().getImageDescriptor(
+					FILTER_PARAMETER_ACTION_IMAGE);
+		}
+
+		public int getStyle() {
+			return AS_CHECK_BOX;
+		}
+
+		public String getToolTipText() {
+			return "Filter parameters";
+		}
+	}
+	
+	
+	private class EnableSortAction extends Action {
+		public EnableSortAction() {
+			super();
+			setText("Sort");
+			setChecked(enableSort);
+		}
+
+		public void run() {
+			enableSort = !enableSort;
+			update();
+		}
+
+		public ImageDescriptor getImageDescriptor() {
+			return VerilogPlugin.getPlugin().getImageDescriptor(
+					ENABLE_SORT_ACTION_IMAGE);
+		}
+
+		public int getStyle() {
+			return AS_CHECK_BOX;
+		}
+
+		public String getToolTipText() {
+			return "Sort";
+		}
+	}
+	
+	private class CollapseAllAction extends Action	
+	{
+		private static final String COLLAPSE_ALL_ACTION_IMAGE="$nl$/icons/collapse_all.gif";
+		public CollapseAllAction()
+		{
+			super();
+			setText("Collapse All");
+		}
+		public void run()
+		{
+			TreeViewer viewer = getTreeViewer();
+			viewer.collapseAll();
+		}
+		public ImageDescriptor getImageDescriptor(){
+			return VerilogPlugin.getPlugin().getImageDescriptor(COLLAPSE_ALL_ACTION_IMAGE);
+		}
+		public int getStyle(){
+			return AS_PUSH_BUTTON;
+		}
+		public String getToolTipText(){
+			return "Collapse all";
+		}
+	}
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/editor/HdlContentOutlineProvider.java vdt/src/com/elphel/vdt/veditor/editor/HdlContentOutlineProvider.java
--- vdt-veditor/src/com/elphel/vdt/veditor/editor/HdlContentOutlineProvider.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/editor/HdlContentOutlineProvider.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,46 +1,57 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-
-package net.sourceforge.veditor.editor;
-
-import java.util.Vector;
-
-import net.sourceforge.veditor.parser.OutlineElement;
-
-/**
- * parse source code for ContentOutline
- */
-public class HdlContentOutlineProvider extends HdlTreeProviderBase
-{
-	public Object[] getChildren(Object parentElement)
-	{
-		if (parentElement instanceof OutlineElement)
-		{
-			OutlineElement e = (OutlineElement)parentElement;
-			Vector<Object> results=new Vector<Object>();
-			OutlineElement[] children=e.getChildren();
-			for(int i=0;i<children.length;i++){
-				if (children[i].isVisible()){
-					results.add(children[i]);
-				}
-			}
-			
-			return results.toArray();
-		}
-		return null;
-	}
-}
-
-
-
-
-
-
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+
+package com.elphel.vdt.veditor.editor;
+
+import java.util.Vector;
+
+import com.elphel.vdt.veditor.parser.OutlineElement;
+
+/**
+ * parse source code for ContentOutline
+ */
+public class HdlContentOutlineProvider extends HdlTreeProviderBase
+{
+	public Object[] getChildren(Object parentElement)
+	{
+		if (parentElement instanceof OutlineElement)
+		{
+			OutlineElement e = (OutlineElement)parentElement;
+			Vector<Object> results=new Vector<Object>();
+			OutlineElement[] children=e.getChildren();
+			for(int i=0;i<children.length;i++){
+				if (children[i].isVisible()){
+					results.add(children[i]);
+				}
+			}
+			
+			return results.toArray();
+		}
+		return null;
+	}
+}
+
+
+
+
+
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/editor/HdlEditor.java vdt/src/com/elphel/vdt/veditor/editor/HdlEditor.java
--- vdt-veditor/src/com/elphel/vdt/veditor/editor/HdlEditor.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/editor/HdlEditor.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,836 +1,1249 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-
-package net.sourceforge.veditor.editor;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.Set;
-
-import net.sourceforge.veditor.VerilogPlugin;
-import net.sourceforge.veditor.actions.ClearErrorMarkersAction;
-import net.sourceforge.veditor.actions.CollapseAll;
-import net.sourceforge.veditor.actions.CommentAction;
-import net.sourceforge.veditor.actions.CompileAction;
-import net.sourceforge.veditor.actions.ExpandAll;
-import net.sourceforge.veditor.actions.FormatAction;
-import net.sourceforge.veditor.actions.GotoMatchingBracketAction;
-import net.sourceforge.veditor.actions.HdlShowInNavigatorAction;
-import net.sourceforge.veditor.actions.OpenDeclarationAction;
-import net.sourceforge.veditor.actions.ShowInHierarchy;
-import net.sourceforge.veditor.actions.ShowInOutline;
-import net.sourceforge.veditor.actions.SynthesizeAction;
-import net.sourceforge.veditor.actions.UnCommentAction;
-import net.sourceforge.veditor.document.HdlDocument;
-import net.sourceforge.veditor.parser.HdlParserException;
-import net.sourceforge.veditor.parser.OutlineContainer;
-import net.sourceforge.veditor.parser.OutlineElement;
-import net.sourceforge.veditor.parser.OutlineContainer.Collapsible;
-import net.sourceforge.veditor.preference.PreferenceStrings;
-
-import org.eclipse.core.resources.IFile;
-import org.eclipse.core.resources.IProject;
-import org.eclipse.core.runtime.CoreException;
-import org.eclipse.core.runtime.IProgressMonitor;
-import org.eclipse.jface.action.IAction;
-import org.eclipse.jface.action.IContributionItem;
-import org.eclipse.jface.action.IMenuManager;
-import org.eclipse.jface.action.MenuManager;
-import org.eclipse.jface.action.Separator;
-import org.eclipse.jface.text.BadLocationException;
-import org.eclipse.jface.text.IDocument;
-import org.eclipse.jface.text.IRegion;
-import org.eclipse.jface.text.Position;
-import org.eclipse.jface.text.source.ISourceViewer;
-import org.eclipse.jface.text.source.IVerticalRuler;
-import org.eclipse.jface.text.source.projection.ProjectionAnnotation;
-import org.eclipse.jface.text.source.projection.ProjectionAnnotationModel;
-import org.eclipse.jface.text.source.projection.ProjectionSupport;
-import org.eclipse.jface.text.source.projection.ProjectionViewer;
-import org.eclipse.jface.viewers.IBaseLabelProvider;
-import org.eclipse.jface.viewers.ITreeContentProvider;
-import org.eclipse.swt.graphics.Point;
-import org.eclipse.swt.widgets.Composite;
-import org.eclipse.swt.widgets.Display;
-import org.eclipse.ui.IEditorDescriptor;
-import org.eclipse.ui.IEditorInput;
-import org.eclipse.ui.IEditorPart;
-import org.eclipse.ui.IWorkbenchPage;
-import org.eclipse.ui.PartInitException;
-import org.eclipse.ui.PlatformUI;
-import org.eclipse.ui.editors.text.TextEditor;
-import org.eclipse.ui.ide.IDE;
-import org.eclipse.ui.part.FileEditorInput;
-import org.eclipse.ui.texteditor.IDocumentProvider;
-import org.eclipse.ui.texteditor.ITextEditorActionDefinitionIds;
-import org.eclipse.ui.texteditor.TextOperationAction;
-import org.eclipse.ui.views.contentoutline.IContentOutlinePage;
-import org.eclipse.core.runtime.preferences.IEclipsePreferences;
-import org.eclipse.core.runtime.preferences.IEclipsePreferences.PreferenceChangeEvent;
-import org.eclipse.core.runtime.preferences.InstanceScope;
-
-
-/**
- *  main class
- */
-abstract public class HdlEditor extends TextEditor
-{
-	private ColorManager colorManager;
-	private HdlContentOutlinePage outlinePage;
-	protected IBaseLabelProvider OutlineLabelProvider;
-	protected ITreeContentProvider TreeContentProvider;
-	protected static HdlEditor current;
-	protected ProjectionSupport m_ProjectionSupport;	
-	protected HashMap<Collapsible,ProjectionAnnotation> m_CollapsibleElements;
-	protected boolean m_bInitialShowing;
-	
-	public static HdlEditor current()
-	{
-		return current;
-	}
-	
-	public HdlEditor()
-	{
-		super();
-
-		setCurrent();
-		colorManager = new ColorManager();	
-		HdlTextAttribute.init();	
-		m_bInitialShowing=true;
-		m_CollapsibleElements=new HashMap<Collapsible,ProjectionAnnotation>();
-		
-		
-		
-	}	
-	
-	/**
-	 * Makes this instance of the editor the current one
-	 * @return the old editor
-	 */
-	public HdlEditor setCurrent(){
-		HdlEditor old=current;
-		current = this;
-		return old;
-	}
-		
-	public void updatePartControl(IEditorInput input)
-	{
-		super.updatePartControl(input);
-		setInputPages(input);
-	}
-
-	protected void initializeKeyBindingScopes()
-	{
-		setKeyBindingScopes(new String[] { "net.sourceforge.veditor.scope" });
-	}
-
-	public IDocument getDocument()
-	{
-		IEditorInput editorInput=getEditorInput();
-		IDocumentProvider provider=getDocumentProvider();
-		
-		if(provider != null && editorInput!=null){
-			return provider.getDocument(editorInput);
-		}
-		
-		return null;
-		
-	}
-
-	protected void createActions()
-	{
-		super.createActions();
-
-		// add content assist action
-		IAction action;
-		action =
-			new TextOperationAction(
-				EditorMessages.getResourceBundle(),
-				"ContentAssistProposal.",
-				this,
-				ISourceViewer.CONTENTASSIST_PROPOSALS);
-		action.setActionDefinitionId(ITextEditorActionDefinitionIds.CONTENT_ASSIST_PROPOSALS);
-		setAction("ContentAssistProposal", action);
-
-		// add special actions
-		setAction("GotoMatchingBracket", new GotoMatchingBracketAction());
-		setAction("OpenDeclaration", new OpenDeclarationAction());
-		setAction("Format", new FormatAction());
-		setAction("Compile", new CompileAction());
-		setAction("Synthesize", new SynthesizeAction());
-		setAction("Comment", new CommentAction());
-		setAction("Uncomment", new UnCommentAction());
-		setAction("CollapseAll",new CollapseAll());
-		setAction("ExpandAll",new ExpandAll());
-		setAction("ShowInHierarchy",new ShowInHierarchy());
-		setAction("ShowInOutline",new ShowInOutline());
-		setAction(HdlShowInNavigatorAction.ID,new HdlShowInNavigatorAction());
-		setAction(ClearErrorMarkersAction.ID,new ClearErrorMarkersAction());
-		
-	}
-
-//	for content assist?
-//	public void editorContextMenuAboutToShow(MenuManager menu)
-//	{
-//		super.editorContextMenuAboutToShow(menu);
-//		addAction(menu, "ContentAssistProposal");
-//		addAction(menu, "ContentAssistTip");
-//	}
-
-	public void dispose()
-	{
-		colorManager.dispose();
-		setInputPages(null);
-		storeCollapsibleStates();
-		super.dispose();
-	}
-
-	public void doRevertToSaved()
-	{
-		super.doRevertToSaved();
-		updatePages();
-	}
-
-	public void doSave(IProgressMonitor monitor)
-	{
-		super.doSave(monitor);
-		updatePages();
-	}
-
-	public void doSaveAs()
-	{
-		super.doSaveAs();
-		updatePages();
-	}
-	
-	public void expandAll(){
-		getAnnotation().expandAll(0, getHdlDocument().getLength());
-	}
-	
-	public void collapseAll(){
-		getAnnotation().collapseAll(0, getHdlDocument().getLength());
-	}
-	/**
-	 * update outline and module hierarchy page
-	 */
-	private void updatePages()
-	{
-		checkSyntax();
-		if (outlinePage != null)
-			outlinePage.update();
-		if (getHierarchyPage() != null)
-			getHierarchyPage().update();
-	}
-	
-	
-	protected Point getCursorLocation(){
-		String[] cursorStr=getCursorPosition().split(":");
-		int line=0,col=0;
-		if(cursorStr.length > 1){
-			line=Integer.parseInt(cursorStr[0].trim());
-			col=Integer.parseInt(cursorStr[1].trim());
-		}
-		
-		return new Point(line,col);
-	}
-	
-	
-	/**
-	 * shows the current object in the hierarchy
-	 */
-	public void showInHierarchy(){
-		Point cursor=getCursorLocation();		
-
-		OutlineContainer container;
-		try {
-			container = getHdlDocument().getOutlineContainer();
-			if(container!=null){
-				OutlineElement element=container.getLineContext(cursor.x, cursor.y);
-				if ( element!=null  && getHierarchyPage() != null){
-						getHierarchyPage().showElement(element);
-				}
-			}
-
-		} catch (HdlParserException e) {
-			e.printStackTrace();
-		}		
-	}
-	
-	/**
-	 * Shows the current line in the hierarchy view
-	 */
-	public void showInOutline(){
-		Point cursor=getCursorLocation();		
-
-		OutlineContainer container;
-		try {
-			container = getHdlDocument().getOutlineContainer();
-			if(container!=null){
-				OutlineElement element=container.getLineContext(cursor.x, cursor.y);
-				if (element!=null && outlinePage != null){
-						outlinePage.showElement(element);
-				}
-			
-			}	
-		} catch (HdlParserException e) {		
-			e.printStackTrace();
-		}			
-	}
-	
-	/**
-	 * returns true if this editor has a hierarchy page
-	 * @return
-	 */
-	public boolean hasHierarchy(){
-		return (getHierarchyPage()!=null);
-	}
-	
-	/**
-	 * returns true if this editor has an outline page
-	 * @return
-	 */
-	public boolean hasOutline(){
-		return outlinePage!=null;
-	}
-	/**
-	 * Called every time a the cursor position may change
-	 */
-	protected void handleCursorPositionChanged() {
-		super.handleCursorPositionChanged();		
-	}
-	
-	private HdlHierarchyPage getHierarchyPage(){
-		HdlHierarchyPage page=null;
-		
-		HdlDocument doc=getHdlDocument();
-		
-		if(doc != null){
-			IProject project=doc.getProject();
-			if(project!=null){
-				try {			
-					page=(HdlHierarchyPage)project.getSessionProperty(VerilogPlugin.getHierarchyId());
-				} catch (CoreException e) {
-					e.printStackTrace();
-				}
-			}
-		}
-		
-		return page;
-	}
-	private void setInputPages(IEditorInput input)
-	{			
-	    if (outlinePage != null)
-			outlinePage.setInput(input);
-		if (getHierarchyPage() != null)
-			getHierarchyPage().setInput(input);
-	}
-	
-	private void checkSyntax()
-	{
-		HdlDocument doc = getHdlDocument();	
-		OutlineContainer outlineContainer;
-		
-		if(doc == null){
-			return;
-		}
-		// check for non-workspace file
-		IFile file = doc.getFile();
-		if (file == null)
-			return;
-		
-		try
-		{
-			outlineContainer=doc.getOutlineContainer();
-			//update the folding structure
-			updateFoldingStructure(outlineContainer.getCollapsibleRegions());
-		}
-		catch (HdlParserException e)
-		{			
-			
-		}		
-	}
-	
-	public void setFocus(){
-		super.setFocus();
-		setCurrent();
-		if(m_bInitialShowing){
-			checkSyntax();
-			m_bInitialShowing=false;
-			restoreCollapsibleStates();
-		}
-	}
-	
-	/**
-	 * update editor view for problem marker.
-	 */
-	public void update()
-	{
-		//TODO Had to remove the following because it caused the document
-		// to become disconnected from the Annotation Model. This funtion is only
-		// called from the compile action to update the markers? I'm not really sure
-		// it is even needed.
-		
-//		try
-//		{
-//			StyledText widget = getViewer().getTextWidget();
-//			int caret = widget.getCaretOffset();
-//			int top = widget.getTopIndex();
-//			
-//			super.doSetInput(getEditorInput());
-//			
-//			// widget might change in doSetInput
-//			widget = getViewer().getTextWidget();
-//			widget.setSelection(caret);
-//			widget.setTopIndex(top);
-//		}
-//		catch (CoreException e)
-//		{
-//		}
-	}
-	
-	public void doSetInput(IEditorInput input) throws CoreException
-	{
-		super.doSetInput(input);
-		setInputPages(input);
-	}
-
-	public Object getAdapter(Class required)
-	{
-		HdlHierarchyPage page=null;
-		// System.out.println("HdlEditor.getAdapter : " + required);
-		if (IContentOutlinePage.class.equals(required))
-		{
-			if (outlinePage == null)
-			{
-				outlinePage = new HdlContentOutlinePage(this);
-				if (getEditorInput() != null)
-					outlinePage.setInput(getEditorInput());
-			}
-			return outlinePage;
-		}
-		else if (HdlHierarchyPage.class.equals(required))
-		{
-			if (getHierarchyPage() == null)
-			{
-				if (getHdlDocument().getProject() != null)
-				{
-					page = new HdlHierarchyPage(this);
-					if (getEditorInput() != null)
-						page.setInput(getEditorInput());
-				}
-			}
-			return page;
-		}
-		return super.getAdapter(required);
-	}
-
-	public HdlDocument getHdlDocument()
-	{
-		IDocument doc = getDocument();
-		if (doc instanceof HdlDocument)
-			return (HdlDocument)doc;
-		else
-			return null;
-	}
-
-	protected void initializeEditor()
-	{
-		super.initializeEditor();
-		// install a change lister that gets called when the user
-		// changes one of this plugin's preferences
-		IEclipsePreferences.IPreferenceChangeListener fPropertyChangeListener;	    
-		fPropertyChangeListener= new IEclipsePreferences.IPreferenceChangeListener() {	    
-
-            @Override
-            public void preferenceChange(PreferenceChangeEvent arg0) {
-                if(arg0.getKey().equals(PreferenceStrings.INDENT_TYPE)){ 
-                   if(arg0.getNewValue().equals(PreferenceStrings.INDENT_TAB)){                  
-                       uninstallTabsToSpacesConverter();
-                   }
-                   else{                      
-                       installTabsToSpacesConverter();
-                   }                       
-                 }                  
-                if(arg0.getKey().equals(PreferenceStrings.INDENT_SIZE)){
-                    uninstallTabsToSpacesConverter();
-                    installTabsToSpacesConverter();
-                }
-            }
-	    };
-	    
-	    IEclipsePreferences peference = new InstanceScope().getNode(VerilogPlugin.ID);	    
-	    peference.addPreferenceChangeListener(fPropertyChangeListener);
-	}
-
-	protected void editorContextMenuAboutToShow(IMenuManager menu)
-	{
-		MenuManager showIn=null;
-		super.editorContextMenuAboutToShow(menu);
-		menu.add(new Separator());
-		menu.add(getAction("Format"));
-		menu.add(getAction("OpenDeclaration"));
-		menu.add(getAction("CollapseAll"));
-		menu.add(getAction("ExpandAll"));
-		menu.add(getAction(ClearErrorMarkersAction.ID));
-		
-		IContributionItem[] contributionItems=menu.getItems();
-		for(IContributionItem item: contributionItems){
-			if (item instanceof MenuManager) {
-				MenuManager menuManager = (MenuManager) item;
-				if(menuManager.getMenuText().startsWith("Sho&w In")){
-					showIn=menuManager;
-					break;
-				}
-			}
-		}
-		if(showIn!=null){
-			//FIXME Need to figure out how to properly add stuff to the "Show In"
-			if(hasHierarchy()) 
-				showIn.add(getAction("ShowInHierarchy"));
-			if(hasOutline())
-				showIn.add(getAction("ShowInOutline"));
-			showIn.add(getAction(HdlShowInNavigatorAction.ID));
-		}
-		
-	}
-
-	public void beep()
-	{
-		Display.getCurrent().beep();
-	}
-	public ISourceViewer getViewer()
-	{
-		return getSourceViewer();
-	}
-
-		
-	/**
-	 * Opens the definitions of an outline element
-	 * @param element
-	 */
-	public void showElement(OutlineElement element) {
-		IWorkbenchPage page = PlatformUI.getWorkbench()
-				.getActiveWorkbenchWindow().getActivePage();
-		try {
-			// Determine the editor descriptor for the given file (generally
-			// VHDL or verilog)
-			IEditorDescriptor editorDesc = IDE.getEditorDescriptor(element.getFile(), true);
-
-			// Create the editor instance
-			IEditorPart editorPart = page.openEditor(new FileEditorInput(element.getFile()),
-					editorDesc.getId());			
-			
-			if (editorPart instanceof HdlEditor) {
-				HdlEditor editor = (HdlEditor) editorPart;
-				IDocument doc = editor.getDocument();
-				
-				//go to the line
-				int line = element.getStartingLine() - 1;
-				
-				int start = doc.getLineOffset(line);
-				int length = doc.getLineOffset(line + element.getLength()) - start;				
-				editor.setHighlightRange(start, length, true);
-				editor.getSourceViewer().revealRange(start, length);
-				markInNavigationHistory();
-			}
-		} catch (PartInitException e) {
-			System.out.println(e);			
-		} catch (BadLocationException e) {
-			System.out.println(e);
-		}
-	}
-
-	/**
-	 * @return Returns the colorManager.
-	 */
-	public ColorManager getColorManager()
-	{
-		return colorManager;
-	}	
-	
-	public IBaseLabelProvider getOutlineLabelProvider(){
-		return OutlineLabelProvider;
-	}
-
-	public ITreeContentProvider getHirarchyProvider() {
-		return TreeContentProvider;
-	}
-	
-	public void createPartControl(Composite parent)
-	{
-	    super.createPartControl(parent);
-	    ProjectionViewer viewer =(ProjectionViewer)getSourceViewer();
-
-	    m_ProjectionSupport = new ProjectionSupport(viewer,getAnnotationAccess(),getSharedColors());
-	    m_ProjectionSupport.install();
-
-	    //turn projection mode on
-	    viewer.doOperation(ProjectionViewer.TOGGLE);	    
-	}
-	
-	protected ISourceViewer createSourceViewer(Composite parent,
-			IVerticalRuler ruler, int styles) {
-		ISourceViewer viewer = new ProjectionViewer(parent, ruler,
-				getOverviewRuler(), isOverviewRulerVisible(), styles);
-
-		// ensure decoration support has been created and configured.
-		getSourceViewerDecorationSupport(viewer);
-		
-
-	    
-		return viewer;
-	}
-	
-	protected Position getElementPosition(Collapsible collapsible){
-		Position  results= new Position(0,0);
-		int start,end;
-					   
-		   HdlDocument doc=getHdlDocument();			
-						
-			try {
-				start=doc.getLineOffset(collapsible.startLine-1);
-				try{
-					end=doc.getLineOffset(collapsible.endLine);
-				}
-				catch(BadLocationException e){
-					//second chance
-					//If there is not and end of line at the end of the
-					//last line in a file, getLineOffset fails
-					//in that case, get the last document character
-					end=doc.getLength();
-				}
-				
-				results.setOffset(start);
-				results.setLength(end-start);			    
-			} catch (BadLocationException e) {
-				// TODO Auto-generated catch block
-				e.printStackTrace();
-			}
-		
-		return results;
-	}
-	/**
-	 * Saves the state of collapsed items
-	 * @param file
-	 */
-	protected void storeCollapsibleStates(){
-		String stateString;		
-		StringBuffer buffer = new StringBuffer();
-		HdlDocument doc = getHdlDocument();
-
-		if (doc == null)
-		    return;
-		//check for non-workspace file
-		IFile file = doc.getFile();
-		if (file == null)
-			return;
-
-		for(Collapsible collapsible:m_CollapsibleElements.keySet().toArray(new Collapsible[0])){
-			if(m_CollapsibleElements.get(collapsible).isCollapsed()){
-				buffer.append(collapsible.hashCode());
-				buffer.append('#');
-			}
-		}
-		stateString=buffer.toString();
-		try {
-			file.setPersistentProperty(VerilogPlugin.getCollapsibleId(),
-					stateString);
-		} catch (CoreException e) {
-			// TODO Auto-generated catch block
-			e.printStackTrace();
-		}		
-	}
-	
-	/**
-	 * Restores the state of collapsed items
-	 */
-	protected void restoreCollapsibleStates(){
-		HashSet<String> collapsedItems=new HashSet<String>();
-		String stateString;
-		HdlDocument doc = getHdlDocument();
-		
-		if(doc == null){
-			return;
-		}
-		//check for non-workspace file
-		IFile file = doc.getFile();
-		if (file == null)
-			return;
-		
-		//attempt to get the files state string
-		try {
-			stateString=file.getPersistentProperty(VerilogPlugin.getCollapsibleId());
-		} catch (CoreException e1) {
-			stateString="";
-		}
-		
-		//get a list of all the collapsed elements
-		if(stateString!=null){
-			for(String s:stateString.split("#")){
-					collapsedItems.add(s);
-			}			
-		}
-		//restore the collapsed state
-		for(Collapsible collapsible:m_CollapsibleElements.keySet().toArray(new Collapsible[0])){
-			String key=String.format("%d",collapsible.hashCode());
-			if(collapsedItems.contains(key)){
-				getAnnotation().collapse(m_CollapsibleElements.get(collapsible));
-			}
-		}		
-	}
-	/**
-	 * This function is called to update the folding structures
-	 * @param positions List of folding positions
-	 */
-	protected void updateFoldingStructure(Collapsible[] newCollapsibles) {			
-		for (Collapsible collapsible : newCollapsibles) {
-			if (m_CollapsibleElements.containsKey(collapsible)) {
-				// an existing element
-				ProjectionAnnotation annotation = m_CollapsibleElements
-						.get(collapsible);
-				Position oldPosition = getAnnotation()
-						.getPosition(annotation);
-				Position newPosition = getElementPosition(collapsible);
-				// did the position change?
-				if (oldPosition == null || !oldPosition.equals(newPosition)) {
-					getAnnotation().modifyAnnotationPosition(annotation,
-							newPosition);
-				}
-			} else {
-				// if a new element was found
-				ProjectionAnnotation annotation = new ProjectionAnnotation();
-				Position position = getElementPosition(collapsible);
-				getAnnotation().addAnnotation(annotation, position);
-				// add it to the list of known collapsible
-				m_CollapsibleElements.put(collapsible, annotation);
-			}
-		}
-		// find deleted elements
-		Set<Collapsible> collapsibleSet = m_CollapsibleElements.keySet();
-		Iterator<Collapsible> it = collapsibleSet.iterator();
-		ArrayList<Collapsible> deletedItems = new ArrayList<Collapsible>();
-		while (it.hasNext()) {
-			Collapsible collapsible = it.next();
-			ProjectionAnnotation annotation = m_CollapsibleElements.get(collapsible);
-			// if the element does not exist in the new list, remove it
-			boolean bFound=false;
-			for(int i=0;i<newCollapsibles.length;i++){
-				if (newCollapsibles[i].equals(collapsible)){
-					bFound=true;
-					break;
-				}
-			}
-			if (!bFound) {				
-				getAnnotation().removeAnnotation(annotation);
-				deletedItems.add(collapsible);
-			} 
-		}
-		for (int i = 0; i < deletedItems.size(); i++) {
-			m_CollapsibleElements.remove(deletedItems.get(i));
-		}		
-	}
-	
-	/**
-	 * Adds an element to the list of collapsible positions
-	 * 
-	 * @param collapsible
-	 *            the collapsible to add
-	 * @param ArrayList
-	 *            the list of collapsible elements
-	 */
-	protected void addCollapsible(Collapsible collapsible,ArrayList<Position> positions){
-		
-		
-		HdlDocument doc=getHdlDocument();			
-		int start,end;
-		
-		
-		try {
-			start=doc.getLineOffset(collapsible.startLine-1);
-			end=doc.getLineOffset(collapsible.endLine);				
-			positions.add(new Position(start,end-start));
-		} catch (BadLocationException e) {
-			e.printStackTrace();
-		}			
-	}
-	/**
-	 * Called to get a list of collapsible positions
-	 * @param outlineContainer This editor's outline container
-	 * @return list of collapsible positions
-	 */
-	protected ArrayList<Position> getCollapsiblePositions(OutlineContainer outlineContainer){
-		ArrayList<Position> positions=new ArrayList<Position>();		
-		
-		if(outlineContainer!=null){
-			Collapsible[] collapsibleList=outlineContainer.getCollapsibleRegions();
-			//loop through all the children
-			for(Collapsible collapsible:collapsibleList){				
-				addCollapsible(collapsible,positions);
-			}
-		}
-		return positions;
-	}
-	
-	/**
-	 * Returns the indent string of a line number
-	 * @param offset offset of a character in the line
-	 * @param doc The document where the line resides
-	 * @return indent string
-	 */
-	protected String getLineIndent(int offset){
-		StringBuffer indent = new StringBuffer();
-		IDocument doc=getDocument();
-		
-		try {
-			IRegion lineRegion;
-			int lineNum = doc.getLineOfOffset(offset);
-			lineRegion = doc.getLineInformation(lineNum);		
-			String  line=doc.get(
-				lineRegion.getOffset(),
-				lineRegion.getLength());
-			for(int i=0;i<line.length();i++){
-				Character c=line.charAt(i);
-				if(Character.isSpaceChar(c)==false && c!='\t'){
-					break;
-				}
-				indent.append(c);
-			}		
-		} catch (BadLocationException e) {		
-			e.printStackTrace();
-		}
-		return indent.toString();
-	}
-	
-	@Override
-	protected boolean isTabsToSpacesConversionEnabled(){
-	    boolean bUseSpaceForTab = true;           
-                
-        String indent = VerilogPlugin.getPreferenceString(PreferenceStrings.INDENT_TYPE);
-        
-        if (indent.equals(PreferenceStrings.INDENT_TAB))
-            bUseSpaceForTab=false;
-        return bUseSpaceForTab;
-	}
-	
-	/**
-	 * Gets a reference to the documents current annotation model
-	 * @return Reference to the documents current annotation model
-	 */
-	protected ProjectionAnnotationModel getAnnotation(){
-	    ProjectionViewer viewer =(ProjectionViewer)getSourceViewer();
-	    return viewer.getProjectionAnnotationModel();
-	}
-	
-}
-
-
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+
+package com.elphel.vdt.veditor.editor;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import org.eclipse.core.resources.IFile;
+import org.eclipse.core.resources.IProject;
+import org.eclipse.core.runtime.CoreException;
+import org.eclipse.core.runtime.IProgressMonitor;
+//import org.eclipse.core.runtime.Preferences.PropertyChangeEvent;
+import org.eclipse.jface.action.IAction;
+import org.eclipse.jface.action.IContributionItem;
+import org.eclipse.jface.action.IMenuManager;
+import org.eclipse.jface.action.MenuManager;
+import org.eclipse.jface.action.Separator;
+import org.eclipse.jface.preference.IPreferenceStore;
+import org.eclipse.jface.preference.PreferenceConverter;
+import org.eclipse.jface.text.BadLocationException;
+import org.eclipse.jface.text.IDocument;
+import org.eclipse.jface.text.IRegion;
+import org.eclipse.jface.text.ITextSelection;
+import org.eclipse.jface.text.ITextViewerExtension2;
+import org.eclipse.jface.text.Position;
+import org.eclipse.jface.text.TypedPosition;
+import org.eclipse.jface.text.source.ISourceViewer;
+import org.eclipse.jface.text.source.ISourceViewerExtension2;
+import org.eclipse.jface.text.source.IVerticalRuler;
+import org.eclipse.jface.text.source.projection.ProjectionAnnotation;
+import org.eclipse.jface.text.source.projection.ProjectionAnnotationModel;
+import org.eclipse.jface.text.source.projection.ProjectionSupport;
+import org.eclipse.jface.text.source.projection.ProjectionViewer;
+import org.eclipse.jface.util.IPropertyChangeListener;
+import org.eclipse.jface.util.PropertyChangeEvent;
+import org.eclipse.jface.viewers.IBaseLabelProvider;
+import org.eclipse.jface.viewers.ISelectionProvider;
+import org.eclipse.jface.viewers.ITreeContentProvider;
+import org.eclipse.jface.viewers.SelectionChangedEvent;
+import org.eclipse.swt.graphics.Color;
+import org.eclipse.swt.graphics.Point;
+import org.eclipse.swt.graphics.RGB;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Display;
+import org.eclipse.ui.IEditorDescriptor;
+import org.eclipse.ui.IEditorInput;
+import org.eclipse.ui.IEditorPart;
+import org.eclipse.ui.IWorkbenchPage;
+import org.eclipse.ui.PartInitException;
+import org.eclipse.ui.PlatformUI;
+import org.eclipse.ui.editors.text.EditorsUI;
+import org.eclipse.ui.editors.text.TextEditor;
+import org.eclipse.ui.ide.IDE;
+import org.eclipse.ui.part.FileEditorInput;
+import org.eclipse.ui.texteditor.ChainedPreferenceStore;
+import org.eclipse.ui.texteditor.IDocumentProvider;
+import org.eclipse.ui.texteditor.ITextEditorActionDefinitionIds;
+import org.eclipse.ui.texteditor.SourceViewerDecorationSupport;
+import org.eclipse.ui.texteditor.TextOperationAction;
+import org.eclipse.ui.views.contentoutline.IContentOutlinePage;
+
+import com.elphel.vdt.veditor.VerilogPlugin;
+import com.elphel.vdt.veditor.actions.ClearErrorMarkersAction;
+import com.elphel.vdt.veditor.actions.CollapseAll;
+import com.elphel.vdt.veditor.actions.CommentAction;
+import com.elphel.vdt.veditor.actions.CompileAction;
+import com.elphel.vdt.veditor.actions.ExpandAll;
+import com.elphel.vdt.veditor.actions.FormatAction;
+import com.elphel.vdt.veditor.actions.GotoDriverAction;
+import com.elphel.vdt.veditor.actions.GotoMatchingBracketAction;
+import com.elphel.vdt.veditor.actions.HdlShowInNavigatorAction;
+import com.elphel.vdt.veditor.actions.OpenDeclarationAction;
+import com.elphel.vdt.veditor.actions.ShowInHierarchy;
+import com.elphel.vdt.veditor.actions.ShowInOutline;
+import com.elphel.vdt.veditor.actions.SynthesizeAction;
+import com.elphel.vdt.veditor.actions.UnCommentAction;
+import com.elphel.vdt.veditor.cdt.LineBackgroundPainter;
+import com.elphel.vdt.veditor.document.HdlDocument;
+import com.elphel.vdt.veditor.parser.HdlParserException;
+import com.elphel.vdt.veditor.parser.OutlineContainer;
+import com.elphel.vdt.veditor.parser.OutlineContainer.Collapsible;
+import com.elphel.vdt.veditor.parser.OutlineElement;
+import com.elphel.vdt.veditor.preference.PreferenceStrings;
+
+/**
+ *  main class
+ */
+abstract public class HdlEditor
+    extends TextEditor
+{
+	private Point lastCursor = new Point(0,0);
+	private ColorManager colorManager;
+	private HdlContentOutlinePage outlinePage;
+	protected IBaseLabelProvider OutlineLabelProvider;
+	protected ITreeContentProvider TreeContentProvider;
+	protected static HdlEditor current;
+	protected ProjectionSupport m_ProjectionSupport;	
+	protected HashMap<Collapsible,ProjectionAnnotation> m_CollapsibleElements;
+	protected boolean m_bInitialShowing;
+	private AtomicBoolean updatingPages;
+	private LineBackgroundPainter fBackgroundPainter=null;
+	private List<Position> curDisabledCode= Collections.emptyList();
+	
+	
+	public String getCursorPosition(){
+		return super.getCursorPosition();
+	}
+	public static HdlEditor current()
+	{
+		return current;
+	}
+	
+	public HdlEditor()
+	{
+		super();
+
+		setCurrent();
+		colorManager = new ColorManager();	
+		HdlTextAttribute.init();	
+		m_bInitialShowing=true;
+		m_CollapsibleElements=new HashMap<Collapsible,ProjectionAnnotation>();
+		updatingPages=new AtomicBoolean(false);
+	}	
+	
+	public void setDisabledCodePainter(LineBackgroundPainter painter){
+		fBackgroundPainter = painter;
+	}
+	/**
+	 * Makes this instance of the editor the current one
+	 * @return the old editor
+	 */
+	public HdlEditor setCurrent(){
+		HdlEditor old=current;
+		current = this;
+		return old;
+	}
+		
+	public void updatePartControl(IEditorInput input)
+	{
+		super.updatePartControl(input);
+		setInputPages(input);
+	}
+
+	protected void initializeKeyBindingScopes()
+	{
+		setKeyBindingScopes(new String[] { "com.elphel.vdt.veditor.scope" });
+	}
+
+	public IDocument getDocument()
+	{
+		IEditorInput editorInput=getEditorInput();
+		IDocumentProvider provider=getDocumentProvider();
+		
+		if(provider != null && editorInput!=null){
+			return provider.getDocument(editorInput);
+		}
+		
+		return null;
+		
+	}
+	
+	public void refreshEditor(){
+/*
+ One way to refresh the text editor in Eclipse
+ Finally I find the solution in the book "Eclipse Plugins". The code snippet is the following:
+ someEditor.getDocumentProvider().resetDocument(someEditor.getEditorInput());
+ This reloads editor, all changes are lost.		
+ */
+		IEditorInput editorInput=getEditorInput();
+		IDocumentProvider provider=getDocumentProvider();
+		
+		if(provider != null && editorInput!=null){
+			try {
+				provider.resetDocument(editorInput);
+			} catch (CoreException e) {
+				System.out.println("Failed to resetDocument(), e="+e);
+			}
+		}
+	}
+	// never called
+//	protected void handlePreferenceStoreChanged(PropertyChangeEvent event) {
+//		System.out.println("handlePreferenceStoreChanged("+event+")");
+//	}
+
+	
+	protected void createActions()
+	{
+		super.createActions();
+
+		// add content assist action
+		IAction action;
+		action =
+			new TextOperationAction(
+				EditorMessages.getResourceBundle(),
+				"ContentAssistProposal.",
+				this,
+				ISourceViewer.CONTENTASSIST_PROPOSALS);
+		action.setActionDefinitionId(ITextEditorActionDefinitionIds.CONTENT_ASSIST_PROPOSALS);
+		setAction("ContentAssistProposal", action);
+
+		// add special actions
+		setAction("GotoMatchingBracket", new GotoMatchingBracketAction());
+		setAction("OpenDeclaration", new OpenDeclarationAction());
+		setAction("GotoDriver",     new GotoDriverAction());
+		setAction("Format", new FormatAction());
+		setAction("Compile", new CompileAction());
+		setAction("Synthesize", new SynthesizeAction());
+		setAction("Comment", new CommentAction());
+		setAction("Uncomment", new UnCommentAction());
+		setAction("CollapseAll",new CollapseAll());
+		setAction("ExpandAll",new ExpandAll());
+		setAction("ShowInHierarchy",new ShowInHierarchy()); // Widget disposed
+		setAction("ShowInOutline",new ShowInOutline()); // opens element from the next line
+		setAction(HdlShowInNavigatorAction.ID,new HdlShowInNavigatorAction());
+		setAction(ClearErrorMarkersAction.ID,new ClearErrorMarkersAction());
+		
+	}
+
+//	for content assist?
+//	public void editorContextMenuAboutToShow(MenuManager menu)
+//	{
+//		super.editorContextMenuAboutToShow(menu);
+//		addAction(menu, "ContentAssistProposal");
+//		addAction(menu, "ContentAssistTip");
+//	}
+
+	public void dispose()
+	{
+		setDocumentEditor(null);
+		ProjectionViewer viewer = (ProjectionViewer) getSourceViewer();
+		viewer.removePainter(fBackgroundPainter);
+		fBackgroundPainter.dispose();
+		fBackgroundPainter = null;
+		colorManager.dispose();
+		setInputPages(null);
+		storeCollapsibleStates();
+		super.dispose();
+		
+	}
+
+	public void doRevertToSaved()
+	{
+		super.doRevertToSaved();
+		updatePages();
+	}
+
+	public void doSave(IProgressMonitor monitor)
+	{
+		super.doSave(monitor);
+		updatePages();
+	}
+
+	public void doSaveAs()
+	{
+		super.doSaveAs();
+		updatePages();
+	}
+	
+	public void expandAll(){
+		getAnnotation().expandAll(0, getHdlDocument().getLength());
+	}
+	
+	public void collapseAll(){
+		getAnnotation().collapseAll(0, getHdlDocument().getLength());
+	}
+	
+	
+	
+	/**
+	 * update pages (and check syntax) only if it is not updating now 
+	 * Called after timer when document is modified
+	 * Synchronized method  updatePages() is called from save, saveAs and revert document
+	 * @param force run even if busy (wait for synchronized)
+	 * @return true if updated, false if it was busy
+	 */
+	// TODO: Schedule a job to updatePages() asynchronously,? But it still seems very fast. Or is there thread launching inside // Andrey 
+	public boolean updatePagesIfFree(boolean force){
+//		System.out.println("updatePagesIfFree("+force+")");
+		if (!force && !updatingPages.compareAndSet(false, true)) {
+			return false;
+		}
+		updatePages();
+		return true;
+	}
+	
+	/**
+	 * update outline and module hierarchy page
+	 */
+	
+	private synchronized void updatePages()
+	{
+		updatingPages.set(true);
+		checkSyntax();
+//		System.out.println("updatePagesIfFree():1");
+		if (outlinePage != null){
+			outlinePage.update();
+//			System.out.println("updatePagesIfFree():2");
+		}
+		if (getHierarchyPage() != null) {
+			getHierarchyPage().update();
+//			System.out.println("updatePagesIfFree():3");
+		}
+
+		updatingPages.set(false);
+	}
+	
+	protected Point getCursorLocation(){
+		int dline=-1;
+		int dcol=-1;
+		// selection-based cursor position - works when tabs are used, but applies to start of selection,
+		// not the cursor
+		try {
+			ISelectionProvider selectionProvider=getSelectionProvider(); 
+			ITextSelection textSelection=(ITextSelection) selectionProvider.getSelection();
+			int offset=textSelection.getOffset();
+			IDocument doc=getDocument();
+			dline=doc.getLineOfOffset(offset);
+			dcol= offset-doc.getLineOffset(dline); // zero-base
+		} catch (Exception e) {
+		} // zero-based
+		if ((dline>=0) && (dcol>=0)){
+			return new Point(dline+1,dcol+1);
+		}
+// Original way to determine cursor location - it fails when tabs are used 
+		String[] cursorStr=getCursorPosition().split(":");
+		int line=0,col=0;
+		if(cursorStr.length > 1){
+			line=Integer.parseInt(cursorStr[0].trim());
+			col=Integer.parseInt(cursorStr[1].trim());
+		}
+		return new Point(line,col);
+	}
+	
+	
+	/**
+	 * shows the current object in the hierarchy
+	 */
+	public void showInHierarchy(){
+		Point cursor=getCursorLocation();		
+
+		OutlineContainer container;
+		try {
+			container = getHdlDocument().getOutlineContainer();
+			if(container!=null){
+				OutlineElement element=container.getLineContext(cursor.x, cursor.y);
+				if ( element!=null  && getHierarchyPage() != null){
+						getHierarchyPage().showElement(element);
+						getHierarchyPage().showElement(element); // for some reason does not work first time AF 2016/06/19
+						getHierarchyPage().setFocus(); // does not work? setVisible
+				}
+			}
+
+		} catch (HdlParserException e) {
+			System.out.println("Failed to showInHierarchy(), e="+e);
+			return;
+//			e.printStackTrace();
+		}		
+	}
+	
+	/**
+	 * Shows the current line in the hierarchy view
+	 */
+	public void showInOutline(){
+		showInOutline(true);
+	}
+	public void showInOutline(boolean unconditionally){
+		Point cursor=getCursorLocation(); // gets to the right of the element?
+		// do not update Outline after moving cursor by 1 while editing text
+		if (!unconditionally) {
+			if (((Math.abs(lastCursor.x-cursor.x)<2) && (Math.abs(lastCursor.y-cursor.y)<2)) ||
+					(Math.abs(lastCursor.y-cursor.y)==1)) { // up/down with tabs 
+			lastCursor.x=cursor.x;
+			lastCursor.y=cursor.y;
+				return;
+			}
+		}
+		lastCursor.x=cursor.x;
+		lastCursor.y=cursor.y;
+		OutlineContainer container;
+		try {
+			container = getHdlDocument().getOutlineContainer();
+			if(container!=null){
+				OutlineElement element=container.getLineContext(cursor.x, cursor.y);
+				if (element!=null && outlinePage != null){
+						outlinePage.showElement(element);
+				}
+			
+			}	
+		} catch (HdlParserException e) {
+//			e.printStackTrace(); // do nothing on parse error
+		}			
+	}
+	
+	/**
+	 * returns true if this editor has a hierarchy page
+	 * @return
+	 */
+	public boolean hasHierarchy(){
+		return (getHierarchyPage()!=null);
+	}
+	
+	/**
+	 * returns true if this editor has an outline page
+	 * @return
+	 */
+	public boolean hasOutline(){
+		return outlinePage!=null;
+	}
+	/**
+	 * Called every time a the cursor position may change
+	 */
+	protected void handleCursorPositionChanged() {
+		super.handleCursorPositionChanged();
+		if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.SYNC_OUTLINE)) {
+			showInOutline(false);
+		}
+	}
+	
+	private HdlHierarchyPage getHierarchyPage(){
+		HdlHierarchyPage page=null;
+		
+		HdlDocument doc=getHdlDocument();
+		
+		if(doc != null){
+			IProject project=doc.getProject();
+			if(project!=null){
+				try {			
+					page=(HdlHierarchyPage)project.getSessionProperty(VerilogPlugin.getHierarchyId());
+				} catch (CoreException e) {
+					e.printStackTrace();
+				}
+			}
+		}
+		
+		return page;
+	}
+	private void setInputPages(IEditorInput input)
+	{			
+	    if (outlinePage != null)
+			outlinePage.setInput(input);
+		if (getHierarchyPage() != null)
+			getHierarchyPage().setInput(input);
+	}
+	
+	private void checkSyntax()
+	{
+		HdlDocument doc = getHdlDocument();	
+		OutlineContainer outlineContainer;
+		
+		if(doc == null){
+			return;
+		}
+		// check for non-workspace file
+		IFile file = doc.getFile();
+		if (file == null)
+			return;
+		
+		try
+		{
+			outlineContainer=doc.getOutlineContainer();
+			//update the folding structure
+			updateFoldingStructure(outlineContainer.getCollapsibleRegions());
+		}
+		catch (HdlParserException e)
+		{			
+			
+		}		
+	}
+	
+	public void setFocus(){
+		super.setFocus();
+		setCurrent();
+		if(m_bInitialShowing){
+			checkSyntax();
+			m_bInitialShowing=false;
+			restoreCollapsibleStates();
+			setDocumentEditor(this);
+		}
+//		sendDocumentModificationEvent("\n\n\n"); // so mouse click on document tab will cause reparse (\n\n\n - reparse even if parse while typing is off)
+//		markDisabledCode();
+		Runnable sendModEvent = new Runnable() {
+			public void run() {
+				sendDocumentModificationEvent("\n\n\n");
+			}
+		};
+		if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_DISABLED)) {
+			System.out.println("sendDocumentModificationEvent in a thread");
+		}
+		Display.getDefault().asyncExec(sendModEvent);
+	}
+	
+	public void setDocumentEditor(HdlEditor editor){
+		IDocument document = getDocument();
+		if ((document != null) && (document instanceof HdlDocument)){
+			((HdlDocument)getDocument()).setEditor(this);
+			
+		}
+		
+	}
+	
+	public void sendDocumentModificationEvent(String txt){
+		IDocument document = getDocument();
+		if ((document != null) && (document instanceof HdlDocument)){
+			((HdlDocument)getDocument()).sendDocumentModificationEvent(txt);
+			
+		}
+	}	
+	/**
+	 * update editor view for problem marker.
+	 */
+	public void update()
+	{
+		//TODO Had to remove the following because it caused the document
+		// to become disconnected from the Annotation Model. This function is only
+		// called from the compile action to update the markers? I'm not really sure
+		// it is even needed.
+		
+//		try
+//		{
+//			StyledText widget = getViewer().getTextWidget();
+//			int caret = widget.getCaretOffset();
+//			int top = widget.getTopIndex();
+//			
+//			super.doSetInput(getEditorInput());
+//			
+//			// widget might change in doSetInput
+//			widget = getViewer().getTextWidget();
+//			widget.setSelection(caret);
+//			widget.setTopIndex(top);
+//		}
+//		catch (CoreException e)
+//		{
+//		}
+	}
+	
+	public void doSetInput(IEditorInput input) throws CoreException
+	{
+		super.doSetInput(input);
+		setInputPages(input);
+// For disabled code
+		ISourceViewer sourceViewer= getSourceViewer();
+		if (!(sourceViewer instanceof ISourceViewerExtension2)) {
+			setPreferenceStore(createCombinedPreferenceStore(input));
+		}
+		setupPropertyChangeListener(); // moved from initialize as we need combined property store		
+	}
+	
+	@Override
+	public Object getAdapter(Class required)
+	{
+		HdlHierarchyPage page=null;
+		// System.out.println("HdlEditor.getAdapter : " + required);
+		if (IContentOutlinePage.class.equals(required))
+		{
+			if (outlinePage == null)
+			{
+				outlinePage = new HdlContentOutlinePage(this);
+				if (getEditorInput() != null)
+					outlinePage.setInput(getEditorInput());
+			}
+			return outlinePage;
+		}
+		else if (HdlHierarchyPage.class.equals(required))
+		{
+			if (getHierarchyPage() == null)
+			{
+				if (getHdlDocument().getProject() != null)
+				{
+					page = new HdlHierarchyPage(this);
+					if (getEditorInput() != null)
+						page.setInput(getEditorInput());
+				}
+			}
+			return page;
+		}
+		return super.getAdapter(required);
+	}
+
+	public HdlDocument getHdlDocument()
+	{
+		IDocument doc = getDocument();
+		if (doc instanceof HdlDocument)
+			return (HdlDocument)doc;
+		else
+			return null;
+	}
+
+	protected void initializeEditor()
+	{
+		super.initializeEditor();
+	}
+
+	private void setupPropertyChangeListener(){
+		// install a change lister that gets called when the user
+		// changes one of this plugin's preferences
+		IPropertyChangeListener fPropertyChangeListener;	    
+		fPropertyChangeListener= new IPropertyChangeListener() {	    
+			@Override
+			public void propertyChange(PropertyChangeEvent event) {
+				final String property= event.getProperty();
+				
+                if(property.equals(PreferenceStrings.INDENT_TYPE)){ 
+                    if(event.getNewValue().equals(PreferenceStrings.INDENT_TAB)){// null pointer                  
+                        uninstallTabsToSpacesConverter();
+                    }
+                    else{                      
+                        installTabsToSpacesConverter();
+                    }                       
+                  }                  
+                 if(property.equals(PreferenceStrings.INDENT_SIZE)){
+                     uninstallTabsToSpacesConverter();
+                     installTabsToSpacesConverter();
+                 }
+                 if (property.equals("Color."+PreferenceStrings.DISABLED_CODE)){
+                	 if (fBackgroundPainter != null) {
+                		 fBackgroundPainter.setBackgroundColor(PreferenceStrings.DISABLED_CODE_KEY, getColor(property));
+                		 Runnable disCodeRunner = new Runnable() {
+                			 public void run() {
+                				 if (fBackgroundPainter != null && !fBackgroundPainter.isDisposed()) {
+//                					 fBackgroundPainter.setBackgroundColor(PreferenceStrings.DISABLED_CODE_KEY, getColor(property));
+                					 fBackgroundPainter.redraw();
+                				 }
+                			 }
+                		 };
+                		 Display.getDefault().asyncExec(disCodeRunner);
+                	 }
+                 }
+				
+			}
+	    };
+	    IPreferenceStore store = getPreferenceStore();
+	    store.addPropertyChangeListener(fPropertyChangeListener);
+
+	}
+
+	protected void editorContextMenuAboutToShow(IMenuManager menu)
+	{
+		MenuManager showIn=null;
+		super.editorContextMenuAboutToShow(menu);
+		menu.add(new Separator());
+		menu.add(getAction("Format"));
+		menu.add(getAction("OpenDeclaration"));
+		menu.add(getAction("GotoDriver"));
+		menu.add(getAction("ShowInHierarchy")); // Duplicate to Show In (below)
+		
+		menu.add(getAction("CollapseAll"));
+		menu.add(getAction("ExpandAll"));
+		menu.add(getAction(ClearErrorMarkersAction.ID));
+		
+		IContributionItem[] contributionItems=menu.getItems();
+		for(IContributionItem item: contributionItems){
+			if (item instanceof MenuManager) {
+				MenuManager menuManager = (MenuManager) item;
+				if(menuManager.getMenuText().startsWith("Sho&w In")){
+					showIn=menuManager;
+					break;
+				}
+			}
+		}
+		if(showIn!=null){
+			//FIXME Need to figure out how to properly add stuff to the "Show In"
+			if(hasHierarchy()) 
+				showIn.add(getAction("ShowInHierarchy")); // Yes, gets here just before context menu opens TODO: add copy instance submenu here
+			if(hasOutline())
+				showIn.add(getAction("ShowInOutline"));
+			showIn.add(getAction(HdlShowInNavigatorAction.ID));
+		}
+		
+	}
+
+	public void beep()
+	{
+		Display.getCurrent().beep();
+	}
+	public ISourceViewer getViewer()
+	{
+		return getSourceViewer();
+	}
+
+		
+	/**
+	 * Opens the definitions of an outline element
+	 * @param element
+	 */
+	public void showElement(OutlineElement element) {
+		IWorkbenchPage page = PlatformUI.getWorkbench()
+				.getActiveWorkbenchWindow().getActivePage();
+		try {
+			// Determine the editor descriptor for the given file (generally
+			// VHDL or verilog)
+			IEditorDescriptor editorDesc = IDE.getEditorDescriptor(element.getFile(), true);
+
+			// Create the editor instance
+			IEditorPart editorPart = page.openEditor(new FileEditorInput(element.getFile()),
+					editorDesc.getId());			
+			
+			if (editorPart instanceof HdlEditor) {
+				HdlEditor editor = (HdlEditor) editorPart;
+				IDocument doc = editor.getDocument();
+				
+				//go to the line
+				int line = element.getStartingLine() - 1;
+				
+				int start = doc.getLineOffset(line);
+				int length = doc.getLineOffset(line + element.getLength()) - start;				
+				editor.setHighlightRange(start, length, true);
+				editor.getSourceViewer().revealRange(start, length);
+				markInNavigationHistory();
+			}
+		} catch (PartInitException e) {
+			System.out.println(e);			
+		} catch (BadLocationException e) {
+			System.out.println(e);
+		}
+	}
+	
+    /**
+     * Shows specified line in a document
+     * @param line
+     */
+    public void showLine(int line) {
+        IDocument doc = getDocument();
+    	int start;
+    	int length;
+        try {
+        	start =    doc.getLineOffset(line);
+        	length =   doc.getLineLength(line);
+        	if (doc.getLineDelimiter(line)!=null)
+        		length -= doc.getLineDelimiter(line).length();
+            setHighlightRange(start, length, true);
+            getSourceViewer().revealRange(start, length);
+            markInNavigationHistory();
+        } catch (BadLocationException e) {
+            System.out.println(e);
+        }
+    }
+
+    /**
+     * Get specified line text w/o delimiter
+     * @param line
+     */
+    public String getLine(int line) {
+        IDocument doc = getDocument();
+        try {
+        	int start =    doc.getLineOffset(line);
+        	int length =   doc.getLineLength(line);
+        	if (doc.getLineDelimiter(line)!=null)
+        		length -= doc.getLineDelimiter(line).length();
+        	return doc.get(start,length);
+        } catch (BadLocationException e) {
+            System.out.println(e);
+            return null;
+        }
+    }
+    
+    
+
+	/**
+	 * @return Returns the colorManager.
+	 */
+	public ColorManager getColorManager()
+	{
+		return colorManager;
+	}	
+
+	private Color getColor(String key) {
+		if (getPreferenceStore() != null) {
+			RGB rgb = PreferenceConverter.getColor(getPreferenceStore(), key);
+			return getColor(rgb);
+		}
+		return null;
+	}
+	private Color getColor(RGB rgb) {
+		return getSharedColors().getColor(rgb);
+	}
+	
+	public IBaseLabelProvider getOutlineLabelProvider(){
+		return OutlineLabelProvider;
+	}
+
+	public ITreeContentProvider getHirarchyProvider() {
+		return TreeContentProvider;
+	}
+// Replaced, see below	
+	
+/*	
+	public void createPartControl(Composite parent)
+	{
+	    super.createPartControl(parent);
+	    ProjectionViewer viewer =(ProjectionViewer)getSourceViewer();
+
+	    m_ProjectionSupport = new ProjectionSupport(viewer,getAnnotationAccess(),getSharedColors());
+	    m_ProjectionSupport.install();
+
+	    //turn projection mode on
+	    viewer.doOperation(ProjectionViewer.TOGGLE);	    
+	}
+*/	
+	protected ISourceViewer createSourceViewer(Composite parent,
+			IVerticalRuler ruler, int styles) {
+		ISourceViewer viewer = new ProjectionViewer(parent, ruler, getOverviewRuler(), isOverviewRulerVisible(), styles);
+//		ISourceViewer viewer = new HdlSourceViewer (parent, ruler, getOverviewRuler(), isOverviewRulerVisible(), styles,
+//				getPreferenceStore()); // fPreferenceStore);
+
+		// ensure decoration support has been created and configured.
+		getSourceViewerDecorationSupport(viewer);
+		
+
+	    
+		return viewer;
+	}
+	
+	protected Position getElementPosition(Collapsible collapsible){
+		Position  results= new Position(0,0);
+		int start,end;
+					   
+		   HdlDocument doc=getHdlDocument();			
+						
+			try {
+				start=doc.getLineOffset(collapsible.startLine-1);
+				try{
+					end=doc.getLineOffset(collapsible.endLine);
+				}
+				catch(BadLocationException e){
+					//second chance
+					//If there is not and end of line at the end of the
+					//last line in a file, getLineOffset fails
+					//in that case, get the last document character
+					end=doc.getLength();
+				}
+				
+				results.setOffset(start);
+				results.setLength(end-start);			    
+			} catch (BadLocationException e) {
+				// TODO Auto-generated catch block
+				e.printStackTrace();
+			}
+		
+		return results;
+	}
+	/**
+	 * Saves the state of collapsed items
+	 * @param file
+	 */
+	protected void storeCollapsibleStates(){
+		String stateString;		
+		StringBuffer buffer = new StringBuffer();
+		HdlDocument doc = getHdlDocument();
+
+		if (doc == null)
+		    return;
+		//check for non-workspace file
+		IFile file = doc.getFile();
+		if (file == null)
+			return;
+
+		for(Collapsible collapsible:m_CollapsibleElements.keySet().toArray(new Collapsible[0])){
+			if(m_CollapsibleElements.get(collapsible).isCollapsed()){
+				buffer.append(collapsible.hashCode());
+				buffer.append('#');
+			}
+		}
+		stateString=buffer.toString();
+		try {
+			file.setPersistentProperty(VerilogPlugin.getCollapsibleId(),
+					stateString);
+		} catch (CoreException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}		
+	}
+	
+	/**
+	 * Restores the state of collapsed items
+	 */
+	protected void restoreCollapsibleStates(){
+		HashSet<String> collapsedItems=new HashSet<String>();
+		String stateString;
+		HdlDocument doc = getHdlDocument();
+		
+		if(doc == null){
+			return;
+		}
+		//check for non-workspace file
+		IFile file = doc.getFile();
+		if (file == null)
+			return;
+		
+		//attempt to get the files state string
+		try {
+			stateString=file.getPersistentProperty(VerilogPlugin.getCollapsibleId());
+		} catch (CoreException e1) {
+			stateString="";
+		}
+		
+		//get a list of all the collapsed elements
+		if(stateString!=null){
+			for(String s:stateString.split("#")){
+					collapsedItems.add(s);
+			}			
+		}
+		//restore the collapsed state
+		for(Collapsible collapsible:m_CollapsibleElements.keySet().toArray(new Collapsible[0])){
+			String key=String.format("%d",collapsible.hashCode());
+			if(collapsedItems.contains(key)){
+				getAnnotation().collapse(m_CollapsibleElements.get(collapsible));
+			}
+		}		
+	}
+	/**
+	 * This function is called to update the folding structures
+	 * @param positions List of folding positions
+	 */
+	protected void updateFoldingStructure(Collapsible[] newCollapsibles) {			
+		for (Collapsible collapsible : newCollapsibles) {
+			if (m_CollapsibleElements.containsKey(collapsible)) {
+				// an existing element
+				ProjectionAnnotation annotation = m_CollapsibleElements
+						.get(collapsible);
+				Position oldPosition = getAnnotation()
+						.getPosition(annotation);
+				Position newPosition = getElementPosition(collapsible);
+				// did the position change?
+				if (oldPosition == null || !oldPosition.equals(newPosition)) {
+					getAnnotation().modifyAnnotationPosition(annotation,
+							newPosition);
+				}
+			} else {
+				// if a new element was found
+				ProjectionAnnotation annotation = new ProjectionAnnotation();
+				Position position = getElementPosition(collapsible);
+				try {
+					getAnnotation().addAnnotation(annotation, position); // java.lang.IllegalArgumentException
+				} catch (Exception e){
+					System.out.println("updateFoldingStructure(): position="+position+", e="+e);
+					return;
+				}
+				// add it to the list of known collapsible
+				m_CollapsibleElements.put(collapsible, annotation);
+			}
+		}
+		// find deleted elements
+		Set<Collapsible> collapsibleSet = m_CollapsibleElements.keySet();
+		Iterator<Collapsible> it = collapsibleSet.iterator();
+		ArrayList<Collapsible> deletedItems = new ArrayList<Collapsible>();
+		while (it.hasNext()) {
+			Collapsible collapsible = it.next();
+			ProjectionAnnotation annotation = m_CollapsibleElements.get(collapsible);
+			// if the element does not exist in the new list, remove it
+			boolean bFound=false;
+			for(int i=0;i<newCollapsibles.length;i++){
+				if (newCollapsibles[i].equals(collapsible)){
+					bFound=true;
+					break;
+				}
+			}
+			if (!bFound) {				
+				getAnnotation().removeAnnotation(annotation);
+				deletedItems.add(collapsible);
+			} 
+		}
+		for (int i = 0; i < deletedItems.size(); i++) {
+			m_CollapsibleElements.remove(deletedItems.get(i));
+		}		
+	}
+	
+	/**
+	 * Adds an element to the list of collapsible positions
+	 * 
+	 * @param collapsible
+	 *            the collapsible to add
+	 * @param ArrayList
+	 *            the list of collapsible elements
+	 */
+	protected void addCollapsible(Collapsible collapsible,ArrayList<Position> positions){
+		
+		
+		HdlDocument doc=getHdlDocument();			
+		int start,end;
+		
+		
+		try {
+			start=doc.getLineOffset(collapsible.startLine-1);
+			end=doc.getLineOffset(collapsible.endLine);				
+			positions.add(new Position(start,end-start));
+		} catch (BadLocationException e) {
+			e.printStackTrace();
+		}			
+	}
+	/**
+	 * Called to get a list of collapsible positions
+	 * @param outlineContainer This editor's outline container
+	 * @return list of collapsible positions
+	 */
+	protected ArrayList<Position> getCollapsiblePositions(OutlineContainer outlineContainer){
+		ArrayList<Position> positions=new ArrayList<Position>();		
+		
+		if(outlineContainer!=null){
+			Collapsible[] collapsibleList=outlineContainer.getCollapsibleRegions();
+			//loop through all the children
+			for(Collapsible collapsible:collapsibleList){				
+				addCollapsible(collapsible,positions);
+			}
+		}
+		return positions;
+	}
+	
+	/**
+	 * Returns the indent string of a line number
+	 * @param offset offset of a character in the line
+	 * @param doc The document where the line resides
+	 * @return indent string
+	 */
+	protected String getLineIndent(int offset){
+		StringBuffer indent = new StringBuffer();
+		IDocument doc=getDocument();
+		
+		try {
+			IRegion lineRegion;
+			int lineNum = doc.getLineOfOffset(offset);
+			lineRegion = doc.getLineInformation(lineNum);		
+			String  line=doc.get(
+				lineRegion.getOffset(),
+				lineRegion.getLength());
+			for(int i=0;i<line.length();i++){
+				Character c=line.charAt(i);
+				if(Character.isSpaceChar(c)==false && c!='\t'){
+					break;
+				}
+				indent.append(c);
+			}		
+		} catch (BadLocationException e) {		
+			e.printStackTrace();
+		}
+		return indent.toString();
+	}
+	
+	@Override
+	protected boolean isTabsToSpacesConversionEnabled(){
+	    boolean bUseSpaceForTab = true;           
+                
+        String indent = VerilogPlugin.getPreferenceString(PreferenceStrings.INDENT_TYPE);
+        
+        if (indent.equals(PreferenceStrings.INDENT_TAB))
+            bUseSpaceForTab=false;
+        return bUseSpaceForTab;
+	}
+	
+	/**
+	 * Gets a reference to the documents current annotation model
+	 * @return Reference to the documents current annotation model
+	 */
+	protected ProjectionAnnotationModel getAnnotation(){
+	    ProjectionViewer viewer =(ProjectionViewer)getSourceViewer();
+//		HdlSourceViewer viewer =(HdlSourceViewer) getSourceViewer();
+	    
+	    return viewer.getProjectionAnnotationModel();
+	}
+
+	public void markDisabledCode(){
+		if (fBackgroundPainter == null){
+    		if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_DISABLED)) {
+    			System.out.println("markDisabledCode(): fBackgroundPainter is null");
+    		}
+			return;
+		}
+		HdlDocument document = (HdlDocument) getDocument();
+		
+		OutlineContainer container = null;
+		try {
+			container = document.getOutlineContainer();
+		} catch (HdlParserException hpe){
+			System.out.println("markDisabledCode(): failed to get OutlineContainer for this document");
+			return; // nothing to do
+		}
+		
+		
+		ArrayList<java.awt.Point> disabledRanges = container.getDisabledCode(true); // true - until range start is smaller than previous. false - sorted
+		ArrayList<Position> disabledCodePositions= new ArrayList<Position>();
+		if ((disabledRanges.size() == 0) && (curDisabledCode.size()== 0)){
+    		if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_DISABLED)) {
+    			System.out.println("No disabled code segments in "+document.getFile()+" and curDisabledCode is empty too");
+    		}
+//			return; // no disabled segments in
+			//
+		}
+		for (java.awt.Point p:disabledRanges){
+			int lineStart, lineEnd;
+			try {
+				lineStart= document.getLineOffset(p.x-1);
+			} catch (BadLocationException e) {
+				System.out.println("markDisabledCode(): Bad start offset");
+				continue;
+			}
+			try {
+				lineEnd= document.getLineOffset(p.y); // first character of next line
+			} catch (BadLocationException e) {
+				lineEnd= document.getLength();
+			}
+			disabledCodePositions.add(new TypedPosition(lineStart, lineEnd-lineStart, PreferenceStrings.DISABLED_CODE_KEY));
+		}
+		// set positions in a thread
+		final ArrayList<Position> finList = disabledCodePositions; 
+		//curDisabledCode
+		Runnable disCodeRunner = new Runnable() {
+			public void run() {
+				if (fBackgroundPainter != null && !fBackgroundPainter.isDisposed()) {
+					fBackgroundPainter.replaceHighlightPositions(curDisabledCode, finList);
+					curDisabledCode= finList;
+				}
+			}
+		};
+		if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_DISABLED)) {
+			System.out.println("Updating "+document.getFile()+" in a thread");
+		}
+		Display.getDefault().asyncExec(disCodeRunner);
+	}
+
+	/**
+	 * Removes the given listener.
+	 * Has no effect if an identical listener was not already registered.
+	 *
+	 * @param listener	the reconcile listener to be removed
+	 * @since 4.0
+	 */
+	
+	private EditorSelectionChangedListener fEditorSelectionChangedListener;
+	
+	@Override
+	public void createPartControl(Composite parent) {
+		if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_DISABLED)) {
+			try {
+				
+				System.out.println("createPartControl("+((HdlDocument)getDocument()).getFile()+" current="+((HdlDocument)current.getDocument()).getFile());
+			} catch (Exception e) {
+				System.out.println("createPartControl - null document");
+			}
+		}		
+		super.createPartControl(parent); //... installs backgroundPainter Add after this line
+	    ProjectionViewer viewer =(ProjectionViewer)getSourceViewer();
+
+		if (fBackgroundPainter == null) {
+			setDocumentEditor(this);
+    		if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_DISABLED)) {
+    			System.out.println("installLineBackgroundPainter();");
+    		}
+			fBackgroundPainter = new LineBackgroundPainter(viewer);
+			fBackgroundPainter.setBackgroundColor(PreferenceStrings.DISABLED_CODE_KEY, getColor("Color."+PreferenceStrings.DISABLED_CODE));
+			((ITextViewerExtension2)viewer).addPainter(fBackgroundPainter);
+			
+			fBackgroundPainter.enableCursorLine(true);
+	   		 Runnable disCodeRunner = new Runnable() {
+				 public void run() {
+					 if (fBackgroundPainter != null && !fBackgroundPainter.isDisposed()) {
+						 fBackgroundPainter.redraw();
+					 }
+				 }
+			 };
+			 Display.getDefault().asyncExec(disCodeRunner);
+		}
+		
+	    m_ProjectionSupport = new ProjectionSupport(viewer,getAnnotationAccess(),getSharedColors());
+	    m_ProjectionSupport.install();
+
+	    //turn projection mode on
+	    viewer.doOperation(ProjectionViewer.TOGGLE);
+	    // For disabled code
+		fEditorSelectionChangedListener = new EditorSelectionChangedListener();
+		fEditorSelectionChangedListener.install(getSelectionProvider());
+	}
+
+	@Override
+	protected SourceViewerDecorationSupport getSourceViewerDecorationSupport(ISourceViewer viewer) {
+		if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_DISABLED)) {
+			System.out.println("getSourceViewerDecorationSupport();");
+		}
+		if (fSourceViewerDecorationSupport == null) {
+			fSourceViewerDecorationSupport= new SourceViewerDecorationSupport(viewer, getOverviewRuler(), getAnnotationAccess(), getSharedColors());
+			configureSourceViewerDecorationSupport(fSourceViewerDecorationSupport);
+		}
+		return fSourceViewerDecorationSupport;
+	}
+
+	/**
+	 * Updates the C outline page selection and this editor's range indicator.
+	 *
+	 * @since 3.0
+	 */
+	
+	private class EditorSelectionChangedListener extends AbstractSelectionChangedListener {
+		@Override
+		public void selectionChanged(SelectionChangedEvent event) {
+			// TODO: see https://bugs.eclipse.org/bugs/show_bug.cgi?id=56161
+			HdlEditor.this.selectionChanged();
+		}
+	}
+	/**
+	 * Reacts to changed selection in the editor.
+	 *
+	 * @since 3.0
+	 */
+	protected void selectionChanged() {
+		if (getSelectionProvider() == null)
+			return;
+	}
+    
+	private IPreferenceStore createCombinedPreferenceStore(IEditorInput input) {
+		List<IPreferenceStore> stores= new ArrayList<IPreferenceStore>(2);
+//VerilogPlugin.getPlugin().getPreferenceStore()
+		stores.add(VerilogPlugin.getDefault().getPreferenceStore());
+		stores.add(EditorsUI.getPreferenceStore());
+		for (IPreferenceStore ips: stores){
+    		if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_DISABLED)) {
+    			System.out.println("createCombinedPreferenceStore():"+ ips.toString());
+    		}
+		}
+		return new ChainedPreferenceStore(stores.toArray(new IPreferenceStore[stores.size()]));
+	}
+	
+	
+}
+
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/editor/HdlHierarchyPage.java vdt/src/com/elphel/vdt/veditor/editor/HdlHierarchyPage.java
--- vdt-veditor/src/com/elphel/vdt/veditor/editor/HdlHierarchyPage.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/editor/HdlHierarchyPage.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,567 +1,1001 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.editor;
-
-import java.util.Vector;
-
-import net.sourceforge.veditor.VerilogPlugin;
-import net.sourceforge.veditor.document.HdlDocument;
-import net.sourceforge.veditor.parser.OutlineDatabase;
-import net.sourceforge.veditor.parser.OutlineElement;
-import net.sourceforge.veditor.parser.OutlineDatabase.OutlineDatabaseEvent;
-import net.sourceforge.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogInstanceElement;
-
-import org.eclipse.core.resources.IProject;
-import org.eclipse.core.runtime.CoreException;
-import org.eclipse.jface.action.Action;
-import org.eclipse.jface.action.IMenuListener;
-import org.eclipse.jface.action.IMenuManager;
-import org.eclipse.jface.action.IToolBarManager;
-import org.eclipse.jface.action.MenuManager;
-import org.eclipse.jface.resource.ImageDescriptor;
-import org.eclipse.jface.text.IDocument;
-import org.eclipse.jface.viewers.DoubleClickEvent;
-import org.eclipse.jface.viewers.IDoubleClickListener;
-import org.eclipse.jface.viewers.ISelection;
-import org.eclipse.jface.viewers.ISelectionChangedListener;
-import org.eclipse.jface.viewers.IStructuredSelection;
-import org.eclipse.jface.viewers.SelectionChangedEvent;
-import org.eclipse.jface.viewers.TreeViewer;
-import org.eclipse.jface.viewers.ViewerSorter;
-import org.eclipse.swt.dnd.Clipboard;
-import org.eclipse.swt.dnd.TextTransfer;
-import org.eclipse.swt.dnd.Transfer;
-import org.eclipse.swt.graphics.Color;
-import org.eclipse.swt.graphics.RGB;
-import org.eclipse.swt.widgets.Composite;
-import org.eclipse.swt.widgets.Control;
-import org.eclipse.swt.widgets.Display;
-import org.eclipse.swt.widgets.Menu;
-import org.eclipse.swt.widgets.TreeItem;
-import org.eclipse.ui.part.Page;
-
-public class HdlHierarchyPage extends Page implements ISelectionChangedListener,
-		IDoubleClickListener
-{
-    private TreeViewer m_TreeViewer;
-    private HdlEditor  m_Editor;
-    private Clipboard  m_Clipboard;
-    private ISelection m_Selection;
-    private Action     m_RefreshAction;
-    private Action     m_CopyTextAction;
-    private Action     m_CopyHierarchyAction;
-    private Action     m_GotoDefinition;
-    private Action     m_CollapseAllAction;
-    private Action     m_RescanAllAction;
-    private Action     m_EnableSortAction;
-    private boolean enableSort;
-
-    private final static String REFRESH_ACTION_IMAGE="$nl$/icons/refresh.gif";
-    private final static String GOTO_DEF_ACTION_IMAGE="$nl$/icons/goto_def.gif";
-	private static final String ENABLE_SORT_ACTION_IMAGE="$nl$/icons/sort.gif";
-    
-	public HdlHierarchyPage(HdlEditor editor) {
-		super();
-		this.m_Editor = editor;
-		m_Clipboard = new Clipboard(Display.getCurrent());
-		m_Selection = null;
-		m_TreeViewer = null;
-		m_CollapseAllAction = null;
-		m_RescanAllAction = null;
-		m_EnableSortAction = null;
-		enableSort = VerilogPlugin.getPreferenceBoolean("Outline.Sort");
-	}
-	
-	public void dispose() {
-		super.dispose();
-		m_Selection = null;
-		m_TreeViewer = null;
-	}
-	
-	public boolean isDisposed(){
-		return m_TreeViewer==null;
-	}
-	
-	
-	protected class databaseListner extends OutlineDatabaseEvent{
-
-		@Override
-		public void handel() {
-			   update();        
-		}
-		
-	}
-	
-	public void createControl(Composite parent)
-	{
-		m_TreeViewer=new TreeViewer(parent);
-		createActions();		
-		createMenu();
-		createToolbar();
-		createContextMenu(m_TreeViewer.getTree());
-
-		m_TreeViewer.setContentProvider(m_Editor.getHirarchyProvider());
-		m_TreeViewer.setLabelProvider(m_Editor.getOutlineLabelProvider());
-		m_TreeViewer.addSelectionChangedListener(this);
-		m_TreeViewer.addDoubleClickListener(this);
-		if (enableSort)
-			m_TreeViewer.setSorter(new ViewerSorter());
-		IDocument doc = m_Editor.getDocument();
-		if (doc != null)
-		{
-			m_TreeViewer.setInput(doc);
-			m_TreeViewer.collapseAll();
-			//register the update function
-			if (doc instanceof HdlDocument) {
-				HdlDocument hdlDoc = (HdlDocument) doc;				
-				hdlDoc.getOutlineDatabase().addChangeListner(new databaseListner());
-			}
-		}			
-	}
-	/**
-	 * creates the actions
-	 */
-	private void createActions() {
-		m_CopyTextAction = new CopyTextAction();
-		m_CopyHierarchyAction = new CopyHierarchyAction();
-		m_RefreshAction = new RefreshAction();
-		m_GotoDefinition = new GotoDefinitionAction();
-		m_CollapseAllAction = new CollapseAllAction();
-		m_RescanAllAction = new RescanAllAction();
-		m_EnableSortAction = new EnableSortAction();
-	}
-
-	/** 
-	 *  creates a menu for this view
-	 */
-	private void createMenu(){
-		
-	}
-	/**
-	 * Creates a toolbar for this view
-	 */
-	private void createToolbar(){
-		IToolBarManager mgr = getSite().getActionBars().getToolBarManager();
-		mgr.add(m_EnableSortAction);
-        mgr.add(m_RefreshAction);
-        mgr.add(m_CollapseAllAction);
-        mgr.add(m_RescanAllAction);
-	}
-	/**
-	 * Creates a context menu for this view
-	 * @param control
-	 */
-	private void createContextMenu(Control control)
-	{
-		MenuManager menuManager = new MenuManager();
-		menuManager.setRemoveAllWhenShown(true);
-		menuManager.addMenuListener(new IMenuListener() {
-			public void menuAboutToShow(IMenuManager menu)
-			{
-				if(m_Selection != null){
-					menu.add(m_CopyTextAction);
-					menu.add(m_CopyHierarchyAction);
-					menu.add(m_GotoDefinition);
-				}
-				menu.add(m_RefreshAction);
-				menu.add(m_CollapseAllAction);				
-			}
-		});
-		Menu menu = menuManager.createContextMenu(control);		
-		control.setMenu(menu);			
-	}
-
-	public Control getControl()
-	{
-		if (m_TreeViewer == null)
-			return null;
-		return m_TreeViewer.getControl();
-	}
-
-	public void setFocus()
-	{
-		m_TreeViewer.getControl().setFocus();
-	}
-
-	public void setInput(Object input)
-	{
-//		update();
-	}
-	
-	
-	/**
-	 * Searches through the tree item recursively and looks the specified element
-	 * @param element
-	 * @param item
-	 * @return
-	 */
-	protected TreeItem findTreeItem(TreeItem item,OutlineElement element){
-		if (item.getData() instanceof OutlineElement) {
-			OutlineElement e = (OutlineElement) item.getData();
-			if(e.equals(element)){
-				return item;
-			}			
-		}else
-		{
-			return null;
-		}
-		//look through the children
-		for(TreeItem child:item.getItems()){
-			TreeItem temp=findTreeItem(child,element);
-			if(temp!=null){
-				return temp;
-			}
-		}
-		
-		return null;
-	}
-	
-	/**
-	 * scans the tree and selects the item
-	 * @param element
-	 * @return true if item was found and is select, false otherwise
-	 */
-	private boolean selectElement(OutlineElement element){
-		TreeItem target=null;		
-		if(element == null){			
-			return false;
-		}
-
-		TreeItem[] treeItems=m_TreeViewer.getTree().getItems();
-		Vector<TreeItem> itemsVector=new Vector<TreeItem>();
-		for(TreeItem item: treeItems){
-			target=findTreeItem(item, element);
-			if(target!=null){
-				itemsVector.add(target);							
-			}
-		}
-		//since the hierarchy tree may only include some of the outline elements,
-		//we may need seek backwards in the parent's history to find something in
-		//the hierarchy list
-		if(itemsVector.size()==0){
-			return selectElement(element.getParent());
-		}else{
-			TreeItem[] items=itemsVector.toArray(new TreeItem[0]);
-			RGB rgb=new RGB(255,255,10);
-			Color bgColor=new Color(Display.getCurrent(), rgb);
-	
-			m_TreeViewer.collapseAll();
-			//expand the node and its parents
-			for(TreeItem item:items){				
-				TreeItem tempTreeItem=item;
-				item.setBackground(bgColor);
-				do{
-					tempTreeItem.setExpanded(true);
-					
-					tempTreeItem=tempTreeItem.getParentItem();					
-				}while(tempTreeItem != null);				
-			}	
-		}
-		
-		return true;
-		
-	}
-	/**
-	 * Searches for the given element and if found, makes it visible
-	 * @param element
-	
-	 */
-	public void showElement(OutlineElement element){	
-		
-		m_TreeViewer.getControl().setRedraw(false);
-		update();
-		Object[] expandedElements=m_TreeViewer.getExpandedElements();
-		//force all the elements to be scanned in
-		m_TreeViewer.expandAll();
-		m_TreeViewer.setExpandedElements(expandedElements);		
-		if(selectElement(element) == false){
-			Display.getCurrent().beep();
-		}
-		m_TreeViewer.getControl().setRedraw(true);
-		
-		
-	}
-	
-	public void update() {
-		if (m_TreeViewer != null) {
-			if (enableSort)
-				m_TreeViewer.setSorter(new ViewerSorter());
-			else
-				m_TreeViewer.setSorter(null);
-			Control control = m_TreeViewer.getControl();
-			IDocument doc = m_Editor.getDocument();
-			if (control != null && !control.isDisposed() && doc != null) {
-				Object expanded[] = m_TreeViewer.getExpandedElements();
-				control.setRedraw(false);
-				m_TreeViewer.setInput(doc);
-				if (expanded.length > 0) {
-					m_TreeViewer.setExpandedElements(expanded);
-				} else {
-					m_TreeViewer.collapseAll();
-				}
-				control.setRedraw(true);
-			}
-		}
-	}
-
-	public void selectionChanged(SelectionChangedEvent event)
-	{
-		m_Selection = event.getSelection();
-	}
-
-	public void doubleClick(DoubleClickEvent event)
-	{
-		ISelection selection = event.getSelection();
-		if (selection instanceof IStructuredSelection)
-		{
-			IStructuredSelection elements = (IStructuredSelection)selection;
-			if (elements.size() == 1)
-			{
-				Object element = elements.getFirstElement();
-				if (element instanceof OutlineElement) {
-					OutlineElement outlineElement = (OutlineElement) element;
-					m_Editor.showElement(outlineElement);
-				}
-			}
-		}
-	}
-
-	/**
-	 * set text to clipboard<p>
-	 * it is called from the Actions
-	 */
-	private void setClipboard(StringBuffer text)
-	{
-		TextTransfer plainTextTransfer = TextTransfer.getInstance();
-		m_Clipboard.setContents(new String[] { text.toString() },
-				new Transfer[] { plainTextTransfer });
-	}
-	
-	/**
-	 * Class used to copy the items text to the clip board
-	 */
-	private class CopyTextAction extends Action
-	{
-		public CopyTextAction()
-		{
-			super();
-			setText("Copy Text");
-		}
-		public void run()
-		{
-			StringBuffer text = new StringBuffer();
-
-			if (m_Selection instanceof IStructuredSelection)
-			{
-				Object[] ary = ((IStructuredSelection)m_Selection).toArray();
-				for (int i = 0; i < ary.length; i++)
-				{
-					text.append(ary[i].toString() + "\n");
-				}
-				setClipboard(text);
-			}
-		}
-	}
-
-	private class EnableSortAction extends Action {
-		public EnableSortAction() {
-			super();
-			setText("Sort");
-			setChecked(enableSort);
-		}
-
-		public void run() {
-			enableSort = !enableSort;
-			update();
-		}
-
-		public ImageDescriptor getImageDescriptor() {
-			return VerilogPlugin.getPlugin().getImageDescriptor(
-					ENABLE_SORT_ACTION_IMAGE);
-		}
-
-		public int getStyle() {
-			return AS_CHECK_BOX;
-		}
-
-		public String getToolTipText() {
-			return "Sort";
-		}
-	}
-
-	/**
-	 * Class used to perform the refresh action
-	 */
-	private class RefreshAction extends Action
-	{
-		public RefreshAction()
-		{
-			super();
-			setText("Refresh Hierarchy");
-		}
-		public void run()
-		{
-			update();
-		}
-		/**
-		 * Gets an image descriptor for this action
-		 */
-		public ImageDescriptor getImageDescriptor(){
-			return VerilogPlugin.getPlugin().getImageDescriptor(REFRESH_ACTION_IMAGE);
-		}
-	}
-	/**
-	 * Class used to perform the refresh action
-	 */
-	private class GotoDefinitionAction extends Action
-	{
-		public GotoDefinitionAction()
-		{
-			super();
-			setText("Goto Definition");
-		}
-		public void run() {
-			if (m_Selection instanceof IStructuredSelection) {
-				IStructuredSelection elements = (IStructuredSelection) m_Selection;
-				if (elements.size() == 1) {
-					Object element = elements.getFirstElement();
-
-					if (element instanceof VerilogInstanceElement) {
-						VerilogInstanceElement instance = (VerilogInstanceElement) element;
-						OutlineDatabase database = getOutlineDatabase();
-						if (database != null) {
-							OutlineElement module = database.findDefinition(instance);
-							if (module != null)
-								m_Editor.showElement(module);
-						}
-
-					} else if (element instanceof OutlineElement) {
-						OutlineElement outlineElement = (OutlineElement) element;
-						m_Editor.showElement(outlineElement);
-					}
-				}
-			}
-		}
-		/**
-		 * Gets an image descriptor for this action
-		 */
-		public ImageDescriptor getImageDescriptor(){
-			return VerilogPlugin.getPlugin().getImageDescriptor(GOTO_DEF_ACTION_IMAGE);
-		}
-	}
-	private class CollapseAllAction extends Action	
-	{
-		private static final String COLLAPSE_ALL_ACTION_IMAGE="$nl$/icons/collapse_all.gif";
-		public CollapseAllAction()
-		{
-			super();
-			setText("Collapse All");
-		}
-		public void run()
-		{
-			m_TreeViewer.collapseAll();
-		}
-		public ImageDescriptor getImageDescriptor(){
-			return VerilogPlugin.getPlugin().getImageDescriptor(COLLAPSE_ALL_ACTION_IMAGE);
-		}
-		public int getStyle(){
-			return AS_PUSH_BUTTON;
-		}
-		public String getToolTipText(){
-			return "Collapse all";
-		}
-	}
-	private class RescanAllAction extends Action	
-	{
-		private static final String COLLAPSE_ALL_ACTION_IMAGE="$nl$/icons/rescan.gif";
-		public RescanAllAction()
-		{
-			super();
-			setText("Rescan All");
-		}
-		public void run()
-		{
-			OutlineDatabase database = getOutlineDatabase();
-			if(database != null) 
-				database.scanProject();
-		}
-		public ImageDescriptor getImageDescriptor(){
-			return VerilogPlugin.getPlugin().getImageDescriptor(COLLAPSE_ALL_ACTION_IMAGE);
-		}
-		public int getStyle(){
-			return AS_PUSH_BUTTON;
-		}
-		public String getToolTipText(){
-			return "Rescan all HDL files";
-		}
-	}
-	
-	/**
-	 * utility function for getting OutlineDatabase
-	 */
-	private OutlineDatabase getOutlineDatabase() {
-		IProject project = m_Editor.getHdlDocument().getProject();
-		OutlineDatabase database = null;
-		try {
-			database = (OutlineDatabase) project
-					.getSessionProperty(VerilogPlugin.getOutlineDatabaseId());
-		} catch (CoreException e) {
-			return null;
-		}
-		return database;
-	}
-	
-	/**
-	 * Class used to copy the hierarchy
-	 */
-	private class CopyHierarchyAction extends Action
-	{
-		public CopyHierarchyAction()
-		{
-			super();
-			setText("Copy Hierarchy");
-		}
-		public void run()
-		{
-			StringBuffer text = new StringBuffer();
-
-			if (m_Selection instanceof IStructuredSelection)
-			{
-				Object[] ary = ((IStructuredSelection)m_Selection).toArray();
-				addText(text, 0, ary);
-
-				setClipboard(text);
-			}
-		}
-
-		/**
-		 * add text with indent of hierarchy
-		 * @param text	destination string
-		 * @param level	hierarchical level
-		 * @param ary	instance array
-		 */
-		private void addText(StringBuffer text, int level, Object[] ary)
-		{
-			if (ary == null)
-				return;
-			for (int i = 0; i < ary.length; i++)
-			{
-				for (int j = 0; j < level; j++)
-					text.append("    ");
-				text.append(ary[i].toString() + "\n");
-
-			}
-		}
-	}	
-
-}
-
-
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.editor;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Vector;
+import java.util.regex.Pattern;
+
+import com.elphel.vdt.veditor.VerilogPlugin;
+import com.elphel.vdt.veditor.document.HdlDocument;
+import com.elphel.vdt.veditor.parser.OutlineDatabase;
+import com.elphel.vdt.veditor.parser.OutlineElement;
+import com.elphel.vdt.veditor.parser.OutlineDatabase.OutlineDatabaseEvent;
+import com.elphel.vdt.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogInstanceElement;
+import com.elphel.vdt.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogModuleElement;
+import com.elphel.vdt.veditor.preference.PreferenceStrings;
+
+import org.eclipse.core.resources.IFile;
+import org.eclipse.core.resources.IProject;
+import org.eclipse.core.runtime.CoreException;
+import org.eclipse.jface.action.Action;
+import org.eclipse.jface.action.IMenuListener;
+import org.eclipse.jface.action.IMenuManager;
+import org.eclipse.jface.action.IToolBarManager;
+import org.eclipse.jface.action.MenuManager;
+import org.eclipse.jface.action.Separator;
+import org.eclipse.jface.resource.ImageDescriptor;
+import org.eclipse.jface.text.IDocument;
+import org.eclipse.jface.viewers.DoubleClickEvent;
+import org.eclipse.jface.viewers.IDoubleClickListener;
+import org.eclipse.jface.viewers.ISelection;
+import org.eclipse.jface.viewers.ISelectionChangedListener;
+import org.eclipse.jface.viewers.IStructuredSelection;
+import org.eclipse.jface.viewers.SelectionChangedEvent;
+import org.eclipse.jface.viewers.TreeViewer;
+import org.eclipse.jface.viewers.Viewer;
+import org.eclipse.jface.viewers.ViewerFilter;
+import org.eclipse.jface.viewers.ViewerSorter;
+import org.eclipse.swt.dnd.Clipboard;
+import org.eclipse.swt.dnd.TextTransfer;
+import org.eclipse.swt.dnd.Transfer;
+import org.eclipse.swt.graphics.Color;
+import org.eclipse.swt.graphics.RGB;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Display;
+import org.eclipse.swt.widgets.Menu;
+import org.eclipse.swt.widgets.Shell;
+import org.eclipse.swt.widgets.TreeItem;
+import org.eclipse.ui.IEditorPart;
+import org.eclipse.ui.IEditorReference;
+import org.eclipse.ui.IPartListener2;
+import org.eclipse.ui.IPropertyListener;
+import org.eclipse.ui.IWorkbenchPage;
+import org.eclipse.ui.IWorkbenchPartReference;
+import org.eclipse.ui.PlatformUI;
+import org.eclipse.ui.part.Page;
+import org.eclipse.ui.part.PageBook;
+
+public class HdlHierarchyPage extends Page implements ISelectionChangedListener,
+		IDoubleClickListener
+{
+    private TreeViewer m_TreeViewer;
+    private HdlEditor  m_Editor;  // m_Editor is just one of the editor tabs (add list of Editors to find active?)
+    private IProject   m_Project; // AF
+    private Clipboard  m_Clipboard;
+    private ISelection m_Selection;
+    private Action     m_RefreshAction;
+    private Action     m_CopyTextAction;
+    private Action     m_CopyHierarchyAction;
+    private Action     m_GotoDefinition;
+    private Action     m_CollapseAllAction;
+    private Action     m_RescanAllAction;
+    private Action     m_EnableSortAction;
+    private Action     m_HierarchyFilterAction;
+    private Action     m_CopyInstaceTemplateNoparamsAction;
+    private Action     m_CopyInstaceTemplateSinglelineAction;
+    private Action     m_CopyInstaceTemplateMultilineAction;
+    private Action     m_CopyInstaceTemplateAction;
+    private boolean    enableSort;
+    private boolean    hierarchyTopOnly;
+    private boolean    editorOnly; // unfinished AF2016/06/19
+    private databaseListner docChangeListener;
+
+	private static final String FILTER_HIERARCHY= "$nl$/icons/filter_signal.gif"; /* TODO: replace */
+    private final static String REFRESH_ACTION_IMAGE="$nl$/icons/refresh.gif";
+    private final static String GOTO_DEF_ACTION_IMAGE="$nl$/icons/goto_def.gif";
+	private static final String ENABLE_SORT_ACTION_IMAGE="$nl$/icons/sort.gif";
+    
+	public HdlHierarchyPage(HdlEditor editor) {
+		super();
+		this.m_Editor = editor;
+		try {
+			this.m_Project = m_Editor.getHdlDocument().getProject(); //null pointer (getHdlDocument()==null)
+		} catch (NullPointerException e) {
+			System.out.println("Failed in set project for HdlHierarchyPage");
+			this.m_Project =null ;
+		}
+		m_Clipboard = new Clipboard(Display.getCurrent());
+		m_Selection = null;
+		m_TreeViewer = null;
+		m_CollapseAllAction = null;
+		m_RescanAllAction = null;
+		m_EnableSortAction = null;
+	    m_CopyInstaceTemplateNoparamsAction = null;
+	    m_CopyInstaceTemplateSinglelineAction = null;
+	    m_CopyInstaceTemplateMultilineAction = null;
+	    m_CopyInstaceTemplateAction = null;
+		
+		enableSort = VerilogPlugin.getPreferenceBoolean("Outline.Sort");
+		hierarchyTopOnly = VerilogPlugin.getPreferenceBoolean(PreferenceStrings.TOP_DIR_ONLY);
+		docChangeListener = null;
+		editorOnly = !hierarchyTopOnly; // just temporary
+		
+	}
+	
+	public void dispose() {
+		super.dispose();
+		m_Selection = null;
+		m_TreeViewer = null;
+	}
+	
+	public boolean isDisposed(){
+		return m_TreeViewer==null;
+	}
+	
+	
+	protected class databaseListner extends OutlineDatabaseEvent{
+
+		@Override
+		public void handel() {
+			   update();        
+		}
+		
+	}
+	
+	public void createControl(Composite parent)
+	{
+		m_TreeViewer=new TreeViewer(parent);
+		createActions();		
+		createMenu();
+		m_TreeViewer.addFilter(new HierarchyFilter());
+
+		createToolbar();
+		createContextMenu(m_TreeViewer.getTree());
+
+		m_TreeViewer.setContentProvider(m_Editor.getHirarchyProvider());
+		m_TreeViewer.setLabelProvider(m_Editor.getOutlineLabelProvider());
+		m_TreeViewer.addSelectionChangedListener(this);
+		m_TreeViewer.addDoubleClickListener(this);
+		if (enableSort)
+			m_TreeViewer.setSorter(new ViewerSorter());
+		IDocument doc = m_Editor.getDocument();
+		docChangeListener = null;
+		if (doc != null) {
+			m_TreeViewer.setInput(doc);
+			m_TreeViewer.collapseAll();
+			//register the update function
+			if (doc instanceof HdlDocument) {
+				HdlDocument hdlDoc = (HdlDocument) doc;
+				docChangeListener = new databaseListner();
+				hdlDoc.getOutlineDatabase().addChangeListner(docChangeListener); // new databaseListner());
+			}
+		}
+		// Here? AF 2016_06_18
+		addEditorChangeListener();
+		
+	}
+	/**
+	 * creates the actions
+	 */
+	private void createActions() {
+		m_CopyTextAction = new CopyTextAction();
+		m_CopyHierarchyAction = new CopyHierarchyAction();
+		m_RefreshAction = new RefreshAction();
+		m_GotoDefinition = new GotoDefinitionAction();
+		m_CollapseAllAction = new CollapseAllAction();
+		m_RescanAllAction = new RescanAllAction();
+		m_EnableSortAction = new EnableSortAction();
+		m_HierarchyFilterAction = new HierarchyFilterAction();
+		
+	    m_CopyInstaceTemplateNoparamsAction = new CopyInstaceTemplateNoparamsAction();
+	    m_CopyInstaceTemplateSinglelineAction = new CopyInstaceTemplateSinglelineAction();
+	    m_CopyInstaceTemplateMultilineAction = new CopyInstaceTemplateMultilineAction();
+	    m_CopyInstaceTemplateAction = new CopyInstaceTemplateAction();
+	}
+
+	/** 
+	 *  creates a menu for this view
+	 */
+	private void createMenu(){
+		
+	}
+	/**
+	 * Creates a toolbar for this view
+	 */
+	private void createToolbar(){
+		IToolBarManager mgr = getSite().getActionBars().getToolBarManager();
+		mgr.add(m_EnableSortAction);
+        mgr.add(m_RefreshAction);
+        mgr.add(m_CollapseAllAction);
+        mgr.add(m_RescanAllAction);
+        mgr.add(m_HierarchyFilterAction);
+	}
+	/**
+	 * Creates a context menu for this view
+	 * @param control
+	 */
+	private void createContextMenu(Control control)
+	{
+		MenuManager menuManager = new MenuManager();
+		menuManager.setRemoveAllWhenShown(true);
+		menuManager.addMenuListener(new IMenuListener() {
+			public void menuAboutToShow(IMenuManager menu)
+			{
+				if(m_Selection != null){
+					menu.add(m_CopyTextAction);
+					menu.add(m_CopyHierarchyAction);
+					menu.add(m_GotoDefinition);
+				}
+				menu.add(m_RefreshAction);
+				menu.add(m_CollapseAllAction);				
+				if(m_Selection != null){
+					menu.add(new Separator());
+					menu.add(m_CopyInstaceTemplateNoparamsAction);
+					menu.add(m_CopyInstaceTemplateSinglelineAction);
+					menu.add(m_CopyInstaceTemplateMultilineAction);
+					menu.add(m_CopyInstaceTemplateAction);
+				}
+			}
+		});
+		Menu menu = menuManager.createContextMenu(control);		
+		control.setMenu(menu);			
+	}
+
+	public Control getControl()
+	{
+		if (m_TreeViewer == null)
+			return null;
+		return m_TreeViewer.getControl();
+	}
+
+	public void setFocus()
+	{
+		// make ancestors visible (otherwise not possible to set focus)
+		Composite theComposite=m_TreeViewer.getControl().getParent();
+		while (theComposite != null) {
+			theComposite.setVisible(true);
+			if(theComposite.isVisible()) break;
+			theComposite = theComposite.getParent();
+		}
+		m_TreeViewer.getControl().setFocus();
+		
+	}
+
+	public void setVisible()
+	{
+		// make ancestors visible (otherwise not possible to set focus)
+		Composite theComposite=m_TreeViewer.getControl().getParent();
+		while (theComposite != null) {
+			theComposite.setVisible(true);
+			if(theComposite.isVisible()) break;
+			theComposite = theComposite.getParent();
+		}
+		((PageBook) m_TreeViewer.getControl().getParent()).showPage(m_TreeViewer.getControl());
+		
+	}
+
+	public void setInput(Object input)
+	{
+//		update();
+	}
+	
+	
+	/**
+	 * Searches through the tree item recursively and looks the specified element
+	 * @param element
+	 * @param item
+	 * @return
+	 */
+	protected TreeItem findTreeItem(TreeItem item,OutlineElement element){
+		if (!item.isDisposed() && (item.getData() instanceof OutlineElement)) {
+			OutlineElement e = (OutlineElement) item.getData();
+//			System.out.println("e="+e+", element="+element);
+			if(e.equals(element)){
+//				System.out.println("**** match ****");
+				return item;
+			}
+			/*
+			if (e.equals(element.getParent())){
+				System.out.println("**** parent (module) match ****");
+				return item;
+			}
+			*/
+		}else
+		{
+			return null;
+		}
+		//look through the children
+		for(TreeItem child:item.getItems()){
+			TreeItem temp=findTreeItem(child,element);
+			if(temp!=null){
+				return temp;
+			}
+		}
+		
+		return null;
+	}
+	
+	/**
+	 * scans the tree and selects the item
+	 * @param element
+	 * @return true if item was found and is select, false otherwise
+	 */
+	private boolean selectElement(OutlineElement element){
+		TreeItem target=null;		
+		if(element == null){			
+			return false;
+		}
+
+		TreeItem[] treeItems=m_TreeViewer.getTree().getItems();
+		Vector<TreeItem> itemsVector=new Vector<TreeItem>();
+		for(TreeItem item: treeItems){
+			target=findTreeItem(item, element);
+			if((target!=null) && !target.isDisposed()){ // Andrey
+				itemsVector.add(target);							
+			}
+		}
+		//since the hierarchy tree may only include some of the outline elements,
+		//we may need seek backwards in the parent's history to find something in
+		//the hierarchy list
+		if(itemsVector.size()==0){
+			return selectElement(element.getParent());
+		}else{
+			TreeItem[] items=itemsVector.toArray(new TreeItem[0]);
+			RGB rgb=new RGB(255,255,10);
+			Color bgColor=new Color(Display.getCurrent(), rgb);
+/*	
+			m_TreeViewer.collapseAll(); // disposes found item?
+			for(TreeItem item:items){				
+				TreeItem tempTreeItem=item;
+				item.setBackground(bgColor); // Item is disposed
+				do{
+					tempTreeItem.setExpanded(true);
+					
+					tempTreeItem=tempTreeItem.getParentItem();					
+				}while(tempTreeItem != null);				
+			}
+*/
+			List<TreeItem> expandedItems=new ArrayList<TreeItem>();
+			//expand the node and its parents
+			for(TreeItem item:items){				
+				TreeItem tempTreeItem=item;
+				item.setBackground(bgColor); // Item is disposed
+				do{
+					expandedItems.add(tempTreeItem);
+					tempTreeItem=tempTreeItem.getParentItem();					
+				} while(tempTreeItem != null);				
+			}
+			m_TreeViewer.setExpandedElements(expandedItems.toArray(new TreeItem[0]));
+//			now collapse all highest level elements not needed for selected
+/*			
+			for(TreeItem item:treeItems){
+				if (!expandedItems.contains(item) &&
+						((item.getParentItem()==null) || 
+						expandedItems.contains(item.getParentItem()))){
+					item.setExpanded(false);
+				}
+			}
+*/		
+		}
+		return true;
+	}
+	/**
+	 * Searches for the given element and if found, makes it visible
+	 * @param element
+	
+	 */
+	// For some reasons works only on the second time after collapse all
+	public void showElement(OutlineElement element){	
+		m_TreeViewer.reveal(element);				
+		TreeItem[] treeItems=m_TreeViewer.getTree().getItems();
+		m_TreeViewer.getControl().setRedraw(false);
+		update();
+		Object[] expandedElements=m_TreeViewer.getExpandedElements();
+		//force all the elements to be scanned in
+		m_TreeViewer.expandAll();
+		if(selectElement(element) == false){
+			Display.getCurrent().beep();
+		} else {
+			Object[] newExpandedElements=m_TreeViewer.getExpandedElements();
+			Object [] combinedExpandedItems=new Object[expandedElements.length+newExpandedElements.length];
+			for (int i=0;i<expandedElements.length;i++) combinedExpandedItems[i]=expandedElements[i];
+			int len=expandedElements.length;
+			for (int i=0;i<newExpandedElements.length;i++) combinedExpandedItems[len+i]=newExpandedElements[i];
+			expandedElements=combinedExpandedItems;
+		}
+		m_TreeViewer.setExpandedElements(expandedElements);		
+		m_TreeViewer.getControl().setRedraw(true);
+		for(TreeItem item: treeItems){
+			TreeItem target=findTreeItem(item, element);
+			if(target!=null){
+				m_TreeViewer.getTree().setSelection(target);
+				m_TreeViewer.reveal(element);
+				break;
+			}
+		}				
+	}
+	
+	public void addEditorChangeListener() {
+		IWorkbenchPage page = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage();
+		//the active part
+		//				IWorkbenchPart active = page.getActivePart();
+		//adding a listener
+		IPartListener2 pl = new IPartListener2() {
+			public void partActivated(IWorkbenchPartReference ref) {
+				//			          System.out.println("Active: "+ref.getTitle());
+				if (ref instanceof IEditorReference) {
+					IEditorPart editorPart = ((IEditorReference) ref).getEditor(false); //Tries to restore the editor if restore is true.
+					if (editorPart instanceof HdlEditor) {
+						HdlEditor editor = (HdlEditor) editorPart;
+						if (editor != m_Editor){
+							if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR)) {
+								System.out.println("Switching to editor "+ref.getTitle());
+							}
+
+							HdlEditor oldEditor = m_Editor; 
+							m_Editor = editor;
+							try {
+								IProject project = m_Editor.getHdlDocument().getProject(); //null pointer (getHdlDocument()==null)
+								if (m_Project != project) {
+									m_Project = project; // rebuld 
+									System.out.println("Need to rebuild database here (project changted)");
+								}
+							} catch (NullPointerException e) {
+								System.out.println("Failed in set project for HdlHierarchyPage in addEditorChangeListener()");
+							}
+							// Set other fileds for the new editor
+							// remove links to old document
+							if (docChangeListener != null){
+								IDocument doc = oldEditor.getDocument();
+								if ((doc != null) && (doc instanceof HdlDocument)) { // null if editor was closed
+									HdlDocument hdlDoc = (HdlDocument) doc;				
+									hdlDoc.getOutlineDatabase().removeChangeListner(docChangeListener);
+								}
+							}
+
+
+							m_TreeViewer.setContentProvider(m_Editor.getHirarchyProvider());
+							m_TreeViewer.setLabelProvider(m_Editor.getOutlineLabelProvider());
+							IDocument doc = m_Editor.getDocument();
+							if (doc != null)
+							{
+								m_TreeViewer.setInput(doc);
+								m_TreeViewer.collapseAll();
+								//register the update function
+								if (doc instanceof HdlDocument) {
+									HdlDocument hdlDoc = (HdlDocument) doc;
+									if (docChangeListener == null) docChangeListener = new databaseListner();
+									hdlDoc.getOutlineDatabase().addChangeListner(docChangeListener);
+								}
+							}			
+							update();
+						}
+					}
+
+				}
+
+			}
+			//			      ... other listener methods ...
+
+			@Override
+			public void partBroughtToTop(IWorkbenchPartReference arg0) {
+				// TODO Auto-generated method stub
+
+			}
+
+			@Override
+			public void partClosed(IWorkbenchPartReference arg0) {
+				// TODO Auto-generated method stub
+
+			}
+
+			@Override
+			public void partDeactivated(IWorkbenchPartReference arg0) {
+				// TODO Auto-generated method stub
+
+			}
+
+			@Override
+			public void partHidden(IWorkbenchPartReference arg0) {
+				// TODO Auto-generated method stub
+
+			}
+
+			@Override
+			public void partInputChanged(IWorkbenchPartReference arg0) {
+				// TODO Auto-generated method stub
+
+			}
+
+			@Override
+			public void partOpened(IWorkbenchPartReference arg0) {
+				// TODO Auto-generated method stub
+
+			}
+
+			@Override
+			public void partVisible(IWorkbenchPartReference arg0) {
+				// TODO Auto-generated method stub
+
+			}
+		};
+		page.addPartListener(pl);
+
+	}	
+	
+	
+	public void update() {
+		
+		if (m_TreeViewer != null) {
+			if (enableSort)
+				m_TreeViewer.setSorter(new ViewerSorter());
+			else
+				m_TreeViewer.setSorter(null);
+			Control control = m_TreeViewer.getControl();
+			IDocument doc = m_Editor.getDocument();
+			if (control != null && !control.isDisposed() && doc != null) {
+				Object expanded[] = m_TreeViewer.getExpandedElements();
+				control.setRedraw(false);
+				m_TreeViewer.setInput(doc);
+				if (expanded.length > 0) {
+					m_TreeViewer.setExpandedElements(expanded);
+				} else {
+					m_TreeViewer.collapseAll();
+				}
+				control.setRedraw(true);
+			}
+		}
+	}
+
+	public void selectionChanged(SelectionChangedEvent event)
+	{
+		m_Selection = event.getSelection();
+	}
+
+	public void doubleClick(DoubleClickEvent event)
+	{
+		ISelection selection = event.getSelection();
+		if (selection instanceof IStructuredSelection)
+		{
+			IStructuredSelection elements = (IStructuredSelection)selection;
+			if (elements.size() == 1)
+			{
+				Object element = elements.getFirstElement();
+				if (element instanceof OutlineElement) {
+					OutlineElement outlineElement = (OutlineElement) element;
+					m_Editor.showElement(outlineElement);
+				}
+			}
+		}
+	}
+
+	/**
+	 * set text to clipboard<p>
+	 * it is called from the Actions
+	 */
+	private void setClipboard(StringBuffer text)
+	{
+		TextTransfer plainTextTransfer = TextTransfer.getInstance();
+		m_Clipboard.setContents(new String[] { text.toString() },
+				new Transfer[] { plainTextTransfer });
+	}
+
+	private void setClipboard(String text)
+	{
+		TextTransfer plainTextTransfer = TextTransfer.getInstance();
+		m_Clipboard.setContents(new String[] { text },
+				new Transfer[] { plainTextTransfer });
+	}
+	
+	/**
+	 * Class used to copy the items text to the clip board
+	 */
+	private class CopyTextAction extends Action
+	{
+		public CopyTextAction()
+		{
+			super();
+			setText("Copy Text");
+		}
+		public void run()
+		{
+			StringBuffer text = new StringBuffer();
+
+			if (m_Selection instanceof IStructuredSelection)
+			{
+				Object[] ary = ((IStructuredSelection)m_Selection).toArray();
+				for (int i = 0; i < ary.length; i++)
+				{
+					text.append(ary[i].toString() + "\n");
+				}
+				setClipboard(text);
+			}
+		}
+	}
+
+	private class EnableSortAction extends Action {
+		public EnableSortAction() {
+			super();
+			setText("Sort");
+			setChecked(enableSort);
+		}
+
+		public void run() {
+			enableSort = !enableSort;
+			update();
+		}
+
+		public ImageDescriptor getImageDescriptor() {
+			return VerilogPlugin.getPlugin().getImageDescriptor(
+					ENABLE_SORT_ACTION_IMAGE);
+		}
+
+		public int getStyle() {
+			return AS_CHECK_BOX;
+		}
+
+		public String getToolTipText() {
+			return "Sort";
+		}
+	}
+
+	/**
+	 * Class used to perform the refresh action
+	 */
+	private class RefreshAction extends Action
+	{
+		public RefreshAction()
+		{
+			super();
+			setText("Refresh Hierarchy");
+		}
+		public void run()
+		{
+			update();
+		}
+		/**
+		 * Gets an image descriptor for this action
+		 */
+		public ImageDescriptor getImageDescriptor(){
+			return VerilogPlugin.getPlugin().getImageDescriptor(REFRESH_ACTION_IMAGE);
+		}
+	}
+	/**
+	 * Class used to perform the refresh action
+	 */
+	private class GotoDefinitionAction extends Action
+	{
+		public GotoDefinitionAction()
+		{
+			super();
+			setText("Goto Definition");
+		}
+		public void run() {
+			if (m_Selection instanceof IStructuredSelection) {
+				IStructuredSelection elements = (IStructuredSelection) m_Selection;
+				if (elements.size() == 1) {
+					Object element = elements.getFirstElement();
+
+					if (element instanceof VerilogInstanceElement) {
+						VerilogInstanceElement instance = (VerilogInstanceElement) element;
+						OutlineDatabase database = getOutlineDatabase();
+						if (database != null) {
+							OutlineElement module = database.findDefinition(instance);
+							if (module != null)
+								m_Editor.showElement(module);
+						}
+
+					} else if (element instanceof OutlineElement) {
+						OutlineElement outlineElement = (OutlineElement) element;
+						m_Editor.showElement(outlineElement);
+					}
+				}
+			}
+		}
+		/**
+		 * Gets an image descriptor for this action
+		 */
+		public ImageDescriptor getImageDescriptor(){
+			return VerilogPlugin.getPlugin().getImageDescriptor(GOTO_DEF_ACTION_IMAGE);
+		}
+	}
+
+	private class CopyInstaceTemplateAction extends Action
+	{
+		protected boolean addComments = true;
+		protected boolean multiline   = true;
+		protected boolean noParams    = false;
+		public CopyInstaceTemplateAction()
+		{
+			super();
+			setText("Copy Instance Template (multiline with comments");
+		}
+		public void run() {
+			if (m_Selection instanceof IStructuredSelection) {
+				IStructuredSelection elements = (IStructuredSelection) m_Selection;
+				if (elements.size() == 1) {
+					Object element = elements.getFirstElement();
+
+					if (element instanceof VerilogInstanceElement) {
+						VerilogInstanceElement instance = (VerilogInstanceElement) element;
+						OutlineDatabase database = getOutlineDatabase();
+						if (database != null) {
+							OutlineElement module = database.findDefinition(instance);
+							if (module != null) {
+								if (module instanceof VerilogModuleElement) {
+									String template= ((VerilogModuleElement) module).getInstanceTemplate(addComments,multiline,noParams);
+									if (template!=null){
+										setClipboard(template);
+									}
+									
+								}
+							}
+						}
+					} else if (element instanceof VerilogModuleElement) {
+						String template= ((VerilogModuleElement) element).getInstanceTemplate(addComments,multiline,noParams);
+						if (template!=null){
+							setClipboard(template);
+						}
+						
+					}
+				}
+			}
+		}
+		/**
+		 * Gets an image descriptor for this action
+		 */
+		//TODO: make icon (and to other classes)?
+//		public ImageDescriptor getImageDescriptor(){
+//			return VerilogPlugin.getPlugin().getImageDescriptor(GOTO_DEF_ACTION_IMAGE);
+//		}
+	}
+
+	private class CopyInstaceTemplateNoparamsAction extends CopyInstaceTemplateAction
+	{
+		public CopyInstaceTemplateNoparamsAction()
+		{
+			super();
+			setText("Copy Instance Template (single line, no parameters)");
+		}
+		public void run() {
+			addComments = false;
+			multiline   = false;
+			noParams    = true;
+			super.run();
+		}
+	}
+	private class CopyInstaceTemplateSinglelineAction extends CopyInstaceTemplateAction
+	{
+		public CopyInstaceTemplateSinglelineAction()
+		{
+			super();
+			setText("Copy Instance Template (single line with parameters)");
+		}
+		public void run() {
+			addComments = false;
+			multiline   = false;
+			noParams    = false;
+			super.run();
+		}
+	}
+	private class CopyInstaceTemplateMultilineAction extends CopyInstaceTemplateAction
+	{
+		public CopyInstaceTemplateMultilineAction()
+		{
+			super();
+			setText("Copy Instance Template (multi-line, no comments)");
+		}
+		public void run() {
+			addComments = false;
+			multiline   = false;
+			noParams    = false;
+			super.run();
+		}
+	}
+
+	
+	private class CollapseAllAction extends Action	
+	{
+		private static final String COLLAPSE_ALL_ACTION_IMAGE="$nl$/icons/collapse_all.gif";
+		public CollapseAllAction()
+		{
+			super();
+			setText("Collapse All");
+		}
+		public void run()
+		{
+			m_TreeViewer.collapseAll();
+		}
+		public ImageDescriptor getImageDescriptor(){
+			return VerilogPlugin.getPlugin().getImageDescriptor(COLLAPSE_ALL_ACTION_IMAGE);
+		}
+		public int getStyle(){
+			return AS_PUSH_BUTTON;
+		}
+		public String getToolTipText(){
+			return "Collapse all";
+		}
+	}
+	private class RescanAllAction extends Action	
+	{
+		private static final String COLLAPSE_ALL_ACTION_IMAGE="$nl$/icons/rescan.gif";
+		public RescanAllAction()
+		{
+			super();
+			setText("Rescan All");
+		}
+		public void run()
+		{
+			OutlineDatabase database = getOutlineDatabase();
+			if(database != null) 
+				database.scanProject();
+		}
+		public ImageDescriptor getImageDescriptor(){
+			return VerilogPlugin.getPlugin().getImageDescriptor(COLLAPSE_ALL_ACTION_IMAGE);
+		}
+		public int getStyle(){
+			return AS_PUSH_BUTTON;
+		}
+		public String getToolTipText(){
+			return "Rescan all HDL files";
+		}
+	}
+	
+	/**
+	 * utility function for getting OutlineDatabase
+	 */
+	private OutlineDatabase getOutlineDatabase() {
+		IProject project = m_Project; // Per hierarchy page
+		if (project == null){
+			System.out.println("Hierarchy page project is null, trying old way");
+			try {
+				project = m_Editor.getHdlDocument().getProject(); //null pointer (getHdlDocument()==null)
+			} catch (NullPointerException e) {
+				System.out.println("Failed in getOutlineDatabase() due to a null pointer");
+				return null;
+			}
+		}
+		OutlineDatabase database = null;
+		try {
+			database = (OutlineDatabase) project
+					.getSessionProperty(VerilogPlugin.getOutlineDatabaseId());
+		} catch (CoreException e) {
+			return null;
+		}
+		return database;
+	}
+	
+	/**
+	 * Class used to copy the hierarchy
+	 */
+	private class CopyHierarchyAction extends Action
+	{
+		public CopyHierarchyAction()
+		{
+			super();
+			setText("Copy Hierarchy");
+		}
+		public void run()
+		{
+			StringBuffer text = new StringBuffer();
+
+			if (m_Selection instanceof IStructuredSelection)
+			{
+				Object[] ary = ((IStructuredSelection)m_Selection).toArray();
+				addText(text, 0, ary);
+
+				setClipboard(text);
+			}
+		}
+
+		/**
+		 * add text with indent of hierarchy
+		 * @param text	destination string
+		 * @param level	hierarchical level
+		 * @param ary	instance array
+		 */
+		private void addText(StringBuffer text, int level, Object[] ary)
+		{
+			if (ary == null)
+				return;
+			for (int i = 0; i < ary.length; i++)
+			{
+				for (int j = 0; j < level; j++)
+					text.append("    ");
+				text.append(ary[i].toString() + "\n");
+
+			}
+		}
+	}
+	
+	private class HierarchyFilter extends ViewerFilter {
+
+		public boolean select(Viewer viewer, Object parentElement,
+				Object element) {
+//			boolean hierarchyTopOnly = true; // override global 
+			
+			// TODO: Implement that filtering that shows only subtree that goes through the active editor
+			
+			if (hierarchyTopOnly && !select_filter_top(viewer, parentElement,element)) 
+				return false;
+//			if (editorOnly &&       !select_filter_editor(viewer, parentElement,element)) 
+//				return false;
+			return true;
+		}
+
+		private boolean select_filter_top(Viewer viewer, Object parentElement,
+				Object element) {
+			OutlineElement oe= (OutlineElement) element;
+			try {
+				Pattern pattern=Pattern.compile(VerilogPlugin.getPreferenceString(PreferenceStrings.EXCLUDE_DIRS_REGEX));
+				while (oe.getParent()!=null) oe=oe.getParent();
+				if (pattern.matcher(oe.getFile().toString()).find()) return false; 
+				return true;
+			} catch (Exception e){
+				return true; // bad pattern, show all
+			}
+		}
+		private boolean select_filter_editor(Viewer viewer, Object parentElement,
+				Object element) {
+			HdlEditor editor = m_Editor;
+//			m_Editor.getEditorInput();
+//			IFile editorFile=m_Editor.getHdlDocument().getFile();
+			IFile editorFile=editor.getHdlDocument().getFile();
+			OutlineElement oe= (OutlineElement) element;
+			// see if this element are any of the parents are in the editor document
+			System.out.println("editorFile = "+editorFile);
+			while (oe != null){
+				System.out.println("oe.getFile() = "+oe.getFile());
+				if (editorFile.equals(oe.getFile())) {
+					return true;
+				}
+				oe = oe.getParent();
+			}
+			return false;
+		}
+
+		
+	}
+
+	private class HierarchyFilterAction extends Action {
+		public HierarchyFilterAction() {
+			super();
+			setText("Filter Hierarchy");
+			setChecked(hierarchyTopOnly);
+		}
+
+		public void run() {
+			hierarchyTopOnly = !hierarchyTopOnly;
+			editorOnly = !hierarchyTopOnly; // just temporary 
+			update();
+		}
+
+		public ImageDescriptor getImageDescriptor() {
+			return VerilogPlugin.getPlugin().getImageDescriptor(
+					FILTER_HIERARCHY);
+		}
+
+		public int getStyle() {
+			return AS_CHECK_BOX;
+		}
+
+		public String getToolTipText() {
+			return "Filter hierarchy";
+		}
+	}
+
+}
+
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/editor/HdlLabelProvider.java vdt/src/com/elphel/vdt/veditor/editor/HdlLabelProvider.java
--- vdt-veditor/src/com/elphel/vdt/veditor/editor/HdlLabelProvider.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/editor/HdlLabelProvider.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,64 +1,75 @@
-/*******************************************************************************
- * Copyright (c) 2007 Ali Ghorashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    Ali Ghorashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.editor;
-
-import net.sourceforge.veditor.VerilogPlugin;
-import net.sourceforge.veditor.parser.OutlineElement;
-
-import org.eclipse.jface.viewers.LabelProvider;
-import org.eclipse.swt.graphics.Image;
-
-abstract public class HdlLabelProvider extends LabelProvider {
-	/**
-	 * Converts a name to a string using the type string
-	 * @param name element's name
-	 * @param Type element's type
-	 * @return
-	 */
-	abstract protected String convertToString(OutlineElement outlineElement);
-	
-	/**
-	 * Returns an image name to be used for the given type
-	 * @param type Type string
-	 * @return Image name to be used for this tye
-	 */
-	abstract protected String getImageNameForType(OutlineElement outlineElement);
-	/* (non-Javadoc)
-	 * @see org.eclipse.jface.viewers.LabelProvider#getText(java.lang.Object)
-	 */
-	public String getText(Object element){
-		 if (element instanceof OutlineElement) {
-			OutlineElement outlineElement = (OutlineElement) element;
-			
-			return convertToString(outlineElement);
-		}
-		 else{
-			 return element.toString();
-		 }
-	}
-	
-	/* (non-Javadoc)
-	 * @see org.eclipse.jface.viewers.LabelProvider#getImage(java.lang.Object)
-	 */
-	public Image getImage(Object element) {
-		VerilogPlugin plugin = VerilogPlugin.getPlugin();
-		Image results = null;
-
-		// if the element is an outline element
-		if (element instanceof OutlineElement) {
-			OutlineElement outlineElement = (OutlineElement) element;
-			String imageName = getImageNameForType(outlineElement);
-			results=plugin.getImage(imageName);			
-		}		
-		
-		return results;
-	}
-}
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2007 Ali Ghorashi and others.
+ *
+ * Contributors:
+ *    Ali Ghorashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.editor;
+
+import com.elphel.vdt.veditor.VerilogPlugin;
+import com.elphel.vdt.veditor.parser.OutlineElement;
+
+import org.eclipse.jface.viewers.LabelProvider;
+import org.eclipse.swt.graphics.Image;
+
+abstract public class HdlLabelProvider extends LabelProvider {
+	/**
+	 * Converts a name to a string using the type string
+	 * @param name element's name
+	 * @param Type element's type
+	 * @return
+	 */
+	abstract protected String convertToString(OutlineElement outlineElement);
+	
+	/**
+	 * Returns an image name to be used for the given type
+	 * @param type Type string
+	 * @return Image name to be used for this tye
+	 */
+	abstract protected String getImageNameForType(OutlineElement outlineElement);
+	/* (non-Javadoc)
+	 * @see org.eclipse.jface.viewers.LabelProvider#getText(java.lang.Object)
+	 */
+	public String getText(Object element){
+		 if (element instanceof OutlineElement) {
+			OutlineElement outlineElement = (OutlineElement) element;
+			
+			return convertToString(outlineElement);
+		}
+		 else{
+			 return element.toString();
+		 }
+	}
+	
+	/* (non-Javadoc)
+	 * @see org.eclipse.jface.viewers.LabelProvider#getImage(java.lang.Object)
+	 */
+	public Image getImage(Object element) {
+		VerilogPlugin plugin = VerilogPlugin.getPlugin();
+		Image results = null;
+
+		// if the element is an outline element
+		if (element instanceof OutlineElement) {
+			OutlineElement outlineElement = (OutlineElement) element;
+			String imageName = getImageNameForType(outlineElement);
+			results=plugin.getImage(imageName);			
+		}		
+		
+		return results;
+	}
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/editor/HdlSourceViewerConfiguration.java vdt/src/com/elphel/vdt/veditor/editor/HdlSourceViewerConfiguration.java
--- vdt-veditor/src/com/elphel/vdt/veditor/editor/HdlSourceViewerConfiguration.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/editor/HdlSourceViewerConfiguration.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,467 +1,526 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-
-package net.sourceforge.veditor.editor;
-
-import java.util.Iterator;
-import java.util.Vector;
-
-import net.sourceforge.veditor.VerilogPlugin;
-import net.sourceforge.veditor.document.HdlDocument;
-import net.sourceforge.veditor.document.VhdlDocument;
-import net.sourceforge.veditor.editor.scanner.HdlCommentScanner;
-import net.sourceforge.veditor.editor.scanner.HdlPartitionScanner;
-import net.sourceforge.veditor.editor.scanner.HdlScanner;
-import net.sourceforge.veditor.parser.HdlParserException;
-import net.sourceforge.veditor.parser.OutlineContainer;
-import net.sourceforge.veditor.parser.OutlineDatabase;
-import net.sourceforge.veditor.parser.OutlineElement;
-import net.sourceforge.veditor.parser.vhdl.VhdlOutlineElementFactory.ComponentDeclElement;
-import net.sourceforge.veditor.parser.vhdl.VhdlOutlineElementFactory.ComponentInstElement;
-import net.sourceforge.veditor.parser.vhdl.VhdlOutlineElementFactory.PackageDeclElement;
-import net.sourceforge.veditor.parser.vhdl.VhdlOutlineElementFactory.VhdlOutlineElement;
-
-import org.eclipse.core.resources.IMarker;
-import org.eclipse.jface.text.BadLocationException;
-import org.eclipse.jface.text.IDocument;
-import org.eclipse.jface.text.IRegion;
-import org.eclipse.jface.text.ITextHover;
-import org.eclipse.jface.text.ITextViewer;
-import org.eclipse.jface.text.Region;
-import org.eclipse.jface.text.contentassist.ContentAssistant;
-import org.eclipse.jface.text.contentassist.IContentAssistant;
-import org.eclipse.jface.text.presentation.IPresentationReconciler;
-import org.eclipse.jface.text.presentation.PresentationReconciler;
-import org.eclipse.jface.text.rules.DefaultDamagerRepairer;
-import org.eclipse.jface.text.rules.Token;
-import org.eclipse.jface.text.source.IAnnotationHover;
-import org.eclipse.jface.text.source.IAnnotationModel;
-import org.eclipse.jface.text.source.ISourceViewer;
-import org.eclipse.jface.text.source.SourceViewerConfiguration;
-import org.eclipse.ui.texteditor.MarkerAnnotation;
-
-/**
- * parse verilog source code
- */
-abstract public class HdlSourceViewerConfiguration extends
-		SourceViewerConfiguration
-{
-	private HdlScanner scanner;
-	private HdlEditor m_Editor;
-	
-	public static HdlSourceViewerConfiguration createForVerilog(HdlEditor editor)
-	{
-		return new HdlSourceViewerConfiguration(editor)
-		{
-			public HdlScanner createScanner()
-			{
-				return HdlScanner.createForVerilog(getColorManager());
-			}
-			public HdlCompletionProcessor createCompletionProcessor()
-			{
-				return new VerilogCompletionProcessor();
-			}
-		};
-	}
-	public static HdlSourceViewerConfiguration createForVhdl(HdlEditor editor)
-	{
-		return new HdlSourceViewerConfiguration(editor)
-		{
-			public HdlScanner createScanner()
-			{
-				return HdlScanner.createForVhdl(getColorManager());
-			}
-			public HdlCompletionProcessor createCompletionProcessor()
-			{
-				return new VhdlCompletionProcessor();
-			}
-		};
-	}
-	
-	public HdlSourceViewerConfiguration(HdlEditor editor)
-	{
-		m_Editor = editor;
-	}
-
-	abstract HdlScanner createScanner();
-	abstract HdlCompletionProcessor createCompletionProcessor();
-
-	public ColorManager getColorManager()
-	{
-		return m_Editor.getColorManager();
-	}
-
-	public String[] getConfiguredContentTypes(ISourceViewer sourceViewer)
-	{
-		String[] types = HdlPartitionScanner.getContentTypes();
-		String[] ret = new String[types.length+1];
-		ret[0] = IDocument.DEFAULT_CONTENT_TYPE; 
-		for( int i = 0 ; i < types.length ; i++ )
-			ret[i+1] = types[i];
-		return ret;
-	}
-	
-	private HdlScanner getHdlScanner()
-	{
-		if (scanner == null)
-		{
-			scanner = createScanner();
-			scanner.setDefaultReturnToken(new Token(
-					HdlTextAttribute.DEFAULT.getTextAttribute(m_Editor.getColorManager())));
-		}
-		return scanner;
-	}
-
-	public IPresentationReconciler getPresentationReconciler(
-			ISourceViewer sourceViewer)
-	{
-		PresentationReconciler reconciler = new PresentationReconciler();
-		
-		DefaultDamagerRepairer dr;
-		dr = new DefaultDamagerRepairer(getHdlScanner());
-		reconciler.setDamager(dr, IDocument.DEFAULT_CONTENT_TYPE);
-		reconciler.setRepairer(dr, IDocument.DEFAULT_CONTENT_TYPE);
-		
-	    String[] contentTypes = HdlPartitionScanner.getContentTypes();
-		HdlTextAttribute[] attrs = HdlPartitionScanner.getContentTypeAttributes();
-		for (int i = 0; i < contentTypes.length; i++)
-		{
-			addRepairer(reconciler, attrs[i], contentTypes[i]);
-		}
-		
-	    addCommentScanner(reconciler, HdlTextAttribute.SINGLE_LINE_COMMENT,HdlPartitionScanner.SINGLE_LINE_COMMENT);
-	    addCommentScanner(reconciler, HdlTextAttribute.MULTI_LINE_COMMENT,HdlPartitionScanner.MULTI_LINE_COMMENT);
-	    addCommentScanner(reconciler, HdlTextAttribute.DOXYGEN_COMMENT,HdlPartitionScanner.DOXYGEN_SINGLE_LINE_COMMENT);     
-	    addCommentScanner(reconciler, HdlTextAttribute.DOXYGEN_COMMENT,HdlPartitionScanner.DOXYGEN_MULTI_LINE_COMMENT);
-        
-		return reconciler;
-	}
-	
-	private void addCommentScanner(PresentationReconciler reconciler ,HdlTextAttribute attr,String contentType){	
-
-	    Token defaultToken=new Token(attr.getTextAttribute(m_Editor.getColorManager()));
-	    HdlCommentScanner commentScanner=new HdlCommentScanner(m_Editor.getColorManager(),defaultToken);        
-	    DefaultDamagerRepairer dr = new DefaultDamagerRepairer(commentScanner);
-        reconciler.setDamager(dr, contentType);
-        reconciler.setRepairer(dr, contentType);
-    
-	}
-	
-	private void addRepairer(PresentationReconciler reconciler,
-			HdlTextAttribute attr, String partition)
-	{
-		NonRuleBasedDamagerRepairer ndr;
-		ndr = new NonRuleBasedDamagerRepairer(attr
-				.getTextAttribute(m_Editor.getColorManager()));
-		reconciler.setDamager(ndr, partition);
-		reconciler.setRepairer(ndr, partition);
-	}
-
-	public IContentAssistant getContentAssistant(ISourceViewer sourceViewer)
-	{
-		ContentAssistant assistant = new ContentAssistant();
-		assistant.setContentAssistProcessor(createCompletionProcessor(),
-				IDocument.DEFAULT_CONTENT_TYPE);
-
-		assistant.enableAutoActivation(true);
-		assistant.setAutoActivationDelay(500);
-		assistant
-				.setProposalPopupOrientation(IContentAssistant.PROPOSAL_OVERLAY);
-		assistant
-				.setContextInformationPopupOrientation(IContentAssistant.CONTEXT_INFO_ABOVE);
-
-		return assistant;
-	}
-
-	public IAnnotationHover getAnnotationHover(ISourceViewer sourceViewer)
-	{
-		return new AnnotationHover();
-	}
-	
-	public ITextHover getTextHover(ISourceViewer sourceViewer,
-			String contentType)
-	{
-		return new TextHover();
-	}
-
-	private static class AnnotationHover implements IAnnotationHover
-	{
-
-		public String getHoverInfo(ISourceViewer sourceViewer, int lineNumber)
-		{
-			IAnnotationModel model = sourceViewer.getAnnotationModel();
-			if (model == null)
-				return null;
-			
-			// lineNumber starts from 0, not 1
-			lineNumber++;
-
-	
-			Iterator i= model.getAnnotationIterator();;
-			String messages = null;
-
-			while(i.hasNext())
-			{
-				Object annotaion = i.next();
-				if (annotaion instanceof MarkerAnnotation)
-				{
-					IMarker marker = ((MarkerAnnotation)annotaion).getMarker();
-					int refline = marker.getAttribute(IMarker.LINE_NUMBER, 0);
-					if (refline == lineNumber)
-					{
-						String mkmsg = marker.getAttribute(IMarker.MESSAGE, "");
-						if (messages == null)
-							messages = mkmsg;
-						else
-							messages += "\n" + mkmsg;
-					}
-				}
-			}
-			return messages;
-		}
-	}
-	private static class TextHover implements ITextHover
-	{
-		public IRegion getHoverRegion(ITextViewer textViewer, int offset)
-		{
-			String text = textViewer.getDocument().get();
-			int length = text.length();
-
-			int begin = offset;
-			while(begin >= 0 && isWordCharacter(text.charAt(begin)))
-			{
-				begin --;
-			}
-			begin++;
-			
-			int end = offset;
-			while(end < length && isWordCharacter(text.charAt(end)))
-			{
-				end++;
-			}
-			
-			if (end - begin > 0)
-				return new Region(begin, end - begin);
-			else
-				return null;
-		}
-		
-		public String getHoverInfo(ITextViewer textViewer, IRegion region)
-		{
-			String text;
-
-			// FIXME: module and signal is contents dependent
-			HdlDocument doc = (HdlDocument)textViewer.getDocument(); 
-			try
-			{
-				text = doc.get(region.getOffset(), region.getLength());
-			}
-			catch (BadLocationException e)
-			{
-				return null;
-			}
-
-			String hover = getVariableHover(text, doc, region.getOffset());
-			return hover;
-		}
-
-		private boolean isWordCharacter(char ch)
-		{
-			return Character.isJavaIdentifierPart(ch);
-		}
-		
-		private String getVariableHover(String text, HdlDocument doc, int offset)
-		{
-			String results = "";
-			String signalName = text;
-			Vector<OutlineElement> definitions = doc.getDefinitionList(signalName, offset);
-			
-			OutlineElement component = getComponentElement(signalName, doc,offset);
-			boolean atLeftOfComponentInstantion = false;
-			
-			if(component instanceof ComponentInstElement) {
-				String doccontent = doc.get();
-				int indexArrow = doccontent.indexOf("=>", offset);
-				int lineNrArrow,lineNrString;
-				try {
-					lineNrArrow = doc.getLineOfOffset(indexArrow);
-					lineNrString = doc.getLineOfOffset(offset);
-					
-					if (lineNrString == lineNrArrow) {
-						atLeftOfComponentInstantion = true;
-					} else {
-						atLeftOfComponentInstantion = false;
-					}
-				} catch (BadLocationException e) {
-				}
-			}
-			
-			if(!atLeftOfComponentInstantion) {  
-				for(OutlineElement element:definitions) {
-					String commentString;
-					OutlineDatabase cc=doc.getOutlineDatabase();
-					OutlineContainer pp=cc.getOutlineContainer(element.getFile());
-					results+=pp.getCommentsNear(element);
-					if(doc instanceof VhdlDocument){
-						commentString="--";
-					}
-					else{
-						commentString="//";
-					}
-					results=results.trim();
-					if(results.length() > 0){
-						results=results.replaceAll("^",commentString+" ");
-						results=results.replaceAll("\n","\n"+commentString+" ");
-						results+="\n";
-					}
-					// ULTRANO
-					//results+=element.getLongName()+"\n";
-					results+=element.getFullSourceCode();
-				}
-			} else {
-				VhdlOutlineElement component1 = (VhdlOutlineElement) component;
-				String componentName = component1.getTypePart1();
-				OutlineElement componentDef = searchComponent(doc,
-						componentName);
-				String signalType = searchSignalType(componentDef, signalName);
-				results += signalType;
-			}
-				
-			return results;
-		}
-
-		private String searchSignalType(OutlineElement componentDef,String signalName) {
-			if ( componentDef != null) {
-				OutlineElement[] memberElements =  componentDef.getChildren();
-				
-				for (int h = 0; h < memberElements.length; h++) {
-					String componentMember = memberElements[h].getName().toLowerCase();//Access
-					if (componentMember.equalsIgnoreCase(signalName)) {
-						String signalType=((VhdlOutlineElement)memberElements[h]).getTypePart1()+" "+((VhdlOutlineElement)memberElements[h]).getTypePart2();			 
-						 return signalType;
-						 
-						
-					}
-				}
-			}return null;
-		}
-
-		private OutlineElement getComponentElement (String text, HdlDocument doc,int offset) {
-			
-			OutlineElement currentElement = null;
-	         HdlDocument wi=doc;
-	         try {	
-	        	 currentElement=wi.getElementAt(offset,true);
-	         
-	         }
-	         catch (BadLocationException e) {
-	 		} catch (HdlParserException e) {
-	 			e.printStackTrace();			
-	 		}
-			
-	
-		
-			return currentElement;
-			
-		}
-
-	}
-		
-	public static OutlineElement searchComponent(HdlDocument doc,
-			 String componentName) {
-		
-		OutlineDatabase database = doc.getOutlineDatabase();
-		
-		if (database != null) {
-			OutlineElement[] elements = database.findTopLevelElements("");
-			for (int i = 0; i < elements.length; i++) {
-				if(elements[i] instanceof PackageDeclElement ){
-					OutlineElement[] subPackageElements=elements[i].getChildren();
-					for(int j=0; j< subPackageElements.length; j++){
-						if (subPackageElements[j] instanceof ComponentDeclElement
-								&& subPackageElements[j].getName()
-										.equalsIgnoreCase(componentName)) {
-							return subPackageElements[j];
-
-						}
-					}
-				}
-			
-			}	
-
-		}
-		return null;
-	}
-	
-	
-	public int getTabWidth(ISourceViewer sourceViewer){
-	    int nSize;
-	    String size = VerilogPlugin.getPreferenceString("Style.indentSize");
-	    try{
-	        nSize = Integer.parseInt(size);
-	    }
-	    catch(NumberFormatException e){
-	        nSize = 4;
-	    }
-	    
-	    return nSize;
-	}
-	   
-	protected String[] getIndentPrefixesForTab(int tabWidth){	    
-	    return super.getIndentPrefixesForTab(tabWidth);
-	}
-	
-    public String[] getIndentPrefixes(ISourceViewer sourceViewer,
-            String contentType) {
-/*        String[] indentPrefixes = new String[2];
-        int tabWidth = getTabWidth(sourceViewer);
-        
-        if(m_Editor.isTabsToSpacesConversionEnabled()){
-            char[] spaceChars= new char[tabWidth];          
-            Arrays.fill(spaceChars, ' ');
-            indentPrefixes[0]= new String(spaceChars);
-        }
-        else{
-            indentPrefixes[0]="\t";
-        }
-        
-        indentPrefixes[1]="";*/
-        
-        String[] indentPrefixes = getIndentPrefixesForTab(getTabWidth(sourceViewer));
-        boolean bUseSpaceForTab;               
-        
-        if (indentPrefixes == null)
-            return null;
-                
-        
-        bUseSpaceForTab=m_Editor.isTabsToSpacesConversionEnabled();
-      
-        int length = indentPrefixes.length;
-        
-        if (length > 2 && bUseSpaceForTab) {
-
-            // Swap first with second last
-            String first = indentPrefixes[0];
-            indentPrefixes[0] = indentPrefixes[length - 2];
-            indentPrefixes[length - 2] = first;
-        }
-
-        return indentPrefixes;
-    }
-}
-
-
-
-
-
-
-
-
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+
+package com.elphel.vdt.veditor.editor;
+
+import java.util.Iterator;
+import java.util.Vector;
+
+import com.elphel.vdt.veditor.VerilogPlugin;
+import com.elphel.vdt.veditor.document.HdlDocument;
+import com.elphel.vdt.veditor.document.VhdlDocument;
+import com.elphel.vdt.veditor.editor.scanner.HdlCommentScanner;
+import com.elphel.vdt.veditor.editor.scanner.HdlPartitionScanner;
+import com.elphel.vdt.veditor.editor.scanner.HdlScanner;
+import com.elphel.vdt.veditor.parser.HdlParserException;
+import com.elphel.vdt.veditor.parser.OutlineContainer;
+import com.elphel.vdt.veditor.parser.OutlineDatabase;
+import com.elphel.vdt.veditor.parser.OutlineElement;
+import com.elphel.vdt.veditor.parser.verilog.VerilogOutlineElementFactory;
+import com.elphel.vdt.veditor.parser.vhdl.VhdlOutlineElementFactory.ComponentDeclElement;
+import com.elphel.vdt.veditor.parser.vhdl.VhdlOutlineElementFactory.ComponentInstElement;
+import com.elphel.vdt.veditor.parser.vhdl.VhdlOutlineElementFactory.PackageDeclElement;
+import com.elphel.vdt.veditor.parser.vhdl.VhdlOutlineElementFactory.VhdlOutlineElement;
+import com.elphel.vdt.veditor.preference.PreferenceStrings;
+
+import org.eclipse.core.resources.IMarker;
+import org.eclipse.jface.text.BadLocationException;
+import org.eclipse.jface.text.IDocument;
+import org.eclipse.jface.text.IRegion;
+import org.eclipse.jface.text.ITextHover;
+import org.eclipse.jface.text.ITextViewer;
+import org.eclipse.jface.text.Region;
+import org.eclipse.jface.text.TextViewer;
+import org.eclipse.jface.text.contentassist.ContentAssistant;
+import org.eclipse.jface.text.contentassist.IContentAssistant;
+import org.eclipse.jface.text.presentation.IPresentationReconciler;
+import org.eclipse.jface.text.presentation.PresentationReconciler;
+import org.eclipse.jface.text.rules.DefaultDamagerRepairer;
+import org.eclipse.jface.text.rules.Token;
+import org.eclipse.jface.text.source.IAnnotationHover;
+import org.eclipse.jface.text.source.IAnnotationModel;
+import org.eclipse.jface.text.source.ISourceViewer;
+import org.eclipse.jface.text.source.SourceViewerConfiguration;
+import org.eclipse.ui.texteditor.MarkerAnnotation;
+
+/**
+ * parse verilog source code
+ */
+abstract public class HdlSourceViewerConfiguration extends
+		SourceViewerConfiguration
+{
+	private HdlScanner scanner;
+	private HdlEditor m_Editor;
+	
+	public static HdlSourceViewerConfiguration createForVerilog(HdlEditor editor)
+	{
+		return new HdlSourceViewerConfiguration(editor)
+		{
+			public HdlScanner createScanner()
+			{
+				return HdlScanner.createForVerilog(getColorManager());
+			}
+			public HdlCompletionProcessor createCompletionProcessor()
+			{
+				return new VerilogCompletionProcessor();
+			}
+		};
+	}
+	public static HdlSourceViewerConfiguration createForVhdl(HdlEditor editor)
+	{
+		return new HdlSourceViewerConfiguration(editor)
+		{
+			public HdlScanner createScanner()
+			{
+				return HdlScanner.createForVhdl(getColorManager());
+			}
+			public HdlCompletionProcessor createCompletionProcessor()
+			{
+				return new VhdlCompletionProcessor();
+			}
+		};
+	}
+	
+	public HdlSourceViewerConfiguration(HdlEditor editor)
+	{
+		m_Editor = editor;
+	}
+
+	abstract HdlScanner createScanner();
+	abstract HdlCompletionProcessor createCompletionProcessor();
+
+	public ColorManager getColorManager()
+	{
+		return m_Editor.getColorManager();
+	}
+
+	public String[] getConfiguredContentTypes(ISourceViewer sourceViewer)
+	{
+		String[] types = HdlPartitionScanner.getContentTypes();
+		String[] ret = new String[types.length+1];
+		ret[0] = IDocument.DEFAULT_CONTENT_TYPE; 
+		for( int i = 0 ; i < types.length ; i++ )
+			ret[i+1] = types[i];
+		return ret;
+	}
+	
+	private HdlScanner getHdlScanner()
+	{
+		if (scanner == null)
+		{
+			scanner = createScanner();
+			scanner.setDefaultReturnToken(new Token(
+					HdlTextAttribute.DEFAULT.getTextAttribute(m_Editor.getColorManager())));
+		}
+		return scanner;
+	}
+
+	public IPresentationReconciler getPresentationReconciler(
+			ISourceViewer sourceViewer)
+	{
+		PresentationReconciler reconciler = new PresentationReconciler();
+		
+		DefaultDamagerRepairer dr;
+		dr = new DefaultDamagerRepairer(getHdlScanner());
+		reconciler.setDamager(dr, IDocument.DEFAULT_CONTENT_TYPE);
+		reconciler.setRepairer(dr, IDocument.DEFAULT_CONTENT_TYPE);
+		
+	    String[] contentTypes = HdlPartitionScanner.getContentTypes();
+		HdlTextAttribute[] attrs = HdlPartitionScanner.getContentTypeAttributes();
+		for (int i = 0; i < contentTypes.length; i++)
+		{
+			addRepairer(reconciler, attrs[i], contentTypes[i]);
+		}
+		
+	    addCommentScanner(reconciler, HdlTextAttribute.SINGLE_LINE_COMMENT,HdlPartitionScanner.SINGLE_LINE_COMMENT);
+	    addCommentScanner(reconciler, HdlTextAttribute.MULTI_LINE_COMMENT,HdlPartitionScanner.MULTI_LINE_COMMENT);
+	    addCommentScanner(reconciler, HdlTextAttribute.DOXYGEN_COMMENT,HdlPartitionScanner.DOXYGEN_SINGLE_LINE_COMMENT);     
+	    addCommentScanner(reconciler, HdlTextAttribute.DOXYGEN_COMMENT,HdlPartitionScanner.DOXYGEN_MULTI_LINE_COMMENT);
+        
+		return reconciler;
+	}
+	
+	private void addCommentScanner(PresentationReconciler reconciler ,HdlTextAttribute attr,String contentType){	
+
+	    Token defaultToken=new Token(attr.getTextAttribute(m_Editor.getColorManager()));
+	    HdlCommentScanner commentScanner=new HdlCommentScanner(m_Editor.getColorManager(),defaultToken);   //Scanner to highlight meta-keywords inside of comments     
+	    DefaultDamagerRepairer dr = new DefaultDamagerRepairer(commentScanner);
+        reconciler.setDamager(dr, contentType);
+        reconciler.setRepairer(dr, contentType);
+    
+	}
+	
+	private void addRepairer(PresentationReconciler reconciler,
+			HdlTextAttribute attr, String partition)
+	{
+		NonRuleBasedDamagerRepairer ndr;
+		ndr = new NonRuleBasedDamagerRepairer(attr
+				.getTextAttribute(m_Editor.getColorManager()));
+		reconciler.setDamager(ndr, partition);
+		reconciler.setRepairer(ndr, partition);
+	}
+
+	public IContentAssistant getContentAssistant(ISourceViewer sourceViewer)
+	{
+		ContentAssistant assistant = new ContentAssistant();
+		assistant.setContentAssistProcessor(createCompletionProcessor(),
+				IDocument.DEFAULT_CONTENT_TYPE);
+
+		assistant.enableAutoActivation(true);
+		assistant.setAutoActivationDelay(500);
+		assistant
+				.setProposalPopupOrientation(IContentAssistant.PROPOSAL_OVERLAY);
+		assistant
+				.setContextInformationPopupOrientation(IContentAssistant.CONTEXT_INFO_ABOVE);
+
+		return assistant;
+	}
+
+	public IAnnotationHover getAnnotationHover(ISourceViewer sourceViewer)
+	{
+		return new AnnotationHover();
+	}
+	
+	public ITextHover getTextHover(ISourceViewer sourceViewer,
+			String contentType)
+	{
+		return new TextHover();
+	}
+
+	private static class AnnotationHover implements IAnnotationHover
+	{
+
+		public String getHoverInfo(ISourceViewer sourceViewer, int lineNumber)
+		{
+			IAnnotationModel model = sourceViewer.getAnnotationModel();
+			if (model == null)
+				return null;
+			
+			// lineNumber starts from 0, not 1
+			lineNumber++;
+
+	
+			Iterator i= model.getAnnotationIterator();;
+			String messages = null;
+
+			while(i.hasNext())
+			{
+				Object annotaion = i.next();
+				if (annotaion instanceof MarkerAnnotation)
+				{
+					IMarker marker = ((MarkerAnnotation)annotaion).getMarker();
+					int refline = marker.getAttribute(IMarker.LINE_NUMBER, 0);
+					if (refline == lineNumber)
+					{
+						String mkmsg = marker.getAttribute(IMarker.MESSAGE, "");
+						if (messages == null)
+							messages = mkmsg;
+						else
+							messages += "\n" + mkmsg;
+					}
+				}
+			}
+			return messages;
+		}
+	}
+	private static class TextHover implements ITextHover
+	{
+		public IRegion getHoverRegion(ITextViewer textViewer, int offset)
+		{
+			String text = textViewer.getDocument().get();
+			int length = text.length();
+
+			int begin = offset;
+			while(begin >= 0 && isWordCharacter(text.charAt(begin)))
+			{
+				begin --;
+			}
+			begin++;
+			
+			int end = offset;
+			while(end < length && isWordCharacter(text.charAt(end)))
+			{
+				end++;
+			}
+			
+			if (end - begin > 0)
+				return new Region(begin, end - begin);
+			else
+				return null;
+		}
+		
+		public String getHoverInfo(ITextViewer textViewer, IRegion region)
+		{
+			String text;
+
+			// FIXME: module and signal are content dependent
+			HdlDocument doc;
+			try{
+				doc = (HdlDocument)textViewer.getDocument();
+			} catch (java.lang.ClassCastException e1) {
+				System.out.println("getHoverInfo(): "+e1);
+				return null; // org.eclipse.jface.text.Document cannot be cast to com.elphel.vdt.veditor.document.HdlDocument
+			}
+			try
+			{
+				text = doc.get(region.getOffset(), region.getLength());
+			}
+			catch (BadLocationException e)
+			{
+				return null;
+			}
+
+			String hover = getVariableHover(text, doc, region.getOffset());
+//			System.out.println("getHoverInfo(): text="+text+", hover="+hover.substring(0,20));
+			return hover;
+		}
+
+		private boolean isWordCharacter(char ch)
+		{
+			return Character.isJavaIdentifierPart(ch);
+		}
+		
+		private String getVariableHover(String text, HdlDocument doc, int offset)
+		{
+			if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR)) {
+				System.out.println("getVariableHover("+text+","+doc.getFile()+","+offset+")");
+			}
+			String results = "";
+			String signalName = text;
+			Vector<OutlineElement> definitions = doc.getDefinitionList(signalName, offset);
+			
+			OutlineElement component = getComponentElement(signalName, doc,offset);
+			if (component==null) {
+				return results;
+			}
+/*
+ java.lang.NullPointerException
+	at com.elphel.vdt.veditor.editor.HdlSourceViewerConfiguration$TextHover.getVariableHover(HdlSourceViewerConfiguration.java:299)
+	at com.elphel.vdt.veditor.editor.HdlSourceViewerConfiguration$TextHover.getHoverInfo(HdlSourceViewerConfiguration.java:280)
+	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:168)
+ */
+//			if (component.getType()=="module#"){
+//				//Verilog module - generate module instance template
+//				VerilogOutlineElementFactory.VerilogModuleElement element = (VerilogOutlineElementFactory.VerilogModuleElement) component;
+//				return element.getInstanceTemplate(); // This module instance template to copy and insert into code
+//			}
+			boolean atLeftOfComponentInstantion = false;
+			
+			if(component instanceof ComponentInstElement) {
+				String doccontent = doc.get();
+				int indexArrow = doccontent.indexOf("=>", offset);
+				int lineNrArrow,lineNrString;
+				try {
+					lineNrArrow = doc.getLineOfOffset(indexArrow);
+					lineNrString = doc.getLineOfOffset(offset);
+					
+					if (lineNrString == lineNrArrow) {
+						atLeftOfComponentInstantion = true;
+					} else {
+						atLeftOfComponentInstantion = false;
+					}
+				} catch (BadLocationException e) {
+				}
+			}
+			
+			if(!atLeftOfComponentInstantion) {
+				if ((definitions==null) || definitions.isEmpty()) {
+					return null; // once got null pointer in the next line
+				}
+				if ((definitions.size()==1) && (definitions.get(0).getType()=="module#")){
+					//Verilog module - generate module instance template (when hovering either over module definition or module name in instance)
+					VerilogOutlineElementFactory.VerilogModuleElement element = (VerilogOutlineElementFactory.VerilogModuleElement) definitions.get(0);
+					return element.getInstanceTemplate(); // This module instance template to copy and insert into code
+				} else if ((definitions.size()==1) && (definitions.get(0) instanceof VerilogOutlineElementFactory.VerilogInstanceElement)){
+//					OutlineElement oe= definitions.get(0);
+					OutlineDatabase ob=doc.getOutlineDatabase();
+					if (ob!=null) {
+						OutlineElement oe=ob.findDefinition(definitions.get(0));
+						if (oe!=null) return oe.getFullSourceCode(); // source code of module definition, when hovering over instance name
+					}
+				} 
+				for(OutlineElement element:definitions) {
+					String commentString;
+					OutlineDatabase cc=doc.getOutlineDatabase();
+					OutlineContainer pp=cc.getOutlineContainer(element.getFile());
+					// This is not yet used					
+					if (element.getLateDescription()!=null){
+						results+=element.getLateDescription()+"\n";
+					}
+					results+=pp.getCommentsNear(element);
+					if(doc instanceof VhdlDocument){
+						commentString="--";
+					}
+					else{
+						commentString="//";
+					}
+					results=results.trim();
+					if(results.length() > 0){
+						results=results.replaceAll("^",commentString+" ");
+						results=results.replaceAll("\n","\n"+commentString+" ");
+						results+="\n";
+					}
+					// ULTRANO
+					results+=element.getLongName()+"\n"; // show both long name (including current value and width)
+					results+=element.getFullSourceCode();// and the source code line
+				}
+			} else {
+				VhdlOutlineElement component1 = (VhdlOutlineElement) component;
+				String componentName = component1.getTypePart1();
+				OutlineElement componentDef = searchComponent(doc,
+						componentName);
+				String signalType = searchSignalType(componentDef, signalName);
+				results += signalType;
+			}
+				
+			return results;
+		}
+
+		private String searchSignalType(OutlineElement componentDef,String signalName) {
+			if ( componentDef != null) {
+				OutlineElement[] memberElements =  componentDef.getChildren();
+				
+				for (int h = 0; h < memberElements.length; h++) {
+					String componentMember = memberElements[h].getName().toLowerCase();//Access
+					if (componentMember.equalsIgnoreCase(signalName)) {
+						String signalType=((VhdlOutlineElement)memberElements[h]).getTypePart1()+" "+((VhdlOutlineElement)memberElements[h]).getTypePart2();			 
+						 return signalType;
+						 
+						
+					}
+				}
+			}return null;
+		}
+
+		private OutlineElement getComponentElement (String text, HdlDocument doc,int offset) {
+			
+			OutlineElement currentElement = null;
+	         HdlDocument wi=doc;
+	         try {	
+	        	 currentElement=wi.getElementAt(offset,true);
+	         
+	         }
+	         catch (BadLocationException e) {
+	 		} catch (HdlParserException e) {
+				System.out.println("Failed to getComponentElement(), e="+e);
+				return null;
+//	 			e.printStackTrace();			
+	 		}
+			
+	
+		
+			return currentElement;
+			
+		}
+
+	}
+		
+	public static OutlineElement searchComponent(HdlDocument doc,
+			 String componentName) {
+		
+		OutlineDatabase database = doc.getOutlineDatabase();
+		
+		if (database != null) {
+			OutlineElement[] elements = database.findTopLevelElements("");
+			for (int i = 0; i < elements.length; i++) {
+				if(elements[i] instanceof PackageDeclElement ){
+					OutlineElement[] subPackageElements=elements[i].getChildren();
+					for(int j=0; j< subPackageElements.length; j++){
+						if (subPackageElements[j] instanceof ComponentDeclElement
+								&& subPackageElements[j].getName()
+										.equalsIgnoreCase(componentName)) {
+							return subPackageElements[j];
+
+						}
+					}
+				}
+			
+			}	
+
+		}
+		return null;
+	}
+	
+	
+	public int getTabWidth(ISourceViewer sourceViewer){
+	    int nSize;
+	    String size = VerilogPlugin.getPreferenceString("Style.indentSize");
+	    try{
+	        nSize = Integer.parseInt(size);
+	    }
+	    catch(NumberFormatException e){
+	        nSize = 4;
+	    }
+	    
+	    return nSize;
+	}
+	   
+	protected String[] getIndentPrefixesForTab(int tabWidth){	    
+	    return super.getIndentPrefixesForTab(tabWidth);
+	}
+	
+    public String[] getIndentPrefixes(ISourceViewer sourceViewer,
+            String contentType) {
+/*        String[] indentPrefixes = new String[2];
+        int tabWidth = getTabWidth(sourceViewer);
+        
+        if(m_Editor.isTabsToSpacesConversionEnabled()){
+            char[] spaceChars= new char[tabWidth];          
+            Arrays.fill(spaceChars, ' ');
+            indentPrefixes[0]= new String(spaceChars);
+        }
+        else{
+            indentPrefixes[0]="\t";
+        }
+        
+        indentPrefixes[1]="";*/
+        
+        String[] indentPrefixes = getIndentPrefixesForTab(getTabWidth(sourceViewer));
+        boolean bUseSpaceForTab;               
+        
+        if (indentPrefixes == null)
+            return null;
+                
+        
+        bUseSpaceForTab=m_Editor.isTabsToSpacesConversionEnabled();
+      
+        int length = indentPrefixes.length;
+        
+        if (length > 2 && bUseSpaceForTab) {
+
+            // Swap first with second last
+            String first = indentPrefixes[0];
+            indentPrefixes[0] = indentPrefixes[length - 2];
+            indentPrefixes[length - 2] = first;
+        }
+
+        return indentPrefixes;
+    }
+}
+
+
+
+
+
+
+
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/editor/HdlTextAttribute.java vdt/src/com/elphel/vdt/veditor/editor/HdlTextAttribute.java
--- vdt-veditor/src/com/elphel/vdt/veditor/editor/HdlTextAttribute.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/editor/HdlTextAttribute.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,88 +1,101 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-
-package net.sourceforge.veditor.editor;
-
-import  org.eclipse.jface.resource.DataFormatException;
-
-import net.sourceforge.veditor.VerilogPlugin;
-import net.sourceforge.veditor.preference.PreferenceStrings;
-
-import org.eclipse.jface.resource.StringConverter;
-import org.eclipse.jface.text.TextAttribute;
-import org.eclipse.swt.SWT;
-import org.eclipse.swt.graphics.RGB;
-
-public final class HdlTextAttribute
-{
-	public static HdlTextAttribute SINGLE_LINE_COMMENT = new HdlTextAttribute();
-	public static HdlTextAttribute MULTI_LINE_COMMENT = new HdlTextAttribute();
-	public static HdlTextAttribute STRING = new HdlTextAttribute();
-	public static HdlTextAttribute DEFAULT = new HdlTextAttribute();
-	public static HdlTextAttribute KEY_WORD = new HdlTextAttribute();
-	public static HdlTextAttribute DOXYGEN_COMMENT = new HdlTextAttribute();
-	public static HdlTextAttribute DIRECTIVE = new HdlTextAttribute();
-	public static HdlTextAttribute TYPES = new HdlTextAttribute();
-	public static HdlTextAttribute AUTOTASKS = new HdlTextAttribute();
-
-	private RGB color;
-	private int style;
-
-	private HdlTextAttribute()
-	{
-		color = null;
-		style = SWT.NORMAL;
-	}
-	
-	public TextAttribute getTextAttribute(ColorManager colorManager)
-	{
-		return new TextAttribute(colorManager.getColor(color), null, style);
-	}
-	
-	public static void init()
-	{
-		readColor(SINGLE_LINE_COMMENT, PreferenceStrings.SINGLE_LINE_COMMENT);
-		readColor(MULTI_LINE_COMMENT, PreferenceStrings.MULTI_LINE_COMMENT);
-		readColor(DOXYGEN_COMMENT, PreferenceStrings.DOXGEN_COMMENT);
-		readColor(STRING, PreferenceStrings.STRING);
-		readColor(DEFAULT, PreferenceStrings.DEFAULT);
-		readColor(DIRECTIVE, PreferenceStrings.DIRECTIVE);
-		readColor(KEY_WORD, PreferenceStrings.KEYWORD);
-		readColor(TYPES, PreferenceStrings.TYPES);
-		readColor(AUTOTASKS, PreferenceStrings.AUTO_TASKS);		
-	}
-
-	private static void readColor(HdlTextAttribute target, String key)
-	{
-		String color = VerilogPlugin.getPreferenceString("Color." + key);
-		boolean bold = VerilogPlugin.getPreferenceBoolean("Bold." + key);
-		boolean italic = VerilogPlugin.getPreferenceBoolean("Italic." + key);
-		try
-		{
-			RGB rgb = StringConverter.asRGB(color);
-			target.color = new RGB(rgb.red, rgb.green, rgb.blue);
-
-			target.style = SWT.NORMAL;
-			if (bold)
-				target.style |= SWT.BOLD;
-			if (italic)
-				target.style |= SWT.ITALIC;
-		}
-		catch (NumberFormatException ex)
-		{
-		}
-		catch ( DataFormatException   e)
-		{
-			VerilogPlugin.println("Bad Color read from file. "+e.toString());
-		}
-	}
-}
-
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+
+package com.elphel.vdt.veditor.editor;
+
+import  org.eclipse.jface.resource.DataFormatException;
+
+import com.elphel.vdt.veditor.VerilogPlugin;
+import com.elphel.vdt.veditor.preference.PreferenceStrings;
+
+import org.eclipse.jface.resource.StringConverter;
+import org.eclipse.jface.text.TextAttribute;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.graphics.RGB;
+
+public final class HdlTextAttribute
+{
+	public static HdlTextAttribute SINGLE_LINE_COMMENT = new HdlTextAttribute();
+	public static HdlTextAttribute MULTI_LINE_COMMENT = new HdlTextAttribute();
+	public static HdlTextAttribute STRING = new HdlTextAttribute();
+	public static HdlTextAttribute DEFAULT = new HdlTextAttribute();
+	public static HdlTextAttribute KEY_WORD = new HdlTextAttribute();
+	public static HdlTextAttribute DOXYGEN_COMMENT = new HdlTextAttribute();
+	public static HdlTextAttribute DIRECTIVE = new HdlTextAttribute();
+	public static HdlTextAttribute TYPES = new HdlTextAttribute();
+	public static HdlTextAttribute AUTOTASKS = new HdlTextAttribute();
+	public static HdlTextAttribute DISABLED_CODE = new HdlTextAttribute();
+
+	private RGB color;
+	private int style;
+
+	private HdlTextAttribute()
+	{
+		color = null;
+		style = SWT.NORMAL;
+	}
+	
+	public TextAttribute getTextAttribute(ColorManager colorManager)
+	{
+		return new TextAttribute(colorManager.getColor(color), null, style);
+	}
+	
+	public static void init()
+	{
+		readColor(SINGLE_LINE_COMMENT, PreferenceStrings.SINGLE_LINE_COMMENT);
+		readColor(MULTI_LINE_COMMENT, PreferenceStrings.MULTI_LINE_COMMENT);
+		readColor(DOXYGEN_COMMENT, PreferenceStrings.DOXGEN_COMMENT);
+		readColor(STRING, PreferenceStrings.STRING);
+		readColor(DEFAULT, PreferenceStrings.DEFAULT);
+		readColor(DIRECTIVE, PreferenceStrings.DIRECTIVE);
+		readColor(KEY_WORD, PreferenceStrings.KEYWORD);
+		readColor(TYPES, PreferenceStrings.TYPES);
+		readColor(AUTOTASKS, PreferenceStrings.AUTO_TASKS);	
+		readColor(DISABLED_CODE, PreferenceStrings.DISABLED_CODE);
+	}
+
+	private static void readColor(HdlTextAttribute target, String key)
+	{
+		String color = VerilogPlugin.getPreferenceString("Color." + key);
+		boolean bold = VerilogPlugin.getPreferenceBoolean("Bold." + key);
+		boolean italic = VerilogPlugin.getPreferenceBoolean("Italic." + key);
+		try
+		{
+			RGB rgb = StringConverter.asRGB(color);
+			target.color = new RGB(rgb.red, rgb.green, rgb.blue);
+
+			target.style = SWT.NORMAL;
+			if (bold)
+				target.style |= SWT.BOLD;
+			if (italic)
+				target.style |= SWT.ITALIC;
+		}
+		catch (NumberFormatException ex)
+		{
+		}
+		catch ( DataFormatException   e)
+		{
+			VerilogPlugin.println("Bad Color read from file. "+e.toString());
+		}
+	}
+}
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/editor/HdlTreeProviderBase.java vdt/src/com/elphel/vdt/veditor/editor/HdlTreeProviderBase.java
--- vdt-veditor/src/com/elphel/vdt/veditor/editor/HdlTreeProviderBase.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/editor/HdlTreeProviderBase.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,74 +1,85 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.editor;
-
-import net.sourceforge.veditor.document.HdlDocument;
-import net.sourceforge.veditor.parser.HdlParserException;
-import net.sourceforge.veditor.parser.OutlineContainer;
-import net.sourceforge.veditor.parser.OutlineElement;
-import org.eclipse.jface.viewers.ITreeContentProvider;
-import org.eclipse.jface.viewers.Viewer;
-
-
-public abstract class HdlTreeProviderBase implements ITreeContentProvider
-{
-	public void inputChanged(Viewer viewer, Object oldInput, Object newInput)
-	{
-	}
-
-
-	public void dispose()
-	{
-	}
-
-	public Object getParent(Object element)
-	{
-		if (element instanceof OutlineElement)
-		{
-			OutlineElement e = (OutlineElement)element;
-			return (Object)e.getParent();
-		}
-		return null;
-	}
-
-	public boolean hasChildren(Object element)
-	{
-		if (element instanceof OutlineElement)
-		{
-			OutlineElement e = (OutlineElement)element;
-			return e.HasChildren();
-		}
-		
-		return false;
-	}
-
-	public Object[] getElements(Object inputElement)
-	{		
-		HdlDocument doc = (HdlDocument)inputElement;
-		OutlineContainer outlineContainer=null;
-		
-		try {
-			outlineContainer=doc.getOutlineContainer();
-			if(outlineContainer != null){
-				return outlineContainer.getTopLevelElements();
-			}
-		} catch (HdlParserException e) {
-	
-		}
-		return new Object[0];
-		
-	}
-
-}
-
-
-
-
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.editor;
+
+import com.elphel.vdt.veditor.document.HdlDocument;
+import com.elphel.vdt.veditor.parser.HdlParserException;
+import com.elphel.vdt.veditor.parser.OutlineContainer;
+import com.elphel.vdt.veditor.parser.OutlineElement;
+import org.eclipse.jface.viewers.ITreeContentProvider;
+import org.eclipse.jface.viewers.Viewer;
+
+
+public abstract class HdlTreeProviderBase implements ITreeContentProvider
+{
+	public void inputChanged(Viewer viewer, Object oldInput, Object newInput)
+	{
+	}
+
+
+	public void dispose()
+	{
+	}
+
+	public Object getParent(Object element)
+	{
+		if (element instanceof OutlineElement)
+		{
+			OutlineElement e = (OutlineElement)element;
+			return (Object)e.getParent();
+		}
+		return null;
+	}
+
+	public boolean hasChildren(Object element)
+	{
+		if (element instanceof OutlineElement)
+		{
+			OutlineElement e = (OutlineElement)element;
+			return e.HasChildren();
+		}
+		
+		return false;
+	}
+
+	public Object[] getElements(Object inputElement)
+	{		
+		HdlDocument doc = (HdlDocument)inputElement;
+		OutlineContainer outlineContainer=null;
+		
+		try {
+			outlineContainer=doc.getOutlineContainer();
+			if(outlineContainer != null){
+				return outlineContainer.getTopLevelElements();
+			}
+		} catch (HdlParserException e) {
+	
+		}
+		return new Object[0];
+		
+	}
+
+}
+
+
+
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/editor/ModuleHierarchyView.java vdt/src/com/elphel/vdt/veditor/editor/ModuleHierarchyView.java
--- vdt-veditor/src/com/elphel/vdt/veditor/editor/ModuleHierarchyView.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/editor/ModuleHierarchyView.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,135 +1,146 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.editor;
-
-import net.sourceforge.veditor.VerilogPlugin;
-
-import org.eclipse.core.resources.IProject;
-import org.eclipse.core.runtime.CoreException;
-import org.eclipse.ui.IEditorPart;
-import org.eclipse.ui.IWorkbenchPage;
-import org.eclipse.ui.IWorkbenchPart;
-import org.eclipse.ui.part.IPage;
-import org.eclipse.ui.part.MessagePage;
-import org.eclipse.ui.part.PageBook;
-import org.eclipse.ui.part.PageBookView;
-
-/**
- * tree view of module instantiation
- */
-public class ModuleHierarchyView extends PageBookView
-{
-	private static String defaultMessage = "Module Hierarchy is not available";
-	
-	public ModuleHierarchyView()
-	{
-		super();
-	}
-
-	public void setFocus()
-	{
-	}
-
-	/**
-	 * Gets this projects hierarchy page
-	 * @param project
-	 * @return
-	 */
-	public HdlHierarchyPage getHierarchyPage(IProject project){
-		HdlHierarchyPage page=null;
-		
-		if(project != null){
-			try {
-				page=(HdlHierarchyPage)project.getSessionProperty(VerilogPlugin.getHierarchyId());
-			} catch (CoreException e) {
-				e.printStackTrace();
-			}
-		}
-		
-		return page;
-	}
-	
-	protected IPage createDefaultPage(PageBook book)
-	{
-		//  These are referred from ContentOutline
-		MessagePage page = new MessagePage();
-		initPage(page);
-		page.createControl(book);
-		page.setMessage(defaultMessage);
-		return page;
-	}
-
-	protected PageRec doCreatePage(IWorkbenchPart part)
-	{
-		IProject project=null;
-		HdlHierarchyPage page=null;
-		
-		if (part instanceof HdlEditor) {
-			HdlEditor hdlEditor = (HdlEditor) part;
-			
-			if(hdlEditor.getHdlDocument()!=null){				
-				project=hdlEditor.getHdlDocument().getProject();
-				//if there is no project, just get out
-				if(project == null){
-					return null;
-				}
-				//does this project have a hierarchy page
-				if(getHierarchyPage(project)==null){
-					//no hierarchy page yet
-					Object obj = part.getAdapter(HdlHierarchyPage.class);
-					if (obj instanceof HdlHierarchyPage){
-						page=(HdlHierarchyPage)obj;
-						initPage(page);
-						page.createControl(getPageBook());
-						try {
-							project.setSessionProperty(VerilogPlugin.getHierarchyId(), page);
-						} catch (CoreException e) {						
-						}
-					}
-				}else{
-					page=getHierarchyPage(project);
-					//if the page is disposed, remove it and create it again
-					if(page.isDisposed()){
-						try {
-							project.setSessionProperty(VerilogPlugin.getHierarchyId(), null);
-						} catch (CoreException e) {
-						}
-						return doCreatePage(part);
-					}					
-				}
-				return new PageRec(part, page);
-			}
-		}			
-		return null;		
-	}
-
-	protected void doDestroyPage(IWorkbenchPart part, PageRec pageRecord)
-	{
-		HdlHierarchyPage page = (HdlHierarchyPage)pageRecord.page;
-		page.dispose();
-		pageRecord.dispose();
-	}
-
-	protected IWorkbenchPart getBootstrapPart()
-	{
-		IWorkbenchPage page = getSite().getPage();
-		if (page != null)
-			return page.getActiveEditor();
-		else
-			return null;
-	}
-
-	protected boolean isImportant(IWorkbenchPart part)
-	{
-		return (part instanceof IEditorPart);
-	}
-}
-
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.editor;
+
+import com.elphel.vdt.veditor.VerilogPlugin;
+
+import org.eclipse.core.resources.IProject;
+import org.eclipse.core.runtime.CoreException;
+import org.eclipse.ui.IEditorPart;
+import org.eclipse.ui.IWorkbenchPage;
+import org.eclipse.ui.IWorkbenchPart;
+import org.eclipse.ui.part.IPage;
+import org.eclipse.ui.part.MessagePage;
+import org.eclipse.ui.part.PageBook;
+import org.eclipse.ui.part.PageBookView;
+
+/**
+ * tree view of module instantiation
+ */
+public class ModuleHierarchyView extends PageBookView
+{
+	private static String defaultMessage = "Module Hierarchy is not available";
+	
+	public ModuleHierarchyView()
+	{
+		super();
+	}
+
+	public void setFocus()
+	{
+	}
+
+	/**
+	 * Gets this projects hierarchy page
+	 * @param project
+	 * @return
+	 */
+	public HdlHierarchyPage getHierarchyPage(IProject project){
+		HdlHierarchyPage page=null;
+		
+		if(project != null){
+			try {
+				page=(HdlHierarchyPage)project.getSessionProperty(VerilogPlugin.getHierarchyId());
+			} catch (CoreException e) {
+				e.printStackTrace();
+			}
+		}
+		
+		return page;
+	}
+	
+	protected IPage createDefaultPage(PageBook book)
+	{
+		//  These are referred from ContentOutline
+		MessagePage page = new MessagePage();
+		initPage(page);
+		page.createControl(book);
+		page.setMessage(defaultMessage);
+		return page;
+	}
+
+	protected PageRec doCreatePage(IWorkbenchPart part)
+	{
+		IProject project=null;
+		HdlHierarchyPage page=null;
+		
+		if (part instanceof HdlEditor) {
+			HdlEditor hdlEditor = (HdlEditor) part;
+			
+			if(hdlEditor.getHdlDocument()!=null){				
+				project=hdlEditor.getHdlDocument().getProject();
+				//if there is no project, just get out
+				if(project == null){
+					return null;
+				}
+				//does this project have a hierarchy page
+				if(getHierarchyPage(project)==null){
+					//no hierarchy page yet
+					Object obj = part.getAdapter(HdlHierarchyPage.class);
+					if (obj instanceof HdlHierarchyPage){
+						page=(HdlHierarchyPage)obj;
+						initPage(page);
+						page.createControl(getPageBook());
+						try {
+							project.setSessionProperty(VerilogPlugin.getHierarchyId(), page);
+						} catch (CoreException e) {						
+						}
+					}
+				}else{
+					page=getHierarchyPage(project);
+					//if the page is disposed, remove it and create it again
+					if(page.isDisposed()){
+						try {
+							project.setSessionProperty(VerilogPlugin.getHierarchyId(), null);
+						} catch (CoreException e) {
+						}
+						return doCreatePage(part);
+					}					
+				}
+				return new PageRec(part, page);
+			}
+		}			
+		return null;		
+	}
+
+	protected void doDestroyPage(IWorkbenchPart part, PageRec pageRecord)
+	{
+		HdlHierarchyPage page = (HdlHierarchyPage)pageRecord.page;
+		page.dispose();
+		pageRecord.dispose();
+	}
+
+	protected IWorkbenchPart getBootstrapPart()
+	{
+		IWorkbenchPage page = getSite().getPage();
+		if (page != null)
+			return page.getActiveEditor();
+		else
+			return null;
+	}
+
+	protected boolean isImportant(IWorkbenchPart part)
+	{
+		return (part instanceof IEditorPart);
+	}
+}
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/editor/NonRuleBasedDamagerRepairer.java vdt/src/com/elphel/vdt/veditor/editor/NonRuleBasedDamagerRepairer.java
--- vdt-veditor/src/com/elphel/vdt/veditor/editor/NonRuleBasedDamagerRepairer.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/editor/NonRuleBasedDamagerRepairer.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,147 +1,160 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-
-package net.sourceforge.veditor.editor;
-
-import org.eclipse.jface.text.BadLocationException;
-import org.eclipse.jface.text.DocumentEvent;
-import org.eclipse.jface.text.IDocument;
-import org.eclipse.jface.text.IRegion;
-import org.eclipse.jface.text.ITypedRegion;
-import org.eclipse.jface.text.Region;
-import org.eclipse.jface.text.TextAttribute;
-import org.eclipse.jface.text.TextPresentation;
-import org.eclipse.jface.text.presentation.IPresentationDamager;
-import org.eclipse.jface.text.presentation.IPresentationRepairer;
-import org.eclipse.swt.custom.StyleRange;
-
-public class NonRuleBasedDamagerRepairer implements IPresentationDamager, IPresentationRepairer
-{
-	private IDocument document;
-	private TextAttribute defaultTextAttribute;
-
-	public NonRuleBasedDamagerRepairer(TextAttribute defaultTextAttribute)
-	{
-
-		this.defaultTextAttribute = defaultTextAttribute;
-	}
-
-	/**
-	 * @see IPresentationRepairer#setDocument(IDocument)
-	 */
-	public void setDocument(IDocument document)
-	{
-		this.document = document;
-	}
-
-	/**
-	 * Returns the end offset of the line that contains the specified offset or
-	 * if the offset is inside a line delimiter, the end offset of the next line.
-	 *
-	 * @param offset the offset whose line end offset must be computed
-	 * @return the line end offset for the given offset
-	 * @exception BadLocationException if offset is invalid in the current document
-	 */
-	protected int endOfLineOf(int offset) throws BadLocationException
-	{
-		IRegion info = document.getLineInformationOfOffset(offset);
-		if (offset <= info.getOffset() + info.getLength())
-			return info.getOffset() + info.getLength();
-
-		int line = document.getLineOfOffset(offset);
-		try
-		{
-			info = document.getLineInformation(line + 1);
-			return info.getOffset() + info.getLength();
-		}
-		catch (BadLocationException x)
-		{
-			return document.getLength();
-		}
-	}
-
-	/**
-	 * @see IPresentationDamager#getDamageRegion(ITypedRegion, DocumentEvent, boolean)
-	 */
-	public IRegion getDamageRegion(
-		ITypedRegion partition,
-		DocumentEvent event,
-		boolean documentPartitioningChanged)
-	{
-		if (!documentPartitioningChanged)
-		{
-			try
-			{
-
-				IRegion info = document.getLineInformationOfOffset(event.getOffset());
-				int start = Math.max(partition.getOffset(), info.getOffset());
-
-				int len;
-				if (event.getText() == null)
-					len = event.getLength();
-				else
-					len = event.getText().length();
-				int end = event.getOffset() + len;
-
-				if (info.getOffset() <= end && end <= info.getOffset() + info.getLength())
-				{
-					// optimize the case of the same line
-					end = info.getOffset() + info.getLength();
-				}
-				else
-					end = endOfLineOf(end);
-
-				end = Math.min(partition.getOffset() + partition.getLength(), end);
-				return new Region(start, end - start);
-
-			}
-			catch (BadLocationException x)
-			{
-			}
-		}
-
-		return partition;
-	}
-
-	/**
-	 * @see IPresentationRepairer#createPresentation(TextPresentation, ITypedRegion)
-	 */
-	public void createPresentation(TextPresentation presentation, ITypedRegion region)
-	{
-		addRange(presentation, region.getOffset(), region.getLength(), defaultTextAttribute);
-	}
-
-	/**
-	 * Adds style information to the given text presentation.
-	 *
-	 * @param presentation the text presentation to be extended
-	 * @param offset the offset of the range to be styled
-	 * @param length the length of the range to be styled
-	 * @param attr the attribute describing the style of the range to be styled
-	 */
-	protected void addRange(
-		TextPresentation presentation,
-		int offset,
-		int length,
-		TextAttribute attr)
-	{
-		if (attr != null)
-		{
-			presentation.addStyleRange(
-				new StyleRange(
-					offset,
-					length,
-					attr.getForeground(),
-					attr.getBackground(),
-					attr.getStyle()));
-		}
-	}
-}
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+
+package com.elphel.vdt.veditor.editor;
+
+import org.eclipse.jface.text.BadLocationException;
+import org.eclipse.jface.text.DocumentEvent;
+import org.eclipse.jface.text.IDocument;
+import org.eclipse.jface.text.IRegion;
+import org.eclipse.jface.text.ITypedRegion;
+import org.eclipse.jface.text.Region;
+import org.eclipse.jface.text.TextAttribute;
+import org.eclipse.jface.text.TextPresentation;
+import org.eclipse.jface.text.presentation.IPresentationDamager;
+import org.eclipse.jface.text.presentation.IPresentationRepairer;
+import org.eclipse.swt.custom.StyleRange;
+
+import com.elphel.vdt.veditor.document.HdlDocument;
+
+public class NonRuleBasedDamagerRepairer implements IPresentationDamager, IPresentationRepairer
+{
+	private IDocument document;
+	private TextAttribute defaultTextAttribute;
+
+	public NonRuleBasedDamagerRepairer(TextAttribute defaultTextAttribute)
+	{
+
+		this.defaultTextAttribute = defaultTextAttribute;
+	}
+
+	/**
+	 * @see IPresentationRepairer#setDocument(IDocument)
+	 */
+	public void setDocument(IDocument document)
+	{
+		this.document = document;
+	}
+
+	/**
+	 * Returns the end offset of the line that contains the specified offset or
+	 * if the offset is inside a line delimiter, the end offset of the next line.
+	 *
+	 * @param offset the offset whose line end offset must be computed
+	 * @return the line end offset for the given offset
+	 * @exception BadLocationException if offset is invalid in the current document
+	 */
+	protected int endOfLineOf(int offset) throws BadLocationException
+	{
+		IRegion info = document.getLineInformationOfOffset(offset);
+		if (offset <= info.getOffset() + info.getLength())
+			return info.getOffset() + info.getLength();
+
+		int line = document.getLineOfOffset(offset);
+		try
+		{
+			info = document.getLineInformation(line + 1);
+			return info.getOffset() + info.getLength();
+		}
+		catch (BadLocationException x)
+		{
+			return document.getLength();
+		}
+	}
+
+	/**
+	 * @see IPresentationDamager#getDamageRegion(ITypedRegion, DocumentEvent, boolean)
+	 */
+	public IRegion getDamageRegion(
+		ITypedRegion partition,
+		DocumentEvent event,
+		boolean documentPartitioningChanged)
+	{
+		if (!documentPartitioningChanged)
+		{
+			try
+			{
+
+				IRegion info = document.getLineInformationOfOffset(event.getOffset());
+				int start = Math.max(partition.getOffset(), info.getOffset());
+
+				int len;
+				if (event.getText() == null)
+					len = event.getLength();
+				else
+					len = event.getText().length();
+				int end = event.getOffset() + len;
+
+				if (info.getOffset() <= end && end <= info.getOffset() + info.getLength())
+				{
+					// optimize the case of the same line
+					end = info.getOffset() + info.getLength();
+				}
+				else
+					end = endOfLineOf(end);
+
+				end = Math.min(partition.getOffset() + partition.getLength(), end);
+				return new Region(start, end - start);
+
+			}
+			catch (BadLocationException x)
+			{
+			}
+		}
+
+		return partition;
+	}
+
+	/**
+	 * @see IPresentationRepairer#createPresentation(TextPresentation, ITypedRegion)
+	 */
+	public void createPresentation(TextPresentation presentation, ITypedRegion region)
+	{
+		addRange(presentation, region.getOffset(), region.getLength(), defaultTextAttribute);
+	}
+
+	/**
+	 * Adds style information to the given text presentation.
+	 *
+	 * @param presentation the text presentation to be extended
+	 * @param offset the offset of the range to be styled
+	 * @param length the length of the range to be styled
+	 * @param attr the attribute describing the style of the range to be styled
+	 */
+	protected void addRange(
+		TextPresentation presentation,
+		int offset,
+		int length,
+		TextAttribute attr)
+	{
+		if (attr != null)
+		{
+			presentation.addStyleRange(
+				new StyleRange(
+					offset,
+					length,
+					attr.getForeground(),
+					attr.getBackground(),
+					attr.getStyle()));
+		}
+	}
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/editor/scanner/HdlCommentScanner.java vdt/src/com/elphel/vdt/veditor/editor/scanner/HdlCommentScanner.java
--- vdt-veditor/src/com/elphel/vdt/veditor/editor/scanner/HdlCommentScanner.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/editor/scanner/HdlCommentScanner.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,18 +1,29 @@
-/*******************************************************************************
- * Copyright (c) 2009 VEditor Team
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2009 VEditor Team
  *
  * Contributors:
  *    Ali G - initial API and implementation
  *****************************************************************************/
 
-package net.sourceforge.veditor.editor.scanner;
-import net.sourceforge.veditor.editor.ColorManager;
-import net.sourceforge.veditor.editor.HdlTextAttribute;
-import net.sourceforge.veditor.parser.IParser;
+package com.elphel.vdt.veditor.editor.scanner;
+import com.elphel.vdt.veditor.editor.ColorManager;
+import com.elphel.vdt.veditor.editor.HdlTextAttribute;
+import com.elphel.vdt.veditor.parser.IParser;
 
 import org.eclipse.jface.text.rules.IRule;
 import org.eclipse.jface.text.rules.IToken;
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/editor/scanner/HdlPartitionScanner.java vdt/src/com/elphel/vdt/veditor/editor/scanner/HdlPartitionScanner.java
--- vdt-veditor/src/com/elphel/vdt/veditor/editor/scanner/HdlPartitionScanner.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/editor/scanner/HdlPartitionScanner.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,68 +1,84 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-
-package net.sourceforge.veditor.editor.scanner;
-import net.sourceforge.veditor.editor.HdlTextAttribute;
-
-import org.eclipse.jface.text.rules.IToken;
-import org.eclipse.jface.text.rules.RuleBasedPartitionScanner;
-import org.eclipse.jface.text.rules.Token;
-
-/**
- * This is an abstract class that defines the common behavior
- * between the VHDL and Verilog Partition scanners
- */
-abstract public class HdlPartitionScanner extends RuleBasedPartitionScanner
-{
-	public static final String DOXYGEN_SINGLE_LINE_COMMENT = "__hdl_doxygen_singleline_comment";
-	public static final String DOXYGEN_MULTI_LINE_COMMENT = "__hdl_doxygen_multiline_comment";
-	public static final String SINGLE_LINE_COMMENT = "__hdl_singleline_comment";
-	public static final String MULTI_LINE_COMMENT = "__hdl_multiline_comment";
-	public static final String STRING = "__hdl_string";	
-	public static final String TASK_TAG = "_hdl_task_tag";
-	public static IToken stringToken = new Token(STRING);
-	public static IToken singleLineCommentToken = new Token(SINGLE_LINE_COMMENT);
-	public static IToken doxygenSingleLineCommentToken = new Token(DOXYGEN_SINGLE_LINE_COMMENT);
-	public static IToken doxygenMultiLineCommentToken = new Token(DOXYGEN_MULTI_LINE_COMMENT);
-	public static IToken taskTagToken = new Token(TASK_TAG);
-	public static IToken multiLineCommentToken=new Token(MULTI_LINE_COMMENT);
-
-	
-	public static String[] getContentTypes()
-	{
-		return new String[] { 
-		        SINGLE_LINE_COMMENT,
-		        DOXYGEN_SINGLE_LINE_COMMENT, 
-		        DOXYGEN_MULTI_LINE_COMMENT,
-		        MULTI_LINE_COMMENT,
-				STRING,
-				TASK_TAG
-				};
-	}
-
-	public static HdlTextAttribute[] getContentTypeAttributes()
-	{
-		// must be same sequence with getContentTypes
-		return new HdlTextAttribute[] { 
-		        HdlTextAttribute.SINGLE_LINE_COMMENT,
-		        HdlTextAttribute.DOXYGEN_COMMENT,
-		        HdlTextAttribute.DOXYGEN_COMMENT,
-				HdlTextAttribute.MULTI_LINE_COMMENT, 
-				HdlTextAttribute.STRING,
-				HdlTextAttribute.AUTOTASKS,
-				};
-	}
-
-	protected HdlPartitionScanner()
-	{
-		super();
-	}
-}
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+
+package com.elphel.vdt.veditor.editor.scanner;
+import com.elphel.vdt.veditor.editor.HdlTextAttribute;
+
+import org.eclipse.jface.text.rules.IToken;
+import org.eclipse.jface.text.rules.RuleBasedPartitionScanner;
+import org.eclipse.jface.text.rules.Token;
+
+/**
+ * This is an abstract class that defines the common behavior
+ * between the VHDL and Verilog Partition scanners
+ */
+abstract public class HdlPartitionScanner extends RuleBasedPartitionScanner
+{
+	public static final String DOXYGEN_SINGLE_LINE_COMMENT = "__hdl_doxygen_singleline_comment";
+	public static final String DOXYGEN_MULTI_LINE_COMMENT = "__hdl_doxygen_multiline_comment";
+	public static final String SINGLE_LINE_COMMENT = "__hdl_singleline_comment";
+	public static final String MULTI_LINE_COMMENT = "__hdl_multiline_comment";
+	public static final String STRING = "__hdl_string";	
+	public static final String TASK_TAG = "_hdl_task_tag";
+	public static final String DISABLED_CODE = "__hdl_disabled_code";
+	
+	public static IToken stringToken = new Token(STRING);
+	public static IToken singleLineCommentToken = new Token(SINGLE_LINE_COMMENT);
+	public static IToken doxygenSingleLineCommentToken = new Token(DOXYGEN_SINGLE_LINE_COMMENT);
+	public static IToken doxygenMultiLineCommentToken = new Token(DOXYGEN_MULTI_LINE_COMMENT);
+	public static IToken taskTagToken = new Token(TASK_TAG);
+	public static IToken multiLineCommentToken=new Token(MULTI_LINE_COMMENT);
+	public static IToken disabledCodeToken=new Token(DISABLED_CODE);
+
+	
+	public static String[] getContentTypes()
+	{
+		return new String[] { 
+		        SINGLE_LINE_COMMENT,
+		        DOXYGEN_SINGLE_LINE_COMMENT, 
+		        DOXYGEN_MULTI_LINE_COMMENT,
+		        MULTI_LINE_COMMENT,
+				STRING,
+				TASK_TAG,
+				DISABLED_CODE
+				};
+	}
+
+	public static HdlTextAttribute[] getContentTypeAttributes()
+	{
+		// must be same sequence with getContentTypes
+		return new HdlTextAttribute[] { 
+		        HdlTextAttribute.SINGLE_LINE_COMMENT,
+		        HdlTextAttribute.DOXYGEN_COMMENT,
+		        HdlTextAttribute.DOXYGEN_COMMENT,
+				HdlTextAttribute.MULTI_LINE_COMMENT, 
+				HdlTextAttribute.STRING,
+				HdlTextAttribute.AUTOTASKS,
+				HdlTextAttribute.DISABLED_CODE
+				};
+	}
+
+	protected HdlPartitionScanner()
+	{
+		super();
+	}
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/editor/scanner/HdlScanner.java vdt/src/com/elphel/vdt/veditor/editor/scanner/HdlScanner.java
--- vdt-veditor/src/com/elphel/vdt/veditor/editor/scanner/HdlScanner.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/editor/scanner/HdlScanner.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,129 +1,141 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-
-package net.sourceforge.veditor.editor.scanner;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import net.sourceforge.veditor.editor.ColorManager;
-import net.sourceforge.veditor.editor.HdlTextAttribute;
-import org.eclipse.jface.text.rules.*;
-
-
-/**
- * find reserved word
- */
-public class HdlScanner extends RuleBasedScanner
-{
-	public static HdlScanner createForVerilog(ColorManager manager)
-	{
-		return new HdlScanner(manager, true);
-	}
-	public static HdlScanner createForVhdl(ColorManager manager)
-	{
-		return new HdlScanner(manager, false);
-	}
-
-	private static final String[] verilogWords = {"always", "and", "assign",
-			"attribute", "begin", "buf", "bufif0", "bufif1", "case", "casex",
-			"casez", "cmos", "deassign", "default", "defparam", "disable",
-			"edge", "else", "end", "endattribute", "endcase", "endfunction", "endmodule",
-			"endprimitive", "endspecify", "endtable", "endtask", "event",
-			"for", "force", "forever", "fork", "function", "highz0", "highz1",
-			"if", "ifnone", "initial", "inout", "input", "integer", "join",
-			"medium", "module", "large", "macromodule", "nand", "negedge",
-			"nmos", "nor", "not", "notif0", "notif1", "or", "output",
-			"parameter", "pmos", "posedge", "primitive", "pull0", "pull1",
-			"pulldown", "pullup", "rcmos", "real", "realtime", "reg",
-			"release", "repeat", "rnmos", "rpmos", "rtran", "rtranif0",
-			"rtranif1", "scalared", "signed", "small", "specify", "specparam",
-			"strenght", "strong0", "strong1", "supply0", "supply1", "table",
-			"task", "time", "tran", "tranif0", "tranif1", "tri", "tri0",
-			"tri1", "triand", "trior", "trireg", "unsigned", "vectored",
-			"wait", "wand", "weak0", "weak1", "while", "wire", "wor", "xnor",
-			"xor",
-			"generate", "endgenerate", "genvar", "localparam"};
-
-	private static final String[] verilogDirectives = { "`ifdef", "`else",
-			"`endif", "`if", "`define", "`undef", "`timescale", "`include" };
-
-	public static final String[] vhdlWords = { "abs", "access", "across", "after",
-			"alias", "all", "and", "architecture", "array", "assert",
-			"attribute", "begin", "block", "body", "break", "buffer", "bus", "case",
-			"component", "configuration", "constant", "disconnect", "downto",
-			"else", "elsif", "end", "entity", "exit", "file", "for",
-			"function", "generate", "generic", "group", "guarded", "if", "impure", "in",
-			"inertial", "inout", "is", "label", "library", "linkage",
-			"literal", "loop", "map", "mod", "nand", "nature", "new", "next", "noise", "nor",
-			"not", "null", "of", "on", "open", "or", "others", "out",
-			"package", "port", "postponed", "procedural", "procedure", "process", "protected", "pure",
-			"quantity", "range", "record", "register", "reject", "rem", "report", "return",
-			"rol", "ror", "select", "severity", "shared", "signal", "sla",
-			"sll", "spectrum", "sra", "srl", "subnature", "subtype", "terminal", "then",
-			"through", "to", "tolerance", "transport", "type",
-			"unaffected", "units", "until", "use", "variable", "wait", "when",
-			"while", "with", "xnor", "xor" };
-	
-	private static final String[] vhdlTypes = { "bit", "bit_vector", "character", 
-			"boolean", "integer", "real", "time", "string",	"severity_level", 
-			"positive", "natural", "signed", "unsigned", "line", "text",
-			"std_logic", "std_logic_vector", "std_ulogic", "std_ulogic_vector", 
-			"qsim_state", "qsim_state_vector", "qsim_12state",
-			"qsim_12state_vector", "qsim_strength", "mux_bit", "mux_vector", 
-			"reg_bit", "reg_vector", "wor_bit",	"wor_vector"};
-
-	private HdlScanner(ColorManager manager, boolean isVerilog)
-	{
-		IToken keyword = new Token(HdlTextAttribute.KEY_WORD
-				.getTextAttribute(manager));
-		IToken directive = new Token(HdlTextAttribute.DIRECTIVE
-				.getTextAttribute(manager));
-		IToken other = new Token(HdlTextAttribute.DEFAULT
-				.getTextAttribute(manager));
-		IToken types = new Token(HdlTextAttribute.TYPES.getTextAttribute(manager));
-
-		List<IRule> rules = new ArrayList<IRule>();
-
-		WordRule wordRule;
-
-		if (isVerilog)
-		{
-		    wordRule= new WordRule(new net.sourceforge.veditor.editor.scanner.verilog.WordDetector(), other);
-			for (int i = 0; i < verilogDirectives.length; i++)
-				wordRule.addWord(verilogDirectives[i], directive);
-			for (int i = 0; i < verilogWords.length; i++)
-				wordRule.addWord(verilogWords[i], keyword);
-		}
-		else
-		{
-		    wordRule= new WordRule(new  net.sourceforge.veditor.editor.scanner.vhdl.WordDetector(), other);
-			for (int i = 0; i < vhdlWords.length; i++)
-				wordRule.addWord(vhdlWords[i], keyword);
-			// it is possible to use upper case in VHDL
-			for (int i = 0; i < vhdlWords.length; i++)
-				wordRule.addWord(vhdlWords[i].toUpperCase(), keyword);
-			
-			for (int i = 0; i < vhdlTypes.length; i++)
-				wordRule.addWord(vhdlTypes[i], types);
-			// it is possible to use upper case in VHDL
-			for (int i = 0; i < vhdlTypes.length; i++)
-				wordRule.addWord(vhdlTypes[i].toUpperCase(), types);
-		}
-		
-		rules.add(wordRule);
-
-		IRule[] result = new IRule[rules.size()];
-		rules.toArray(result);
-		setRules(result);
-	}	
-}
-
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+
+package com.elphel.vdt.veditor.editor.scanner;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import com.elphel.vdt.veditor.editor.ColorManager;
+import com.elphel.vdt.veditor.editor.HdlTextAttribute;
+import org.eclipse.jface.text.rules.*;
+
+
+/**
+ * find reserved word
+ */
+public class HdlScanner extends RuleBasedScanner
+{
+	public static HdlScanner createForVerilog(ColorManager manager)
+	{
+		return new HdlScanner(manager, true);
+	}
+	public static HdlScanner createForVhdl(ColorManager manager)
+	{
+		return new HdlScanner(manager, false);
+	}
+
+	private static final String[] verilogWords = {"always", "and", "assign",
+			"attribute", "begin", "buf", "bufif0", "bufif1", "case", "casex",
+			"casez", "cmos", "deassign", "default", "defparam", "disable",
+			"edge", "else", "end", "endattribute", "endcase", "endfunction", "endmodule",
+			"endprimitive", "endspecify", "endtable", "endtask", "event",
+			"for", "force", "forever", "fork", "function", "highz0", "highz1",
+			"if", "ifnone", "initial", "inout", "input", "integer", "join",
+			"medium", "module", "large", "macromodule", "nand", "negedge",
+			"nmos", "nor", "not", "notif0", "notif1", "or", "output",
+			"parameter", "pmos", "posedge", "primitive", "pull0", "pull1",
+			"pulldown", "pullup", "rcmos", "real", "realtime", "reg",
+			"release", "repeat", "rnmos", "rpmos", "rtran", "rtranif0",
+			"rtranif1", "scalared", "signed", "small", "specify", "specparam",
+			"strenght", "strong0", "strong1", "supply0", "supply1", "table",
+			"task", "time", "tran", "tranif0", "tranif1", "tri", "tri0",
+			"tri1", "triand", "trior", "trireg", "unsigned", "vectored",
+			"wait", "wand", "weak0", "weak1", "while", "wire", "wor", "xnor",
+			"xor",
+			"generate", "endgenerate", "genvar", "localparam"};
+
+	private static final String[] verilogDirectives = { "`ifdef","`ifndef", "`else",
+			"`endif", "`if", "`define", "`undef", "`timescale", "`include",
+			"`celldefine", "`endcelldefine","`elsif"};
+
+	public static final String[] vhdlWords = { "abs", "access", "across", "after",
+			"alias", "all", "and", "architecture", "array", "assert",
+			"attribute", "begin", "block", "body", "break", "buffer", "bus", "case",
+			"component", "configuration", "constant", "disconnect", "downto",
+			"else", "elsif", "end", "entity", "exit", "file", "for",
+			"function", "generate", "generic", "group", "guarded", "if", "impure", "in",
+			"inertial", "inout", "is", "label", "library", "linkage",
+			"literal", "loop", "map", "mod", "nand", "nature", "new", "next", "noise", "nor",
+			"not", "null", "of", "on", "open", "or", "others", "out",
+			"package", "port", "postponed", "procedural", "procedure", "process", "protected", "pure",
+			"quantity", "range", "record", "register", "reject", "rem", "report", "return",
+			"rol", "ror", "select", "severity", "shared", "signal", "sla",
+			"sll", "spectrum", "sra", "srl", "subnature", "subtype", "terminal", "then",
+			"through", "to", "tolerance", "transport", "type",
+			"unaffected", "units", "until", "use", "variable", "wait", "when",
+			"while", "with", "xnor", "xor" };
+	
+	private static final String[] vhdlTypes = { "bit", "bit_vector", "character", 
+			"boolean", "integer", "real", "time", "string",	"severity_level", 
+			"positive", "natural", "signed", "unsigned", "line", "text",
+			"std_logic", "std_logic_vector", "std_ulogic", "std_ulogic_vector", 
+			"qsim_state", "qsim_state_vector", "qsim_12state",
+			"qsim_12state_vector", "qsim_strength", "mux_bit", "mux_vector", 
+			"reg_bit", "reg_vector", "wor_bit",	"wor_vector"};
+
+	private HdlScanner(ColorManager manager, boolean isVerilog)
+	{
+		IToken keyword = new Token(HdlTextAttribute.KEY_WORD
+				.getTextAttribute(manager));
+		IToken directive = new Token(HdlTextAttribute.DIRECTIVE
+				.getTextAttribute(manager));
+		IToken other = new Token(HdlTextAttribute.DEFAULT
+				.getTextAttribute(manager));
+		IToken types = new Token(HdlTextAttribute.TYPES.getTextAttribute(manager));
+
+		List<IRule> rules = new ArrayList<IRule>();
+
+		WordRule wordRule;
+
+		if (isVerilog)
+		{
+		    wordRule= new WordRule(new com.elphel.vdt.veditor.editor.scanner.verilog.WordDetector(), other);
+			for (int i = 0; i < verilogDirectives.length; i++)
+				wordRule.addWord(verilogDirectives[i], directive);
+			for (int i = 0; i < verilogWords.length; i++)
+				wordRule.addWord(verilogWords[i], keyword);
+		}
+		else
+		{
+		    wordRule= new WordRule(new  com.elphel.vdt.veditor.editor.scanner.vhdl.WordDetector(), other);
+			for (int i = 0; i < vhdlWords.length; i++)
+				wordRule.addWord(vhdlWords[i], keyword);
+			// it is possible to use upper case in VHDL
+			for (int i = 0; i < vhdlWords.length; i++)
+				wordRule.addWord(vhdlWords[i].toUpperCase(), keyword);
+			
+			for (int i = 0; i < vhdlTypes.length; i++)
+				wordRule.addWord(vhdlTypes[i], types);
+			// it is possible to use upper case in VHDL
+			for (int i = 0; i < vhdlTypes.length; i++)
+				wordRule.addWord(vhdlTypes[i].toUpperCase(), types);
+		}
+		
+		rules.add(wordRule);
+
+		IRule[] result = new IRule[rules.size()];
+		rules.toArray(result);
+		setRules(result);
+	}	
+}
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/editor/scanner/verilog/VerilogPartitionScanner.java vdt/src/com/elphel/vdt/veditor/editor/scanner/verilog/VerilogPartitionScanner.java
--- vdt-veditor/src/com/elphel/vdt/veditor/editor/scanner/verilog/VerilogPartitionScanner.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/editor/scanner/verilog/VerilogPartitionScanner.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,31 @@
-/*******************************************************************************
- * Copyright (c) 2009 VEditor Team
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2009 VEditor Team
  *
  * Contributors:
  *    Ali G - initial API and implementation
  *******************************************************************************/
 
-package net.sourceforge.veditor.editor.scanner.verilog;
+package com.elphel.vdt.veditor.editor.scanner.verilog;
 
 import java.util.ArrayList;
 import java.util.List;
 
-import net.sourceforge.veditor.editor.scanner.HdlPartitionScanner;
+import com.elphel.vdt.veditor.editor.scanner.HdlPartitionScanner;
 
 import org.eclipse.jface.text.rules.*;
 
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/editor/scanner/verilog/WordDetector.java vdt/src/com/elphel/vdt/veditor/editor/scanner/verilog/WordDetector.java
--- vdt-veditor/src/com/elphel/vdt/veditor/editor/scanner/verilog/WordDetector.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/editor/scanner/verilog/WordDetector.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,4 +1,4 @@
-package net.sourceforge.veditor.editor.scanner.verilog;
+package com.elphel.vdt.veditor.editor.scanner.verilog;
 
 import org.eclipse.jface.text.rules.IWordDetector;
 
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/editor/scanner/vhdl/VhdlPartitionScanner.java vdt/src/com/elphel/vdt/veditor/editor/scanner/vhdl/VhdlPartitionScanner.java
--- vdt-veditor/src/com/elphel/vdt/veditor/editor/scanner/vhdl/VhdlPartitionScanner.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/editor/scanner/vhdl/VhdlPartitionScanner.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,31 @@
-/*******************************************************************************
- * Copyright (c) 2009 VEditor Team
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2009 VEditor Team
  *
  * Contributors:
  *    Ali G - initial API and implementation
  *******************************************************************************/
-package net.sourceforge.veditor.editor.scanner.vhdl;
+package com.elphel.vdt.veditor.editor.scanner.vhdl;
 
 import java.util.ArrayList;
 import java.util.List;
 
 
-import net.sourceforge.veditor.editor.scanner.HdlPartitionScanner;
+import com.elphel.vdt.veditor.editor.scanner.HdlPartitionScanner;
 
 import org.eclipse.jface.text.rules.*;
 
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/editor/scanner/vhdl/WordDetector.java vdt/src/com/elphel/vdt/veditor/editor/scanner/vhdl/WordDetector.java
--- vdt-veditor/src/com/elphel/vdt/veditor/editor/scanner/vhdl/WordDetector.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/editor/scanner/vhdl/WordDetector.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,4 +1,4 @@
-package net.sourceforge.veditor.editor.scanner.vhdl;
+package com.elphel.vdt.veditor.editor.scanner.vhdl;
 
 import org.eclipse.jface.text.rules.IWordDetector;
 
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/editor/VerilogCompletionProcessor.java vdt/src/com/elphel/vdt/veditor/editor/VerilogCompletionProcessor.java
--- vdt-veditor/src/com/elphel/vdt/veditor/editor/VerilogCompletionProcessor.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/editor/VerilogCompletionProcessor.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,233 +1,244 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.editor;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-
-import net.sourceforge.veditor.document.HdlDocument;
-import net.sourceforge.veditor.editor.completionProposals.IComparableCompletionProposal;
-import net.sourceforge.veditor.editor.completionProposals.VerilogCompletionProposal;
-import net.sourceforge.veditor.editor.completionProposals.VerilogInstanceCompletionProposal;
-import net.sourceforge.veditor.parser.HdlParserException;
-import net.sourceforge.veditor.parser.IParser;
-import net.sourceforge.veditor.parser.OutlineDatabase;
-import net.sourceforge.veditor.parser.OutlineElement;
-import net.sourceforge.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogFunctionElement;
-import net.sourceforge.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogModuleElement;
-import net.sourceforge.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogParameterElement;
-import net.sourceforge.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogPortElement;
-import net.sourceforge.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogSignalElement;
-import net.sourceforge.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogTaskElement;
-import net.sourceforge.veditor.templates.VerilogInModuleContextType;
-import net.sourceforge.veditor.templates.VerilogInStatementContextType;
-import net.sourceforge.veditor.templates.VerilogOutModuleContextType;
-
-import org.eclipse.jface.text.BadLocationException;
-import org.eclipse.jface.text.ITextViewer;
-import org.eclipse.jface.text.contentassist.ICompletionProposal;
-import org.eclipse.jface.text.templates.Template;
-import org.eclipse.swt.widgets.Display;
-
-public class VerilogCompletionProcessor extends HdlCompletionProcessor
-{
-	public ICompletionProposal[] computeCompletionProposals(
-			ITextViewer viewer,
-			int documentOffset)
-		{
-			HdlDocument doc = (HdlDocument)viewer.getDocument();
-			String match = getMatchingWord(doc.get(), documentOffset);
-			List<IComparableCompletionProposal> matchList = null;
-			OutlineElement currentElement=null;
-
-			int context = IParser.OUT_OF_MODULE;
-			try
-			{	
-				context = doc.getContext(documentOffset - match.length());
-				currentElement=doc.getElementAt(documentOffset,false);
-			}
-			catch (BadLocationException e)
-			{
-			}
-			catch (HdlParserException e){
-				
-			}
-
-			switch(context)
-			{
-				case IParser.IN_MODULE:
-					matchList = getInModuleProposals(doc, documentOffset, match);
-					break;
-				case IParser.IN_STATEMENT:
-					matchList = getInStatmentProposals(doc, documentOffset, match, currentElement);
-					break;
-				case IParser.OUT_OF_MODULE:
-					matchList = getOutOfModuleProposals(doc, documentOffset, match);				
-					break;
-				default:
-					Display.getCurrent().beep();
-					return null;
-			}
-			
-			matchList.addAll(getTemplates(viewer, documentOffset, context));
-			Collections.sort(matchList);
-			ICompletionProposal[] result = new ICompletionProposal[matchList.size()];
-			for (int i = 0; i < matchList.size(); i++)
-			{
-				result[i] = (ICompletionProposal)matchList.get(i);
-			}
-			return result;
-		}
-	public List<IComparableCompletionProposal> getInModuleProposals(HdlDocument doc, int offset,
-			String replace)
-	{
-		int length = replace.length();
-		List<IComparableCompletionProposal> matchList = new ArrayList<IComparableCompletionProposal>();
-
-		//  reserved word
-		String[] rwords = {"assign ", "reg ", "wire ", "integer ", "parameter "};
-		for(int i = 0 ; i < rwords.length ; i++)
-		{
-			if (isMatch(replace, rwords[i]))
-				matchList.add(getSimpleProposal(rwords[i], offset, length));
-		}
-
-		OutlineDatabase database = doc.getOutlineDatabase();
-		OutlineElement[] topLevelElements=database.findTopLevelElements(replace);
-		for(OutlineElement element: topLevelElements){
-			if (element instanceof VerilogModuleElement) {				
-				matchList.add(new VerilogInstanceCompletionProposal(doc,element, offset, length));
-			}
-		}
-				
-		return matchList;
-	}
-
-	public List<IComparableCompletionProposal> getInStatmentProposals(
-		HdlDocument doc,
-		int offset,
-		String replace,
-		OutlineElement element)
-	{
-		List<IComparableCompletionProposal>  matchList= new ArrayList<IComparableCompletionProposal>();
-
-		//  variable
-		return addVariableProposals(doc, offset, replace, element, matchList);
-	}
-
-	public List<IComparableCompletionProposal> getOutOfModuleProposals(HdlDocument doc, int offset, String replace)
-	{
-		List<IComparableCompletionProposal>  matchList= new ArrayList<IComparableCompletionProposal>();
-		
-		return matchList;
-	}	
-	
-	/**
-	 * Returns the relevance scale of the template given the prefix. 
-	 * This value is used to sort the suggestions made during template completion 
-	 * 
-	 * @param template the template
-	 * @param prefix the prefix
-	 * @return the relevance of the <code>template</code> for the given <code>prefix</code>
-	 */
-	protected int getRelevance(Template template, String prefix) {
-		//for now, all are equal
-		return 0;
-	}
-	
-	/**
-	 * This function should return a context string for the given context.
-	 * This value will be used to lookup the templates in the TemplateStore
-	 * @param context
-	 * @return Context string used to lookup the templates in the TemplateStore
-	 */
-	protected String getTemplateContextString(int context)
-	{
-		final String results;
-		switch (context)
-		{
-			case IParser.OUT_OF_MODULE:
-				results = VerilogOutModuleContextType.CONTEXT_TYPE;
-				break;
-			case IParser.IN_MODULE:
-				results = VerilogInModuleContextType.CONTEXT_TYPE;
-				break;
-			case IParser.IN_STATEMENT:
-			default:
-				results = VerilogInStatementContextType.CONTEXT_TYPE;
-				break;
-		}
-		return results;
-	}
-	
-	protected List<IComparableCompletionProposal> addVariableProposals(
-			HdlDocument doc,
-			int offset, String replace, 
-			OutlineElement element, 
-			List<IComparableCompletionProposal> matchList)
-	{		
-		//scan backwards and add all the available elements
-		while (element != null)
-		{
-			// FIX!!! should we do something more advanced when there
-			// are no modules?
-			if (element instanceof VerilogModuleElement) {
-				VerilogModuleElement module = (VerilogModuleElement) element;
-				for(OutlineElement child: module.getChildren()){					
-					if (child instanceof VerilogPortElement && child.getName().startsWith(replace)) {
-						//add ports
-						VerilogPortElement port = (VerilogPortElement) child;
-						matchList.add(new VerilogCompletionProposal(port, offset, replace.length()));
-						
-					}else if (child instanceof VerilogSignalElement && child.getName().startsWith(replace)) {
-						//add signals
-						VerilogSignalElement signal = (VerilogSignalElement) child;
-						matchList.add(new VerilogCompletionProposal(signal, offset, replace.length()));	
-					}else if (element instanceof VerilogParameterElement) {
-						//add parameter
-						VerilogParameterElement parameter = (VerilogParameterElement) element;
-						matchList.add(new VerilogCompletionProposal(parameter, offset, replace.length()));
-					}					
-				}
-				
-			}else if (element instanceof VerilogTaskElement) {
-				VerilogTaskElement task = (VerilogTaskElement) element;
-				for(OutlineElement child: task.getChildren()){
-					//add signals
-					if (child instanceof VerilogSignalElement && child.getName().startsWith(replace)) {
-						VerilogSignalElement signal = (VerilogSignalElement) child;
-						matchList.add(new VerilogCompletionProposal(signal, offset, replace.length()));	
-					}					
-				}
-				
-				
-			}else if (element instanceof VerilogFunctionElement) {
-				VerilogFunctionElement func = (VerilogFunctionElement) element;
-				for(OutlineElement child: func.getChildren()){
-					//add signals
-					if (child instanceof VerilogSignalElement && child.getName().startsWith(replace)) {
-						VerilogSignalElement signal = (VerilogSignalElement) child;
-						matchList.add(new VerilogCompletionProposal(signal, offset, replace.length()));		
-					}					
-				}
-				
-			}	
-			
-			element=element.getParent();
-		}
-		
-		return matchList;
-	}
-
-}
-
-
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.editor;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import com.elphel.vdt.veditor.document.HdlDocument;
+import com.elphel.vdt.veditor.editor.completionProposals.IComparableCompletionProposal;
+import com.elphel.vdt.veditor.editor.completionProposals.VerilogCompletionProposal;
+import com.elphel.vdt.veditor.editor.completionProposals.VerilogInstanceCompletionProposal;
+import com.elphel.vdt.veditor.parser.HdlParserException;
+import com.elphel.vdt.veditor.parser.IParser;
+import com.elphel.vdt.veditor.parser.OutlineDatabase;
+import com.elphel.vdt.veditor.parser.OutlineElement;
+import com.elphel.vdt.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogFunctionElement;
+import com.elphel.vdt.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogModuleElement;
+import com.elphel.vdt.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogParameterElement;
+import com.elphel.vdt.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogPortElement;
+import com.elphel.vdt.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogSignalElement;
+import com.elphel.vdt.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogTaskElement;
+import com.elphel.vdt.veditor.templates.VerilogInModuleContextType;
+import com.elphel.vdt.veditor.templates.VerilogInStatementContextType;
+import com.elphel.vdt.veditor.templates.VerilogOutModuleContextType;
+
+import org.eclipse.jface.text.BadLocationException;
+import org.eclipse.jface.text.ITextViewer;
+import org.eclipse.jface.text.contentassist.ICompletionProposal;
+import org.eclipse.jface.text.templates.Template;
+import org.eclipse.swt.widgets.Display;
+
+public class VerilogCompletionProcessor extends HdlCompletionProcessor
+{
+	public ICompletionProposal[] computeCompletionProposals(
+			ITextViewer viewer,
+			int documentOffset)
+		{
+			HdlDocument doc = (HdlDocument)viewer.getDocument();
+			String match = getMatchingWord(doc.get(), documentOffset);
+			List<IComparableCompletionProposal> matchList = null;
+			OutlineElement currentElement=null;
+
+			int context = IParser.OUT_OF_MODULE;
+			try
+			{	
+				context = doc.getContext(documentOffset - match.length());
+				currentElement=doc.getElementAt(documentOffset,false);
+			}
+			catch (BadLocationException e)
+			{
+			}
+			catch (HdlParserException e){
+				
+			}
+
+			switch(context)
+			{
+				case IParser.IN_MODULE:
+					matchList = getInModuleProposals(doc, documentOffset, match);
+					break;
+				case IParser.IN_STATEMENT:
+					matchList = getInStatmentProposals(doc, documentOffset, match, currentElement);
+					break;
+				case IParser.OUT_OF_MODULE:
+					matchList = getOutOfModuleProposals(doc, documentOffset, match);				
+					break;
+				default:
+					Display.getCurrent().beep();
+					return null;
+			}
+			
+			matchList.addAll(getTemplates(viewer, documentOffset, context));
+			Collections.sort(matchList);
+			ICompletionProposal[] result = new ICompletionProposal[matchList.size()];
+			for (int i = 0; i < matchList.size(); i++)
+			{
+				result[i] = (ICompletionProposal)matchList.get(i);
+			}
+			return result;
+		}
+	public List<IComparableCompletionProposal> getInModuleProposals(HdlDocument doc, int offset,
+			String replace)
+	{
+		int length = replace.length();
+		List<IComparableCompletionProposal> matchList = new ArrayList<IComparableCompletionProposal>();
+
+		//  reserved word
+		String[] rwords = {"assign ", "reg ", "wire ", "integer ", "parameter "};
+		for(int i = 0 ; i < rwords.length ; i++)
+		{
+			if (isMatch(replace, rwords[i]))
+				matchList.add(getSimpleProposal(rwords[i], offset, length));
+		}
+
+		OutlineDatabase database = doc.getOutlineDatabase();
+		OutlineElement[] topLevelElements=database.findTopLevelElements(replace);
+		for(OutlineElement element: topLevelElements){
+			if (element instanceof VerilogModuleElement) {				
+				matchList.add(new VerilogInstanceCompletionProposal(doc,element, offset, length));
+			}
+		}
+				
+		return matchList;
+	}
+
+	public List<IComparableCompletionProposal> getInStatmentProposals(
+		HdlDocument doc,
+		int offset,
+		String replace,
+		OutlineElement element)
+	{
+		List<IComparableCompletionProposal>  matchList= new ArrayList<IComparableCompletionProposal>();
+
+		//  variable
+		return addVariableProposals(doc, offset, replace, element, matchList);
+	}
+
+	public List<IComparableCompletionProposal> getOutOfModuleProposals(HdlDocument doc, int offset, String replace)
+	{
+		List<IComparableCompletionProposal>  matchList= new ArrayList<IComparableCompletionProposal>();
+		
+		return matchList;
+	}	
+	
+	/**
+	 * Returns the relevance scale of the template given the prefix. 
+	 * This value is used to sort the suggestions made during template completion 
+	 * 
+	 * @param template the template
+	 * @param prefix the prefix
+	 * @return the relevance of the <code>template</code> for the given <code>prefix</code>
+	 */
+	protected int getRelevance(Template template, String prefix) {
+		//for now, all are equal
+		return 0;
+	}
+	
+	/**
+	 * This function should return a context string for the given context.
+	 * This value will be used to lookup the templates in the TemplateStore
+	 * @param context
+	 * @return Context string used to lookup the templates in the TemplateStore
+	 */
+	protected String getTemplateContextString(int context)
+	{
+		final String results;
+		switch (context)
+		{
+			case IParser.OUT_OF_MODULE:
+				results = VerilogOutModuleContextType.CONTEXT_TYPE;
+				break;
+			case IParser.IN_MODULE:
+				results = VerilogInModuleContextType.CONTEXT_TYPE;
+				break;
+			case IParser.IN_STATEMENT:
+			default:
+				results = VerilogInStatementContextType.CONTEXT_TYPE;
+				break;
+		}
+		return results;
+	}
+	
+	protected List<IComparableCompletionProposal> addVariableProposals(
+			HdlDocument doc,
+			int offset, String replace, 
+			OutlineElement element, 
+			List<IComparableCompletionProposal> matchList)
+	{		
+		//scan backwards and add all the available elements
+		while (element != null)
+		{
+			// FIX!!! should we do something more advanced when there
+			// are no modules?
+			if (element instanceof VerilogModuleElement) {
+				VerilogModuleElement module = (VerilogModuleElement) element;
+				for(OutlineElement child: module.getChildren()){					
+					if (child instanceof VerilogPortElement && child.getName().startsWith(replace)) {
+						//add ports
+						VerilogPortElement port = (VerilogPortElement) child;
+						matchList.add(new VerilogCompletionProposal(port, offset, replace.length()));
+						
+					}else if (child instanceof VerilogSignalElement && child.getName().startsWith(replace)) {
+						//add signals
+						VerilogSignalElement signal = (VerilogSignalElement) child;
+						matchList.add(new VerilogCompletionProposal(signal, offset, replace.length()));	
+					}else if (element instanceof VerilogParameterElement) {
+						//add parameter
+						VerilogParameterElement parameter = (VerilogParameterElement) element;
+						matchList.add(new VerilogCompletionProposal(parameter, offset, replace.length()));
+					}					
+				}
+				
+			}else if (element instanceof VerilogTaskElement) {
+				VerilogTaskElement task = (VerilogTaskElement) element;
+				for(OutlineElement child: task.getChildren()){
+					//add signals
+					if (child instanceof VerilogSignalElement && child.getName().startsWith(replace)) {
+						VerilogSignalElement signal = (VerilogSignalElement) child;
+						matchList.add(new VerilogCompletionProposal(signal, offset, replace.length()));	
+					}					
+				}
+				
+				
+			}else if (element instanceof VerilogFunctionElement) {
+				VerilogFunctionElement func = (VerilogFunctionElement) element;
+				for(OutlineElement child: func.getChildren()){
+					//add signals
+					if (child instanceof VerilogSignalElement && child.getName().startsWith(replace)) {
+						VerilogSignalElement signal = (VerilogSignalElement) child;
+						matchList.add(new VerilogCompletionProposal(signal, offset, replace.length()));		
+					}					
+				}
+				
+			}	
+			
+			element=element.getParent();
+		}
+		
+		return matchList;
+	}
+
+}
+
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/editor/VerilogEditor.java vdt/src/com/elphel/vdt/veditor/editor/VerilogEditor.java
--- vdt-veditor/src/com/elphel/vdt/veditor/editor/VerilogEditor.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/editor/VerilogEditor.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,28 +1,40 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.editor;
-
-import net.sourceforge.veditor.document.VerilogDocumentProvider;
-
-
-public class VerilogEditor extends HdlEditor
-{
-	public VerilogEditor()
-	{
-		super();
-		setDocumentProvider(new VerilogDocumentProvider());
-		setSourceViewerConfiguration(HdlSourceViewerConfiguration
-				.createForVerilog(this));
-		OutlineLabelProvider = new VerilogOutlineLabelProvider();
-		TreeContentProvider  = new VerilogHierarchyProvider();
-	}
-		
-}
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.editor;
+
+
+import com.elphel.vdt.veditor.document.VerilogDocumentProvider;
+
+
+public class VerilogEditor extends HdlEditor
+{
+	public VerilogEditor()
+	{
+		super();
+		setDocumentProvider(new VerilogDocumentProvider());
+		setSourceViewerConfiguration(HdlSourceViewerConfiguration
+				.createForVerilog(this));
+		OutlineLabelProvider = new VerilogOutlineLabelProvider();
+		TreeContentProvider  = new VerilogHierarchyProvider();
+	}
+		
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/editor/VerilogHierarchyProvider.java vdt/src/com/elphel/vdt/veditor/editor/VerilogHierarchyProvider.java
--- vdt-veditor/src/com/elphel/vdt/veditor/editor/VerilogHierarchyProvider.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/editor/VerilogHierarchyProvider.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,159 +1,176 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.editor;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-
-import net.sourceforge.veditor.VerilogPlugin;
-import net.sourceforge.veditor.document.HdlDocument;
-import net.sourceforge.veditor.parser.HdlParserException;
-import net.sourceforge.veditor.parser.OutlineDatabase;
-import net.sourceforge.veditor.parser.OutlineElement;
-import net.sourceforge.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogInstanceElement;
-import net.sourceforge.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogModuleElement;
-import net.sourceforge.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogOutlineElement;
-
-import org.eclipse.core.runtime.CoreException;
-
-
-public class VerilogHierarchyProvider extends HdlTreeProviderBase
-{
-	HashMap<String,VerilogModuleElement> m_ModuleList=new HashMap<String,VerilogModuleElement>();
-	
-	public Object[] getElements(Object inputElement)
-	{
-		HdlDocument doc = (HdlDocument)inputElement;
-		try {
-			doc.refreshOutline();
-			return (Object[])scanProject(doc);
-		} catch (HdlParserException e) {
-
-		}
-		return new Object[0];
-	}
-	
-	public Object getParent(Object element)
-	{
-		return null;
-	}
-
-	public boolean hasChildren(Object element)
-	{
-		//if we have a module, it must have instatiations
-		if (element instanceof VerilogModuleElement) {
-			VerilogModuleElement moduleElement = (VerilogModuleElement) element;
-			for(OutlineElement child : moduleElement.getChildren()){
-				if(child instanceof VerilogInstanceElement){
-					return true;
-				}
-			}
-		}
-		//if we have an instance, find the module that goes with it
-		if (element instanceof VerilogInstanceElement) {
-			VerilogInstanceElement instance = (VerilogInstanceElement) element;
-			//get the module
-			if(m_ModuleList.containsKey(instance.getModuleType())){
-				//if the module has instantiations
-				VerilogModuleElement moduleElement=m_ModuleList.get(instance.getModuleType());
-				for(OutlineElement child : moduleElement.getChildren()){
-					if(child instanceof VerilogInstanceElement){
-						VerilogInstanceElement childInstance = (VerilogInstanceElement) child;
-						//guard against recursive definitions
-						if(childInstance.getModuleType().equals(moduleElement.getName()) ==false){
-							return true;
-						}
-					}
-				}
-			}
-		}
-		return false;
-	}	
-	public Object[] getChildren(Object parentElement)
-	{
-		ArrayList<VerilogOutlineElement> children=new ArrayList<VerilogOutlineElement>();
-		
-		//if we have a module, it must have instatiations
-		if (parentElement instanceof VerilogModuleElement) {
-			VerilogModuleElement moduleElement = (VerilogModuleElement) parentElement;
-			for(OutlineElement child : moduleElement.getChildren()){
-				if(child instanceof VerilogInstanceElement){
-					VerilogInstanceElement instance = (VerilogInstanceElement) child;
-					children.add(instance);
-				}
-			}
-		}
-		//if we have an instance, find the module that goes with it
-		if (parentElement instanceof VerilogInstanceElement) {
-			VerilogInstanceElement instance = (VerilogInstanceElement) parentElement;
-			//get the module
-			if(m_ModuleList.containsKey(instance.getModuleType())){
-				//if the module has instantiations
-				VerilogModuleElement moduleElement=m_ModuleList.get(instance.getModuleType());
-				for(OutlineElement child : moduleElement.getChildren()){
-					if(child instanceof VerilogInstanceElement){
-						VerilogInstanceElement childInstance = (VerilogInstanceElement) child;
-						children.add(childInstance);
-					}
-				}
-			}
-		}
-		
-		
-		return children.toArray();
-	}
-	
-	/**
-	 * Gets a list of top level modules in this project
-	 * @return
-	 */
-	private VerilogOutlineElement[] scanProject(HdlDocument doc){
-		OutlineDatabase database;
-		OutlineElement []topLevelElements;
-		HashMap<String,VerilogModuleElement> topLevelModules=new HashMap<String,VerilogModuleElement>();
-		
-		try {
-			database = (OutlineDatabase)
-				doc.getProject().getSessionProperty(VerilogPlugin.getOutlineDatabaseId());
-		} catch (CoreException e) {
-			e.printStackTrace();		
-			return null;
-		}
-		////////////////////////////////////////////
-		//scan for modules and make a list
-		topLevelElements = database.findTopLevelElements("");
-		m_ModuleList.clear();
-		for (OutlineElement element : topLevelElements){
-			if (element instanceof VerilogModuleElement) {
-				VerilogModuleElement moduleElement = (VerilogModuleElement) element;
-				m_ModuleList.put(moduleElement.getShortName(),moduleElement);
-			}
-		} 
-		////////////////////////////////////////////
-		// scan the modules list and remove the ones that 
-		// are instatiated in another module
-		topLevelModules.putAll(m_ModuleList);
-		for(VerilogModuleElement module : topLevelModules.values().toArray(new VerilogModuleElement[0])){
-			for(OutlineElement child: module.getChildren()){
-				if (child instanceof VerilogInstanceElement) {
-					VerilogInstanceElement instance = (VerilogInstanceElement) child;
-					if(topLevelModules.containsKey(instance.getModuleType())){
-						topLevelModules.remove(instance.getModuleType());
-					}
-				}
-			}
-		}
-		
-		//now what we are left with is a list of modules that are never instantiated
-		return topLevelModules.values().toArray(new VerilogOutlineElement[0]);
-	}
-}
-
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.editor;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+
+import com.elphel.vdt.veditor.VerilogPlugin;
+import com.elphel.vdt.veditor.document.HdlDocument;
+import com.elphel.vdt.veditor.parser.HdlParserException;
+import com.elphel.vdt.veditor.parser.OutlineDatabase;
+import com.elphel.vdt.veditor.parser.OutlineElement;
+import com.elphel.vdt.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogInstanceElement;
+import com.elphel.vdt.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogModuleElement;
+import com.elphel.vdt.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogOutlineElement;
+
+import org.eclipse.core.runtime.CoreException;
+
+
+public class VerilogHierarchyProvider extends HdlTreeProviderBase
+{
+	HashMap<String,VerilogModuleElement> m_ModuleList=new HashMap<String,VerilogModuleElement>();
+// will use as a cache instead of scanning project 	
+	HashMap<String,VerilogModuleElement> topLevelModules=new HashMap<String,VerilogModuleElement>();
+	
+	public Object[] getElements(Object inputElement)
+	{
+		HdlDocument doc = (HdlDocument)inputElement;
+		try {
+			doc.refreshOutline();
+			return (Object[])scanProject(doc);
+		} catch (HdlParserException e) {
+
+		}
+		return new Object[0];
+	}
+	
+	public Object getParent(Object element)
+	{
+		return null;
+	}
+
+	public boolean hasChildren(Object element)
+	{
+		//if we have a module, it must have instatiations
+		if (element instanceof VerilogModuleElement) {
+			VerilogModuleElement moduleElement = (VerilogModuleElement) element;
+			for(OutlineElement child : moduleElement.getChildren()){
+				if(child instanceof VerilogInstanceElement){
+					return true;
+				}
+			}
+		}
+		//if we have an instance, find the module that goes with it
+		if (element instanceof VerilogInstanceElement) {
+			VerilogInstanceElement instance = (VerilogInstanceElement) element;
+			//get the module
+			if(m_ModuleList.containsKey(instance.getModuleType())){
+				//if the module has instantiations
+				VerilogModuleElement moduleElement=m_ModuleList.get(instance.getModuleType());
+				for(OutlineElement child : moduleElement.getChildren()){
+					if(child instanceof VerilogInstanceElement){
+						VerilogInstanceElement childInstance = (VerilogInstanceElement) child;
+						//guard against recursive definitions
+						if(childInstance.getModuleType().equals(moduleElement.getName()) ==false){
+							return true;
+						}
+					}
+				}
+			}
+		}
+		return false;
+	}	
+	public Object[] getChildren(Object parentElement)
+	{
+		ArrayList<VerilogOutlineElement> children=new ArrayList<VerilogOutlineElement>();
+		
+		//if we have a module, it must have instatiations
+		if (parentElement instanceof VerilogModuleElement) {
+			VerilogModuleElement moduleElement = (VerilogModuleElement) parentElement;
+			for(OutlineElement child : moduleElement.getChildren()){
+				if(child instanceof VerilogInstanceElement){
+					VerilogInstanceElement instance = (VerilogInstanceElement) child;
+					children.add(instance);
+				}
+			}
+		}
+		//if we have an instance, find the module that goes with it
+		if (parentElement instanceof VerilogInstanceElement) {
+			VerilogInstanceElement instance = (VerilogInstanceElement) parentElement;
+			//get the module
+			if(m_ModuleList.containsKey(instance.getModuleType())){
+				//if the module has instantiations
+				VerilogModuleElement moduleElement=m_ModuleList.get(instance.getModuleType());
+				for(OutlineElement child : moduleElement.getChildren()){
+					if(child instanceof VerilogInstanceElement){
+						VerilogInstanceElement childInstance = (VerilogInstanceElement) child;
+						children.add(childInstance);
+					}
+				}
+			}
+		}
+		
+		
+		return children.toArray();
+	}
+	
+	/**
+	 * Gets a list of top level modules in this project
+	 * @return
+	 */
+	private VerilogOutlineElement[] scanProject(HdlDocument doc){
+		OutlineDatabase database;
+		OutlineElement []topLevelElements;
+//		HashMap<String,VerilogModuleElement> topLevelModules=new HashMap<String,VerilogModuleElement>();
+		
+		try {
+			database = (OutlineDatabase)
+				doc.getProject().getSessionProperty(VerilogPlugin.getOutlineDatabaseId());
+		} catch (CoreException e) {
+			e.printStackTrace();		
+			return null;
+		}
+		////////////////////////////////////////////
+		//scan for modules and make a list
+		topLevelElements = database.findTopLevelElements("");
+		m_ModuleList.clear();
+		for (OutlineElement element : topLevelElements){
+			if (element instanceof VerilogModuleElement) {
+				VerilogModuleElement moduleElement = (VerilogModuleElement) element;
+				m_ModuleList.put(moduleElement.getShortName(),moduleElement);
+			}
+		} 
+		////////////////////////////////////////////
+		// scan the modules list and remove the ones that 
+		// are instatiated in another module
+		topLevelModules.putAll(m_ModuleList);
+		for(VerilogModuleElement module : topLevelModules.values().toArray(new VerilogModuleElement[0])){
+			for(OutlineElement child: module.getChildren()){
+				if (child instanceof VerilogInstanceElement) {
+					VerilogInstanceElement instance = (VerilogInstanceElement) child;
+					if(topLevelModules.containsKey(instance.getModuleType())){
+						topLevelModules.remove(instance.getModuleType());
+					}
+				}
+			}
+		}
+		
+		//now what we are left with is a list of modules that are never instantiated
+		return topLevelModules.values().toArray(new VerilogOutlineElement[0]);
+	}
+	//private VerilogOutlineElement[] getLastScanProject(HdlDocument doc){
+		
+	//}
+
+}
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/editor/VerilogOutlineLabelProvider.java vdt/src/com/elphel/vdt/veditor/editor/VerilogOutlineLabelProvider.java
--- vdt-veditor/src/com/elphel/vdt/veditor/editor/VerilogOutlineLabelProvider.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/editor/VerilogOutlineLabelProvider.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,47 +1,58 @@
-/*******************************************************************************
- * Copyright (c) 2007 Ali Ghorashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    Ali Ghorashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.editor;
-
-import net.sourceforge.veditor.parser.OutlineElement;
-import net.sourceforge.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogOutlineElement;
-
-public class VerilogOutlineLabelProvider extends HdlLabelProvider {	
-	protected static final String OBJ_IMAGE= "$nl$/icons/obj.gif";	
-	
-	/**
-	 * Converts a name to a string using the type string
-	 * @param name element's name
-	 * @param Type element's type
-	 * @return
-	 */
-	protected String convertToString(OutlineElement element){
-		if (element instanceof VerilogOutlineElement) {
-			VerilogOutlineElement verilogElement = (VerilogOutlineElement) element;
-			return verilogElement.getLongName();
-		}
-		//something very wrong
-		return element.toString();
-	}
-		
-	/**
-	 * Returns an image name to be used for the given type
-	 * @param type Type string
-	 * @return Image name to be used for this type
-	 */
-	protected String getImageNameForType(OutlineElement element){
-		if (element instanceof VerilogOutlineElement) {
-			VerilogOutlineElement verilogElement = (VerilogOutlineElement) element;
-			return verilogElement.GetImageName();
-		}
-		//default
-		return OBJ_IMAGE;
-	}
-}
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2007 Ali Ghorashi and others.
+ *
+ * Contributors:
+ *    Ali Ghorashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.editor;
+
+import com.elphel.vdt.veditor.parser.OutlineElement;
+import com.elphel.vdt.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogOutlineElement;
+
+public class VerilogOutlineLabelProvider extends HdlLabelProvider {	
+	protected static final String OBJ_IMAGE= "$nl$/icons/obj.gif";	
+	
+	/**
+	 * Converts a name to a string using the type string
+	 * @param name element's name
+	 * @param Type element's type
+	 * @return
+	 */
+	protected String convertToString(OutlineElement element){
+		if (element instanceof VerilogOutlineElement) {
+			VerilogOutlineElement verilogElement = (VerilogOutlineElement) element;
+			return verilogElement.getLongName(); // In outline view
+		}
+		//something very wrong
+		return element.toString();
+	}
+		
+	/**
+	 * Returns an image name to be used for the given type
+	 * @param type Type string
+	 * @return Image name to be used for this type
+	 */
+	protected String getImageNameForType(OutlineElement element){
+		if (element instanceof VerilogOutlineElement) {
+			VerilogOutlineElement verilogElement = (VerilogOutlineElement) element;
+			return verilogElement.GetImageName();
+		}
+		//default
+		return OBJ_IMAGE;
+	}
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/editor/VhdlCompletionProcessor.java vdt/src/com/elphel/vdt/veditor/editor/VhdlCompletionProcessor.java
--- vdt-veditor/src/com/elphel/vdt/veditor/editor/VhdlCompletionProcessor.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/editor/VhdlCompletionProcessor.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,690 +1,701 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.editor;
-
-import java.util.ArrayList;
-import java.util.Calendar;
-import java.util.Collections;
-import java.util.List;
-
-import net.sourceforge.veditor.VerilogPlugin;
-import net.sourceforge.veditor.document.HdlDocument;
-import net.sourceforge.veditor.document.VhdlDocument;
-import net.sourceforge.veditor.editor.completionProposals.HdlTemplateProposal;
-import net.sourceforge.veditor.editor.completionProposals.IComparableCompletionProposal;
-import net.sourceforge.veditor.editor.completionProposals.VhdlInstanceCompletionProposal;
-import net.sourceforge.veditor.editor.completionProposals.VhdlRecordCompletionProposal;
-import net.sourceforge.veditor.editor.completionProposals.VhdlSubprogramProposalProvider;
-import net.sourceforge.veditor.parser.HdlParserException;
-import net.sourceforge.veditor.parser.IParser;
-import net.sourceforge.veditor.parser.OutlineContainer;
-import net.sourceforge.veditor.parser.OutlineDatabase;
-import net.sourceforge.veditor.parser.OutlineElement;
-import net.sourceforge.veditor.parser.vhdl.VhdlOutlineElementFactory.*;
-import net.sourceforge.veditor.templates.VhdlGlobalContext;
-
-import org.eclipse.core.resources.IFile;
-import org.eclipse.jface.text.BadLocationException;
-import org.eclipse.jface.text.ITextViewer;
-import org.eclipse.jface.text.contentassist.ICompletionProposal;
-import org.eclipse.jface.text.templates.Template;
-import org.eclipse.swt.widgets.Display;
-
-public class VhdlCompletionProcessor extends HdlCompletionProcessor {
-	private static String TEST_BENCH_TEMPLATE_NAME="testbench";
-	
-	private String simplifyCodeLine(String line){
-		char[] cc = line.toCharArray();
-		int edi=0;
-		
-		for(int esi=0;esi<cc.length;esi++){
-			char c = cc[esi];
-			if(c==9)c = 32;
-			if(c==32 && edi!=0 && cc[edi-1]==32){
-				// skip multiple whitespace
-			}else{
-				cc[edi++] = c;
-			}
-		}
-		
-		return new String(cc,0,edi);
-	}
-	
-	
-	private List<IComparableCompletionProposal> matchSpecificPattern(HdlDocument doc,int documentOffset){
-		String line = getCurrentLineUpToOffset(doc.get(), documentOffset);
-		line = line.toLowerCase();
-		line = simplifyCodeLine(line);
-		String tline = line; // left-trimmed line. Can start with whitespace
-		List<IComparableCompletionProposal> matchList = new ArrayList<IComparableCompletionProposal>();
-		
-		if(tline.length()!=0 && tline.charAt(0)==32){
-			tline = tline.substring(1);
-		}
-		
-		if(tline.compareTo("use ")==0){
-			matchList.add(getSimpleProposal("ieee", documentOffset, 0));
-			matchList.add(getSimpleProposal("work", documentOffset, 0));
-		}else if(tline.compareTo("use ieee.")==0){
-			matchList.add(getSimpleProposal("std_logic_1164.all;", documentOffset, 0));
-			matchList.add(getSimpleProposal("numeric_std.all;", documentOffset, 0));
-			matchList.add(getSimpleProposal("std_logic_unsigned.all;", documentOffset, 0));
-		}
-		
-		
-		
-		if(matchList.size()!=0) return matchList;
-		return null;
-	}
-
-	public ICompletionProposal[] computeCompletionProposals(ITextViewer viewer,
-			int documentOffset) {
-		HdlDocument doc = (HdlDocument) viewer.getDocument();
-		String match = getMatchingWord(doc.get(), documentOffset);
-		List<IComparableCompletionProposal> matchList = null;
-		OutlineElement currentElement=null;
-		
-		doc.getFile();
-		int context =VhdlDocument.VHDL_GLOBAL_CONTEXT;
-		try {	
-			context = doc.getContext(documentOffset);
-			currentElement = doc.getElementAt(documentOffset,false);
-		} catch (BadLocationException e) {
-		} catch (HdlParserException e) {
-		}
-		
-		matchList = matchSpecificPattern(doc, documentOffset);
-		String matchwithdot = getMatchingWordWithdot(doc.get(), documentOffset);
-		
-		matchwithdot = matchwithdot+" ";//add space
-		String matchword[]=matchwithdot.split("[.]");
-		
-		if (matchList != null){
-		} else if(matchword.length==1) {
-			switch (context) {
-		 		case VhdlDocument.VHDL_GLOBAL_CONTEXT:
-		 			matchList = getGlobalPropsals(doc, documentOffset, match);
-		 			break;
-		 		default:
-		 			Display.getCurrent().beep(); return null;
-		 	}
-		 
-		 	matchList.addAll(getTemplates(viewer, documentOffset, context));
-			addSignalPropsals(doc, documentOffset, match, currentElement,matchList);
-			addSubprogramProposals(doc, documentOffset, match,currentElement, matchList);
-		} else {  
-			if(matchword.length==2 && matchword[0].equals("work")) { // packages auto completion
-				String match2 = matchword[1].trim();
-				OutlineDatabase database = doc.getOutlineDatabase();
-				OutlineElement[] elements = database.findTopLevelElements(match2);
-				
-				matchList = new ArrayList<IComparableCompletionProposal>();
-				
-				for (int i = 0; i < elements.length; i++) {
-					if(elements[i] instanceof PackageDeclElement){
-						matchList.add(new VhdlInstanceCompletionProposal(doc, elements[i], documentOffset, match2.length()));
-					}
-				}
-			} else { // record member auto completion
-				String recordname = null;
-				recordname = getSignalType(doc, documentOffset, matchword[0], currentElement);
-				for(int i=1;i<matchword.length-1;i++){
-					OutlineElement[] tempRecord=searchRecordDefinition(doc, documentOffset, recordname,currentElement).getChildren();
-					recordname=getMemberType(doc,documentOffset,matchword[i],tempRecord);
-				}
-				
-				TypeDecl finalRecord=(TypeDecl)searchRecordDefinition(doc, documentOffset, recordname,currentElement);
-				
-				
-				matchList = new ArrayList<IComparableCompletionProposal>();
-				
-				if (finalRecord != null) {
-					OutlineElement[] memberElements = finalRecord.getChildren();
-					String matchlc1 = matchword[matchword.length-1];
-					String matchlc=matchlc1.trim().toLowerCase();   
-					for (int h = 0; h < memberElements.length; h++) {
-						String recordmember = memberElements[h].getName().toLowerCase();
-						if (recordmember.startsWith(matchlc)) {
-							 int cc=matchlc.length();
-							 String replace = memberElements[h].getName();
-							
-							 matchList.add(new VhdlRecordCompletionProposal(replace, documentOffset, cc, replace.length(), replace));
-						}
-					}
-				}
-			}
-		}
-
-		Collections.sort(matchList);
-		ICompletionProposal[] result = new ICompletionProposal[matchList.size()];
-		for (int i = 0; i < matchList.size(); i++) {
-			result[i] = (ICompletionProposal) matchList.get(i);
-		}
-		return result;
-	}
-	
-
-
-	// returns typename of member
-	private String getMemberType(HdlDocument doc, int documentOffset,
-			String membername, OutlineElement[] record) {
-
-		String typeName = null;
-		OutlineElement[] children = record;
-		for (int i = 0; i < children.length; i++) {
-			if (children[i].getName().equalsIgnoreCase(membername)) {
-				if (!(children[i] instanceof VhdlOutlineElement))
-					continue;
-				typeName = ((VhdlOutlineElement) children[i]).getTypePart1();
-			}
-		}
-		return typeName;
-	}
-
-
-
-
-	/**
-	 * Returns a list of global proposals based on the given replace string
-	 * @param doc Document where the proposal should be made
-	 * @param offset offset of the proposal in the document 
-	 * @param replace replacement string
-	 * @return List of proposals matching the given string
-	 */
-	public List<IComparableCompletionProposal> getGlobalPropsals(HdlDocument doc,
-			int offset, String replace) {
-		
-		OutlineDatabase database = doc.getOutlineDatabase();
-		List<IComparableCompletionProposal> matchList = new ArrayList<IComparableCompletionProposal>();
-		int length = replace.length();
-		
-		if (database != null) {
-			OutlineElement[] elements = database.findTopLevelElements(replace);
-			for (int i = 0; i < elements.length; i++) {
-				if(VhdlInstanceCompletionProposal.canHandle(elements[i])) {
-					matchList.add(new VhdlInstanceCompletionProposal(doc,
-							elements[i], offset, length));				
-				}
-			}
-			//look into packages
-			elements = database.findTopLevelElements("");
-			for (int i = 0; i < elements.length; i++) {
-				if(elements[i] instanceof PackageDeclElement){
-					OutlineElement[] subPackageElements=elements[i].getChildren();
-					for(int j=0; j< subPackageElements.length; j++){
-						if(VhdlInstanceCompletionProposal.canHandle(subPackageElements[j]) &&
-								subPackageElements[j].getName().toLowerCase().startsWith(replace.toLowerCase())){
-							matchList.add(new VhdlInstanceCompletionProposal(doc,
-									subPackageElements[j], offset, length));
-						}
-					}
-				}
-			}
-			
-			for (int i = 0; i < elements.length; i++) {
-				if(elements[i] instanceof EntityDeclElement || elements[i] instanceof ComponentDeclElement) {
-					String name = elements[i].getName();
-					if(name.startsWith("tb_")) continue;
-					if(isMatch(replace, "tb_"+name)) {
-						matchList.add(createTestBench(doc,(VhdlOutlineElement)elements[i],offset,length));
-					}
-				}
-			}
-			
-			outer : for (int i = 0; i < elements.length; i++) {
-				if(elements[i] instanceof EntityDeclElement) {
-					IComparableCompletionProposal prop = createComponentDecl(doc,(VhdlOutlineElement)elements[i],offset,length);
-					// Avoid duplicate proposals
-					for (IComparableCompletionProposal m : matchList) {
-						if (prop.getDisplayString().equals(m.getDisplayString())) {
-							continue outer;
-						}
-					}
-					String name = elements[i].getName();
-					if(isMatch(replace,name)){
-						matchList.add(prop);
-					}
-				}
-			}
-		}
-
-		return matchList;
-	}
-	
-	private IComparableCompletionProposal createComponentDecl(HdlDocument doc,
-			VhdlOutlineElement mod, int offset, int length) {
-		String modname = mod.toString();
-		String results = String.format(
-				"\tcomponent %s\n${generics}${ports}\tend component;\n",
-				modname);
-
-		OutlineElement[] ports = mod.getChildren();
-
-		boolean first = true;
-		String genericStr = "\t\tgeneric (";
-		for (int i = 0; i < ports.length; i++) {
-			if (!(ports[i] instanceof GenericElement))
-				continue;
-			String port = ports[i].getName();
-			String type = ports[i].getType(); // = port#in#std_logic
-			String[] typesplit = type.split("#");
-			if (typesplit.length != 2)
-				continue;
-			if (typesplit[0].compareToIgnoreCase("generic") != 0)
-				continue;
-			String nl = ";\n\t\t\t";
-			if (first) {
-				nl = "\n\t\t\t";
-				first = false;
-			}
-			genericStr += nl + port + " : " + typesplit[1];
-		}
-		genericStr += "\n\t\t);\n";
-		if (first) {
-			genericStr = "";
-		}
-
-		first = true;
-		String portStr = "\t\tport (";
-		for (int i = 0; i < ports.length; i++) {
-			if (!(ports[i] instanceof VhdlPortElement))
-				continue;
-			String port = ports[i].getName();
-			String type = ports[i].getType(); // = port#in#std_logic
-			String[] typesplit = type.split("#");
-			if (typesplit.length != 3)
-				continue;
-			if (typesplit[0].compareToIgnoreCase("port") != 0)
-				continue;
-			String nl = ";\n\t\t\t";
-			if (first) {
-				nl = "\n\t\t\t";
-				first = false;
-			}
-			portStr += nl + port + " : " + typesplit[1] + " " + typesplit[2];
-		}
-		portStr += "\n\t\t);\n";
-		if (first) {
-			portStr = "";
-		}
-
-		results = results.replace("${generics}", genericStr);
-		results = results.replace("${ports}", portStr);
-
-		String indentationstring = VerilogPlugin.getIndentationString();
-		results = results.replace("\t", indentationstring);
-
-		return getCompletionProposal(results, offset, length, results.length(),
-				modname + " (cmp decl) ");
-	}
-
-	public OutlineElement searchRecordDefinition(HdlDocument doc,
-			int offset, String recordname, OutlineElement  element) {
-		
-		// first search in this file:
-		VhdlOutlineElement parent=null;
-		if (element instanceof VhdlOutlineElement) {
-			parent = (VhdlOutlineElement) element;
-		}
-		//work your way up
-		while(parent != null){
-			OutlineElement[] children =parent.getChildren();
-		
-			for(int i=0;i < children.length;i++){
-				if (children[i] instanceof TypeDecl && children[i].getName()
-						.equalsIgnoreCase(recordname)) {
-					return children[i];
-				}
-			}
-			if (parent.getParent() instanceof VhdlOutlineElement) {
-				parent = (VhdlOutlineElement) parent.getParent();
-			} else {
-				parent=null;
-			}
-		}
-		
-		// not found in this file, search it in packages of other files
-		OutlineDatabase database = doc.getOutlineDatabase();
-		
-		if (database != null) {
-			OutlineElement[] elements = database.findTopLevelElements("");
-			for (int i = 0; i < elements.length; i++) {
-				if(elements[i] instanceof PackageDeclElement ){
-					OutlineElement[] subPackageElements=elements[i].getChildren();
-					for(int j=0; j< subPackageElements.length; j++){
-						if (subPackageElements[j] instanceof TypeDecl
-								&& subPackageElements[j].getName()
-										.equalsIgnoreCase(recordname)) {
-							return subPackageElements[j];
-
-						}
-					}
-				}
-			
-			}
-		}
-
-		return null;
-	}
-
-	private IComparableCompletionProposal createTestBench(HdlDocument doc, VhdlOutlineElement mod, int offset, int length) {
-	  String results=
-	          "library ieee;\n"
-	        + "use ieee.std_logic_1164.all;\n"
-	        + "use ieee.std_logic_arith.all;\n"
-	        + "library std;\n"
-	        + "use std.textio.all;\n"   
-	        + "library work;\n"
-	        + "use work.${module}.PCK.all;\n\n"
-	        + "entity ${testbench} is\n"
-	        + "end ${testbench};\n\n"
-	        + "architecture behav of ${testbench} is\n"
-	        + "-------------------------------\n"
-	        + "-- Test bench for ${module}\n"
-	        + "-------------------------------\n"
-	        + "architecture Test of ${testbench} is\n"
-	        + "    ${signals}\n"
-	        + "    begin\n"
-	        + "    uut:\n" 
-	        + "        ${mod_def}\n"
-	        +  "end architecture Test;\n";
-
-	  //attempt to get new test bench template
-      Template[] templates = VerilogPlugin.getPlugin().getTemplateStore().getTemplates(VhdlGlobalContext.CONTEXT_TYPE);
-        for(Template template: templates){
-            if(TEST_BENCH_TEMPLATE_NAME.equals(template.getName())){
-                results=template.getPattern();
-                break;
-            }
-        }
-       String modname = mod.toString(); 
-       String test_bench="tb_"+modname;
-       OutlineElement[] ports = mod.getChildren();
-       String signals="";
-       for (int i = 0; i < ports.length; i++)
-       {
-           if (!(ports[i] instanceof GenericElement)) continue;
-           String port = ports[i].getName();
-           String type = ports[i].getType(); // = port#in#std_logic            
-           String[] typesplit = type.split("#");
-           if(typesplit.length!=2) continue;
-           if(typesplit[0].compareToIgnoreCase("generic")!=0) continue;
-           signals = signals + ( "\tconstant " + port + " : " + typesplit[1] + " := ;\n" );
-       }       
-       
-       for (int i = 0; i < ports.length; i++)
-       {
-           if (!(ports[i] instanceof VhdlPortElement)) continue;
-           String port = ports[i].getName();
-           String type = ports[i].getType(); // = port#in#std_logic            
-           String[] typesplit = type.split("#");
-           if(typesplit.length!=3) continue;
-           if(typesplit[0].compareToIgnoreCase("port")!=0) continue;
-           signals = signals + ( "\tsignal " + port + " : " + typesplit[2] + ";\n" );
-       }
-       
-       VhdlInstanceCompletionProposal prop = new VhdlInstanceCompletionProposal(doc, mod, offset, length);
-       String module_def = prop.getReplaceString();
-       module_def = module_def.replace("\n", "\n\t"); 
-
-		String indentationstring = VerilogPlugin.getIndentationString();
-		results=results.replace("${testbench}", test_bench);
-		results=results.replace("${signals}", signals);
-		results=results.replace("${module}", modname);
-		results=results.replace("${mod_def}", module_def);
-		results=results.replace("${user}", System.getProperty("user.name"));
-		results=results.replace("${year}", Integer.toString(Calendar.getInstance().get(Calendar.YEAR)));
-		String month = Integer.toString(Calendar.getInstance().get(Calendar.MONTH)+1);
-		if(month.length()<2) month = "0"+month;
-		String day = Integer.toString(Calendar.getInstance().get(Calendar.DAY_OF_MONTH));
-		if(day.length()<2) day = "0"+day;
-		results=results.replace("${month}", month);
-		results=results.replace("${day}", day);
-
-       results = results.replace("\t", indentationstring);
-       
-       return getCompletionProposal(results, offset, length, results.length() , test_bench+" (auto gen testbench) ");
-	}
-
-	
-	private void addEnityIntface(HdlDocument doc,String entityName, int offset, int length,
-			String replace,IFile file, List<IComparableCompletionProposal> matchList){
-		
-		//if no entity was found, bail
-		if (entityName == null){
-			return;
-		}
-		OutlineDatabase database = doc.getOutlineDatabase();
-		OutlineContainer outline = database.getOutlineContainer(file);
-		Object[] children= outline.getTopLevelElements();
-		
-		for (int i=0;i<children.length;i++){
-			if (children[i] instanceof EntityDeclElement) {
-				EntityDeclElement entityDecl = (EntityDeclElement) children[i];			
-				//if we find an entity declaration, add the ports and generics
-				if (entityDecl.getName().equalsIgnoreCase(entityName)) {				
-					//get the entity's children
-					OutlineElement[] enitityChildren=entityDecl.getChildren();
-					for(int entChildIdx=0;entChildIdx<enitityChildren.length;entChildIdx++){
-						if(	enitityChildren[entChildIdx].getName().toUpperCase().startsWith(replace.toUpperCase())){
-							matchList.add(new 
-									VhdlInstanceCompletionProposal(doc,
-											enitityChildren[entChildIdx],
-											offset, 
-											length));
-						}
-					}				
-				}
-			}
-		}
-	}
-	
-	/**
-	 * Adds a list of subprogram calls to the proposal list
-	 * @param doc
-	 * @param offset
-	 * @param replace
-	 * @param element
-	 * @param matchList
-	 */
-	private void addSubprogramProposals(HdlDocument doc,int offset, String replace, OutlineElement  element,
-			List<IComparableCompletionProposal> matchList){
-		VhdlOutlineElement parent=null;
-		int length = replace.length();
-		
-						
-		if (element instanceof VhdlOutlineElement) {
-			parent = (VhdlOutlineElement) element;
-			
-		}
-		//work your way up
-		while(parent != null){
-			OutlineElement[] children =parent.getChildren();
-		
-			for(int i=0;i < children.length;i++){
-				if (children[i] instanceof VhdlSubprogram) {
-					VhdlSubprogram subProgram = (VhdlSubprogram) children[i];
-					
-					if(subProgram.getName().toLowerCase().startsWith(replace.toLowerCase())){
-						VhdlSubprogramProposalProvider proposalProvider=
-							new VhdlSubprogramProposalProvider(doc,subProgram,offset,length);
-						HdlTemplateProposal proposal=proposalProvider.createProposal();
-						matchList.add(proposal);
-					}
-				}				
-			}
-			if (parent.getParent() instanceof VhdlOutlineElement) {
-				parent = (VhdlOutlineElement) parent.getParent();
-				
-			}
-			else{
-				parent=null;
-			}
-		}	
-		//look into packages
-		OutlineDatabase database = doc.getOutlineDatabase();
-		
-		if (database != null) {
-			OutlineElement[] elements = database.findTopLevelElements("");
-			for (int i = 0; i < elements.length; i++) {
-				if(elements[i] instanceof PackageDeclElement){
-					OutlineElement[] subPackageElements=elements[i].getChildren();
-					for(int j=0; j< subPackageElements.length; j++){
-						if(subPackageElements[j] instanceof VhdlSubprogram) {
-							if(subPackageElements[j].getName().toLowerCase().startsWith(replace.toLowerCase())){
-								VhdlSubprogramProposalProvider proposalProvider=
-									new VhdlSubprogramProposalProvider(doc,(VhdlSubprogram)subPackageElements[j],offset,length);
-								HdlTemplateProposal proposal=proposalProvider.createProposal();
-								matchList.add(proposal);
-							}
-						}
-					}
-				}
-			}
-		}
-	}
-
-	
-	// returns typename of the signal.
-	
-	private String getSignalType(HdlDocument doc,int offset, String signalname, OutlineElement  element){
-		VhdlOutlineElement parent=null;
-		
-		String architectureEntityName=null;
-		
-		if (element instanceof VhdlOutlineElement) {
-			parent = (VhdlOutlineElement) element;
-			
-			while (parent != null) {
-				OutlineElement[] children = parent.getChildren();	
-				//if we encounter an architecture, remember its entity
-				if (parent instanceof ArchitectureElement){
-					architectureEntityName=((ArchitectureElement)parent).GetEntityName();
-				}
-				for (int i = 0; i < children.length; i++) {
-					if (children[i].getName().equalsIgnoreCase(signalname)) {
-						if (! (children[i] instanceof VhdlOutlineElement)) continue;
-						return ((VhdlOutlineElement)children[i]).getTypePart1();
-					}
-				}
-				if (parent.getParent() instanceof VhdlOutlineElement) {
-					parent = (VhdlOutlineElement) parent.getParent();
-				} else {
-					parent = null;
-				}
-			}
-		}
-		
-		// now search in the port of the entity of this architecture:
-		if(architectureEntityName!=null){
-			OutlineDatabase database = doc.getOutlineDatabase();
-			OutlineContainer outline = database.getOutlineContainer(doc.getFile());
-			OutlineElement[] children= outline.getTopLevelElements();
-			
-			for (OutlineElement child:children){
-				if (! (child instanceof EntityDeclElement)) continue;
-				EntityDeclElement entityDecl = (EntityDeclElement) child;			
-				//if we find an entity declaration, search ports for signalname
-				if (!entityDecl.getName().equalsIgnoreCase(architectureEntityName)) continue;			
-				//get the entity's children
-				OutlineElement[] entityChildren=entityDecl.getChildren();
-				for(OutlineElement entitychild:entityChildren) {
-					if(!entitychild.getName().equalsIgnoreCase(signalname)) continue;
-					if(!(entitychild instanceof VhdlOutlineElement)) continue;				
-					return ((VhdlOutlineElement)entitychild).getTypePart2();
-				}
-			}
-		}		
-		
-		return "";
-	}
-	
-	/**
-	 * Adds a list of variables to the completion proposal;
-	 * @param doc
-	 * @param offset
-	 * @param replace
-	 * @param element
-	 * @param matchList
-	 */
-	private void addSignalPropsals(HdlDocument doc,int offset, String replace, OutlineElement  element,
-			List<IComparableCompletionProposal> matchList){
-		VhdlOutlineElement parent=null;
-		String architectureEntityName=null;
-		int length = replace.length();
-		
-		if (element instanceof VhdlOutlineElement) {
-			parent = (VhdlOutlineElement) element;
-			
-		}
-		//work your way up
-		while(parent != null){
-			OutlineElement[] children =parent.getChildren();
-			
-			//if we encounter an architecture, remember its entity
-			if (parent instanceof ArchitectureElement){
-				architectureEntityName=((ArchitectureElement)parent).GetEntityName();
-			}
-			
-			for(int i=0;i < children.length;i++){
-				if (VhdlInstanceCompletionProposal.canHandle(children[i])) {
-					if(children[i].getName().toLowerCase().startsWith(replace.toLowerCase())){
-						matchList.add(new VhdlInstanceCompletionProposal(doc,children[i], offset, length));
-					}
-				}
-			}
-			if (parent.getParent() instanceof VhdlOutlineElement) {
-				parent = (VhdlOutlineElement) parent.getParent();
-				
-			}
-			else{
-				parent=null;
-			}
-		}
-		if(architectureEntityName!=null){
-			//add the entity interfaces
-			addEnityIntface(doc,architectureEntityName,offset,length, replace, element.getFile(),matchList);
-		}
-		
-	}
-	/**
-	 * Returns the relevance scale of the template given the prefix. 
-	 * This value is used to sort the suggestions made during template completion 
-	 * 
-	 * @param template the template
-	 * @param prefix the prefix
-	 * @return the relevance of the <code>template</code> for the given <code>prefix</code>
-	 */
-	protected int getRelevance(Template template, String prefix) {
-		//for now, all are equal
-		return 0;
-	}
-
-	/**
-	 * This function should return a context string for the given context.
-	 * This value will be used to lookup the templates in the TemplateStore
-	 * @param context
-	 * @return Context string used to lookup the templates in the TemplateStore
-	 */
-	protected String getTemplateContextString(int context) {
-		final String results;
-		switch (context) {
-		case IParser.OUT_OF_MODULE:
-			results = VhdlGlobalContext.CONTEXT_TYPE;
-			break;
-		default:
-			results = VhdlGlobalContext.CONTEXT_TYPE;
-			break;
-		}
-		return results;
-	}
-	
-}
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.editor;
+
+import java.util.ArrayList;
+import java.util.Calendar;
+import java.util.Collections;
+import java.util.List;
+
+import com.elphel.vdt.veditor.VerilogPlugin;
+import com.elphel.vdt.veditor.document.HdlDocument;
+import com.elphel.vdt.veditor.document.VhdlDocument;
+import com.elphel.vdt.veditor.editor.completionProposals.HdlTemplateProposal;
+import com.elphel.vdt.veditor.editor.completionProposals.IComparableCompletionProposal;
+import com.elphel.vdt.veditor.editor.completionProposals.VhdlInstanceCompletionProposal;
+import com.elphel.vdt.veditor.editor.completionProposals.VhdlRecordCompletionProposal;
+import com.elphel.vdt.veditor.editor.completionProposals.VhdlSubprogramProposalProvider;
+import com.elphel.vdt.veditor.parser.HdlParserException;
+import com.elphel.vdt.veditor.parser.IParser;
+import com.elphel.vdt.veditor.parser.OutlineContainer;
+import com.elphel.vdt.veditor.parser.OutlineDatabase;
+import com.elphel.vdt.veditor.parser.OutlineElement;
+import com.elphel.vdt.veditor.parser.vhdl.VhdlOutlineElementFactory.*;
+import com.elphel.vdt.veditor.templates.VhdlGlobalContext;
+
+import org.eclipse.core.resources.IFile;
+import org.eclipse.jface.text.BadLocationException;
+import org.eclipse.jface.text.ITextViewer;
+import org.eclipse.jface.text.contentassist.ICompletionProposal;
+import org.eclipse.jface.text.templates.Template;
+import org.eclipse.swt.widgets.Display;
+
+public class VhdlCompletionProcessor extends HdlCompletionProcessor {
+	private static String TEST_BENCH_TEMPLATE_NAME="testbench";
+	
+	private String simplifyCodeLine(String line){
+		char[] cc = line.toCharArray();
+		int edi=0;
+		
+		for(int esi=0;esi<cc.length;esi++){
+			char c = cc[esi];
+			if(c==9)c = 32;
+			if(c==32 && edi!=0 && cc[edi-1]==32){
+				// skip multiple whitespace
+			}else{
+				cc[edi++] = c;
+			}
+		}
+		
+		return new String(cc,0,edi);
+	}
+	
+	
+	private List<IComparableCompletionProposal> matchSpecificPattern(HdlDocument doc,int documentOffset){
+		String line = getCurrentLineUpToOffset(doc.get(), documentOffset);
+		line = line.toLowerCase();
+		line = simplifyCodeLine(line);
+		String tline = line; // left-trimmed line. Can start with whitespace
+		List<IComparableCompletionProposal> matchList = new ArrayList<IComparableCompletionProposal>();
+		
+		if(tline.length()!=0 && tline.charAt(0)==32){
+			tline = tline.substring(1);
+		}
+		
+		if(tline.compareTo("use ")==0){
+			matchList.add(getSimpleProposal("ieee", documentOffset, 0));
+			matchList.add(getSimpleProposal("work", documentOffset, 0));
+		}else if(tline.compareTo("use ieee.")==0){
+			matchList.add(getSimpleProposal("std_logic_1164.all;", documentOffset, 0));
+			matchList.add(getSimpleProposal("numeric_std.all;", documentOffset, 0));
+			matchList.add(getSimpleProposal("std_logic_unsigned.all;", documentOffset, 0));
+		}
+		
+		
+		
+		if(matchList.size()!=0) return matchList;
+		return null;
+	}
+
+	public ICompletionProposal[] computeCompletionProposals(ITextViewer viewer,
+			int documentOffset) {
+		HdlDocument doc = (HdlDocument) viewer.getDocument();
+		String match = getMatchingWord(doc.get(), documentOffset);
+		List<IComparableCompletionProposal> matchList = null;
+		OutlineElement currentElement=null;
+		
+		doc.getFile();
+		int context =VhdlDocument.VHDL_GLOBAL_CONTEXT;
+		try {	
+			context = doc.getContext(documentOffset);
+			currentElement = doc.getElementAt(documentOffset,false);
+		} catch (BadLocationException e) {
+		} catch (HdlParserException e) {
+		}
+		
+		matchList = matchSpecificPattern(doc, documentOffset);
+		String matchwithdot = getMatchingWordWithdot(doc.get(), documentOffset);
+		
+		matchwithdot = matchwithdot+" ";//add space
+		String matchword[]=matchwithdot.split("[.]");
+		
+		if (matchList != null){
+		} else if(matchword.length==1) {
+			switch (context) {
+		 		case VhdlDocument.VHDL_GLOBAL_CONTEXT:
+		 			matchList = getGlobalPropsals(doc, documentOffset, match);
+		 			break;
+		 		default:
+		 			Display.getCurrent().beep(); return null;
+		 	}
+		 
+		 	matchList.addAll(getTemplates(viewer, documentOffset, context));
+			addSignalPropsals(doc, documentOffset, match, currentElement,matchList);
+			addSubprogramProposals(doc, documentOffset, match,currentElement, matchList);
+		} else {  
+			if(matchword.length==2 && matchword[0].equals("work")) { // packages auto completion
+				String match2 = matchword[1].trim();
+				OutlineDatabase database = doc.getOutlineDatabase();
+				OutlineElement[] elements = database.findTopLevelElements(match2);
+				
+				matchList = new ArrayList<IComparableCompletionProposal>();
+				
+				for (int i = 0; i < elements.length; i++) {
+					if(elements[i] instanceof PackageDeclElement){
+						matchList.add(new VhdlInstanceCompletionProposal(doc, elements[i], documentOffset, match2.length()));
+					}
+				}
+			} else { // record member auto completion
+				String recordname = null;
+				recordname = getSignalType(doc, documentOffset, matchword[0], currentElement);
+				for(int i=1;i<matchword.length-1;i++){
+					OutlineElement[] tempRecord=searchRecordDefinition(doc, documentOffset, recordname,currentElement).getChildren();
+					recordname=getMemberType(doc,documentOffset,matchword[i],tempRecord);
+				}
+				
+				TypeDecl finalRecord=(TypeDecl)searchRecordDefinition(doc, documentOffset, recordname,currentElement);
+				
+				
+				matchList = new ArrayList<IComparableCompletionProposal>();
+				
+				if (finalRecord != null) {
+					OutlineElement[] memberElements = finalRecord.getChildren();
+					String matchlc1 = matchword[matchword.length-1];
+					String matchlc=matchlc1.trim().toLowerCase();   
+					for (int h = 0; h < memberElements.length; h++) {
+						String recordmember = memberElements[h].getName().toLowerCase();
+						if (recordmember.startsWith(matchlc)) {
+							 int cc=matchlc.length();
+							 String replace = memberElements[h].getName();
+							
+							 matchList.add(new VhdlRecordCompletionProposal(replace, documentOffset, cc, replace.length(), replace));
+						}
+					}
+				}
+			}
+		}
+
+		Collections.sort(matchList);
+		ICompletionProposal[] result = new ICompletionProposal[matchList.size()];
+		for (int i = 0; i < matchList.size(); i++) {
+			result[i] = (ICompletionProposal) matchList.get(i);
+		}
+		return result;
+	}
+	
+
+
+	// returns typename of member
+	private String getMemberType(HdlDocument doc, int documentOffset,
+			String membername, OutlineElement[] record) {
+
+		String typeName = null;
+		OutlineElement[] children = record;
+		for (int i = 0; i < children.length; i++) {
+			if (children[i].getName().equalsIgnoreCase(membername)) {
+				if (!(children[i] instanceof VhdlOutlineElement))
+					continue;
+				typeName = ((VhdlOutlineElement) children[i]).getTypePart1();
+			}
+		}
+		return typeName;
+	}
+
+
+
+
+	/**
+	 * Returns a list of global proposals based on the given replace string
+	 * @param doc Document where the proposal should be made
+	 * @param offset offset of the proposal in the document 
+	 * @param replace replacement string
+	 * @return List of proposals matching the given string
+	 */
+	public List<IComparableCompletionProposal> getGlobalPropsals(HdlDocument doc,
+			int offset, String replace) {
+		
+		OutlineDatabase database = doc.getOutlineDatabase();
+		List<IComparableCompletionProposal> matchList = new ArrayList<IComparableCompletionProposal>();
+		int length = replace.length();
+		
+		if (database != null) {
+			OutlineElement[] elements = database.findTopLevelElements(replace);
+			for (int i = 0; i < elements.length; i++) {
+				if(VhdlInstanceCompletionProposal.canHandle(elements[i])) {
+					matchList.add(new VhdlInstanceCompletionProposal(doc,
+							elements[i], offset, length));				
+				}
+			}
+			//look into packages
+			elements = database.findTopLevelElements("");
+			for (int i = 0; i < elements.length; i++) {
+				if(elements[i] instanceof PackageDeclElement){
+					OutlineElement[] subPackageElements=elements[i].getChildren();
+					for(int j=0; j< subPackageElements.length; j++){
+						if(VhdlInstanceCompletionProposal.canHandle(subPackageElements[j]) &&
+								subPackageElements[j].getName().toLowerCase().startsWith(replace.toLowerCase())){
+							matchList.add(new VhdlInstanceCompletionProposal(doc,
+									subPackageElements[j], offset, length));
+						}
+					}
+				}
+			}
+			
+			for (int i = 0; i < elements.length; i++) {
+				if(elements[i] instanceof EntityDeclElement || elements[i] instanceof ComponentDeclElement) {
+					String name = elements[i].getName();
+					if(name.startsWith("tb_")) continue;
+					if(isMatch(replace, "tb_"+name)) {
+						matchList.add(createTestBench(doc,(VhdlOutlineElement)elements[i],offset,length));
+					}
+				}
+			}
+			
+			outer : for (int i = 0; i < elements.length; i++) {
+				if(elements[i] instanceof EntityDeclElement) {
+					IComparableCompletionProposal prop = createComponentDecl(doc,(VhdlOutlineElement)elements[i],offset,length);
+					// Avoid duplicate proposals
+					for (IComparableCompletionProposal m : matchList) {
+						if (prop.getDisplayString().equals(m.getDisplayString())) {
+							continue outer;
+						}
+					}
+					String name = elements[i].getName();
+					if(isMatch(replace,name)){
+						matchList.add(prop);
+					}
+				}
+			}
+		}
+
+		return matchList;
+	}
+	
+	private IComparableCompletionProposal createComponentDecl(HdlDocument doc,
+			VhdlOutlineElement mod, int offset, int length) {
+		String modname = mod.toString();
+		String results = String.format(
+				"\tcomponent %s\n${generics}${ports}\tend component;\n",
+				modname);
+
+		OutlineElement[] ports = mod.getChildren();
+
+		boolean first = true;
+		String genericStr = "\t\tgeneric (";
+		for (int i = 0; i < ports.length; i++) {
+			if (!(ports[i] instanceof GenericElement))
+				continue;
+			String port = ports[i].getName();
+			String type = ports[i].getType(); // = port#in#std_logic
+			String[] typesplit = type.split("#");
+			if (typesplit.length != 2)
+				continue;
+			if (typesplit[0].compareToIgnoreCase("generic") != 0)
+				continue;
+			String nl = ";\n\t\t\t";
+			if (first) {
+				nl = "\n\t\t\t";
+				first = false;
+			}
+			genericStr += nl + port + " : " + typesplit[1];
+		}
+		genericStr += "\n\t\t);\n";
+		if (first) {
+			genericStr = "";
+		}
+
+		first = true;
+		String portStr = "\t\tport (";
+		for (int i = 0; i < ports.length; i++) {
+			if (!(ports[i] instanceof VhdlPortElement))
+				continue;
+			String port = ports[i].getName();
+			String type = ports[i].getType(); // = port#in#std_logic
+			String[] typesplit = type.split("#");
+			if (typesplit.length != 3)
+				continue;
+			if (typesplit[0].compareToIgnoreCase("port") != 0)
+				continue;
+			String nl = ";\n\t\t\t";
+			if (first) {
+				nl = "\n\t\t\t";
+				first = false;
+			}
+			portStr += nl + port + " : " + typesplit[1] + " " + typesplit[2];
+		}
+		portStr += "\n\t\t);\n";
+		if (first) {
+			portStr = "";
+		}
+
+		results = results.replace("${generics}", genericStr);
+		results = results.replace("${ports}", portStr);
+
+		String indentationstring = VerilogPlugin.getIndentationString();
+		results = results.replace("\t", indentationstring);
+
+		return getCompletionProposal(results, offset, length, results.length(),
+				modname + " (cmp decl) ");
+	}
+
+	public OutlineElement searchRecordDefinition(HdlDocument doc,
+			int offset, String recordname, OutlineElement  element) {
+		
+		// first search in this file:
+		VhdlOutlineElement parent=null;
+		if (element instanceof VhdlOutlineElement) {
+			parent = (VhdlOutlineElement) element;
+		}
+		//work your way up
+		while(parent != null){
+			OutlineElement[] children =parent.getChildren();
+		
+			for(int i=0;i < children.length;i++){
+				if (children[i] instanceof TypeDecl && children[i].getName()
+						.equalsIgnoreCase(recordname)) {
+					return children[i];
+				}
+			}
+			if (parent.getParent() instanceof VhdlOutlineElement) {
+				parent = (VhdlOutlineElement) parent.getParent();
+			} else {
+				parent=null;
+			}
+		}
+		
+		// not found in this file, search it in packages of other files
+		OutlineDatabase database = doc.getOutlineDatabase();
+		
+		if (database != null) {
+			OutlineElement[] elements = database.findTopLevelElements("");
+			for (int i = 0; i < elements.length; i++) {
+				if(elements[i] instanceof PackageDeclElement ){
+					OutlineElement[] subPackageElements=elements[i].getChildren();
+					for(int j=0; j< subPackageElements.length; j++){
+						if (subPackageElements[j] instanceof TypeDecl
+								&& subPackageElements[j].getName()
+										.equalsIgnoreCase(recordname)) {
+							return subPackageElements[j];
+
+						}
+					}
+				}
+			
+			}
+		}
+
+		return null;
+	}
+
+	private IComparableCompletionProposal createTestBench(HdlDocument doc, VhdlOutlineElement mod, int offset, int length) {
+	  String results=
+	          "library ieee;\n"
+	        + "use ieee.std_logic_1164.all;\n"
+	        + "use ieee.std_logic_arith.all;\n"
+	        + "library std;\n"
+	        + "use std.textio.all;\n"   
+	        + "library work;\n"
+	        + "use work.${module}.PCK.all;\n\n"
+	        + "entity ${testbench} is\n"
+	        + "end ${testbench};\n\n"
+	        + "architecture behav of ${testbench} is\n"
+	        + "-------------------------------\n"
+	        + "-- Test bench for ${module}\n"
+	        + "-------------------------------\n"
+	        + "architecture Test of ${testbench} is\n"
+	        + "    ${signals}\n"
+	        + "    begin\n"
+	        + "    uut:\n" 
+	        + "        ${mod_def}\n"
+	        +  "end architecture Test;\n";
+
+	  //attempt to get new test bench template
+      Template[] templates = VerilogPlugin.getPlugin().getTemplateStore().getTemplates(VhdlGlobalContext.CONTEXT_TYPE);
+        for(Template template: templates){
+            if(TEST_BENCH_TEMPLATE_NAME.equals(template.getName())){
+                results=template.getPattern();
+                break;
+            }
+        }
+       String modname = mod.toString(); 
+       String test_bench="tb_"+modname;
+       OutlineElement[] ports = mod.getChildren();
+       String signals="";
+       for (int i = 0; i < ports.length; i++)
+       {
+           if (!(ports[i] instanceof GenericElement)) continue;
+           String port = ports[i].getName();
+           String type = ports[i].getType(); // = port#in#std_logic            
+           String[] typesplit = type.split("#");
+           if(typesplit.length!=2) continue;
+           if(typesplit[0].compareToIgnoreCase("generic")!=0) continue;
+           signals = signals + ( "\tconstant " + port + " : " + typesplit[1] + " := ;\n" );
+       }       
+       
+       for (int i = 0; i < ports.length; i++)
+       {
+           if (!(ports[i] instanceof VhdlPortElement)) continue;
+           String port = ports[i].getName();
+           String type = ports[i].getType(); // = port#in#std_logic            
+           String[] typesplit = type.split("#");
+           if(typesplit.length!=3) continue;
+           if(typesplit[0].compareToIgnoreCase("port")!=0) continue;
+           signals = signals + ( "\tsignal " + port + " : " + typesplit[2] + ";\n" );
+       }
+       
+       VhdlInstanceCompletionProposal prop = new VhdlInstanceCompletionProposal(doc, mod, offset, length);
+       String module_def = prop.getReplaceString();
+       module_def = module_def.replace("\n", "\n\t"); 
+
+		String indentationstring = VerilogPlugin.getIndentationString();
+		results=results.replace("${testbench}", test_bench);
+		results=results.replace("${signals}", signals);
+		results=results.replace("${module}", modname);
+		results=results.replace("${mod_def}", module_def);
+		results=results.replace("${user}", System.getProperty("user.name"));
+		results=results.replace("${year}", Integer.toString(Calendar.getInstance().get(Calendar.YEAR)));
+		String month = Integer.toString(Calendar.getInstance().get(Calendar.MONTH)+1);
+		if(month.length()<2) month = "0"+month;
+		String day = Integer.toString(Calendar.getInstance().get(Calendar.DAY_OF_MONTH));
+		if(day.length()<2) day = "0"+day;
+		results=results.replace("${month}", month);
+		results=results.replace("${day}", day);
+
+       results = results.replace("\t", indentationstring);
+       
+       return getCompletionProposal(results, offset, length, results.length() , test_bench+" (auto gen testbench) ");
+	}
+
+	
+	private void addEnityIntface(HdlDocument doc,String entityName, int offset, int length,
+			String replace,IFile file, List<IComparableCompletionProposal> matchList){
+		
+		//if no entity was found, bail
+		if (entityName == null){
+			return;
+		}
+		OutlineDatabase database = doc.getOutlineDatabase();
+		OutlineContainer outline = database.getOutlineContainer(file);
+		Object[] children= outline.getTopLevelElements();
+		
+		for (int i=0;i<children.length;i++){
+			if (children[i] instanceof EntityDeclElement) {
+				EntityDeclElement entityDecl = (EntityDeclElement) children[i];			
+				//if we find an entity declaration, add the ports and generics
+				if (entityDecl.getName().equalsIgnoreCase(entityName)) {				
+					//get the entity's children
+					OutlineElement[] enitityChildren=entityDecl.getChildren();
+					for(int entChildIdx=0;entChildIdx<enitityChildren.length;entChildIdx++){
+						if(	enitityChildren[entChildIdx].getName().toUpperCase().startsWith(replace.toUpperCase())){
+							matchList.add(new 
+									VhdlInstanceCompletionProposal(doc,
+											enitityChildren[entChildIdx],
+											offset, 
+											length));
+						}
+					}				
+				}
+			}
+		}
+	}
+	
+	/**
+	 * Adds a list of subprogram calls to the proposal list
+	 * @param doc
+	 * @param offset
+	 * @param replace
+	 * @param element
+	 * @param matchList
+	 */
+	private void addSubprogramProposals(HdlDocument doc,int offset, String replace, OutlineElement  element,
+			List<IComparableCompletionProposal> matchList){
+		VhdlOutlineElement parent=null;
+		int length = replace.length();
+		
+						
+		if (element instanceof VhdlOutlineElement) {
+			parent = (VhdlOutlineElement) element;
+			
+		}
+		//work your way up
+		while(parent != null){
+			OutlineElement[] children =parent.getChildren();
+		
+			for(int i=0;i < children.length;i++){
+				if (children[i] instanceof VhdlSubprogram) {
+					VhdlSubprogram subProgram = (VhdlSubprogram) children[i];
+					
+					if(subProgram.getName().toLowerCase().startsWith(replace.toLowerCase())){
+						VhdlSubprogramProposalProvider proposalProvider=
+							new VhdlSubprogramProposalProvider(doc,subProgram,offset,length);
+						HdlTemplateProposal proposal=proposalProvider.createProposal();
+						matchList.add(proposal);
+					}
+				}				
+			}
+			if (parent.getParent() instanceof VhdlOutlineElement) {
+				parent = (VhdlOutlineElement) parent.getParent();
+				
+			}
+			else{
+				parent=null;
+			}
+		}	
+		//look into packages
+		OutlineDatabase database = doc.getOutlineDatabase();
+		
+		if (database != null) {
+			OutlineElement[] elements = database.findTopLevelElements("");
+			for (int i = 0; i < elements.length; i++) {
+				if(elements[i] instanceof PackageDeclElement){
+					OutlineElement[] subPackageElements=elements[i].getChildren();
+					for(int j=0; j< subPackageElements.length; j++){
+						if(subPackageElements[j] instanceof VhdlSubprogram) {
+							if(subPackageElements[j].getName().toLowerCase().startsWith(replace.toLowerCase())){
+								VhdlSubprogramProposalProvider proposalProvider=
+									new VhdlSubprogramProposalProvider(doc,(VhdlSubprogram)subPackageElements[j],offset,length);
+								HdlTemplateProposal proposal=proposalProvider.createProposal();
+								matchList.add(proposal);
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+
+	
+	// returns typename of the signal.
+	
+	private String getSignalType(HdlDocument doc,int offset, String signalname, OutlineElement  element){
+		VhdlOutlineElement parent=null;
+		
+		String architectureEntityName=null;
+		
+		if (element instanceof VhdlOutlineElement) {
+			parent = (VhdlOutlineElement) element;
+			
+			while (parent != null) {
+				OutlineElement[] children = parent.getChildren();	
+				//if we encounter an architecture, remember its entity
+				if (parent instanceof ArchitectureElement){
+					architectureEntityName=((ArchitectureElement)parent).GetEntityName();
+				}
+				for (int i = 0; i < children.length; i++) {
+					if (children[i].getName().equalsIgnoreCase(signalname)) {
+						if (! (children[i] instanceof VhdlOutlineElement)) continue;
+						return ((VhdlOutlineElement)children[i]).getTypePart1();
+					}
+				}
+				if (parent.getParent() instanceof VhdlOutlineElement) {
+					parent = (VhdlOutlineElement) parent.getParent();
+				} else {
+					parent = null;
+				}
+			}
+		}
+		
+		// now search in the port of the entity of this architecture:
+		if(architectureEntityName!=null){
+			OutlineDatabase database = doc.getOutlineDatabase();
+			OutlineContainer outline = database.getOutlineContainer(doc.getFile());
+			OutlineElement[] children= outline.getTopLevelElements();
+			
+			for (OutlineElement child:children){
+				if (! (child instanceof EntityDeclElement)) continue;
+				EntityDeclElement entityDecl = (EntityDeclElement) child;			
+				//if we find an entity declaration, search ports for signalname
+				if (!entityDecl.getName().equalsIgnoreCase(architectureEntityName)) continue;			
+				//get the entity's children
+				OutlineElement[] entityChildren=entityDecl.getChildren();
+				for(OutlineElement entitychild:entityChildren) {
+					if(!entitychild.getName().equalsIgnoreCase(signalname)) continue;
+					if(!(entitychild instanceof VhdlOutlineElement)) continue;				
+					return ((VhdlOutlineElement)entitychild).getTypePart2();
+				}
+			}
+		}		
+		
+		return "";
+	}
+	
+	/**
+	 * Adds a list of variables to the completion proposal;
+	 * @param doc
+	 * @param offset
+	 * @param replace
+	 * @param element
+	 * @param matchList
+	 */
+	private void addSignalPropsals(HdlDocument doc,int offset, String replace, OutlineElement  element,
+			List<IComparableCompletionProposal> matchList){
+		VhdlOutlineElement parent=null;
+		String architectureEntityName=null;
+		int length = replace.length();
+		
+		if (element instanceof VhdlOutlineElement) {
+			parent = (VhdlOutlineElement) element;
+			
+		}
+		//work your way up
+		while(parent != null){
+			OutlineElement[] children =parent.getChildren();
+			
+			//if we encounter an architecture, remember its entity
+			if (parent instanceof ArchitectureElement){
+				architectureEntityName=((ArchitectureElement)parent).GetEntityName();
+			}
+			
+			for(int i=0;i < children.length;i++){
+				if (VhdlInstanceCompletionProposal.canHandle(children[i])) {
+					if(children[i].getName().toLowerCase().startsWith(replace.toLowerCase())){
+						matchList.add(new VhdlInstanceCompletionProposal(doc,children[i], offset, length));
+					}
+				}
+			}
+			if (parent.getParent() instanceof VhdlOutlineElement) {
+				parent = (VhdlOutlineElement) parent.getParent();
+				
+			}
+			else{
+				parent=null;
+			}
+		}
+		if(architectureEntityName!=null){
+			//add the entity interfaces
+			addEnityIntface(doc,architectureEntityName,offset,length, replace, element.getFile(),matchList);
+		}
+		
+	}
+	/**
+	 * Returns the relevance scale of the template given the prefix. 
+	 * This value is used to sort the suggestions made during template completion 
+	 * 
+	 * @param template the template
+	 * @param prefix the prefix
+	 * @return the relevance of the <code>template</code> for the given <code>prefix</code>
+	 */
+	protected int getRelevance(Template template, String prefix) {
+		//for now, all are equal
+		return 0;
+	}
+
+	/**
+	 * This function should return a context string for the given context.
+	 * This value will be used to lookup the templates in the TemplateStore
+	 * @param context
+	 * @return Context string used to lookup the templates in the TemplateStore
+	 */
+	protected String getTemplateContextString(int context) {
+		final String results;
+		switch (context) {
+		case IParser.OUT_OF_MODULE:
+			results = VhdlGlobalContext.CONTEXT_TYPE;
+			break;
+		default:
+			results = VhdlGlobalContext.CONTEXT_TYPE;
+			break;
+		}
+		return results;
+	}
+	
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/editor/VhdlEditor.java vdt/src/com/elphel/vdt/veditor/editor/VhdlEditor.java
--- vdt-veditor/src/com/elphel/vdt/veditor/editor/VhdlEditor.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/editor/VhdlEditor.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,110 +1,117 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.editor;
-
-import net.sourceforge.veditor.document.VhdlDocumentProvider;
-import net.sourceforge.veditor.editor.scanner.HdlPartitionScanner;
-
-import org.eclipse.jface.text.DocumentCommand;
-import org.eclipse.jface.text.IAutoEditStrategy;
-import org.eclipse.jface.text.IDocument;
-import org.eclipse.jface.text.ITextViewerExtension2;
-import org.eclipse.jface.text.TextUtilities;
-import org.eclipse.jface.text.source.DefaultCharacterPairMatcher;
-import org.eclipse.jface.text.source.ISourceViewerExtension2;
-import org.eclipse.jface.text.source.MatchingCharacterPainter;
-import org.eclipse.jface.text.source.SourceViewer;
-import org.eclipse.swt.graphics.Color;
-import org.eclipse.swt.graphics.RGB;
-import org.eclipse.swt.widgets.Composite;
-import org.eclipse.swt.widgets.Display;
-
-
-
-public class VhdlEditor extends HdlEditor
-{
-	static final String REPLACE_COMMENT="-- ";
-	/** The editor's peer Parent Matcher */
-	  private DefaultCharacterPairMatcher fParentMatcher;
-	  private Color colorMatchingChar;
-	  
-	  /** The editor's peer character painter */
-	  private MatchingCharacterPainter fMatchingCharacterPainter;
-	  
-	public VhdlEditor()
-	{
-		super();
-		char[] chars = new char[] {'(', ')'};
-		fParentMatcher = new DefaultCharacterPairMatcher(chars);
-		setDocumentProvider(new VhdlDocumentProvider());
-		setSourceViewerConfiguration(HdlSourceViewerConfiguration
-				.createForVhdl(this));
-		OutlineLabelProvider = new VhdlOutlineLabelProvider();
-		TreeContentProvider  = new VhdlHierarchyProvider();
-	}
-	
-	public void createPartControl(Composite parent)
-	{
-	    super.createPartControl(parent);
-	    
-	    showMatchingCharacters();
-	    
-	    if (getViewer() instanceof SourceViewer) {
-			SourceViewer viewer = (SourceViewer) getViewer();
-	
-			viewer.prependAutoEditStrategy(new CommentExtender(), HdlPartitionScanner.SINGLE_LINE_COMMENT);
-		}	    
-	}
-	
-	
-	/**
-	 * Class used to extend comments
-	 *
-	 */
-	private class CommentExtender implements IAutoEditStrategy{
-
-		public void customizeDocumentCommand(IDocument document,
-				DocumentCommand command) {
-			if(command.text.startsWith("\n") || command.text.startsWith("\r")){
-				command.text= TextUtilities.getDefaultLineDelimiter(document) + 
-				getLineIndent(command.offset)+
-				REPLACE_COMMENT;
-			}
-			
-		}
-		
-	}
-	  /**
-	   * Add a Painter to show matching characters.
-	   */
-	  private final void showMatchingCharacters() {
-	    if (fMatchingCharacterPainter == null) {
-	      if (getSourceViewer() instanceof ISourceViewerExtension2) {
-	        fMatchingCharacterPainter = new MatchingCharacterPainter(
-	            getSourceViewer(), fParentMatcher);
-	        Display display = Display.getCurrent();
-	        //IPreferenceStore store = Activator.getDefault().getPreferenceStore();
-	        //colorMatchingChar = new Color(display, PreferenceConverter.getColor(
-	        //    store, JJPreferences.P_MATCHING_CHAR));
-	        colorMatchingChar = new Color(display,new RGB(128,128,128));
-	        fMatchingCharacterPainter.setColor(colorMatchingChar);
-	        ITextViewerExtension2 extension = (ITextViewerExtension2) getSourceViewer();
-	        extension.addPainter(fMatchingCharacterPainter);
-	      }
-	    }
-	  }
-	  
-
-		
-	
-	  
-
-}
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.editor;
+
+import com.elphel.vdt.veditor.document.VhdlDocumentProvider;
+import com.elphel.vdt.veditor.editor.scanner.HdlPartitionScanner;
+
+import org.eclipse.jface.text.DocumentCommand;
+import org.eclipse.jface.text.IAutoEditStrategy;
+import org.eclipse.jface.text.IDocument;
+import org.eclipse.jface.text.ITextViewerExtension2;
+import org.eclipse.jface.text.TextUtilities;
+import org.eclipse.jface.text.source.DefaultCharacterPairMatcher;
+import org.eclipse.jface.text.source.ISourceViewerExtension2;
+import org.eclipse.jface.text.source.MatchingCharacterPainter;
+import org.eclipse.jface.text.source.SourceViewer;
+import org.eclipse.swt.graphics.Color;
+import org.eclipse.swt.graphics.RGB;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Display;
+
+
+
+public class VhdlEditor extends HdlEditor
+{
+	static final String REPLACE_COMMENT="-- ";
+	/** The editor's peer Parent Matcher */
+	  private DefaultCharacterPairMatcher fParentMatcher;
+	  private Color colorMatchingChar;
+	  
+	  /** The editor's peer character painter */
+	  private MatchingCharacterPainter fMatchingCharacterPainter;
+	  
+	public VhdlEditor()
+	{
+		super();
+		char[] chars = new char[] {'(', ')'};
+		fParentMatcher = new DefaultCharacterPairMatcher(chars);
+		setDocumentProvider(new VhdlDocumentProvider());
+		setSourceViewerConfiguration(HdlSourceViewerConfiguration
+				.createForVhdl(this));
+		OutlineLabelProvider = new VhdlOutlineLabelProvider();
+		TreeContentProvider  = new VhdlHierarchyProvider();
+	}
+	
+	public void createPartControl(Composite parent)
+	{
+	    super.createPartControl(parent);
+	    
+	    showMatchingCharacters();
+	    
+	    if (getViewer() instanceof SourceViewer) {
+			SourceViewer viewer = (SourceViewer) getViewer();
+	
+			viewer.prependAutoEditStrategy(new CommentExtender(), HdlPartitionScanner.SINGLE_LINE_COMMENT);
+		}	    
+	}
+	
+	
+	/**
+	 * Class used to extend comments
+	 *
+	 */
+	private class CommentExtender implements IAutoEditStrategy{
+
+		public void customizeDocumentCommand(IDocument document,
+				DocumentCommand command) {
+			if(command.text.startsWith("\n") || command.text.startsWith("\r")){
+				command.text= TextUtilities.getDefaultLineDelimiter(document) + 
+				getLineIndent(command.offset)+
+				REPLACE_COMMENT;
+			}
+			
+		}
+		
+	}
+	  /**
+	   * Add a Painter to show matching characters.
+	   */
+	  private final void showMatchingCharacters() {
+	    if (fMatchingCharacterPainter == null) {
+	      if (getSourceViewer() instanceof ISourceViewerExtension2) {
+	        fMatchingCharacterPainter = new MatchingCharacterPainter(
+	            getSourceViewer(), fParentMatcher);
+	        Display display = Display.getCurrent();
+	        //IPreferenceStore store = Activator.getDefault().getPreferenceStore();
+	        //colorMatchingChar = new Color(display, PreferenceConverter.getColor(
+	        //    store, JJPreferences.P_MATCHING_CHAR));
+	        colorMatchingChar = new Color(display,new RGB(128,128,128));
+	        fMatchingCharacterPainter.setColor(colorMatchingChar);
+	        ITextViewerExtension2 extension = (ITextViewerExtension2) getSourceViewer();
+	        extension.addPainter(fMatchingCharacterPainter);
+	      }
+	    }
+	  }
+	  
+
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/editor/VhdlHierarchyProvider.java vdt/src/com/elphel/vdt/veditor/editor/VhdlHierarchyProvider.java
--- vdt-veditor/src/com/elphel/vdt/veditor/editor/VhdlHierarchyProvider.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/editor/VhdlHierarchyProvider.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,309 +1,320 @@
-/*******************************************************************************
- * Copyright (c) 2007 Ali Ghorashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    Ali Ghorashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.editor;
-
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.Set;
-import java.util.Vector;
-
-import net.sourceforge.veditor.VerilogPlugin;
-import net.sourceforge.veditor.document.HdlDocument;
-import net.sourceforge.veditor.parser.HdlParserException;
-import net.sourceforge.veditor.parser.OutlineDatabase;
-import net.sourceforge.veditor.parser.OutlineElement;
-import net.sourceforge.veditor.parser.vhdl.VhdlOutlineElementFactory.ArchitectureElement;
-import net.sourceforge.veditor.parser.vhdl.VhdlOutlineElementFactory.ComponentInstElement;
-import net.sourceforge.veditor.parser.vhdl.VhdlOutlineElementFactory.EntityDeclElement;
-import net.sourceforge.veditor.parser.vhdl.VhdlOutlineElementFactory.EntityInstElement;
-import net.sourceforge.veditor.parser.vhdl.VhdlOutlineElementFactory.VhdlOutlineElement;
-
-import org.eclipse.core.runtime.CoreException;
-import org.eclipse.jface.viewers.ITreeContentProvider;
-
-public class VhdlHierarchyProvider extends HdlTreeProviderBase implements
-		ITreeContentProvider {
-	
-	private Vector<VhdlOutlineElement> m_TopLevelEntities;
-	private HashMap<String,Vector<ArchitectureElement>> m_EntityArchList;
-	private HashMap<String,EntityDeclElement> m_ElementDeclList;
-	
-	public VhdlHierarchyProvider(){
-		m_TopLevelEntities	= new Vector<VhdlOutlineElement>();
-		m_EntityArchList    = new HashMap<String,Vector<ArchitectureElement>>();
-		m_ElementDeclList   = new HashMap<String,EntityDeclElement>();
-	}
-
-	/**
-	 * Called to get a list of child elements
-	 */
-	public Object[] getChildren(Object parentElement) {
-		//top level entity
-		if (parentElement instanceof EntityDeclElement)
-		{
-			EntityDeclElement e = (EntityDeclElement)parentElement;
-			//list of architectures
-			return (Object[])m_EntityArchList.get(e.getName().toUpperCase()).toArray();
-		}
-		//architecture
-		else if (parentElement instanceof ArchitectureElement) {
-			ArchitectureElement arch = (ArchitectureElement) parentElement;
-			Vector<VhdlOutlineElement> childInstantiations=new Vector<VhdlOutlineElement>();
-			OutlineElement[] children= arch.getChildren();
-			//return all the instantiations
-			for(int i=0; i< children.length;i++){
-				if (children[i] instanceof EntityInstElement) {
-					//do not add recursive children
-					EntityInstElement e = (EntityInstElement)children[i];
-					if(e.GetEntityName().toUpperCase().equals(arch.GetEntityName().toUpperCase())==false){
-						childInstantiations.add(e);
-					}
-				}
-				if (children[i] instanceof ComponentInstElement) {
-					//do not add recursive children
-					ComponentInstElement comp = (ComponentInstElement)children[i];
-					if(comp.GetEntityName().toUpperCase().equals(arch.GetEntityName().toUpperCase())==false){
-						childInstantiations.add(comp);
-					}					
-				}
-			}
-			return (Object[]) childInstantiations.toArray();
-		}
-		//child instantiation
-		else if (parentElement instanceof EntityInstElement) {
-			EntityInstElement entityInst = (EntityInstElement) parentElement;
-			String entityName= entityInst.GetEntityName().toUpperCase();
-			//list of architectures for this entity
-			return (Object[])m_EntityArchList.get(entityName).toArray();
-		}
-		else if (parentElement instanceof ComponentInstElement) {
-			ComponentInstElement compInst = (ComponentInstElement) parentElement;
-			String componentName= compInst.GetEntityName().toUpperCase();
-			//list of architectures for this entity
-			return (Object[])m_EntityArchList.get(componentName).toArray();
-		}
-		
-		return null;
-	}
-	
-	public ArchitectureElement getArchElement(String entityname) {
-		//VerilogPlugin.println("Searching for element: "+entityname);
-		String entitynameUp = entityname.toUpperCase();
-		Vector<ArchitectureElement> elements = m_EntityArchList.get(entitynameUp);
-		if(elements==null) return null;
-		if(elements.size()==0) return null;
-		return elements.get(0);
-	}
-	
-	/**
-	 * Called to get the parent for an object
-	 */
-	public Object getParent(Object element)
-	{
-		//top level entity
-		if (element instanceof EntityDeclElement)
-		{			
-			//root entities have no parents (how sad :)
-			return null;						
-		}
-		//architecture
-		else if (element instanceof ArchitectureElement) {			
-			return null;			
-		}
-		//child instantiation
-		else if (element instanceof EntityInstElement) {			
-			//list of architectures for this entity
-			return null;
-		}
-		
-		return null;
-	}
-	/**
-	 * Called to see if an object has children
-	 */
-	public boolean hasChildren(Object element)
-	{
-		//top level entity
-		if (element instanceof EntityDeclElement)
-		{
-			EntityDeclElement e = (EntityDeclElement)element;
-			Vector<ArchitectureElement> archList=m_EntityArchList.get(e.getName().toUpperCase());
-			//list of architectures
-			return (archList.size() != 0);
-		}
-		//architecture
-		else if (element instanceof ArchitectureElement) {
-			ArchitectureElement arch = (ArchitectureElement) element;			
-			OutlineElement[] children= arch.getChildren();			
-			//return all the instantiations
-			for(int i=0; i< children.length;i++){
-				if (children[i] instanceof EntityInstElement) {
-					EntityInstElement entityInst = (EntityInstElement)children[i];
-					//if we hit one instantiation, we've got children
-					//beware of recursive definitions
-					if(entityInst.GetEntityName().toUpperCase().equals(arch.GetEntityName().toUpperCase()) == false){
-						return true;
-					}
-				}
-				if (children[i] instanceof ComponentInstElement) {
-					ComponentInstElement componentInst = (ComponentInstElement)children[i];
-					//if we hit one instantiation, we've got children
-					//beware of recursive definitions
-					if(componentInst.GetEntityName().toUpperCase().equals(arch.GetEntityName().toUpperCase()) == false){
-						return true;
-					}					
-				}
-			}
-			return false;
-		}
-		//child instantiation
-		else if (element instanceof EntityInstElement) {
-			EntityInstElement entityInst = (EntityInstElement) element;
-			String entityName= entityInst.GetEntityName().toUpperCase();
-			//list of architectures for this entity
-			Vector<ArchitectureElement> archList=m_EntityArchList.get(entityName);
-			if(archList==null){
-				return false;
-			}
-			return (archList.size() != 0);
-		}
-		else if (element instanceof ComponentInstElement) {
-			ComponentInstElement compInst = (ComponentInstElement) element;
-			String componentName= compInst.GetEntityName().toUpperCase();
-			//list of architectures for this entity
-			Vector<ArchitectureElement> archList=m_EntityArchList.get(componentName);
-			if(archList==null){
-				return false;
-			}
-			return (archList.size() != 0);
-		}
-		
-		return false;
-	}
-	/**
-	 * called to get a list of elements for an object
-	 */
-	public Object[] getElements(Object inputElement)
-	{
-		// parse source code and get instance list
-		HdlDocument doc = (HdlDocument)inputElement;
-		try {
-			doc.refreshOutline();
-			scanOutline(doc);
-			return (Object[])m_TopLevelEntities.toArray();	
-		} catch (HdlParserException e) {			
-		}
-		return new Object[0];
-	}
-
-	
-	/**
-	 * Scans the outline and builds a hierarchy tree
-	 * @param doc Document used to start deriving the hierarchy
-	 * @return true if the scan is successful, false otherwise
-	 */
-	public boolean scanOutline(HdlDocument doc){
-		OutlineDatabase database;				
-		Vector<ArchitectureElement> archList;
-		OutlineElement[] topLevelElements;
-		Set<String> entityNameList;
-		Vector<String> topLevelEntities=new Vector<String>();
-		String entityName;
-		
-		
-		m_TopLevelEntities.clear();
-		m_EntityArchList.clear();
-		m_ElementDeclList.clear();
-		try {
-			database = (OutlineDatabase)
-				doc.getProject().getSessionProperty(VerilogPlugin.getOutlineDatabaseId());
-		} catch (CoreException e) {
-			e.printStackTrace();
-			return false;
-		}
-		////////////////////////////////////////////
-		//scan for architectures		
-		topLevelElements = database.findTopLevelElements("");
-		for (int i=0;i<topLevelElements.length;i++){
-			//architectures
-			if (topLevelElements[i] instanceof ArchitectureElement) {
-				ArchitectureElement arch = (ArchitectureElement) topLevelElements[i];
-				String archEntityName=arch.GetEntityName().toUpperCase();
-				//if the entity name exists, get its list otherwise create a list
-				if(m_EntityArchList.containsKey(archEntityName)){					
-					archList=m_EntityArchList.get(archEntityName);
-				}
-				else{
-					//new entity
-					archList=new Vector<ArchitectureElement>();
-					m_EntityArchList.put(archEntityName, archList);
-				}
-				//add the found architecture to the list of known architectures
-				archList.add(arch);
-			}
-			//entity declarations
-			if (topLevelElements[i] instanceof EntityDeclElement) {
-				EntityDeclElement entityDecl = (EntityDeclElement) topLevelElements[i];
-				m_ElementDeclList.put(entityDecl.getName().toUpperCase(), entityDecl);
-				if(!m_EntityArchList.containsKey(entityDecl.getName().toUpperCase())){					
-					//new entity
-					archList=new Vector<ArchitectureElement>();
-					m_EntityArchList.put(entityDecl.getName().toUpperCase(), archList);
-				}
-			}
-		}
-		/////////////////////////////////////////////
-		//Find top level entities
-		entityNameList = m_EntityArchList.keySet();
-		//start by assuming everything is a top level entity
-		topLevelEntities.addAll(entityNameList);
-		Iterator<String> it=entityNameList.iterator(); 
-		while(it.hasNext()){
-			entityName=it.next();
-			archList=m_EntityArchList.get(entityName);
-			//go through all the architectures
-			for(int i=0; i<archList.size();i++){
-				OutlineElement[] childElements=archList.get(i).getChildren();
-				//go through all the instances
-				for(int j=0;j< childElements.length; j++){
-					if (childElements[j] instanceof EntityInstElement) {
-						EntityInstElement entityInst = (EntityInstElement) childElements[j];
-						String nameParts[] = entityInst.GetEntityName().toUpperCase().split("\\.");
-						String n= 
-							nameParts.length==0 ? entityInst.GetEntityName() : nameParts[nameParts.length-1];
-						//remove the name from the top level
-						topLevelEntities.remove(n.toUpperCase());
-					}
-					if (childElements[j] instanceof ComponentInstElement) {
-						ComponentInstElement compInst = (ComponentInstElement) childElements[j];
-						String nameParts[] = compInst.GetEntityName().toUpperCase().split("\\.");
-						String n= 
-							nameParts.length==0 ? compInst.GetEntityName() : nameParts[nameParts.length-1];
-						//remove the name from the top level
-						topLevelEntities.remove(n.toUpperCase());
-					}
-				}
-			}
-		}
-		//////////////////////////////////////////
-		//Start building the hierarchy		
-		for (int i=0;i<topLevelElements.length;i++){
-			if (topLevelElements[i] instanceof EntityDeclElement) {
-				EntityDeclElement entityDecl = (EntityDeclElement) topLevelElements[i];
-				//if this is a top level element, add it to the root
-				if(topLevelEntities.contains(entityDecl.getName().toUpperCase())){
-					m_TopLevelEntities.add(entityDecl);
-				}
-			}
-		}
-		return true;
-	}
-}
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2007 Ali Ghorashi and others.
+ *
+ * Contributors:
+ *    Ali Ghorashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.editor;
+
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Set;
+import java.util.Vector;
+
+import com.elphel.vdt.veditor.VerilogPlugin;
+import com.elphel.vdt.veditor.document.HdlDocument;
+import com.elphel.vdt.veditor.parser.HdlParserException;
+import com.elphel.vdt.veditor.parser.OutlineDatabase;
+import com.elphel.vdt.veditor.parser.OutlineElement;
+import com.elphel.vdt.veditor.parser.vhdl.VhdlOutlineElementFactory.ArchitectureElement;
+import com.elphel.vdt.veditor.parser.vhdl.VhdlOutlineElementFactory.ComponentInstElement;
+import com.elphel.vdt.veditor.parser.vhdl.VhdlOutlineElementFactory.EntityDeclElement;
+import com.elphel.vdt.veditor.parser.vhdl.VhdlOutlineElementFactory.EntityInstElement;
+import com.elphel.vdt.veditor.parser.vhdl.VhdlOutlineElementFactory.VhdlOutlineElement;
+
+import org.eclipse.core.runtime.CoreException;
+import org.eclipse.jface.viewers.ITreeContentProvider;
+
+public class VhdlHierarchyProvider extends HdlTreeProviderBase implements
+		ITreeContentProvider {
+	
+	private Vector<VhdlOutlineElement> m_TopLevelEntities;
+	private HashMap<String,Vector<ArchitectureElement>> m_EntityArchList;
+	private HashMap<String,EntityDeclElement> m_ElementDeclList;
+	
+	public VhdlHierarchyProvider(){
+		m_TopLevelEntities	= new Vector<VhdlOutlineElement>();
+		m_EntityArchList    = new HashMap<String,Vector<ArchitectureElement>>();
+		m_ElementDeclList   = new HashMap<String,EntityDeclElement>();
+	}
+
+	/**
+	 * Called to get a list of child elements
+	 */
+	public Object[] getChildren(Object parentElement) {
+		//top level entity
+		if (parentElement instanceof EntityDeclElement)
+		{
+			EntityDeclElement e = (EntityDeclElement)parentElement;
+			//list of architectures
+			return (Object[])m_EntityArchList.get(e.getName().toUpperCase()).toArray();
+		}
+		//architecture
+		else if (parentElement instanceof ArchitectureElement) {
+			ArchitectureElement arch = (ArchitectureElement) parentElement;
+			Vector<VhdlOutlineElement> childInstantiations=new Vector<VhdlOutlineElement>();
+			OutlineElement[] children= arch.getChildren();
+			//return all the instantiations
+			for(int i=0; i< children.length;i++){
+				if (children[i] instanceof EntityInstElement) {
+					//do not add recursive children
+					EntityInstElement e = (EntityInstElement)children[i];
+					if(e.GetEntityName().toUpperCase().equals(arch.GetEntityName().toUpperCase())==false){
+						childInstantiations.add(e);
+					}
+				}
+				if (children[i] instanceof ComponentInstElement) {
+					//do not add recursive children
+					ComponentInstElement comp = (ComponentInstElement)children[i];
+					if(comp.GetEntityName().toUpperCase().equals(arch.GetEntityName().toUpperCase())==false){
+						childInstantiations.add(comp);
+					}					
+				}
+			}
+			return (Object[]) childInstantiations.toArray();
+		}
+		//child instantiation
+		else if (parentElement instanceof EntityInstElement) {
+			EntityInstElement entityInst = (EntityInstElement) parentElement;
+			String entityName= entityInst.GetEntityName().toUpperCase();
+			//list of architectures for this entity
+			return (Object[])m_EntityArchList.get(entityName).toArray();
+		}
+		else if (parentElement instanceof ComponentInstElement) {
+			ComponentInstElement compInst = (ComponentInstElement) parentElement;
+			String componentName= compInst.GetEntityName().toUpperCase();
+			//list of architectures for this entity
+			return (Object[])m_EntityArchList.get(componentName).toArray();
+		}
+		
+		return null;
+	}
+	
+	public ArchitectureElement getArchElement(String entityname) {
+		//VerilogPlugin.println("Searching for element: "+entityname);
+		String entitynameUp = entityname.toUpperCase();
+		Vector<ArchitectureElement> elements = m_EntityArchList.get(entitynameUp);
+		if(elements==null) return null;
+		if(elements.size()==0) return null;
+		return elements.get(0);
+	}
+	
+	/**
+	 * Called to get the parent for an object
+	 */
+	public Object getParent(Object element)
+	{
+		//top level entity
+		if (element instanceof EntityDeclElement)
+		{			
+			//root entities have no parents (how sad :)
+			return null;						
+		}
+		//architecture
+		else if (element instanceof ArchitectureElement) {			
+			return null;			
+		}
+		//child instantiation
+		else if (element instanceof EntityInstElement) {			
+			//list of architectures for this entity
+			return null;
+		}
+		
+		return null;
+	}
+	/**
+	 * Called to see if an object has children
+	 */
+	public boolean hasChildren(Object element)
+	{
+		//top level entity
+		if (element instanceof EntityDeclElement)
+		{
+			EntityDeclElement e = (EntityDeclElement)element;
+			Vector<ArchitectureElement> archList=m_EntityArchList.get(e.getName().toUpperCase());
+			//list of architectures
+			return (archList.size() != 0);
+		}
+		//architecture
+		else if (element instanceof ArchitectureElement) {
+			ArchitectureElement arch = (ArchitectureElement) element;			
+			OutlineElement[] children= arch.getChildren();			
+			//return all the instantiations
+			for(int i=0; i< children.length;i++){
+				if (children[i] instanceof EntityInstElement) {
+					EntityInstElement entityInst = (EntityInstElement)children[i];
+					//if we hit one instantiation, we've got children
+					//beware of recursive definitions
+					if(entityInst.GetEntityName().toUpperCase().equals(arch.GetEntityName().toUpperCase()) == false){
+						return true;
+					}
+				}
+				if (children[i] instanceof ComponentInstElement) {
+					ComponentInstElement componentInst = (ComponentInstElement)children[i];
+					//if we hit one instantiation, we've got children
+					//beware of recursive definitions
+					if(componentInst.GetEntityName().toUpperCase().equals(arch.GetEntityName().toUpperCase()) == false){
+						return true;
+					}					
+				}
+			}
+			return false;
+		}
+		//child instantiation
+		else if (element instanceof EntityInstElement) {
+			EntityInstElement entityInst = (EntityInstElement) element;
+			String entityName= entityInst.GetEntityName().toUpperCase();
+			//list of architectures for this entity
+			Vector<ArchitectureElement> archList=m_EntityArchList.get(entityName);
+			if(archList==null){
+				return false;
+			}
+			return (archList.size() != 0);
+		}
+		else if (element instanceof ComponentInstElement) {
+			ComponentInstElement compInst = (ComponentInstElement) element;
+			String componentName= compInst.GetEntityName().toUpperCase();
+			//list of architectures for this entity
+			Vector<ArchitectureElement> archList=m_EntityArchList.get(componentName);
+			if(archList==null){
+				return false;
+			}
+			return (archList.size() != 0);
+		}
+		
+		return false;
+	}
+	/**
+	 * called to get a list of elements for an object
+	 */
+	public Object[] getElements(Object inputElement)
+	{
+		// parse source code and get instance list
+		HdlDocument doc = (HdlDocument)inputElement;
+		try {
+			doc.refreshOutline();
+			scanOutline(doc);
+			return (Object[])m_TopLevelEntities.toArray();	
+		} catch (HdlParserException e) {			
+		}
+		return new Object[0];
+	}
+
+	
+	/**
+	 * Scans the outline and builds a hierarchy tree
+	 * @param doc Document used to start deriving the hierarchy
+	 * @return true if the scan is successful, false otherwise
+	 */
+	public boolean scanOutline(HdlDocument doc){
+		OutlineDatabase database;				
+		Vector<ArchitectureElement> archList;
+		OutlineElement[] topLevelElements;
+		Set<String> entityNameList;
+		Vector<String> topLevelEntities=new Vector<String>();
+		String entityName;
+		
+		
+		m_TopLevelEntities.clear();
+		m_EntityArchList.clear();
+		m_ElementDeclList.clear();
+		try {
+			database = (OutlineDatabase)
+				doc.getProject().getSessionProperty(VerilogPlugin.getOutlineDatabaseId());
+		} catch (CoreException e) {
+			e.printStackTrace();
+			return false;
+		}
+		////////////////////////////////////////////
+		//scan for architectures		
+		topLevelElements = database.findTopLevelElements("");
+		for (int i=0;i<topLevelElements.length;i++){
+			//architectures
+			if (topLevelElements[i] instanceof ArchitectureElement) {
+				ArchitectureElement arch = (ArchitectureElement) topLevelElements[i];
+				String archEntityName=arch.GetEntityName().toUpperCase();
+				//if the entity name exists, get its list otherwise create a list
+				if(m_EntityArchList.containsKey(archEntityName)){					
+					archList=m_EntityArchList.get(archEntityName);
+				}
+				else{
+					//new entity
+					archList=new Vector<ArchitectureElement>();
+					m_EntityArchList.put(archEntityName, archList);
+				}
+				//add the found architecture to the list of known architectures
+				archList.add(arch);
+			}
+			//entity declarations
+			if (topLevelElements[i] instanceof EntityDeclElement) {
+				EntityDeclElement entityDecl = (EntityDeclElement) topLevelElements[i];
+				m_ElementDeclList.put(entityDecl.getName().toUpperCase(), entityDecl);
+				if(!m_EntityArchList.containsKey(entityDecl.getName().toUpperCase())){					
+					//new entity
+					archList=new Vector<ArchitectureElement>();
+					m_EntityArchList.put(entityDecl.getName().toUpperCase(), archList);
+				}
+			}
+		}
+		/////////////////////////////////////////////
+		//Find top level entities
+		entityNameList = m_EntityArchList.keySet();
+		//start by assuming everything is a top level entity
+		topLevelEntities.addAll(entityNameList);
+		Iterator<String> it=entityNameList.iterator(); 
+		while(it.hasNext()){
+			entityName=it.next();
+			archList=m_EntityArchList.get(entityName);
+			//go through all the architectures
+			for(int i=0; i<archList.size();i++){
+				OutlineElement[] childElements=archList.get(i).getChildren();
+				//go through all the instances
+				for(int j=0;j< childElements.length; j++){
+					if (childElements[j] instanceof EntityInstElement) {
+						EntityInstElement entityInst = (EntityInstElement) childElements[j];
+						String nameParts[] = entityInst.GetEntityName().toUpperCase().split("\\.");
+						String n= 
+							nameParts.length==0 ? entityInst.GetEntityName() : nameParts[nameParts.length-1];
+						//remove the name from the top level
+						topLevelEntities.remove(n.toUpperCase());
+					}
+					if (childElements[j] instanceof ComponentInstElement) {
+						ComponentInstElement compInst = (ComponentInstElement) childElements[j];
+						String nameParts[] = compInst.GetEntityName().toUpperCase().split("\\.");
+						String n= 
+							nameParts.length==0 ? compInst.GetEntityName() : nameParts[nameParts.length-1];
+						//remove the name from the top level
+						topLevelEntities.remove(n.toUpperCase());
+					}
+				}
+			}
+		}
+		//////////////////////////////////////////
+		//Start building the hierarchy		
+		for (int i=0;i<topLevelElements.length;i++){
+			if (topLevelElements[i] instanceof EntityDeclElement) {
+				EntityDeclElement entityDecl = (EntityDeclElement) topLevelElements[i];
+				//if this is a top level element, add it to the root
+				if(topLevelEntities.contains(entityDecl.getName().toUpperCase())){
+					m_TopLevelEntities.add(entityDecl);
+				}
+			}
+		}
+		return true;
+	}
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/editor/VhdlOutlineLabelProvider.java vdt/src/com/elphel/vdt/veditor/editor/VhdlOutlineLabelProvider.java
--- vdt-veditor/src/com/elphel/vdt/veditor/editor/VhdlOutlineLabelProvider.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/editor/VhdlOutlineLabelProvider.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,48 +1,59 @@
-/*******************************************************************************
- * Copyright (c) 2007 Ali Ghorashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    Ali Ghorashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.editor;
-
-import net.sourceforge.veditor.parser.OutlineElement;
-import net.sourceforge.veditor.parser.vhdl.VhdlOutlineElementFactory.VhdlOutlineElement;
-
-public class VhdlOutlineLabelProvider extends HdlLabelProvider {
-	protected static final String OBJ_IMAGE= "$nl$/icons/obj.gif";	
-	/**
-	 * Converts a name to a string using the type string
-	 * @param name element's name
-	 * @param Type element's type
-	 * @return
-	 */
-	protected String convertToString(OutlineElement element){
-		if (element instanceof VhdlOutlineElement) {
-			VhdlOutlineElement vhdlElement = (VhdlOutlineElement) element;
-			return vhdlElement.getShortName();
-		}
-		//if not a vhdl element, something must be very wrong
-		return "??";			
-	}
-	
-	
-	/**
-	 * Returns an image name to be used for the given type
-	 * @param type Type string
-	 * @return Image name to be used for this tye
-	 */
-	protected String getImageNameForType(OutlineElement element){
-		if (element instanceof VhdlOutlineElement) {
-			VhdlOutlineElement vhdlElement = (VhdlOutlineElement) element;
-			return vhdlElement.GetImageName();
-		}
-		//if not a vhdl element, something must be very wrong
-		return OBJ_IMAGE;
-	}
-
-}
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2007 Ali Ghorashi and others.
+ *
+ * Contributors:
+ *    Ali Ghorashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.editor;
+
+import com.elphel.vdt.veditor.parser.OutlineElement;
+import com.elphel.vdt.veditor.parser.vhdl.VhdlOutlineElementFactory.VhdlOutlineElement;
+
+public class VhdlOutlineLabelProvider extends HdlLabelProvider {
+	protected static final String OBJ_IMAGE= "$nl$/icons/obj.gif";	
+	/**
+	 * Converts a name to a string using the type string
+	 * @param name element's name
+	 * @param Type element's type
+	 * @return
+	 */
+	protected String convertToString(OutlineElement element){
+		if (element instanceof VhdlOutlineElement) {
+			VhdlOutlineElement vhdlElement = (VhdlOutlineElement) element;
+			return vhdlElement.getShortName();
+		}
+		//if not a vhdl element, something must be very wrong
+		return "??";			
+	}
+	
+	
+	/**
+	 * Returns an image name to be used for the given type
+	 * @param type Type string
+	 * @return Image name to be used for this tye
+	 */
+	protected String getImageNameForType(OutlineElement element){
+		if (element instanceof VhdlOutlineElement) {
+			VhdlOutlineElement vhdlElement = (VhdlOutlineElement) element;
+			return vhdlElement.GetImageName();
+		}
+		//if not a vhdl element, something must be very wrong
+		return OBJ_IMAGE;
+	}
+
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/HdlNature.java vdt/src/com/elphel/vdt/veditor/HdlNature.java
--- vdt-veditor/src/com/elphel/vdt/veditor/HdlNature.java	2016-06-24 10:29:40.848495740 -0600
+++ vdt/src/com/elphel/vdt/veditor/HdlNature.java	2016-06-24 10:29:40.816496628 -0600
@@ -1,178 +1,189 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-
-package net.sourceforge.veditor;
-
-import java.util.ArrayList;
-import java.util.Map;
-
-import net.sourceforge.veditor.builder.BuildConfig;
-import net.sourceforge.veditor.builder.SimulateBuilder;
-
-import org.eclipse.core.resources.ICommand;
-import org.eclipse.core.resources.IProject;
-import org.eclipse.core.resources.IProjectDescription;
-import org.eclipse.core.resources.IProjectNature;
-import org.eclipse.core.runtime.CoreException;
-
-public class HdlNature implements IProjectNature
-{
-	public static final String NATURE_ID = "net.sourceforge.veditor.HdlNature";
-	public static final String SIMULATOR_ID = SimulateBuilder.BUILDER_ID;
-
-	private IProject project;
-	
-	public HdlNature()
-	{
-		super();
-	}
-	
-	
-	/**
-	 * This function checks see if a builder already exists. 
-	 * If one is not found, then one is created and added
-	 * with default parameters
-	 * @throws CoreException
-	 */
-	private void checkAndAddBuilder() throws CoreException{
-		ArrayList<ICommand> commandList=new ArrayList<ICommand>();
-		ICommand hdlCommand=null;
-
-		IProjectDescription description;
-		description = getProject().getDescription();
-		for(ICommand command: description.getBuildSpec()){
-			//try to find an existing builder in the list of builders
-			if(command.getBuilderName().startsWith(SIMULATOR_ID)){
-				hdlCommand=command;
-			}
-			commandList.add(command);
-		}				
-		//if no hdl command was found
-		if(hdlCommand==null){
-			//make a new one
-			hdlCommand = description.newCommand();
-			hdlCommand.setBuilderName(SIMULATOR_ID);
-			//add it to the list of builders
-			commandList.add(hdlCommand);
-			//set the arguments 
-			Map<String,String> args=BuildConfig.encodeArgs(new BuildConfig[]{new BuildConfig()});
-			hdlCommand.setArguments(args);
-			//set the builders
-			description.setBuildSpec(commandList.toArray(new ICommand[0]));
-			getProject().setDescription(description, null);
-		}		
-		
-	}
-		
-	/**
-	 * Adds an instance of our builder with default values
-	 */
-	public void configure() throws CoreException
-	{
-		checkAndAddBuilder();
-	}
-	
-	/**
-	 * Removes our builder form the builders list
-	 */
-	public void deconfigure() throws CoreException
-	{
-		ArrayList<ICommand> commandList=new ArrayList<ICommand>();
-
-		IProjectDescription description;
-		description = getProject().getDescription();
-		for(ICommand command: description.getBuildSpec()){
-			//try to find an existing builder in the list of builders
-			if(command.getBuilderName().startsWith(SIMULATOR_ID)){
-				//skip this one
-				continue;
-			}
-			commandList.add(command);
-		}				
-		//set the builders
-		description.setBuildSpec(commandList.toArray(new ICommand[0]));
-		getProject().setDescription(description, null);
-	}
-	
-	/**
-	 * Gets a list of builder commands and their arguments for this project
-	 * @return
-	 */
-	@SuppressWarnings("unchecked")
-	public Map<String,BuildConfig> getCommands(){
-		Map<String,BuildConfig> buildConfigList=null;
-		try
-		{
-			IProjectDescription description;
-			description = getProject().getDescription();
-			for(ICommand command: description.getBuildSpec()){
-				if(command.getBuilderName().equals(SIMULATOR_ID)){					
-					buildConfigList=BuildConfig.parseCommandArguments(command.getArguments());
-					break;
-				}
-			}			
-		}
-		catch (CoreException e)
-		{
-		}		
-		return buildConfigList;
-	}
-	
-	/**
-	 * Sets the commands based on the given arguments
-	 */
-	public void setCommands(BuildConfig[] buildConfig){
-		ArrayList<ICommand> buildConfigList=new ArrayList<ICommand>();
-		ICommand hdlCommand=null;
-		
-		try
-		{
-			IProjectDescription description;
-			description = getProject().getDescription();
-			
-			//
-			// If the user blew away the builder we may need to add it back in
-			checkAndAddBuilder();
-						
-			for(ICommand command: description.getBuildSpec()){
-				//try to find an existing builder in the list of builders
-				if(command.getBuilderName().startsWith(SIMULATOR_ID)){
-					hdlCommand=command;
-				}
-				buildConfigList.add(command);
-			}				
-						
-			if(hdlCommand!=null){
-				//set the arguments 
-				Map<String,String> args=BuildConfig.encodeArgs(buildConfig);
-				hdlCommand.setArguments(args);
-			}				
-			//set the builders
-			description.setBuildSpec(buildConfigList.toArray(new ICommand[0]));
-			getProject().setDescription(description, null);
-		}
-		catch (CoreException e)
-		{
-		}	
-	}
-	
-
-	public IProject getProject()
-	{
-		return project;
-	}
-
-	public void setProject(IProject project)
-	{
-		this.project = project;
-	}
-	
-}
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+
+package com.elphel.vdt.veditor;
+
+import java.util.ArrayList;
+import java.util.Map;
+
+import com.elphel.vdt.veditor.builder.BuildConfig;
+import com.elphel.vdt.veditor.builder.SimulateBuilder;
+
+import org.eclipse.core.resources.ICommand;
+import org.eclipse.core.resources.IProject;
+import org.eclipse.core.resources.IProjectDescription;
+import org.eclipse.core.resources.IProjectNature;
+import org.eclipse.core.runtime.CoreException;
+
+public class HdlNature implements IProjectNature
+{
+	public static final String NATURE_ID = "com.elphel.vdt.veditor.HdlNature";
+	public static final String SIMULATOR_ID = SimulateBuilder.BUILDER_ID;
+
+	private IProject project;
+	
+	public HdlNature()
+	{
+		super();
+	}
+	
+	
+	/**
+	 * This function checks see if a builder already exists. 
+	 * If one is not found, then one is created and added
+	 * with default parameters
+	 * @throws CoreException
+	 */
+	private void checkAndAddBuilder() throws CoreException{
+		ArrayList<ICommand> commandList=new ArrayList<ICommand>();
+		ICommand hdlCommand=null;
+
+		IProjectDescription description;
+		description = getProject().getDescription();
+		for(ICommand command: description.getBuildSpec()){
+			//try to find an existing builder in the list of builders
+			if(command.getBuilderName().startsWith(SIMULATOR_ID)){
+				hdlCommand=command;
+			}
+			commandList.add(command);
+		}				
+		//if no hdl command was found
+		if(hdlCommand==null){
+			//make a new one
+			hdlCommand = description.newCommand();
+			hdlCommand.setBuilderName(SIMULATOR_ID);
+			//add it to the list of builders
+			commandList.add(hdlCommand);
+			//set the arguments 
+			Map<String,String> args=BuildConfig.encodeArgs(new BuildConfig[]{new BuildConfig()});
+			hdlCommand.setArguments(args);
+			//set the builders
+			description.setBuildSpec(commandList.toArray(new ICommand[0]));
+			getProject().setDescription(description, null);
+		}		
+		
+	}
+		
+	/**
+	 * Adds an instance of our builder with default values
+	 */
+	public void configure() throws CoreException
+	{
+		checkAndAddBuilder();
+	}
+	
+	/**
+	 * Removes our builder form the builders list
+	 */
+	public void deconfigure() throws CoreException
+	{
+		ArrayList<ICommand> commandList=new ArrayList<ICommand>();
+
+		IProjectDescription description;
+		description = getProject().getDescription();
+		for(ICommand command: description.getBuildSpec()){
+			//try to find an existing builder in the list of builders
+			if(command.getBuilderName().startsWith(SIMULATOR_ID)){
+				//skip this one
+				continue;
+			}
+			commandList.add(command);
+		}				
+		//set the builders
+		description.setBuildSpec(commandList.toArray(new ICommand[0]));
+		getProject().setDescription(description, null);
+	}
+	
+	/**
+	 * Gets a list of builder commands and their arguments for this project
+	 * @return
+	 */
+	@SuppressWarnings("unchecked")
+	public Map<String,BuildConfig> getCommands(){
+		Map<String,BuildConfig> buildConfigList=null;
+		try
+		{
+			IProjectDescription description;
+			description = getProject().getDescription();
+			for(ICommand command: description.getBuildSpec()){
+				if(command.getBuilderName().equals(SIMULATOR_ID)){					
+					buildConfigList=BuildConfig.parseCommandArguments(command.getArguments());
+					break;
+				}
+			}			
+		}
+		catch (CoreException e)
+		{
+		}		
+		return buildConfigList;
+	}
+	
+	/**
+	 * Sets the commands based on the given arguments
+	 */
+	public void setCommands(BuildConfig[] buildConfig){
+		ArrayList<ICommand> buildConfigList=new ArrayList<ICommand>();
+		ICommand hdlCommand=null;
+		
+		try
+		{
+			IProjectDescription description;
+			description = getProject().getDescription();
+			
+			//
+			// If the user blew away the builder we may need to add it back in
+			checkAndAddBuilder();
+						
+			for(ICommand command: description.getBuildSpec()){
+				//try to find an existing builder in the list of builders
+				if(command.getBuilderName().startsWith(SIMULATOR_ID)){
+					hdlCommand=command;
+				}
+				buildConfigList.add(command);
+			}				
+						
+			if(hdlCommand!=null){
+				//set the arguments 
+				Map<String,String> args=BuildConfig.encodeArgs(buildConfig);
+				hdlCommand.setArguments(args);
+			}				
+			//set the builders
+			description.setBuildSpec(buildConfigList.toArray(new ICommand[0]));
+			getProject().setDescription(description, null);
+		}
+		catch (CoreException e)
+		{
+		}	
+	}
+	
+
+	public IProject getProject()
+	{
+		return project;
+	}
+
+	public void setProject(IProject project)
+	{
+		this.project = project;
+	}
+	
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/log/LogDocumentProvider.java vdt/src/com/elphel/vdt/veditor/log/LogDocumentProvider.java
--- vdt-veditor/src/com/elphel/vdt/veditor/log/LogDocumentProvider.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/log/LogDocumentProvider.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,90 +1,101 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.log;
-
-import org.eclipse.core.resources.IContainer;
-import org.eclipse.core.resources.IFile;
-import org.eclipse.core.resources.IFolder;
-import org.eclipse.core.resources.IProject;
-import org.eclipse.core.runtime.CoreException;
-import org.eclipse.core.runtime.IProgressMonitor;
-import org.eclipse.jface.text.IDocument;
-import org.eclipse.ui.IFileEditorInput;
-import org.eclipse.ui.editors.text.FileDocumentProvider;
-
-public class LogDocumentProvider extends FileDocumentProvider
-{
-	protected IDocument createDocument(Object element) throws CoreException
-	{
-		IDocument document = super.createDocument(element);
-		
-		parseDocument(element);
-
-		return document;
-	}
-
-	protected void doSynchronize(Object element, IProgressMonitor monitor)
-			throws CoreException
-	{
-		super.doSynchronize(element, monitor);
-		parseDocument(element);
-	}
-
-	private void parseDocument(Object element) throws CoreException
-	{
-		IDocument document = super.createDocument(element);
-
-		if (document == null)
-			return;
-
-		if (element instanceof IFileEditorInput)
-		{
-			// find project
-			IFileEditorInput input = (IFileEditorInput) element;
-			IFile file = input.getFile();
-
-			IContainer folder = file.getParent();
-			IContainer project = folder;
-			while (project instanceof IFolder)
-			{
-				project = project.getParent();
-			}
-			if (project instanceof IProject)
-			{
-				parse((IProject)project, folder, document.get());
-			}
-		}
-	}
-
-	private void parse(IProject project, IContainer folder, String message)
-	{
-//      FIXME Do something sensible here
-//		HdlNature nature = new HdlNature(project);
-//		ICommand command = nature.getSimulateCommand();
-//		if (command == null)
-//			return;
-//		Map args = command.getArguments();
-//		Object parserName = args.get("parser");
-//		if (parserName == null)
-//			return;
-//
-//		VerilogPlugin.clearProblemMarker(project);
-//		ErrorParser parser;
-//		parser = ErrorParser.getParser(parserName.toString());
-//		if (parser != null)
-//			parser.parse(folder, message);
-	}
-}
-
-
-
-
-
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.log;
+
+import org.eclipse.core.resources.IContainer;
+import org.eclipse.core.resources.IFile;
+import org.eclipse.core.resources.IFolder;
+import org.eclipse.core.resources.IProject;
+import org.eclipse.core.runtime.CoreException;
+import org.eclipse.core.runtime.IProgressMonitor;
+import org.eclipse.jface.text.IDocument;
+import org.eclipse.ui.IFileEditorInput;
+import org.eclipse.ui.editors.text.FileDocumentProvider;
+
+public class LogDocumentProvider extends FileDocumentProvider
+{
+	protected IDocument createDocument(Object element) throws CoreException
+	{
+		IDocument document = super.createDocument(element);
+		
+		parseDocument(element);
+
+		return document;
+	}
+
+	protected void doSynchronize(Object element, IProgressMonitor monitor)
+			throws CoreException
+	{
+		super.doSynchronize(element, monitor);
+		parseDocument(element);
+	}
+
+	private void parseDocument(Object element) throws CoreException
+	{
+		IDocument document = super.createDocument(element);
+
+		if (document == null)
+			return;
+
+		if (element instanceof IFileEditorInput)
+		{
+			// find project
+			IFileEditorInput input = (IFileEditorInput) element;
+			IFile file = input.getFile();
+
+			IContainer folder = file.getParent();
+			IContainer project = folder;
+			while (project instanceof IFolder)
+			{
+				project = project.getParent();
+			}
+			if (project instanceof IProject)
+			{
+				parse((IProject)project, folder, document.get());
+			}
+		}
+	}
+
+	private void parse(IProject project, IContainer folder, String message)
+	{
+//      FIXME Do something sensible here
+//		HdlNature nature = new HdlNature(project);
+//		ICommand command = nature.getSimulateCommand();
+//		if (command == null)
+//			return;
+//		Map args = command.getArguments();
+//		Object parserName = args.get("parser");
+//		if (parserName == null)
+//			return;
+//
+//		VerilogPlugin.clearProblemMarker(project);
+//		ErrorParser parser;
+//		parser = ErrorParser.getParser(parserName.toString());
+//		if (parser != null)
+//			parser.parse(folder, message);
+	}
+}
+
+
+
+
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/log/LogEditor.java vdt/src/com/elphel/vdt/veditor/log/LogEditor.java
--- vdt-veditor/src/com/elphel/vdt/veditor/log/LogEditor.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/log/LogEditor.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,24 +1,35 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-
-package net.sourceforge.veditor.log;
-
-import org.eclipse.ui.editors.text.TextEditor;
-
-public class LogEditor extends TextEditor
-{
-	public LogEditor()
-	{
-		super();
-		setDocumentProvider(new LogDocumentProvider());
-		setSourceViewerConfiguration(new LogSourceViewerConfiguration());
-	}
-}
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+
+package com.elphel.vdt.veditor.log;
+
+import org.eclipse.ui.editors.text.TextEditor;
+
+public class LogEditor extends TextEditor
+{
+	public LogEditor()
+	{
+		super();
+		setDocumentProvider(new LogDocumentProvider());
+		setSourceViewerConfiguration(new LogSourceViewerConfiguration());
+	}
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/log/LogSourceViewerConfiguration.java vdt/src/com/elphel/vdt/veditor/log/LogSourceViewerConfiguration.java
--- vdt-veditor/src/com/elphel/vdt/veditor/log/LogSourceViewerConfiguration.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/log/LogSourceViewerConfiguration.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,19 +1,30 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-
-package net.sourceforge.veditor.log;
-
-import org.eclipse.jface.text.source.SourceViewerConfiguration;
-
-public class LogSourceViewerConfiguration extends SourceViewerConfiguration
-{
-	// TODO: implement getPresentationReconciler for partitioning
-}
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+
+package com.elphel.vdt.veditor.log;
+
+import org.eclipse.jface.text.source.SourceViewerConfiguration;
+
+public class LogSourceViewerConfiguration extends SourceViewerConfiguration
+{
+	// TODO: implement getPresentationReconciler for partitioning
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/HdlParserException.java vdt/src/com/elphel/vdt/veditor/parser/HdlParserException.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/HdlParserException.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/HdlParserException.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,101 +1,101 @@
-package net.sourceforge.veditor.parser;
-
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-public class HdlParserException extends Exception {
-	/** This should match (something) Number (something) number */
-	static private final String TOKEN_MGR_ERROR_PATTERN=".*line ([0-9]*).*column ([0-9]*).*";
-	private String m_Message;
-	private int m_StartLine;
-	private int m_Column;	
-	/**
-	 * 
-	 */
-	private static final long serialVersionUID = 1L;
-	
-	/**
-	 * Default constructor
-	 */
-	public HdlParserException(){
-		m_Message="";
-		m_StartLine=0;
-	}
-	
-	/**
-	 * Attempts to parse a token error message
-	 * @Note: I hope the token message format does not chage
-	 * @param msg The message to parse
-	 */
-	protected void parseTokenMessage(String msg){
-		//Do the easy part
-		m_Message=msg;
-		//get the line from the message
-		
-		Pattern pattern = Pattern.compile(TOKEN_MGR_ERROR_PATTERN);
-		Matcher m = pattern.matcher(msg);
-		if (m.matches() && m.groupCount()>1)
-		{
-			String[] segments=new String[] {m.group(1),m.group(2)};
-			m_StartLine=Integer.parseInt(segments[0]);
-			m_Column=Integer.parseInt(segments[1]);
-		}
-		else{
-			m_StartLine=0;
-			m_Column=0;
-		}
-	}
-	
-	public HdlParserException(int beginLine,int beginColumn, String message){
-		m_Message=message;
-		m_StartLine=beginLine;
-		m_Column=beginColumn;
-	}
-	/**
-	 * Generic exception converter
-	 * @param e
-	 */
-	public HdlParserException(Object e){
-		if (e instanceof net.sourceforge.veditor.parser.vhdl.ParseException){
-			net.sourceforge.veditor.parser.vhdl.ParseException parseException=
-				(net.sourceforge.veditor.parser.vhdl.ParseException)e;
-			m_Message=parseException.getMessage();
-			m_StartLine=parseException.currentToken.beginLine;
-			m_Column=parseException.currentToken.beginColumn;
-		}
-		else if (e instanceof net.sourceforge.veditor.parser.verilog.ParseException){
-			net.sourceforge.veditor.parser.verilog.ParseException parseException=
-				(net.sourceforge.veditor.parser.verilog.ParseException)e;
-			m_Message=parseException.getMessage();
-			m_StartLine=parseException.currentToken.beginLine;
-			m_Column=parseException.currentToken.beginColumn;
-		}
-		else if (e instanceof net.sourceforge.veditor.parser.verilog.TokenMgrError){
-			net.sourceforge.veditor.parser.verilog.TokenMgrError tokenMgrError=
-				(net.sourceforge.veditor.parser.verilog.TokenMgrError)e;
-			parseTokenMessage(tokenMgrError.toString());			
-		}
-		else if (e instanceof net.sourceforge.veditor.parser.vhdl.TokenMgrError){
-			net.sourceforge.veditor.parser.vhdl.TokenMgrError tokenMgrError=
-				(net.sourceforge.veditor.parser.vhdl.TokenMgrError)e;
-			parseTokenMessage(tokenMgrError.toString());			
-		}
-		else{
-			m_Message="";
-			m_StartLine=0;
-			m_Column=0;
-		}
-	}
-	
-	public String getMessage(){
-		return m_Message;
-	}
-	
-	public int getStartLine(){
-		return m_StartLine;
-	}
-	
-	public int getColumn(){
-		return m_Column;
-	}
-}
+package com.elphel.vdt.veditor.parser;
+
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class HdlParserException extends Exception {
+	/** This should match (something) Number (something) number */
+	static private final String TOKEN_MGR_ERROR_PATTERN=".*line ([0-9]*).*column ([0-9]*).*";
+	private String m_Message;
+	private int m_StartLine;
+	private int m_Column;	
+	/**
+	 * 
+	 */
+	private static final long serialVersionUID = 1L;
+	
+	/**
+	 * Default constructor
+	 */
+	public HdlParserException(){
+		m_Message="";
+		m_StartLine=0;
+	}
+	
+	/**
+	 * Attempts to parse a token error message
+	 * @Note: I hope the token message format does not chage
+	 * @param msg The message to parse
+	 */
+	protected void parseTokenMessage(String msg){
+		//Do the easy part
+		m_Message=msg;
+		//get the line from the message
+		
+		Pattern pattern = Pattern.compile(TOKEN_MGR_ERROR_PATTERN);
+		Matcher m = pattern.matcher(msg);
+		if (m.matches() && m.groupCount()>1)
+		{
+			String[] segments=new String[] {m.group(1),m.group(2)};
+			m_StartLine=Integer.parseInt(segments[0]);
+			m_Column=Integer.parseInt(segments[1]);
+		}
+		else{
+			m_StartLine=0;
+			m_Column=0;
+		}
+	}
+	
+	public HdlParserException(int beginLine,int beginColumn, String message){
+		m_Message=message;
+		m_StartLine=beginLine;
+		m_Column=beginColumn;
+	}
+	/**
+	 * Generic exception converter
+	 * @param e
+	 */
+	public HdlParserException(Object e){
+		if (e instanceof com.elphel.vdt.veditor.parser.vhdl.ParseException){
+			com.elphel.vdt.veditor.parser.vhdl.ParseException parseException=
+				(com.elphel.vdt.veditor.parser.vhdl.ParseException)e;
+			m_Message=parseException.getMessage();
+			m_StartLine=parseException.currentToken.beginLine;
+			m_Column=parseException.currentToken.beginColumn;
+		}
+		else if (e instanceof com.elphel.vdt.veditor.parser.verilog.ParseException){
+			com.elphel.vdt.veditor.parser.verilog.ParseException parseException=
+				(com.elphel.vdt.veditor.parser.verilog.ParseException)e;
+			m_Message=parseException.getMessage();
+			m_StartLine=parseException.currentToken.beginLine;
+			m_Column=parseException.currentToken.beginColumn;
+		}
+		else if (e instanceof com.elphel.vdt.veditor.parser.verilog.TokenMgrError){
+			com.elphel.vdt.veditor.parser.verilog.TokenMgrError tokenMgrError=
+				(com.elphel.vdt.veditor.parser.verilog.TokenMgrError)e;
+			parseTokenMessage(tokenMgrError.toString());			
+		}
+		else if (e instanceof com.elphel.vdt.veditor.parser.vhdl.TokenMgrError){
+			com.elphel.vdt.veditor.parser.vhdl.TokenMgrError tokenMgrError=
+				(com.elphel.vdt.veditor.parser.vhdl.TokenMgrError)e;
+			parseTokenMessage(tokenMgrError.toString());			
+		}
+		else{
+			m_Message="";
+			m_StartLine=0;
+			m_Column=0;
+		}
+	}
+	
+	public String getMessage(){
+		return m_Message;
+	}
+	
+	public int getStartLine(){
+		return m_StartLine;
+	}
+	
+	public int getColumn(){
+		return m_Column;
+	}
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/IParser.java vdt/src/com/elphel/vdt/veditor/parser/IParser.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/IParser.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/IParser.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,25 +1,37 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.parser;
-
-public interface IParser
-{
-	public static final int OUT_OF_MODULE = 0;
-	public static final int IN_MODULE = 1;
-	public static final int IN_STATEMENT = 2;
-	//These are tags used to set create tasks inside of comments. The first token is
-	//considered to have high priority. The rest are normal priorities
-	public static final String[] taskCommentTokens={"FIXME","TODO","FIXME:","TODO:"};
-
-	public void parse() throws HdlParserException;
-	public int getContext();
-}
-
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.parser;
+
+public interface IParser
+{
+	public static final int OUT_OF_MODULE = 0;
+	public static final int IN_MODULE = 1;
+	public static final int IN_STATEMENT = 2;
+	//These are tags used to set create tasks inside of comments. The first token is
+	//considered to have high priority. The rest are normal priorities
+	public static final String[] taskCommentTokens={"FIXME","TODO","FIXME:","TODO:"};
+
+	public void parse() throws HdlParserException;
+	public void parse(int pass) throws HdlParserException;
+	public int getContext();
+}
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/OutlineContainer.java vdt/src/com/elphel/vdt/veditor/parser/OutlineContainer.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/OutlineContainer.java	2016-06-24 10:29:40.852495628 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/OutlineContainer.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,312 +1,393 @@
-/*******************************************************************************
- * Copyright (c) 2006 Ali Ghorashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    Ali Ghorashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.parser;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-
-import org.eclipse.core.resources.IFile;
-
-/**
- * module database for each project
- */
-public class OutlineContainer
-{	
-	
-	class Comment {
-		public Comment(String s, Boolean o) {
-			m_comment = s;
-			m_onlycommentline = o;
-		}
-		public String m_comment;
-		public Boolean m_onlycommentline; // true when this line contains nothing else then comment		
-	}
-	
-	private static final int  MINIMUM_COLLAPSIBLE_SIZE=1;
-	ArrayList<Collapsible> m_Collapsibles;
-	HashMap<Integer,Comment > m_Comments; 
-		
-	
-	public OutlineContainer(){
-		m_Collapsibles=new ArrayList<Collapsible>();
-		m_Comments=new HashMap<Integer,Comment>();
-	}
-	
-	/**
-	* Class to include all the information about a file
-	*/
-	private  class FileInfo{
-		public OutlineElement CurrentElement;
-		public ArrayList<OutlineElement> ElementList;
-		/**
-		* constructor
-		*/
-		public FileInfo(){
-			ElementList=new ArrayList<OutlineElement>();
-			CurrentElement = null;
-		}
-	}
-	
-	/**
-	 * Class to encapsulate collapsible elements
-	 */
-	public class Collapsible extends Object{
-		public int startLine;
-		public int endLine;
-		public Collapsible(int start,int end){startLine=start;endLine=end;}
-		/* (non-Javadoc)
-		 * @see java.lang.Object#equals(java.lang.Object)
-		 */
-		public boolean equals(Object obj){
-			if (obj instanceof Collapsible) {
-				Collapsible collapsible = (Collapsible) obj;				
-				if (startLine == collapsible.startLine && endLine == collapsible.endLine){return true;}		
-			}
-			return false;
-		}
-		public int hashCode(){ return String.format("%d:%d", startLine,endLine).hashCode();}
-	}
-	
-	/** list of all the files we have seen */ 
-	private  FileInfo m_FileInfo = new FileInfo();
-	
-	/** gets the current element scope */
-	public OutlineElement GetCurrentElement(){		
-		return m_FileInfo.CurrentElement;
-	}
-	
-	/**
-	 * @return a list of elements at the file level
-	 */
-	public OutlineElement[] getTopLevelElements(){
-		return m_FileInfo.ElementList.toArray(new OutlineElement[0]);
-	}
-
-	/**
-	 * Find a top level element with the given name.
-	 * @param name Element name
-	 * @return found element or null if not found.
-	 */
-	public OutlineElement findTopLevelElement(String name) {
-		for (OutlineElement element : m_FileInfo.ElementList) {
-			if (element.getName().equals(name)) {
-				return element;
-			}
-		}
-		return null;
-	}
-	
-	/**
-	* returns true if the given element has any children
-	*/
-	public boolean HasChildren(OutlineElement element){
-		return element.HasChildren();
-	}
-	/**
-	*inserts an element into the element list
-	*/
-	private  void InsertElement(OutlineElement element,FileInfo fileInfo){
-		if (fileInfo.CurrentElement != null){
-			fileInfo.CurrentElement.AddChild(element);
-		}
-		else{
-			fileInfo.ElementList.add(element);
-		}		
-		fileInfo.CurrentElement = element;			
-	}
-	
-	/**
-	 * Removes all the outline elements. This function is should
-	 * be called before re-parsing a file to avoid duplicate 
-	 * entries
-	 */
-	public void clear(){
-		m_FileInfo.CurrentElement = null;
-		m_FileInfo.ElementList.clear();
-		m_Collapsibles.clear();
-		m_Comments.clear();
-	}
-	/**
-	* This function is called to mark the beginning of an
-	* element
-	* @param elementName name of the element
-	  @param type type of the element
-	  @param line ending line
-	  @param filename filename in which the element lives
-	  @return newly created element
-	*/
-	public OutlineElement beginElement(String elementName,
-				String type,
-				int line, 
-				int col,
-				IFile file,
-				OutlineElementFactory elementFactory){
-				
-		OutlineElement element = 
-			elementFactory.CreateElement(elementName,type,line,col,java.lang.Integer.MAX_VALUE,java.lang.Integer.MAX_VALUE,file);
-		//put the element into the element list
-		InsertElement(element,m_FileInfo);
-		return element;
-	}
-	
-	/**
-	 * This function is called to mark the ending of an element	
-	 * @param elementName name of the element
-	 * @param type type of the element
-	 * @param line ending line
-	 * @param filename filename in which the element lives
-	 * @return true if successful, false otherwise
-	 */
-	public  boolean endElement(String elementName, String type,int line,int col, IFile file){		
-		if (m_FileInfo.CurrentElement == null){
-			//huh?? encountered the end of an element without seeing the beginning
-			return false;
-		}
-		else{
-			//sanity check
-			if (!m_FileInfo.CurrentElement.getName().equals(elementName) ||
-				!m_FileInfo.CurrentElement.getFile().equals(file)) {
-				//something terribly wrong
-				return false;
-			}
-			else{
-				m_FileInfo.CurrentElement.setEndingLine(line);
-				m_FileInfo.CurrentElement.setEndingCol(col);
-				m_FileInfo.CurrentElement = m_FileInfo.CurrentElement.getParent();
-			}					
-		}			
-		return true;
-	}
-	
-	/**
-	 * Adds the position to the list of collapsible positions
-	 * @param position
-	 */
-	public void addCollapsibleRegion(Collapsible collapsible){
-		if(collapsible.endLine - collapsible.startLine > MINIMUM_COLLAPSIBLE_SIZE){
-			m_Collapsibles.add(collapsible);
-		}
-	}
-	
-	/**
-	 * 
-	 * @return A list of collapsible regions
-	 */
-	public Collapsible[] getCollapsibleRegions(){
-		return m_Collapsibles.toArray(new Collapsible[0]);
-	}
-	
-	/**
-	 * Adds a string to the comments list
-	 * @param endLine Ending line of the comment
-	 * @param text The comment text
-	 */
-	public void addComment(int endLine,String text, Boolean onlycomment){
-		m_Comments.put(endLine,new Comment(text,onlycomment));
-	}
-	
-	/**
-	 * Gets the comments near the given element. These comments will 
-	 * presumably be associated with the element
-	 * @param element the element to look around
-	 * @return Comment string
-	 */
-	public String getCommentsNear(OutlineElement element){
-		int startLine=element.getStartingLine();
-		//look on the same line
-		if(m_Comments.containsKey(startLine)){
-			return m_Comments.get(startLine).m_comment;
-		}
-		// look on previous lines:
-		String comment = "";
-		for(int line = startLine-1;;line--) {
-			if(!m_Comments.containsKey(line)) break;
-			if(!m_Comments.get(line).m_onlycommentline) break;
-			comment = m_Comments.get(line).m_comment+"\n"+comment;
-		}	
-		return comment;
-	}
-	
-	
-	/**
-	 * Decides whether the give line and column is inside the element
-	 * @param e
-	 * @param line
-	 * @param col
-	 * @return
-	 */
-	private boolean isPositionInsideElement(OutlineElement e,int line,int col){
-		//easy case
-		if(line > e.getStartingLine() && line < e.getEndingLine()){
-			return true;
-		}
-		//special case
-		//if the line and beginning line of the element are on the same line
-		if(line == e.getStartingLine() && col > e.getStartingCol()){
-			//then the starting column must be after the element's column
-		}
-		else{
-			return false;
-		}
-		//if the end line is the same as the elements end line
-		if(line == e.getEndingCol() && col < e.getEndingCol()){
-			//then the column must be before the element's end column
-			return true;
-		}
-		
-		return false;
-	}
-	/**
-	 * Recursively scans through the element and its children to find the
-	 * deepest element surrounding the given line and column
-	 * @param element
-	 * @param line
-	 * @param col
-	 * @return The deepest element surrounding the line. null if no element 
-	 * surrounds the given line
-	 */
-	private OutlineElement getContext(OutlineElement element,int line,int col){
-		OutlineElement results=null;
-		if(isPositionInsideElement(element, line, col)){
-			//is the line enclosed in one of the children
-			for(OutlineElement child:element.getChildren()){
-				results=getContext(child,line,col);
-				if(results!=null){
-					return results;
-				}
-			}
-			//if not in children, then this element is the parent
-			return element;
-		}
-		//this element does not enclose the line
-		return null;
-	}
-	/**
-	 * This function returns the context of the given line and column
-	 * @param line the line number for the context
-	 * @param col the column number for the context
-	 * @return OutlineElement of the context enclosing the specified 
-	 * line. null if the line is in file scope
-	 */
-	public OutlineElement getLineContext(int line,int col){
-		OutlineElement results=null;
-		OutlineElement[] topLevelElements=getTopLevelElements();
-		
-		for(OutlineElement element:topLevelElements){
-			results=getContext(element,line,col);
-			if(results!=null){
-				break;
-			}
-		}
-		
-		return results;
-	}
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2006 Ali Ghorashi and others.
+ *
+ * Contributors:
+ *    Ali Ghorashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.parser;
+
+import java.awt.Point;
+import java.io.File;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.HashMap;
+
+import org.eclipse.core.resources.IFile;
+
+/**
+ * module database for each project
+ */
+public class OutlineContainer
+{	
+	
+	class Comment {
+		public Comment(String s, Boolean o) {
+			m_comment = s;
+			m_onlycommentline = o;
+		}
+		public String m_comment;
+		public Boolean m_onlycommentline; // true when this line contains nothing else then comment
+		
+	}
+	
+	private static final int  MINIMUM_COLLAPSIBLE_SIZE=1;
+	ArrayList<Collapsible> m_Collapsibles;
+	HashMap<Integer,Comment > m_Comments; 
+	ArrayList<Point> m_disabledCode;	
+	
+	public void resetDisabledCode(){
+		m_disabledCode=new ArrayList<Point>();
+	}
+	public OutlineContainer(){
+		m_Collapsibles=new ArrayList<Collapsible>();
+		m_Comments=new HashMap<Integer,Comment>();
+		resetDisabledCode();
+	}
+	public void addDisabledCode(int startLine, int endLine){
+		Point r = new Point(startLine, endLine);
+		if (!m_disabledCode.contains(r)){
+			m_disabledCode.add(r);
+		}
+	}
+	public ArrayList<Point> getDisabledCode(boolean cutDecreasing){
+		if (cutDecreasing){
+			int i;
+			for (i=1; i < m_disabledCode.size(); i++){
+				if (m_disabledCode.get(i).x < m_disabledCode.get(i-1).x){
+					for (int j = i; j< m_disabledCode.size(); j++){
+						m_disabledCode.remove(i);
+					}
+				}
+			}
+		} else {
+			Collections.sort(m_disabledCode, new RangeCompare());
+		}
+		return m_disabledCode;
+	}
+	
+	private class RangeCompare implements Comparator<Point> {
+	    public int compare(Point a, Point b) {
+	        if (a.x < b.x) {
+	            return -1;
+	        }
+	        else if (a.x > b.x) {
+	            return 1;
+	        }
+	        else {
+	            return 0;
+	        }
+	    }
+	}	
+	
+	/**
+	* Class to include all the information about a file
+	*/
+	private  class FileInfo{
+		public OutlineElement CurrentElement;
+		public ArrayList<OutlineElement> ElementList;
+		public ArrayList<File> includedFiles;
+		/**
+		* constructor
+		*/
+		public FileInfo(){
+			ElementList=new ArrayList<OutlineElement>();
+			CurrentElement = null;
+			includedFiles=new ArrayList<File>();
+		}
+	}
+	
+	/**
+	 * Class to encapsulate collapsible elements
+	 */
+	public class Collapsible extends Object{
+		public int startLine;
+		public int endLine;
+		public Collapsible(int start,int end){startLine=start;endLine=end;}
+		/* (non-Javadoc)
+		 * @see java.lang.Object#equals(java.lang.Object)
+		 */
+		public boolean equals(Object obj){
+			if (obj instanceof Collapsible) {
+				Collapsible collapsible = (Collapsible) obj;				
+				if (startLine == collapsible.startLine && endLine == collapsible.endLine){return true;}		
+			}
+			return false;
+		}
+		public int hashCode(){ return String.format("%d:%d", startLine,endLine).hashCode();}
+	}
+	
+	/** list of all the files we have seen */ 
+	private  FileInfo m_FileInfo = new FileInfo();
+	
+	/** gets the current element scope */
+	public OutlineElement GetCurrentElement(){		
+		return m_FileInfo.CurrentElement;
+	}
+	
+	/**
+	 * @return a list of elements at the file level
+	 */
+	public OutlineElement[] getTopLevelElements(){
+		return m_FileInfo.ElementList.toArray(new OutlineElement[0]);
+	}
+
+	/**
+	 * @return a list of included files
+	 */
+	public ArrayList<File> getIncludedFiles(){
+		return m_FileInfo.includedFiles;
+	}
+	
+	public void addIncludedFile(File file) {
+		if (!m_FileInfo.includedFiles.contains(file)) m_FileInfo.includedFiles.add(file);
+	}
+	
+	/**
+	 * Find a top level element with the given name.
+	 * @param name Element name
+	 * @return found element or null if not found.
+	 */
+	public OutlineElement findTopLevelElement(String name) {
+		for (OutlineElement element : m_FileInfo.ElementList) {
+			if (element.getName().equals(name)) {
+				return element;
+			}
+		}
+		return null;
+	}
+	
+	/**
+	* returns true if the given element has any children
+	*/
+	public boolean HasChildren(OutlineElement element){
+		return element.HasChildren();
+	}
+	/**
+	*inserts an element into the element list
+	*/
+	// Modifying to work with existent elements
+	
+	private  void InsertElement(OutlineElement element,FileInfo fileInfo){
+		if (fileInfo.CurrentElement != null){
+//			OutlineElement existentElement=fileInfo.CurrentElement.sameChildThis(element);
+//			if (existentElement!=null){
+			int sameIndex=fileInfo.CurrentElement.sameChildThisIndex(element);
+			if (sameIndex>=0){
+//				fileInfo.CurrentElement = existentElement;
+// Andrey: Trying here to replace old element with the new one (or just some members?)
+// The reason is that with multi-pass parser something (displayed in Outline view (value, bit ranges))
+// may change as a result of parameter evaluation				
+				fileInfo.CurrentElement.replaceChild(sameIndex, element);
+			} else {
+				fileInfo.CurrentElement.AddChild(element);
+			}
+		}
+		else{
+			for (OutlineElement existentElement:fileInfo.ElementList){
+				if ((existentElement.m_Name.equals(element.m_Name)) &&
+						(existentElement.m_StartingLine == element.m_StartingLine) &&
+						(existentElement.m_StartingCol  == element.m_StartingCol)){
+					fileInfo.CurrentElement = existentElement;
+					return;
+				}
+			}
+			fileInfo.ElementList.add(element);
+		}		
+		fileInfo.CurrentElement = element;			
+	}
+	
+	/**
+	 * Removes all the outline elements. This function is should
+	 * be called before re-parsing a file to avoid duplicate 
+	 * entries
+	 */
+	public void clear(){
+		m_FileInfo.CurrentElement = null;
+		m_FileInfo.ElementList.clear();
+		m_Collapsibles.clear();
+		m_Comments.clear();
+	}
+	/**
+	* This function is called to mark the beginning of an
+	* element
+	* @param elementName name of the element
+	  @param type type of the element
+	  @param line ending line
+	  @param filename filename in which the element lives
+	  @return newly created element
+	*/
+//	public OutlineElement beginElement(String elementName,
+	public void beginElement(String elementName,
+				String type,
+				int line, 
+				int col,
+				IFile file,
+				OutlineElementFactory elementFactory){
+				
+		OutlineElement element = 
+			elementFactory.CreateElement(elementName,type,line,col,java.lang.Integer.MAX_VALUE,java.lang.Integer.MAX_VALUE,file);
+		//put the element into the element list
+		InsertElement(element,m_FileInfo);
+//		return element;
+	}
+	
+	/**
+	 * This function is called to mark the ending of an element	
+	 * @param elementName name of the element
+	 * @param type type of the element
+	 * @param line ending line
+	 * @param filename filename in which the element lives
+	 * @return true if successful, false otherwise
+	 */
+	public  boolean endElement(String elementName, String type,int line,int col, IFile file){		
+		if (m_FileInfo.CurrentElement == null){
+			//huh?? encountered the end of an element without seeing the beginning
+			return false;
+		}
+		else{
+			//sanity check
+			if (!m_FileInfo.CurrentElement.getName().equals(elementName) ||
+				!m_FileInfo.CurrentElement.getFile().equals(file)) {
+				//something terribly wrong - show it
+				System.out.println("endElement("+elementName+","+type+","+line+","+col+","+file+") problem:"+
+				" m_FileInfo.CurrentElement.getName()="+m_FileInfo.CurrentElement.getName()+
+				" m_FileInfo.CurrentElement.getFile()="+m_FileInfo.CurrentElement.getFile());
+				return false;
+			}
+			else{
+				m_FileInfo.CurrentElement.setEndingLine(line);
+				m_FileInfo.CurrentElement.setEndingCol(col);
+				m_FileInfo.CurrentElement = m_FileInfo.CurrentElement.getParent();
+			}					
+		}			
+		return true;
+	}
+	
+	/**
+	 * Adds the position to the list of collapsible positions
+	 * @param position
+	 */
+	public void addCollapsibleRegion(Collapsible collapsible){
+		if(collapsible.endLine - collapsible.startLine > MINIMUM_COLLAPSIBLE_SIZE){
+			m_Collapsibles.add(collapsible);
+		}
+	}
+	
+	/**
+	 * 
+	 * @return A list of collapsible regions
+	 */
+	public Collapsible[] getCollapsibleRegions(){
+		return m_Collapsibles.toArray(new Collapsible[0]);
+	}
+	
+	/**
+	 * Adds a string to the comments list
+	 * @param endLine Ending line of the comment
+	 * @param text The comment text
+	 */
+	public void addComment(int endLine,String text, Boolean onlycomment){
+		m_Comments.put(endLine,new Comment(text,onlycomment));
+	}
+	
+	/**
+	 * Gets the comments near the given element. These comments will 
+	 * presumably be associated with the element
+	 * @param element the element to look around
+	 * @return Comment string
+	 */
+	public String getCommentsNear(OutlineElement element){
+		int startLine=element.getStartingLine();
+		//look on the same line
+		if(m_Comments.containsKey(startLine)){
+			return m_Comments.get(startLine).m_comment;
+		}
+		// look on previous lines:
+		String comment = "";
+		for(int line = startLine-1;;line--) {
+			if(!m_Comments.containsKey(line)) break;
+			if(!m_Comments.get(line).m_onlycommentline) break;
+			comment = m_Comments.get(line).m_comment+"\n"+comment;
+		}	
+		return comment;
+	}
+	
+	
+	/**
+	 * Decides whether the give line and column is inside the element
+	 * @param e
+	 * @param line
+	 * @param col
+	 * @return
+	 */
+	private boolean isPositionInsideElement(OutlineElement e,int line,int col){
+		if (line < e.getStartingLine()) return false;
+		if (line > e.getEndingLine())   return false;
+		if ((line == e.getStartingLine()) && (col < e.getStartingCol())) return false;
+		if ((line == e.getEndingLine())   && (col > e.getEndingCol())) return false;
+		return true;
+	}
+	/**
+	 * Recursively scans through the element and its children to find the
+	 * deepest element surrounding the given line and column
+	 * @param element
+	 * @param line 1-based!
+	 * @param col 1-based!
+	 * @return The deepest element surrounding the line. null if no element 
+	 * surrounds the given line
+	 */
+	private OutlineElement getContext(OutlineElement element,int line,int col){
+		OutlineElement results=null;
+		if(isPositionInsideElement(element, line, col)){
+			//is the line enclosed in one of the children
+			for(OutlineElement child:element.getChildren()){
+				results=getContext(child,line,col);
+				if(results!=null){
+					return results;
+				}
+			}
+			//if not in children, then this element is the parent
+			return element;
+		}
+		//this element does not enclose the line
+		return null;
+	}
+	/**
+	 * This function returns the context of the given line and column
+	 * @param line the line number for the context (zero-based!) -> one based
+	 * @param col the column number for the context (zero-based!) -> one based
+	 * @return OutlineElement of the context enclosing the specified 
+	 * line. null if the line is in file scope
+	 */
+	public OutlineElement getLineContext(int line,int col){
+		OutlineElement results=null;
+		OutlineElement[] topLevelElements=getTopLevelElements();
+		
+		for(OutlineElement element:topLevelElements){
+//			results=getContext(element,line+1,col+1);
+			results=getContext(element,line,col);
+			if(results!=null){
+				break;
+			}
+		}
+		
+		return results;
+	}
+
 }	
\ No newline at end of file
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/OutlineDatabase.java vdt/src/com/elphel/vdt/veditor/parser/OutlineDatabase.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/OutlineDatabase.java	2016-06-24 10:29:40.856495517 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/OutlineDatabase.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,500 +1,1099 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.parser;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.Vector;
-
-import net.sourceforge.veditor.VerilogPlugin;
-import net.sourceforge.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogInstanceElement;
-import net.sourceforge.veditor.parser.verilog.VerilogParserReader;
-import net.sourceforge.veditor.parser.vhdl.VhdlOutlineElementFactory.PackageDeclElement;
-import net.sourceforge.veditor.semanticwarnings.SemanticWarnings;
-
-import org.eclipse.core.resources.IContainer;
-import org.eclipse.core.resources.IFile;
-import org.eclipse.core.resources.IProject;
-import org.eclipse.core.resources.IResource;
-import org.eclipse.core.resources.IResourceChangeEvent;
-import org.eclipse.core.resources.IResourceChangeListener;
-import org.eclipse.core.resources.IResourceDelta;
-import org.eclipse.core.resources.IResourceDeltaVisitor;
-import org.eclipse.core.runtime.CoreException;
-import org.eclipse.core.runtime.IProgressMonitor;
-import org.eclipse.core.runtime.IStatus;
-import org.eclipse.core.runtime.Status;
-import org.eclipse.core.runtime.jobs.Job;
-import org.eclipse.swt.widgets.Display;
-
-/**
- * module database for each project
- */
-public class OutlineDatabase {
-	private IProject m_Project;
-	private HashMap<IFile, OutlineContainer> m_HierarchyDatabase;
-	public enum ScanState { NOT_STARTED, IN_PROGRESS, DONE, CANCELLED}
-	private ScanState m_ScanState;
-	private resourceChangeListern m_ResourceChangeListener;
-	private Vector<OutlineDatabaseEvent> m_Listeners;
-
-	
-	public static OutlineDatabase getProjectsDatabase(IProject project){
-		try {
-			return (OutlineDatabase)project.getSessionProperty(VerilogPlugin.getOutlineDatabaseId());
-		} catch (CoreException e) {
-			return null;
-		}
-	}
-	/**
-	 * constructor
-	 * @param project
-	 */
-	public OutlineDatabase(IProject project) {
-		m_Project           = project;
-		m_HierarchyDatabase = new HashMap<IFile, OutlineContainer>();
-		m_ScanState=ScanState.NOT_STARTED;
-		m_ResourceChangeListener = new resourceChangeListern();
-		m_Listeners = new Vector<OutlineDatabaseEvent>();
-		VerilogPlugin.getWorkspace().addResourceChangeListener(
-				m_ResourceChangeListener, IResourceChangeEvent.POST_CHANGE);
-	}
-
-	public OutlineContainer getOutlineContainer(IFile file) {
-		OutlineContainer results = m_HierarchyDatabase.get(file);
-		//if the outline already exists
-		if (m_HierarchyDatabase.get(file) == null) {
-			results = new OutlineContainer();
-			m_HierarchyDatabase.put(file, results);			
-		}
-		return results;
-	}
-	
-	/**
-	 * Finds top level elements starting with the given name
-	 * @param name Element name
-	 * @param exactly if true, find only exactly equal
-	 * @return List of elements matching the given name. list.length = 0 if not found
-	 */
-	synchronized public OutlineElement[] findTopLevelElements(String name, boolean exactly) {
-		ArrayList<OutlineElement> list = new ArrayList<OutlineElement>();
-		Iterator<OutlineContainer> iter = m_HierarchyDatabase.values()
-				.iterator();
-
-		while (iter.hasNext()) {
-			OutlineContainer outline = iter.next();
-
-			Object[] obj = outline.getTopLevelElements();
-			for (int i = 0; i < obj.length; i++) {
-				if (obj[i] instanceof OutlineElement) {
-					OutlineElement element = (OutlineElement) obj[i];
-					if (exactly) {
-						if (element.getName().equals(name)) {
-							list.add(element);
-						}
-					} else {
-						if (element.getName().startsWith(name)) {
-							list.add(element);
-						}
-					}
-				}
-			}
-		}
-		return list.toArray(new OutlineElement[0]);
-	}
-
-	public OutlineElement[] findTopLevelElements(String name){
-		return findTopLevelElements(name, false);
-	}
-	
-	
-	
-	synchronized public PackageDeclElement[] findTopLevelPackages() {
-		ArrayList<PackageDeclElement> list = new ArrayList<PackageDeclElement>();
-		Iterator<OutlineContainer> iter = m_HierarchyDatabase.values()
-				.iterator();
-
-		while (iter.hasNext()) {
-			OutlineContainer outline = iter.next();
-
-			Object[] obj = outline.getTopLevelElements();
-			for (int i = 0; i < obj.length; i++) {
-				if (obj[i] instanceof PackageDeclElement) {
-					PackageDeclElement element = (PackageDeclElement) obj[i];
-					list.add(element);
-				}
-			}
-		}
-		return list.toArray(new PackageDeclElement[0]);
-	}
-	
-	/**
-	 * Find a top level element with the given name.
-	 * @param name Element name
-	 * @return found element or null if not found.
-	 */
-	public OutlineElement findTopLevelElement(String name) {
-		for (OutlineContainer container : m_HierarchyDatabase.values()) {
-			OutlineElement element = container.findTopLevelElement(name);
-			if (element != null)
-				return element;
-		}
-		return null;
-	}
-
-	/**
-	 * Class used to inform the listeners of change
-	 * 
-	 * @author gho18481
-	 * 
-	 */
-	public abstract static class OutlineDatabaseEvent{
-		public abstract void handel();
-		
-		protected void run() {
-			Display.getDefault().asyncExec(new Runnable() {
-	               public void run() {
-	            	   handel();
-	               }
-	            }
-			);
-		}
-	}
-	
-	/**
-	 * Adds a listener to the list of listeners
-	 * @param eventListner
-	 */
-	public void addChangeListner(OutlineDatabaseEvent eventListener){
-		synchronized(m_Listeners){
-			m_Listeners.add(eventListener);
-		}
-	}
-	
-	
-	/**
-	 * Adds a listener to the list of listeners
-	 * @param eventListner
-	 */
-	public void removeChangeListner(OutlineDatabaseEvent eventListener){
-		synchronized(m_Listeners){
-			m_Listeners.remove(eventListener);
-		}
-	}
-	
-	/**
-	 * Fires a change event
-	 */
-	protected void fireChangeEvent(){
-		synchronized(m_Listeners){
-			for(int i=0;i<m_Listeners.size();i++){			
-				m_Listeners.get(i).run();
-			}
-		}
-	}
-	
-	/**
-	 * Class used to launch the project scanning task
-	 * @author gho18481
-	 *
-	 */
-	private class ScanProjectJob extends Job {
-		private Vector<IFile> m_Files;
-		
-		/**
-		 * Constructor
-		 * @param files to scan
-		 */
-		public ScanProjectJob(Vector<IFile> files) {
-			super("Scanning HDL Files");
-			m_Files=files;
-		}
-
-		public IStatus run(IProgressMonitor monitor) {
-			final int ticks = m_Files.size();
-			monitor.beginTask("Scanning HDL Files", ticks);
-			try {
-				for (int i = 0; i < ticks; i++) {
-					if (monitor.isCanceled()){
-						m_ScanState=ScanState.CANCELLED;
-						return Status.CANCEL_STATUS;
-					}
-					monitor.subTask("Scanning " + m_Files.get(i).getName());
-					scanFile(m_Files.get(i));
-					monitor.worked(1);
-					fireChangeEvent();
-				}
-			} finally {
-				monitor.done();
-			}
-			SemanticWarnings.clearWarningsGenerated();
-			m_ScanState=ScanState.DONE;
-			return Status.OK_STATUS;
-		}
-	}
-
-	/**
-	 * Class used to launch the project scanning task
-	 */
-	private class ScanTreeJob extends Job {
-		private IFile file;
-		
-		/**
-		 * Constructor
-		 * @param files to scan
-		 */
-		public ScanTreeJob(IFile file) {
-			super("Scanning HDL Tree");
-			this.file = file;
-		}
-
-		public IStatus run(IProgressMonitor monitor) {
-			monitor.beginTask("Scanning HDL Tree", 1);
-			try {
-				scanChildrenFiles(file);
-				monitor.worked(1);
-				fireChangeEvent();
-			} finally {
-				monitor.done();
-			}
-			m_ScanState=ScanState.DONE;
-			return Status.OK_STATUS;
-		}
-	}
-	
-	/**
-	 * @return The current scan state
-	 */
-	public ScanState getScanState(){
-		return m_ScanState;
-	}
-	/**
-	 * Public access to scan function
-	 */
-	public void scanProject() {
-		if (VerilogPlugin.getPreferenceBoolean("ScanProject.Enable")) {
-
-			Vector<IFile> files = getProjectFiles(m_Project);
-			VerilogPlugin.deleteMarkers(m_Project);
-			
-			if (m_ScanState != ScanState.IN_PROGRESS) {
-				ScanProjectJob job = new ScanProjectJob(files);
-				m_ScanState = ScanState.IN_PROGRESS;
-				// not a critical job
-				job.setPriority(Job.DECORATE);
-				job.schedule();
-			}
-		}
-	}
-	/**
-	 * Searches the project for a list of files to be scanned
-	 */
-	private Vector<IFile> getProjectFiles(IContainer root){
-		IResource[] members;
-		Vector<IFile> results=new Vector<IFile>();
-		
-		try {
-			members = root.members();
-			for (int i = 0; i < members.length; i++) {
-				if (members[i] instanceof IContainer){
-					results.addAll(getProjectFiles((IContainer)members[i]));
-				} else if (members[i] instanceof IFile) {
-					IFile file = (IFile) members[i];					
-					if(file.getName().endsWith(".v") || file.getName().endsWith(".vhd")){
-						results.add(file);
-					}
-				}
-			}
-			
-		} catch (CoreException e) {
-			// TODO Auto-generated catch block
-			e.printStackTrace();
-		}
-		return results;
-	}
-	
-	/**
-	 * Public access to scan function
-	 */
-	public void scanTree(IFile file){
-		if (VerilogPlugin.getPreferenceBoolean("ScanProject.Enable") == false) {
-			if (m_ScanState != ScanState.IN_PROGRESS) {
-				ScanTreeJob job = new ScanTreeJob(file);
-				m_ScanState = ScanState.IN_PROGRESS;
-				// not a critical job
-				job.setPriority(Job.DECORATE);
-				job.schedule();
-			}
-		}
-	}
-
-	/**
-	 * Scan children recursively
-	 */
-	private void scanChildrenFiles(IFile file){
-		OutlineContainer container = getOutlineContainer(file);
-		OutlineElement[] elements = container.getTopLevelElements();
-		for(int i = 0; i < elements.length; i++){
-			OutlineElement[] children = elements[i].getChildren();
-			for(int j = 0; j < children.length; j++)
-			{
-				if (children[j] instanceof VerilogInstanceElement)
-				{
-					VerilogInstanceElement instance = (VerilogInstanceElement)children[j];
-					String[] types = instance.getType().split("#");
-					OutlineElement[] element = findTopLevelElements(types[1], true);
-					if (element.length == 0)
-					{
-						IFile found = findFile(m_Project, types[1] + ".v");
-						if (found != null)
-						{
-							scanFile(found);
-							scanChildrenFiles(found);
-						}
-					}
-				}
-				// TODO: VHDL files must be scanned
-			}
-		}
-	}
-	
-	/**
-	 * search definition from instance
-	 */
-	public OutlineElement findDefinition(OutlineElement instance) {
-		if (instance instanceof VerilogInstanceElement) {
-			String[] types = instance.getType().split("#");
-			OutlineElement[] element = findTopLevelElements(types[1], true);
-			if (element.length == 0)
-				return null;
-			else
-				return element[0];
-		}
-		// TODO: VHDL module must be found
-		return null;
-	}
-	
-	/**
-	 * Searches file for name in the project
-	 * 
-	 * @return
-	 */
-	private IFile findFile(IContainer root, String fileName) {
-		try {
-			IResource[] members;
-			members = root.members();
-			for (int i = 0; i < members.length; i++) {
-				if (members[i] instanceof IContainer) {
-					IFile file = findFile((IContainer) members[i], fileName);
-					if (file != null)
-						return file;
-				}
-				if (members[i] instanceof IFile) {
-					IFile file = (IFile) members[i];
-					if (fileName.equals(file.getName()))
-						return file;
-				}
-			}
-		} catch (CoreException e) {
-		}
-		return null;
-	}
-	
-	/**
-	 * Scans a single file and adds its contents to the database
-	 * 
-	 * @param file
-	 *            file to be scanned
-	 */
-	private void scanFile(IFile file) {
-		try {
-			IParser parser=null;
-			if (file.getName().endsWith(".v")){
-				// VerilogParserReader handles verilog compiler directive
-				ParserReader reader = new VerilogParserReader(file.getContents(), file);
-				parser = ParserFactory.createVerilogParser(reader, m_Project,
-						file);
-			} else 	if (file.getName().endsWith(".vhd")){
-				ParserReader reader = new ParserReader(file.getContents());
-				parser = ParserFactory.createVhdlParser(reader, m_Project, file);
-			}
-			//do we have parser
-			if(parser!= null){
-				parser.parse();				
-			}
-		} catch (CoreException e) {
-		} catch (HdlParserException e){
-			
-		}
-	}
-	
-	
-	 /**
-	  * Class used to determine the changes
-	  *
-	  */
-	 class DeltaPrinter implements IResourceDeltaVisitor {
-		public boolean visit(IResourceDelta delta) {
-			IResource res = delta.getResource();
-			switch (delta.getKind()) {
-			case IResourceDelta.ADDED:
-				if (res instanceof IFile) {
-					IFile file=(IFile) res;
-					if(file.getName().endsWith(".v") || file.getName().endsWith(".vhd")){
-						// just scan added file
-						scanFile(file);
-					}
-				}
-				break;
-			case IResourceDelta.REMOVED:
-				if (res instanceof IFile) {
-					IFile file = (IFile) res;
-					//remove this file from the outline database
-					m_HierarchyDatabase.remove(file);
-				}
-				break;
-			case IResourceDelta.CHANGED:
-				break;
-			}
-			return true; // visit the children
-		}
-	}
-	 
-	/**
-	 * Class used to keep track of workspace resources
-	 */
-	class resourceChangeListern implements IResourceChangeListener {
-		/**
-		 * Called when a resource is changed
-		 */
-		public void resourceChanged(IResourceChangeEvent event) {
-			switch (event.getType()) {
-			case IResourceChangeEvent.PRE_CLOSE:
-				break;
-			case IResourceChangeEvent.PRE_DELETE:
-				break;
-			case IResourceChangeEvent.POST_CHANGE:
-				try {
-					event.getDelta().accept(new DeltaPrinter());
-				} catch (CoreException e) {
-					// TODO Auto-generated catch block
-					e.printStackTrace();
-				}
-				break;
-			case IResourceChangeEvent.PRE_BUILD:
-				break;
-			case IResourceChangeEvent.POST_BUILD:
-				break;
-			}
-		}
-	}
-}
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.parser;
+
+import java.io.File;
+import java.util.ArrayList;
+//import java.util.Collections;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.HashSet;
+//import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.TreeMap;
+import java.util.Vector;
+import java.util.concurrent.ConcurrentHashMap;
+
+import com.elphel.vdt.VerilogUtils;
+import com.elphel.vdt.ui.variables.SelectedResourceManager;
+import com.elphel.vdt.util.VerilogParseMultipass;
+import com.elphel.vdt.veditor.VerilogPlugin;
+import com.elphel.vdt.veditor.document.HdlDocument;
+import com.elphel.vdt.veditor.editor.HdlEditor;
+import com.elphel.vdt.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogInstanceElement;
+import com.elphel.vdt.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogModuleElement;
+//import com.elphel.vdt.veditor.parser.verilog.VariableStore;
+//import com.elphel.vdt.veditor.parser.verilog.VerilogParser;
+import com.elphel.vdt.veditor.parser.verilog.VerilogParserReader;
+import com.elphel.vdt.veditor.parser.vhdl.VhdlOutlineElementFactory.PackageDeclElement;
+import com.elphel.vdt.veditor.preference.PreferenceStrings;
+import com.elphel.vdt.veditor.semanticwarnings.SemanticWarnings;
+
+import org.eclipse.core.resources.IContainer;
+import org.eclipse.core.resources.IFile;
+import org.eclipse.core.resources.IProject;
+import org.eclipse.core.resources.IResource;
+import org.eclipse.core.resources.IResourceChangeEvent;
+import org.eclipse.core.resources.IResourceChangeListener;
+import org.eclipse.core.resources.IResourceDelta;
+import org.eclipse.core.resources.IResourceDeltaVisitor;
+import org.eclipse.core.resources.IWorkspace;
+import org.eclipse.core.resources.ResourcesPlugin;
+import org.eclipse.core.runtime.CoreException;
+import org.eclipse.core.runtime.IProgressMonitor;
+import org.eclipse.core.runtime.IStatus;
+import org.eclipse.core.runtime.Path;
+import org.eclipse.core.runtime.Status;
+import org.eclipse.core.runtime.jobs.Job;
+import org.eclipse.swt.widgets.Display;
+
+/**
+ * module database for each project
+ */
+public class OutlineDatabase {
+	private IProject m_Project;
+//	private HashMap<IFile, OutlineContainer> m_HierarchyDatabase;
+	private ConcurrentHashMap<IFile, OutlineContainer> m_HierarchyDatabase;
+	public enum ScanState { NOT_STARTED, IN_PROGRESS, DONE, CANCELLED}
+	private ScanState m_ScanState;
+	private resourceChangeListern m_ResourceChangeListener;
+	private Vector<OutlineDatabaseEvent> m_Listeners;
+	
+	// Cache partial db for particular tool/set of defines (only one combination)
+	private ConcurrentHashMap<IFile, OutlineContainer> m_tool_HierarchyDatabase;
+	private IFile m_toolTopFile;
+	private String m_toolDefine;
+	
+	private static void DEBUG_PRINT(String msg){
+		if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_CLOSURE)) {
+			System.out.println(msg);
+		}
+	}
+	
+	
+	public String [] getExtList(String str){
+		return str.split("[\\, ]+");
+	}
+	public boolean isVerilogFile(IFile file){
+		String name=file.getName();
+		String [] patterns=getExtList(VerilogPlugin.getPreferenceString(PreferenceStrings.VERILOG_EXT));
+		for (int i=0;i<patterns.length;i++) if (name.endsWith(patterns[i])) return true;
+		return false;
+	}
+	public boolean isVhdlFile(IFile file){
+		String name=file.getName();
+		String [] patterns=getExtList(VerilogPlugin.getPreferenceString(PreferenceStrings.VHDL_EXT));
+		for (int i=0;i<patterns.length;i++) if (name.endsWith(patterns[i])) return true;
+		return false;
+	}
+	
+	public static OutlineDatabase getProjectsDatabase(IProject project){
+		try {
+			return (OutlineDatabase)project.getSessionProperty(VerilogPlugin.getOutlineDatabaseId());
+		} catch (CoreException e) {
+			return null;
+		} catch (NullPointerException e) {
+			return null;
+		}
+	}
+	/**
+	 * constructor
+	 * @param project
+	 */
+	public OutlineDatabase(IProject project) {
+		m_Project           = project;
+//		m_HierarchyDatabase = new HashMap<IFile, OutlineContainer>();
+		clearDatabase();
+//		m_HierarchyDatabase = new ConcurrentHashMap<IFile, OutlineContainer>();
+		m_ScanState=ScanState.NOT_STARTED;
+		m_ResourceChangeListener = new resourceChangeListern();
+		m_Listeners = new Vector<OutlineDatabaseEvent>();
+		VerilogPlugin.getWorkspace().addResourceChangeListener(
+				m_ResourceChangeListener, IResourceChangeEvent.POST_CHANGE);
+	}
+	
+	public void clearDatabase(){
+		m_HierarchyDatabase = new ConcurrentHashMap<IFile, OutlineContainer>();
+		invalidateToolCache();
+	}
+	
+	public void invalidateToolCache(){
+//	    System.out.print("/"); // ln("-:::---invalidateToolCache()");
+		m_tool_HierarchyDatabase = null;
+		m_toolTopFile = null;
+		m_toolDefine =  "";
+	}
+	
+	public ConcurrentHashMap<IFile, OutlineContainer> getToolCache(IFile topFile, String defines){
+		if ((m_toolTopFile != null) && m_toolTopFile.equals(topFile) && m_toolDefine.equals(defines)){
+			return m_tool_HierarchyDatabase;
+		} else {
+			invalidateToolCache();
+			return null;
+		}
+	}
+
+	public void setToolCache(Map<IFile, OutlineContainer> tool_HierarchyDatabase, IFile topFile, String defines){
+		m_tool_HierarchyDatabase = (ConcurrentHashMap<IFile, OutlineContainer>) tool_HierarchyDatabase;
+		m_toolTopFile = topFile;
+		m_toolDefine =  defines;
+	}
+	
+// Same OutlineContainer appears multiple times - not erased before re-scanning
+	public OutlineContainer getOutlineContainer(IFile file) {
+		OutlineContainer results = m_HierarchyDatabase.get(file);
+		//if the outline already exists
+		if (m_HierarchyDatabase.get(file) == null) {
+			results = new OutlineContainer();
+			m_HierarchyDatabase.put(file, results);			
+		}
+		return results;
+	}
+	
+	/**
+	 * Finds top level elements starting with the given name
+	 * @param name Element name
+	 * @param exactly if true, find only exactly equal
+	 * @return List of elements matching the given name. list.length = 0 if not found
+	 */
+//	public OutlineElement[] findTopLevelElements(String name, boolean exactly) {
+	public OutlineElement[] findTopLevelElements(String name, boolean exactly) {
+		return findTopLevelElements(name, exactly, false);
+	}
+	synchronized public OutlineElement[] findTopLevelElements(String name, boolean exactly, boolean nameStarts) {
+		ArrayList<OutlineElement> list = new ArrayList<OutlineElement>();
+		Iterator<OutlineContainer> iter = m_HierarchyDatabase.values()
+				.iterator();
+		if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_DATABASE))
+			System.out.println("Staring Synchronized method >>");
+		while (iter.hasNext()) {
+			OutlineContainer outline = iter.next(); /* this throws java.util.ConcurrentModificationException*/
+
+			Object[] obj = outline.getTopLevelElements();
+			for (int i = 0; i < obj.length; i++) {
+				if (obj[i] instanceof OutlineElement) {
+					OutlineElement element = (OutlineElement) obj[i];
+					if (exactly) {
+						if (element.getName().equals(name)) {
+							list.add(element);
+						}
+					} else if (nameStarts) {
+						if (name.startsWith(element.getName())) {
+							list.add(element);
+						}
+					} else {
+						if (element.getName().startsWith(name)) {
+							list.add(element);
+						}
+					}
+				}
+			}
+		}
+		if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_DATABASE))
+			System.out.println("<< Ending Synchronized method, list size is "+list.size());
+		return list.toArray(new OutlineElement[0]);
+	}
+
+	public OutlineElement[] findTopLevelElements(String name){
+		if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_DATABASE))
+			System.out.println("Calling findTopLevelElements(\""+name+"\", false)");
+		return findTopLevelElements(name, false);
+	}
+	
+	synchronized public PackageDeclElement[] findTopLevelPackages() {
+		ArrayList<PackageDeclElement> list = new ArrayList<PackageDeclElement>();
+		Iterator<OutlineContainer> iter = m_HierarchyDatabase.values()
+				.iterator();
+
+		while (iter.hasNext()) {
+			OutlineContainer outline = iter.next();
+
+			Object[] obj = outline.getTopLevelElements();
+			for (int i = 0; i < obj.length; i++) {
+				if (obj[i] instanceof PackageDeclElement) {
+					PackageDeclElement element = (PackageDeclElement) obj[i];
+					list.add(element);
+				}
+			}
+		}
+		return list.toArray(new PackageDeclElement[0]);
+	}
+
+	public IFile[] getDatabaseFileList(){
+    	return m_HierarchyDatabase.keySet().toArray(new IFile[0]);
+	}
+
+	public IFile[] getFileList(int level) { /* 1 - files in project root only , <0 - all */
+		int numSegments=(level>=0)?(m_Project.getFullPath().segmentCount()+level):level;
+    	ArrayList<IFile> fList = new ArrayList<IFile>();
+    	Vector<IFile> vFile= getProjectFiles(m_Project);
+    	for (int i=0;i<vFile.size();i++){
+    		if ((numSegments<0) || (vFile.get(i).getFullPath().segmentCount()<=numSegments)){
+    			fList.add(vFile.get(i));
+    		}
+    	}
+    	return fList.toArray(new IFile [0]);
+	}
+
+	public IFile[] getClosureSorted(IFile[] topFiles) {
+		return (new VerilogClosureSorted(topFiles).getFiles());
+	}	
+	public IFile[] getClosureUnsorted(IFile[] topFiles) {
+		return (new VerilogClosure(topFiles).getFiles());
+	}	
+	public IFile[] getClosureIncludes(IFile[] topFiles) {
+		return (new VerilogClosureSorted(topFiles).getIncludedFiles());
+	}	
+	public class VerilogClosure {
+		private Set<IFile> fileSet=null;
+		public VerilogClosure(IFile[] topFiles) {
+			fileSet= new HashSet<IFile>();
+			for (int i=0;i<topFiles.length;i++) {
+				//fileSet.add(topFiles[i]);
+				recursiveAddDefinitions(topFiles[i]);
+			}
+		}
+		public IFile[] getFiles(){
+			return fileSet.toArray(new IFile[0]);
+		}
+		private void recursiveAddDefinitions(IFile file){
+			if (fileSet.contains(file)) return;
+			fileSet.add(file);
+			OutlineContainer container = m_HierarchyDatabase.get(file);
+			if (container==null) return;
+			Object[] obj = container.getTopLevelElements();
+			for (int i = 0; i < obj.length; i++) { /* top level elements - modules */
+				if (obj[i] instanceof VerilogModuleElement) {
+					VerilogModuleElement module= (VerilogModuleElement) obj[i];
+					OutlineElement[] children = module.getChildren();
+					for(int j = 0; j < children.length; j++) {
+						if (children[j] instanceof VerilogInstanceElement) {
+							VerilogInstanceElement instance = (VerilogInstanceElement) children[j];
+							OutlineElement definitionModule =findDefinition(instance);
+							if (definitionModule != null) {
+								recursiveAddDefinitions(definitionModule.getFile());
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+	public static final Comparator<IFile> MODULE_LEVEL_ORDER = 
+			new Comparator <IFile> (){
+		public int compare (IFile file1, IFile file2){
+			return 0;
+		}
+	};
+
+	public class VerilogClosureSorted {
+//		private Set<IFile> fileSet=null;
+		ConcurrentHashMap<IFile, Integer> fileSet;
+        LevelComparator levelComparator =  new LevelComparator();
+        TreeMap<IFile, Integer> sortedFiles = new TreeMap<IFile, Integer>(levelComparator);
+        ArrayList<File> includedFiles=null;
+
+		public VerilogClosureSorted(IFile[] topFiles) {
+			fileSet= new ConcurrentHashMap<IFile,Integer>();
+			for (int i=0;i<topFiles.length;i++) {
+				//fileSet.add(topFiles[i]);
+				recursiveAddDefinitions(topFiles[i], topFiles.length);
+			}
+			/* change the order of the topFiles */
+			for (int i=0;i<topFiles.length;i++) {
+				 fileSet.replace(topFiles[i], i); 
+			}
+			sortedFiles.putAll(fileSet);
+		}
+		
+		public IFile[] getFiles(){
+			/* get all keys in the order of increasing values */
+			Iterator<IFile> iter = sortedFiles.descendingKeySet().iterator();
+	    	ArrayList<IFile> fList = new ArrayList<IFile>();
+			while (iter.hasNext()) {
+				fList.add(iter.next());
+			}
+// Convert included files to IFile (if they are in the project) and add to the list
+//			IWorkspace workspace= ResourcesPlugin.getWorkspace();    
+//			for (File includedFile: includedFiles){
+//				IFile iFile=workspace.getRoot().getFileForLocation(Path.fromOSString(includedFile.getAbsolutePath()));
+//				if (iFile != null)	fList.add(iFile);
+//			}
+			return fList.toArray(new IFile[0]);
+		}
+
+		public IFile[] getIncludedFiles(){
+	    	ArrayList<IFile> fList = new ArrayList<IFile>();
+// Covert included files to IFile (if they are in the project) and add to the list
+			IWorkspace workspace= ResourcesPlugin.getWorkspace();    
+			for (File includedFile: includedFiles){
+				IFile iFile=workspace.getRoot().getFileForLocation(Path.fromOSString(includedFile.getAbsolutePath()));
+				if (iFile != null)	fList.add(iFile);
+			}
+//			Collections.sort(fList);
+			return fList.toArray(new IFile[0]);
+		}
+		
+		private void recursiveAddDefinitions(IFile file, Integer level){
+			// Debug only
+//			String indent="";
+//			for (int i =0; i<level;i++) indent += "  ";
+//			System.out.println(indent+"recursiveAddDefinitions("+file+", "+level+")");
+			 Integer oldLevel=fileSet.get(file);
+			if (oldLevel!=null) {
+				 if (oldLevel>level){
+					 fileSet.replace(file, level); 
+				 }
+				return;
+			}
+			fileSet.put(file,level);
+			OutlineContainer container = m_HierarchyDatabase.get(file);
+			if (container==null) return;
+			if (container.getIncludedFiles()!=null){
+				if (includedFiles==null) includedFiles=new ArrayList<File>(); 
+				for (File includedFile:container.getIncludedFiles()){
+					if (!includedFiles.contains(includedFile)) includedFiles.add(includedFile);
+				}
+//				System.out.println(indent+"recursiveAddDefinitions): includedFiles.size()="+includedFiles.size());
+			}
+			Object[] obj = container.getTopLevelElements();
+//			System.out.println(indent+"recursiveAddDefinitions): container.getTopLevelElements().length="+obj.length);
+
+			for (int i = 0; i < obj.length; i++) { /* top level elements - modules */
+				if (obj[i] instanceof VerilogModuleElement) {
+					VerilogModuleElement module= (VerilogModuleElement) obj[i];
+					OutlineElement[] children = module.getChildren();
+//					System.out.println(indent+"recursiveAddDefinitions): "+module.getName()+" children.length="+children.length);
+					for(int j = 0; j < children.length; j++) {
+						if (children[j] instanceof VerilogInstanceElement) {
+							VerilogInstanceElement instance = (VerilogInstanceElement) children[j];
+//							System.out.println(indent+"recursiveAddDefinitions): instance="+instance.getName());
+							OutlineElement definitionModule =findDefinition(instance);
+							if (definitionModule != null) {
+								recursiveAddDefinitions(definitionModule.getFile(),level+1);
+							} else {
+								System.out.println("WARNING: recursiveAddDefinitions(): no definition for "+instance.getName());
+								// Got here, creating dependencies for IVerilog with non-master OutlineDatabase,
+								// while the normal database had it. Did not find what was the difference, but
+								// the failure to find definition of a module was caused by Xilinx syntax error in
+								// unisims module, so parser failed.
+								// Trying to get definition in the master database
+						        OutlineDatabase masterBase = OutlineDatabase.getProjectsDatabase(m_Project);
+						        if ((masterBase != null) && !this.equals(masterBase)) {
+									definitionModule = masterBase.findDefinition(instance);
+							        if (definitionModule != null) {
+										System.out.println("Found definition in the project OutlineDatabase: "+definitionModule.getFile());
+							        } else {
+										System.out.println("WARNING: No definition in the project OutlineDatabase");
+							        }
+
+						        }
+							}
+						}
+					}
+//					System.out.println(indent+"recursiveAddDefinitions): done with module "+module.getName());
+				}
+			}
+		}
+		//.getFullPath().segmentCount()==2
+		class LevelComparator implements Comparator<IFile> {
+		    public int compare(IFile a, IFile b) {
+		    	/* First output files with less subfolders level, only then - level of dependence */
+		    	if      (a.getFullPath().segmentCount() > b.getFullPath().segmentCount()) return -1;
+		    	else if (a.getFullPath().segmentCount() < b.getFullPath().segmentCount()) return 1;
+		        if (fileSet.get(a) >= fileSet.get(b)) {
+		            return -1;
+		        } else {
+		            return 1;
+		        } // returning 0 would merge keys
+		    }
+		}
+	}
+	
+	
+	/**
+	 * Create list of the instances contained in the closure of the specified module
+	 * with the name "resembling" given one
+	 * @param topModule module to start search from
+	 * @param name target name
+	 * @param mode 0 - exact match, 1 - name starts with instance name, -1 - instance names start with name
+	 * @return list of matched instances
+	 */
+	public OutlineElement[] getChildInstances(OutlineElement topModule, String name, int mode) {
+		return (new InstanceSearch(topModule, name, mode).getInstances());
+	}	
+
+	
+	public class InstanceSearch{
+		private List<OutlineElement> instances;
+		private int mode; // 0 - exact, 1 - name includes base, -1 base includes name
+		private String name;
+		public InstanceSearch(OutlineElement topModule, String name, int mode){
+			instances=new ArrayList<OutlineElement>();
+			this.mode=mode;
+			this.name=name;
+			recursiveInstanceSearch(topModule);
+		}
+		public OutlineElement[] getInstances(){
+			return instances.toArray(new OutlineElement[0]);
+		}
+		
+		private void recursiveInstanceSearch(OutlineElement module){
+			OutlineElement[] children = module.getChildren();
+			for(int j = 0; j < children.length; j++) {
+				if (children[j] instanceof VerilogInstanceElement) {
+					VerilogInstanceElement instance = (VerilogInstanceElement) children[j];
+					String instName=instance.getName();
+					if (
+							(              name.equals(instName)) ||
+							((mode > 0) && name.startsWith(instName)) ||
+							((mode < 0) && instName.startsWith(name))){
+						if (!instances.contains(instance)) {
+							instances.add(instance);
+						} else {
+							System.out.println("recursiveInstanceSearch(): instance "+instance.getName()+"("+instance.getFile()+") is already in the list!");
+						}
+					}
+					OutlineElement [] definitionModules = findAllDefinitions(instance);
+					for (OutlineElement definitionModule:definitionModules){
+						recursiveInstanceSearch(definitionModule);
+					}
+				}
+			}
+		}
+	}
+	
+	
+	/**
+	 * Find a top level element with the given name.
+	 * @param name Element name
+	 * @return found element or null if not found.
+	 */
+	public OutlineElement findTopLevelElement(String name) {
+		for (OutlineContainer container : m_HierarchyDatabase.values()) {
+			OutlineElement element = container.findTopLevelElement(name);
+			if (element != null)
+				return element;
+		}
+		return null;
+	}
+
+	
+	/**
+	 * Class used to inform the listeners of change
+	 * 
+	 * @author gho18481
+	 * 
+	 */
+	public abstract static class OutlineDatabaseEvent{
+		public abstract void handel();
+		
+		protected void run() {
+			Display.getDefault().asyncExec(new Runnable() {
+	               public void run() {
+	            	   handel();
+	               }
+	            }
+			);
+		}
+	}
+	
+	/**
+	 * Adds a listener to the list of listeners
+	 * @param eventListner
+	 */
+	public void addChangeListner(OutlineDatabaseEvent eventListener){
+		synchronized(m_Listeners){
+			m_Listeners.add(eventListener);
+		}
+	}
+	
+	
+	/**
+	 * Adds a listener to the list of listeners
+	 * @param eventListner
+	 */
+	public void removeChangeListner(OutlineDatabaseEvent eventListener){
+		synchronized(m_Listeners){
+			m_Listeners.remove(eventListener);
+		}
+	}
+	
+	/**
+	 * Fires a change event
+	 */
+	protected void fireChangeEvent(){
+		synchronized(m_Listeners){
+			for(int i=0;i<m_Listeners.size();i++){			
+				m_Listeners.get(i).run();
+			}
+		}
+	}
+	
+	/**
+	 * Class used to launch the project scanning task
+	 * @author gho18481
+	 *
+	 */
+	private class ScanProjectJob extends Job {
+		private Vector<IFile> m_Files;
+		
+		/**
+		 * Constructor
+		 * @param files to scan
+		 */
+		public ScanProjectJob(Vector<IFile> files) {
+			super("Scanning HDL Files");
+			m_Files=files;
+		}
+
+		public IStatus run(IProgressMonitor monitor) {
+			final int ticks = m_Files.size();
+			long nTime,interval;
+			String  sInterval=VerilogPlugin.getPreferenceString(PreferenceStrings.MIN_RESCAN_TIME);
+			try{
+				interval = Integer.parseInt(sInterval);
+			}catch (NumberFormatException e) {
+				interval=2000;
+			}
+			interval*=1000000;
+			nTime=System.nanoTime()+interval;
+			monitor.beginTask("Scanning HDL Files", ticks);
+			try {
+				for (int i = 0; i < ticks; i++) {
+					if (monitor.isCanceled()){
+						m_ScanState=ScanState.CANCELLED;
+						return Status.CANCEL_STATUS;
+					}
+					monitor.subTask("Scanning " + m_Files.get(i).getName());
+					scanFile(m_Files.get(i));
+					monitor.worked(1);
+					/* ConcurrentHashMap did the job? */
+					if (System.nanoTime()>=nTime) {
+						/* TODO: How to find Display JobManager? then only fire here if isIdle() */
+						fireChangeEvent(); /* seems to flood redrawing of the tree - make it smart?*/
+						nTime=System.nanoTime()+interval;
+						if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_DATABASE))
+							System.out.println("Time: "+System.nanoTime()+" next="+nTime+" interval="+interval);
+					}
+				}
+			} finally {
+				monitor.done();
+				fireChangeEvent(); /* Fire here after scanning is over */
+			}
+			SemanticWarnings.clearWarningsGenerated();
+			m_ScanState=ScanState.DONE;
+//			SelectedResourceManager.getDefault().getToolSequence().finalizeBootAfterVEditor();
+  			Display.getDefault().asyncExec(new Runnable() {
+ 				public void run() {
+ 					try {
+ 						SelectedResourceManager.getDefault().getToolSequence().finalizeBootAfterVEditor();
+ 					} catch (Exception e){
+						System.out.println("Failed to execute SelectedResourceManager.getDefault().getToolSequence().finalizeBootAfterVEditor() - Null pointer?");
+ 					}
+					// re-pase document in the editor
+					if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.FULL_REPARSE)) {
+						// reparse all "important" (not filtered out) files so to make problem list valid
+						// (Just scanning tree uses a single pass that leaves many false warnings 
+						fullParseFilteredFiles();
+					}
+					// full reparse just a single file - the one in the editor
+					if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR)) {
+						System.out.println("Parsing document in the Editor after initial building of the database");
+					}
+					HdlEditor current=HdlEditor.current();
+					if (current!=null) {
+						current.updatePagesIfFree(true); // Only if there is HDL editor in the editor
+						HdlDocument doc=current.getHdlDocument();
+						if (doc!=null)
+							try {
+								doc.uncondRefreshOutline();
+							} catch (HdlParserException e) {
+								System.out.println("Failed to doc.uncondRefreshOutline()");
+							}
+						//						current.refreshEditor(); // This reload file to the editor, or changes are lost!
+					}
+
+				}
+			});
+			return Status.OK_STATUS;
+		}
+	}
+
+	/**
+	 * Class used to launch the project scanning task
+	 */
+	private class ScanTreeJob extends Job {
+		private IFile file;
+		
+		/**
+		 * Constructor
+		 * @param files to scan
+		 */
+		public ScanTreeJob(IFile file) {
+			super("Scanning HDL Tree");
+			this.file = file;
+		}
+
+		public IStatus run(IProgressMonitor monitor) {
+			monitor.beginTask("Scanning HDL Tree", 1);
+			try {
+				scanChildrenFiles(file);
+				monitor.worked(1);
+				fireChangeEvent();
+			} finally {
+				monitor.done();
+			}
+			m_ScanState=ScanState.DONE;
+			return Status.OK_STATUS;
+		}
+	}
+	
+	/**
+	 * @return The current scan state
+	 */
+	public ScanState getScanState(){
+		return m_ScanState;
+	}
+	public Vector<IFile> getProjectFilesList(){
+		return getProjectFiles(m_Project);
+	}
+	
+	/**
+	 * Public access to scan function
+	 */
+	public void scanProject() {
+		if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.SCAN_ENABLE)) {
+
+			Vector<IFile> files = getProjectFiles(m_Project);
+			VerilogPlugin.deleteMarkers(m_Project);
+			if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_DATABASE))
+				System.out.println("scanProject(), m_ScanState="+m_ScanState);
+			if (m_ScanState != ScanState.IN_PROGRESS) {
+				if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.SCAN_RESET)) { //SCAN_RESET
+					 clearDatabase();
+				}
+				if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_DATABASE))
+					System.out.println("scanProject(), proceeding...");
+				ScanProjectJob job = new ScanProjectJob(files);
+				m_ScanState = ScanState.IN_PROGRESS;
+				// not a critical job
+				job.setPriority(Job.DECORATE);
+				job.schedule();
+			}
+		}
+	}
+	/**
+	 * Searches the project for a list of files to be scanned
+	 */
+	private Vector<IFile> getProjectFiles(IContainer root){
+		IResource[] members;
+		Vector<IFile> results=new Vector<IFile>();
+		
+		try {
+			members = root.members();
+			for (int i = 0; i < members.length; i++) {
+				if (members[i] instanceof IContainer){
+					results.addAll(getProjectFiles((IContainer)members[i]));
+				} else if (members[i] instanceof IFile) {
+					IFile file = (IFile) members[i];					
+//					if(file.getName().endsWith(".v") || file.getName().endsWith(".vhd")){
+					if(isVerilogFile(file) || isVhdlFile(file)){
+						results.add(file);
+					}
+				}
+			}
+			
+		} catch (CoreException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+		return results;
+	}
+
+	/**
+	 * Public access to scan function
+	 */
+	public void scanTree(IFile file){
+		if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.SCAN_ENABLE) == false) {
+			if (m_ScanState != ScanState.IN_PROGRESS) {
+				ScanTreeJob job = new ScanTreeJob(file);
+				m_ScanState = ScanState.IN_PROGRESS;
+				// not a critical job
+				job.setPriority(Job.DECORATE);
+				job.schedule();
+			}
+		}
+	}
+
+	public void scanFilesWithDefine(IFile file, String define){
+        
+        OutlineDatabase masterBase = OutlineDatabase.getProjectsDatabase(m_Project);
+        m_HierarchyDatabase = masterBase.getToolCache(file, define);
+        
+        
+        if (m_HierarchyDatabase != null) {
+        	DEBUG_PRINT("---------------- scanFilesWithDefines("+file+", "+ define+") - cache HIT, got "+m_HierarchyDatabase.size());        	
+        	return; // using previously calculated database
+        }
+    	DEBUG_PRINT("-=-=-=-=-=-=-=-= scanFilesWithDefines("+file+", "+ define+") - cache MISS");        	
+		clearDatabase();
+        Map<String, String> defines = new HashMap<String, String>();
+        if ((define != null) && (define !="")) defines.put(define,"");
+        
+        //		System.out.println("===== scanFilesWithDefines("+file+")");
+		Map<String, String> top_defines = scanFile(file , defines); // scan top file, add defines
+		for (Map.Entry<String, String> entry : top_defines.entrySet()) {
+        	DEBUG_PRINT(entry.getKey()+": '"+entry.getValue()+"'");
+		}		
+		
+		// scan all children, use same pre-defines
+		scanChildrenFiles(file, top_defines, masterBase);
+		masterBase.setToolCache(m_HierarchyDatabase, file, define);
+    	DEBUG_PRINT("===== scanFilesWithDefines("+file+", "+ define+") - saving "+m_HierarchyDatabase.size());        	
+	}
+
+	/**
+	 * Scan children recursively - seems it was broken/not used, could not find module definitions in
+	 * differently called files
+	 */
+	private void scanChildrenFiles(IFile file){
+//    	DEBUG_PRINT("*** OutlineDatabase.scanChildrenFiles("+file+")");
+		String [] patterns=getExtList(VerilogPlugin.getPreferenceString(PreferenceStrings.VERILOG_EXT));
+		OutlineContainer container = getOutlineContainer(file);
+		OutlineElement[] elements = container.getTopLevelElements();
+		for(int i = 0; i < elements.length; i++){
+			OutlineElement[] children = elements[i].getChildren();
+			for(int j = 0; j < children.length; j++)
+			{
+				if (children[j] instanceof VerilogInstanceElement)
+				{
+					VerilogInstanceElement instance = (VerilogInstanceElement)children[j];
+					String[] types = instance.getType().split("#");
+					OutlineElement[] element = findTopLevelElements(types[1], true);
+					//DEBUG_PRINT("referenced module "+types[1]+" num element="+element.length);
+					if (element.length == 0)
+					{
+						for (int ii=0;ii<patterns.length;ii++) {
+							IFile found = findFile(m_Project, types[1] + patterns[ii]);
+				        	DEBUG_PRINT("findFile("+m_Project+", "+(types[1] + patterns[ii])+") -> "+found);
+							if (found != null)
+							{   
+								scanFile(found);
+								scanChildrenFiles(found);
+								break;
+							}
+						}
+					}
+				}
+				// TODO: VHDL files must be scanned
+			}
+		}
+	}
+	// Use defines from the tool and from the top file (if provided) for all other files
+	private void scanChildrenFiles(IFile file, Map<String, String> defines, OutlineDatabase masterBase){
+    	DEBUG_PRINT("+++ OutlineDatabase.scanChildrenFiles("+file+", "+((defines==null)?"null":defines.size())+")");
+		OutlineContainer container = getOutlineContainer(file);
+		OutlineElement[] elements = container.getTopLevelElements();
+		for(int i = 0; i < elements.length; i++){
+			OutlineElement[] children = elements[i].getChildren();
+			for(int j = 0; j < children.length; j++)
+			{
+				if (children[j] instanceof VerilogInstanceElement)
+				{
+					VerilogInstanceElement instance = (VerilogInstanceElement)children[j];
+					String[] types = instance.getType().split("#");
+					OutlineElement[] element = findTopLevelElements(types[1], true);
+					if (element.length == 0) { // Not in this database
+						// Here need to search master database
+					    element = masterBase.findTopLevelElements(types[1], true); // search in master
+			        	DEBUG_PRINT("referenced module "+types[1]+" num element="+element.length);
+						// here get file name, and check that this (not master) database does not have it
+						if (element.length > 0){
+							IFile moduleDefinition = element[0].getFile();
+							scanFile(moduleDefinition , defines);
+							scanChildrenFiles(moduleDefinition, defines, masterBase);
+						} else {
+							String xcrap = (types[1].startsWith("B_"))?"Is it some X...x binary crap?":"";
+							System.out.println("No definitions for the referenced module "+types[1]+ ". "+xcrap);
+						}
+					}
+				}
+			}
+		}
+	}
+	
+	/**
+	 * search definition from instance
+	 */
+	public OutlineElement findDefinition(OutlineElement instance) {
+		if (instance instanceof VerilogInstanceElement) {
+			String[] types = instance.getType().split("#");
+			OutlineElement[] element = findTopLevelElements(types[1], true);
+			if (element.length == 0)
+				return null;
+			else
+				return element[0];
+		}
+		// TODO: VHDL module must be found
+		return null;
+	}
+	public OutlineElement [] findAllDefinitions(OutlineElement instance) {
+		if (instance instanceof VerilogInstanceElement) {
+			String[] types = instance.getType().split("#");
+			OutlineElement[] element = findTopLevelElements(types[1], true);
+			if (element.length == 0)
+				return null;
+			else
+				return element;
+		}
+		// TODO: VHDL module must be found
+		return null;
+	}
+
+	
+	
+	/**
+	 * Searches file for name in the project
+	 * 
+	 * @return
+	 */
+	private IFile findFile(IContainer root, String fileName) {
+		try {
+			IResource[] members;
+			members = root.members();
+			for (int i = 0; i < members.length; i++) {
+				if (members[i] instanceof IContainer) {
+					IFile file = findFile((IContainer) members[i], fileName);
+					if (file != null)
+						return file;
+				}
+				if (members[i] instanceof IFile) {
+					IFile file = (IFile) members[i];
+					if (fileName.equals(file.getName()))
+						return file;
+				}
+			}
+		} catch (CoreException e) {
+		}
+		return null;
+	}
+	
+	/**
+	 * Scans a single file and adds its contents to the database
+	 * 
+	 * @param file
+	 *            file to be scanned
+	 */
+	private void scanFile(IFile file) { // Old/normal way
+		String text= VerilogUtils.getEditorText(file);
+		try {
+			IParser parser=null;
+			//			if (file.getName().endsWith(".v")){
+			if (isVerilogFile(file)){
+				// VerilogParserReader handles verilog compiler directive
+//					ParserReader reader = new VerilogParserReader(file.getContents(), file);
+				ParserReader reader = (text==null)?
+						(new VerilogParserReader(file.getContents(), file)): // use file
+						(new VerilogParserReader(text, file)); // use one of the files open in the editor (possibly dirty)
+				// remove same file from the outline database here (if exists)
+				m_HierarchyDatabase.remove(file); 
+				parser = ParserFactory.createVerilogParser(reader, m_Project,
+						file); /* Creates file on outline database */
+				//			} else 	if (file.getName().endsWith(".vhd")){
+			} else 	if (isVhdlFile(file)){
+				ParserReader reader = new ParserReader(file.getContents());
+				// remove same file from the outline database here (if exists)
+				m_HierarchyDatabase.remove(file); 
+				parser = ParserFactory.createVhdlParser(reader, m_Project, file); /* Creates file on outline database */
+			}
+			//do we have parser
+			if(parser!= null){
+				parser.parse();				
+			}
+		} catch (CoreException e) {
+		} catch (HdlParserException e){
+
+		}
+	}
+
+	// Modified version - just to scan for tools closure
+	private Map<String,String> scanFile(IFile file, Map<String,String> defines) {
+    	DEBUG_PRINT("+++ OutlineDatabase.scanFile("+file+"), m_Project="+m_Project);
+		String text= VerilogUtils.getEditorText(file);
+		Map<String,String> new_defines = null;
+        OutlineDatabase masterBase = OutlineDatabase.getProjectsDatabase(m_Project);
+        OutlineContainer masterFileContainer = null; 
+        
+		IParser parser=null;
+		ParserReader reader = null;
+        
+		try {
+			//			if (file.getName().endsWith(".v")){
+			if (isVerilogFile(file)){
+				// VerilogParserReader handles verilog compiler directive
+				reader = (text==null)?
+						(new VerilogParserReader(file.getContents(), file, defines)): // use file
+						(new VerilogParserReader(text, file, defines)); // use one of the files open in the editor (possibly dirty)
+						
+				new_defines= ((VerilogParserReader) reader).getDefines();
+	            masterFileContainer =  masterBase.m_HierarchyDatabase.remove(file); 
+
+                // remove same file from the outline database here (if exists)
+				parser = ParserFactory.createVerilogParser(reader, m_Project, // Parser uses project OutlineDatabase
+						file); /* Creates file on outline database */
+/*			
+			} else 	if (isVhdlFile(file)){ // Just a broken placeholder
+				reader = new ParserReader(file.getContents());
+				// remove same file from the outline database here (if exists)
+				m_HierarchyDatabase.remove(file); 
+				parser = ParserFactory.createVhdlParser(reader, m_Project, file);
+*/				
+			}
+		} catch (CoreException e) {
+//		} catch (HdlParserException e){
+
+		}
+		if (parser!= null){
+    		try {
+    			parser.parse(0);
+			} catch (HdlParserException e){
+				System.out.println("+++ OutlineDatabase.scanFile("+file+"), parse() FAILED "+e.getMessage()); 
+    		}
+            // Exchange new file OutlineContainer with the original one - put this to a new database, save old one back here
+            if (masterBase.m_HierarchyDatabase.get(file) !=null) {
+            	m_HierarchyDatabase.put(file, masterBase.m_HierarchyDatabase.remove(file));
+            }
+            if (masterFileContainer!=null){
+            	masterBase.m_HierarchyDatabase.put(file,masterFileContainer);
+            }
+//			System.out.println("+++ OutlineDatabase.scanFile("+file+"), parse() done");
+            //Now master(project) OutlineDatabase is unchanged, the new one (this) should have this file entry
+            if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_CLOSURE)) {
+	            OutlineContainer thisContainer = m_HierarchyDatabase.get(file);
+	            OutlineContainer masterContainer = masterBase.m_HierarchyDatabase.get(file);
+	            if (thisContainer!=null){
+	            	OutlineElement[] toe= thisContainer.getTopLevelElements();
+	            	for (OutlineElement oe : toe) {
+	            		System.out.print(oe.getName()+" ");
+	            	}
+	        		System.out.println();
+	            }
+	            if (masterContainer!=null){
+	            	OutlineElement[] moe= masterContainer.getTopLevelElements();
+	            	for (OutlineElement oe : moe) {
+	            		System.out.print(oe.getName()+" ");
+	            	}
+	        		System.out.println();
+            }
+            }
+		}
+		
+		return new_defines;
+	}
+
+	 /**
+	  * Class used to determine the changes
+	  *
+	  */
+	 class DeltaPrinter implements IResourceDeltaVisitor {
+		public boolean visit(IResourceDelta delta) {
+			IResource res = delta.getResource();
+			if ((res instanceof IFile) && (delta.getFlags() != IResourceDelta.MARKERS)) {
+				IFile file = (IFile) res;
+//                System.out.println(String.format("DeltaPrinter( ): %s : flags=0x%x",res.toString(), delta.getFlags()));
+				switch (delta.getKind()) {
+				case IResourceDelta.ADDED:
+					if(file.getName().endsWith(".v") || file.getName().endsWith(".vhd")){
+						// just scan added file
+//						System.out.println("File added: "+file.getFullPath()+", scanning...");
+						scanFile(file);
+					}
+					break;
+				case IResourceDelta.REMOVED:
+					//remove this file from the outline database
+					m_HierarchyDatabase.remove(file);
+					break;
+				case IResourceDelta.CHANGED:
+					break;
+				}
+				invalidateToolCache();
+				
+            }
+		    return true; // visit the children
+		}
+	}
+	 
+	/**
+	 * Class used to keep track of workspace resources
+	 */
+	class resourceChangeListern implements IResourceChangeListener {
+		/**
+		 * Called when a resource is changed
+		 */
+		public void resourceChanged(IResourceChangeEvent event) {
+			switch (event.getType()) {
+			case IResourceChangeEvent.PRE_CLOSE:
+				break;
+			case IResourceChangeEvent.PRE_DELETE:
+				break;
+			case IResourceChangeEvent.POST_CHANGE:
+				try {
+					event.getDelta().accept(new DeltaPrinter());
+				} catch (CoreException e) {
+					// TODO Auto-generated catch block
+					e.printStackTrace();
+				}
+				break;
+			case IResourceChangeEvent.PRE_BUILD:
+				break;
+			case IResourceChangeEvent.POST_BUILD:
+				break;
+			}
+		}
+	}
+	public void fullParseFilteredFiles(){ // not used?
+		if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR)) {
+			System.out.println("fullParseFilteredFiles()");
+		}
+		if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.FULL_REPARSE) == false) {
+			return; // re-parsing is disabled
+		}
+		if (m_HierarchyDatabase==null) { // should be called after the database is already scanned
+			System.out.println("Can not run fullParseFilteredFiles() as database is null");
+			return;
+		}
+		if (m_ScanState != ScanState.DONE) {
+			System.out.println("Can not run fullParseFilteredFiles() as database is not DONE, it is "+m_ScanState);
+			return;
+		}
+		IFile [] files=getDatabaseFileList();
+		VerilogParseMultipass verilogParseMultipass=new VerilogParseMultipass();
+		for (IFile file:files) if (isVerilogFile(file)){
+			boolean needProcess=!VerilogPlugin.filterMarkes(file,true); // ignore TOP_ONLY, always filter
+			verilogParseMultipass.parseMultiPass(file, needProcess);
+		}
+	}
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/OutlineElementFactory.java vdt/src/com/elphel/vdt/veditor/parser/OutlineElementFactory.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/OutlineElementFactory.java	2016-06-24 10:29:40.856495517 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/OutlineElementFactory.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,25 +1,36 @@
-/*******************************************************************************
- * Copyright (c) 2006 Ali Ghorashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    Ali Ghorashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.parser;
-
-import org.eclipse.core.resources.IFile;
-
-/**
- * This class defines the interface for class factory that generates outline elements
- * based on the given type
- *
- */
-abstract public class OutlineElementFactory {
-	//do not directly instantiate
-	protected OutlineElementFactory() {}
-	
-	abstract public OutlineElement CreateElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file);
-}
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2006 Ali Ghorashi and others.
+ *
+ * Contributors:
+ *    Ali Ghorashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.parser;
+
+import org.eclipse.core.resources.IFile;
+
+/**
+ * This class defines the interface for class factory that generates outline elements
+ * based on the given type
+ *
+ */
+abstract public class OutlineElementFactory {
+	//do not directly instantiate
+	protected OutlineElementFactory() {}
+	
+	abstract public OutlineElement CreateElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file);
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/OutlineElement.java vdt/src/com/elphel/vdt/veditor/parser/OutlineElement.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/OutlineElement.java	2016-06-24 10:29:40.856495517 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/OutlineElement.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,250 +1,545 @@
-/*******************************************************************************
- * Copyright (c) 2007 Ali Ghorashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    Ali Ghorashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.parser;
-
-import java.io.BufferedReader;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Vector;
-
-import org.eclipse.core.resources.IFile;
-
-/**
-* Class to describe the element and its children
-*/
-public class OutlineElement extends Object{
-	protected String m_Name;
-	protected String m_HashString;
-	protected IFile m_File;
-	protected int m_StartingLine, m_StartingCol;
-	protected int m_EndingLine, m_EndingCol;
-	protected List<OutlineElement> m_Children;	
-	protected OutlineElement m_Parent;
-	protected String m_Type;
-	protected boolean m_bIsVisible;
-	
-	public String GetImageName(){
-		return null;
-	}
-	
-	/* (non-Javadoc)
-	 * @see java.lang.Object#equals(java.lang.Object)
-	 */
-	public boolean equals(Object obj){
-		if (obj instanceof OutlineElement) {
-			OutlineElement outlineElem = (OutlineElement) obj;
-			
-			if (outlineElem.m_HashString.equals(m_HashString)){
-				return true;
-			}		
-		}
-		return false;
-	}
-	
-	/* (non-Javadoc)
-	 * @see java.lang.Object#hashCode()
-	 */
-	public int hashCode(){		
-		return m_HashString.hashCode();		
-	}
-	/**
-	 * Constructor
-	 * @param name element name
-	 * @param startLine element's starting line
-	 * @param endLine The element's ending line
-	 * @param file The filename the element lives in
-	 * @param bVisible If true, this element will appear in the outline, if false it will be used for
-	 * internal bookkeeping only
-	 */
-	public OutlineElement(String name,
-			String type,
-			int startLine,
-			int startCol,
-			int endLine,
-			int endCol,
-			IFile file,
-			boolean bVisible){
-		m_Name = name;
-		m_StartingLine = startLine;
-		m_StartingCol= startCol;
-		m_EndingLine = endLine;
-		m_EndingCol = endCol;
-		m_bIsVisible=bVisible;
-		m_File = file;
-		m_Children = new ArrayList<OutlineElement>();
-		// all children are created as orphans :)
-		m_Parent = null;
-		m_Type = type;
-		m_HashString = m_Name+"#"+type;
-	}
-	
-	public boolean isVisible(){
-		return m_bIsVisible;
-	}
-	
-	public String toString()
-	{
-		return m_Name;
-	}
-	/**
-	* Adds an element to the child list
-	* @param element The element to add
-	*/
-	public void AddChild(OutlineElement element){
-		element.m_Parent = this;
-		m_Children.add(element);
-	}
-	/**
-	 *@return True if the element has any children
-	 */
-	public boolean HasChildren(){
-		return (m_Children.size()!= 0);
-	}
-	/**
-	* Determines if an element is child of another
-    */
-	public boolean IsAChildOf(OutlineElement child){
-		// both modules must live in the same file
-		if ( !m_File.equals(child.getFile())){
-			return false;
-		}
-		
-		return false;
-	}
-	/**
-	 * @return The name of this element
-	 */
-	public String getName() {
-		return m_Name;
-	}
-	
-	/**
-	 * @return The name of this element with all the decorations
-	 */
-	public String getLongName(){
-		return m_Name;
-	}
-	
-	public String getFullSourceCode(){
-		try {
-			InputStream is = m_File.getContents(true);
-			BufferedReader br = new BufferedReader(new InputStreamReader(is));
-			int line=1;
-			for(;line < m_StartingLine;line++)	br.readLine();
-			StringBuffer sb = new StringBuffer();
-			
-			Vector<String> lines = new Vector<String>();
-			lines.add(br.readLine()); line++;
-			
-			for(;line <= m_EndingLine;line++)	{
-				lines.add(br.readLine());
-			}
-			br.close();
-			is.close();
-			
-			String firstline = lines.elementAt(0);
-			int wordstart = 0;
-			for(;wordstart < firstline.length();wordstart++){
-				char c = firstline.charAt(wordstart);
-				if(c==9 || c==32)continue;
-				break;
-			}
-			
-			String whitespace = firstline.substring(0,wordstart);
-			
-			for(int i=0; i<lines.size();i++){
-				String a = lines.elementAt(i);
-				String b = a;
-				if(wordstart != 0){
-					if(a.startsWith(whitespace))b = a.substring(wordstart);
-				}
-				if(i!=0)sb.append("\n");
-				sb.append(b);
-			}
-			
-			
-			return sb.toString().trim();
-		} catch (Exception e) {
-			e.printStackTrace();
-			return "";
-		}
-	}
-	
-
-	/**
-	 * @return The name of this element with minimum decorations
-	 */
-	public String getShortName(){
-		return m_Name;
-	}
-	/**
-	 * @return Number of lines between begin and end
-	 */
-	public int getLength(){
-		return m_EndingLine - m_StartingLine;
-	}
-	public void setName(String name) {
-		m_Name = name;
-		m_HashString = m_Name+"#"+m_Type;
-	}
-	public IFile getFile() {
-		return m_File;
-	}
-	public void setFile(IFile file) {
-		m_File = file;
-	}
-	public int getStartingLine() {
-		return m_StartingLine;
-	}
-	public int getEndingLine() {
-		return m_EndingLine;
-	}
-	public void setEndingLine(int endingLine) {
-		m_EndingLine = endingLine;
-	}		
-	public void setEndingCol(int col){m_EndingCol=col;}
-	public int  getEndingCol(){return m_EndingCol;}
-	public int  getStartingCol(){return m_StartingCol;} 
-	
-	public OutlineElement getParent() {
-		return m_Parent;
-	}
-	public void setParent(OutlineElement parent) {
-		m_Parent = parent;
-	}
-
-	public OutlineElement[] getChildren() {
-		return m_Children.toArray(new OutlineElement[0]);
-	}
-	
-	public OutlineElement findChild(String name) {
-		for (OutlineElement child : m_Children) {
-			if (child.getName().equals(name)) {
-				return child;
-			}
-		}
-		return null;
-	}
-
-	public OutlineElement getChild(int index) {
-		if (index < m_Children.size())
-			return m_Children.get(index);
-		else
-			return null;
-	}
-
-	public String getType() {
-		return m_Type;
-	}
-	
-}
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2007 Ali Ghorashi and others.
+ *
+ * Contributors:
+ *    Ali Ghorashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.parser;
+
+import java.io.BufferedReader;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.StringReader;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Vector;
+
+import org.eclipse.core.resources.IFile;
+
+import com.elphel.vdt.veditor.VerilogPlugin;
+import com.elphel.vdt.veditor.document.HdlDocument;
+import com.elphel.vdt.veditor.editor.HdlEditor;
+import com.elphel.vdt.veditor.parser.verilog.VerilogOutlineElementFactory;
+import com.elphel.vdt.veditor.preference.PreferenceStrings;
+import com.elphel.vdt.veditor.parser.OutlineElement;
+
+/**
+* Class to describe the element and its children
+*/
+public class OutlineElement extends Object{
+	protected String m_Name;
+	protected String m_HashString;
+	protected IFile m_File;
+	protected int m_StartingLine, m_StartingCol;
+	protected int m_EndingLine, m_EndingCol;
+	protected List<OutlineElement> m_Children;	
+	protected OutlineElement m_Parent;
+	protected String m_Type;
+	protected boolean m_bIsVisible;
+	// needed for ports that may have width depending on parameters
+	protected List<String> m_Depends=new ArrayList<String>();
+    // Andrey: this is not yet used
+	protected String lateDescription=null; // Additional description (bit ranges, value) calculated during multi-pass parsing
+	public String getLateDescription(){
+		return lateDescription;
+	}
+	public void setLateDescription(String description){
+		lateDescription=description;
+	}
+	
+	public void addDepend(OutlineElement oe){
+		if (oe==null) return;
+		String hash=oe.m_Name+"#"+oe.m_Type.split("#")[0]; // name#type (name#parameter or name#localparam)
+		if (!m_Depends.contains(hash)) m_Depends.add(hash);
+	}
+	public void addAllDepends(OutlineElement oe){
+		if (oe==null) return;
+		addDepend(oe); // element itself
+		for (String hash:oe.m_Depends)
+			if (!m_Depends.contains(hash)) m_Depends.add(hash);
+	}
+	public void addEncodedDeps(String encodedDeps){
+		String [] deps=encodedDeps.split(":");
+		for (String hash:deps)
+			if (!m_Depends.contains(hash)) m_Depends.add(hash);
+	}
+	public List<String> getDepends(){
+		return m_Depends;
+	}
+	
+	public String GetImageName(){
+		return null;
+	}
+	
+	/* (non-Javadoc)
+	 * @see java.lang.Object#equals(java.lang.Object)
+	 */
+	public boolean equals(Object obj){
+		if (obj instanceof OutlineElement) {
+			OutlineElement outlineElem = (OutlineElement) obj;
+			
+			if (outlineElem.m_HashString.equals(m_HashString)){
+				return true;
+			}		
+		}
+		return false;
+	}
+	
+	/* (non-Javadoc)
+	 * @see java.lang.Object#hashCode()
+	 */
+	public int hashCode(){		
+		return m_HashString.hashCode();		
+	}
+	/**
+	 * Constructor
+	 * @param name element name
+	 * @param startLine element's starting line
+	 * @param endLine The element's ending line
+	 * @param file The filename the element lives in
+	 * @param bVisible If true, this element will appear in the outline, if false it will be used for
+	 * internal bookkeeping only
+	 */
+	public OutlineElement(String name,
+			String type,
+			int startLine,
+			int startCol,
+			int endLine,
+			int endCol,
+			IFile file,
+			boolean bVisible){
+		m_Name = name;
+		m_StartingLine = startLine;
+		m_StartingCol= startCol;
+		m_EndingLine = endLine;
+		m_EndingCol = endCol;
+		m_bIsVisible=bVisible;
+		m_File = file;
+		m_Children = new ArrayList<OutlineElement>();
+		// all children are created as orphans :)
+		m_Parent = null;
+		m_Type = type;
+//		m_HashString = m_Name+"#"+type;
+		m_HashString = m_Name+"#"+type+"#"+startLine+":"+startCol; // In outline view got wrong element that had the same hash string
+	}
+	// Andrey
+	public void setVisible (boolean visible){
+		m_bIsVisible=visible;
+	}
+	
+	public boolean isVisible(){
+		return m_bIsVisible;
+	}
+	
+	public String toString()
+	{
+		return m_Name;
+	}
+	/**
+	* Adds an element to the child list
+	* @param element The element to add
+	*/
+	public void AddChild(OutlineElement element){
+		element.m_Parent = this;
+		m_Children.add(element);
+	}
+
+	// Andrey
+	public void replaceChild(int index, OutlineElement element){
+		element.m_Parent = this;
+		m_Children.set(index,element);
+	}
+
+	// Add module's port as a child to instance port
+	public void makeAChild(OutlineElement element){
+//		element.m_Parent = this;
+		m_Children.add(element);
+	}
+
+	
+	/**
+	 * Check if the same element already exist 
+	 * @param element
+	 * @return existent element or null
+	 * by Andrey
+	 */
+	public OutlineElement sameChildThis(OutlineElement element){
+		if (!HasChildren()) return null;
+		for (OutlineElement existentElement:m_Children){
+			if ((existentElement.m_Name.equals(element.m_Name)) &&
+					(existentElement.m_StartingLine == element.m_StartingLine) &&
+					(existentElement.m_StartingCol  == element.m_StartingCol)){
+				return existentElement;
+			}
+		}
+		return null;
+	}
+
+	public int sameChildThisIndex(OutlineElement element){
+		if (!HasChildren()) return -1;
+		for (int i=0;i< m_Children.size();i++){
+			OutlineElement existentElement=m_Children.get(i);
+			if ((existentElement.m_Name.equals(element.m_Name)) &&
+					(existentElement.m_StartingLine == element.m_StartingLine) &&
+					(existentElement.m_StartingCol  == element.m_StartingCol)){
+				return i;
+			}
+		}
+		return-1;
+	}
+	
+	// Andrey
+	public void clearChildren(){
+		m_Children.clear();
+	}
+	
+	/**
+	 *@return True if the element has any children
+	 */
+	public boolean HasChildren(){
+		return (m_Children.size()!= 0);
+	}
+	/**
+	* Determines if an element is child of another
+    */
+	public boolean IsAChildOf(OutlineElement child){
+		// both modules must live in the same file
+		if ( !m_File.equals(child.getFile())){
+			return false;
+		}
+		
+		return false;
+	}
+	/**
+	 * @return The name of this element
+	 */
+	public String getName() {
+		return m_Name;
+	}
+	
+	/**
+	 * @return The name of this element with all the decorations
+	 */
+	public String getLongName(){
+		return m_Name;
+	}
+	
+	public String getFullSourceCode(){
+		//TODO: Andrey:  If document is open in the editor, use editor window, not the file:
+		String text=null;
+		try{
+			HdlDocument document=  HdlEditor.current().getHdlDocument();
+			if (document.getFile().equals(m_File)) text=document.get();
+		} catch (Exception e){
+			text=null; // Other file, not the editor window
+		}
+		try {
+			BufferedReader br;
+			InputStream is=null;
+			if (text!=null) {
+				br = new BufferedReader(new StringReader(text));
+			} else {
+				is = m_File.getContents(true);
+				br = new BufferedReader(new InputStreamReader(is));
+			}
+			int line=1;
+			for(;line < m_StartingLine;line++)	br.readLine();
+			StringBuffer sb = new StringBuffer();
+			
+			Vector<String> lines = new Vector<String>();
+			lines.add(br.readLine()); line++;
+			
+			for(;line <= m_EndingLine;line++)	{
+				lines.add(br.readLine());
+			}
+			br.close();
+			if (is!=null) is.close();
+			
+			String firstline = lines.elementAt(0);
+			int wordstart = 0;
+			if (firstline==null) return "";
+			for(;wordstart < firstline.length();wordstart++){
+				char c = firstline.charAt(wordstart);
+				if(c==9 || c==32)continue;
+				break;
+			}
+			
+			String whitespace = firstline.substring(0,wordstart);
+			
+			for(int i=0; i<lines.size();i++){
+				String a = lines.elementAt(i);
+				String b = a;
+				if(wordstart != 0){
+					if(a.startsWith(whitespace))b = a.substring(wordstart);
+				}
+				if(i!=0)sb.append("\n");
+				sb.append(b);
+			}
+			
+			
+			return sb.toString().trim();
+		} catch (Exception e) {
+			e.printStackTrace();
+			return "";
+		}
+	}
+	
+
+	/**
+	 * @return The name of this element with minimum decorations
+	 */
+	public String getShortName(){
+		return m_Name;
+	}
+	/**
+	 * @return Number of lines between begin and end
+	 */
+	public int getLength(){
+		return m_EndingLine - m_StartingLine;
+	}
+	public void setName(String name) {
+		m_Name = name;
+		m_HashString = m_Name+"#"+m_Type;
+	}
+	public IFile getFile() {
+		return m_File;
+	}
+	public void setFile(IFile file) {
+		m_File = file;
+	}
+	public int getStartingLine() {
+		return m_StartingLine;
+	}
+	public int getEndingLine() {
+		return m_EndingLine;
+	}
+	public void setEndingLine(int endingLine) {
+		m_EndingLine = endingLine;
+	}		
+	public void setEndingCol(int col){m_EndingCol=col;}
+	public int  getEndingCol(){return m_EndingCol;}
+	public int  getStartingCol(){return m_StartingCol;} 
+	
+	public OutlineElement getParent() {
+		return m_Parent;
+	}
+	public void setParent(OutlineElement parent) {
+		m_Parent = parent;
+	}
+
+	public OutlineElement[] getChildren() {
+		return m_Children.toArray(new OutlineElement[0]);
+	}
+	
+	public OutlineElement findChild(String name) {
+		for (OutlineElement child : m_Children) {
+			if (child.getName().equals(name)) {
+				return child;
+			}
+		}
+		return null;
+	}
+	
+	
+	public OutlineElement findHierarchicalChild(String name, OutlineDatabase database) {
+		if (!name.contains(".")) return findChild(name);
+		// try local first
+		OutlineElement e=this;
+		// if it is VerilogOutlineElement - go up to the module level
+		if (e instanceof VerilogOutlineElementFactory.VerilogOutlineElement){
+			VerilogOutlineElementFactory.VerilogOutlineElement ve=
+					(VerilogOutlineElementFactory.VerilogOutlineElement) e;
+			while (!ve.isModule() && (ve.getParent()!=null)){
+				e=ve.getParent();
+				if (e instanceof VerilogOutlineElementFactory.VerilogOutlineElement){
+					ve=	(VerilogOutlineElementFactory.VerilogOutlineElement) e;
+				} else {
+					break;
+				}
+			}
+		}
+		e=findHierarchicalChild(name, database, e);
+		if (e!=null) return e;
+		e=findHierarchicalChild(name, database, null); // global scope
+		// now try top modules
+//		System.out.println("findHierarchicalChild("+name+"), trying from top modules");
+/*		
+		e=database.findTopLevelElement(name.split("\\.")[0]);
+		if (e!=null) {
+			e=findHierarchicalChild(name, database, e);
+		} else {
+			//System.out.println("findHierarchicalChild("+name+"), failed");
+			// OK on the first pass before instances are set up
+		}
+*/		
+		return e;
+	}
+	
+	public OutlineElement findHierarchicalChild(String name, OutlineDatabase database,OutlineElement e) {
+//		if (!name.contains(".")) return findChild(name);
+		String [] hier=name.split("\\.");
+		for (int i=0;i<hier.length;i++){
+			if ((i==0) && (e==null)){
+				e=database.findTopLevelElement(hier[0]);
+				if (e==null) return null;
+			} else {
+				if (e==null) return null;
+				e=e.findChild(hier[i]);
+				if (e==null) return null;
+				if (i<(hier.length-1)){
+					if (!e.getType().split("#")[0].equals("instance")){
+						System.out.println("findHierarchicalChild("+name+"): not an instance: "+e.getType());
+						return null;
+					}
+					e=database.findDefinition(e);
+					if (e==null){
+						System.out.println("findHierarchicalChild("+name+"): could not find definition");
+					}
+				}
+			}
+		}
+		return e;
+	}
+
+	// Find all matching elements, starting with relative to the current module, then global
+	public OutlineElement[] findHierarchicalChildren (String name, OutlineDatabase database) {
+		if (database==null) return null;
+		if (!name.contains(".")) {
+			OutlineElement [] ee={findChild(name)};
+			if (ee[0]==null) return null;
+			return ee;
+		}
+		// try local first
+		OutlineElement e=this;
+		// if it is VerilogOutlineElement - go up to the module level
+		if (e instanceof VerilogOutlineElementFactory.VerilogOutlineElement){
+			VerilogOutlineElementFactory.VerilogOutlineElement ve=
+					(VerilogOutlineElementFactory.VerilogOutlineElement) e;
+			while (!ve.isModule() && (ve.getParent()!=null)){
+				e=ve.getParent();
+				if (e instanceof VerilogOutlineElementFactory.VerilogOutlineElement){
+					ve=	(VerilogOutlineElementFactory.VerilogOutlineElement) e;
+				} else {
+					break;
+				}
+			}
+		}
+		List<OutlineElement> list = findHierarchicalChildren(name, database, e);
+		if (list==null) list=new ArrayList<OutlineElement>();
+		e=database.findTopLevelElement(name.split("\\.")[0]);
+		List<OutlineElement> globalList=findHierarchicalChildren(name, database, null);
+		if (globalList!=null) list.addAll(globalList);
+		if (list.size()==0) return null;
+		return list.toArray(new OutlineElement[0]);
+
+	}
+	
+	/**
+	 *  Find elements matching hierarchical name (dot separated) and add them to the list using  recursiveFindChildren()
+	 * @param name element hierarchical name, all but last segment should be instances
+	 * @param database HDL database 
+	 * @param e current element to start search from. If null - look for the top level elements (modules)
+	 * @return list of matching elements
+	 */
+	public List<OutlineElement> findHierarchicalChildren(String name, OutlineDatabase database,OutlineElement e) {
+		ArrayList<OutlineElement> list = new ArrayList<OutlineElement>(); 
+		recursiveFindChildren(list, name, database, e );
+		return list;
+	}
+	
+	/**
+	 * Find elements matching hierarchical name (dot separated) and add them to the list
+	 * @param list list of already found elements
+	 * @param name element hierarchical name, all but last segment should be instances
+	 * @param database HDL database 
+	 * @param e current element to start search from. If null - look for the top level elements (modules)
+	 */
+	public void recursiveFindChildren(List<OutlineElement> list, String name,OutlineDatabase database, OutlineElement e ){
+		// remove first dot if the name starts with it
+/*		
+		if (name.startsWith(".")){
+			name = name.substring(1);
+		}
+*/		
+		String [] hier = {name};
+		if (name.contains(".")) {
+			hier=name.split("\\.");
+		}
+		if (e!=null) {
+			e=e.findChild(hier[0]);
+			if (e==null) return;
+			if (hier.length>1){
+				if (!e.getType().split("#")[0].equals("instance")){
+					System.out.println("recursiveFindChildren("+name+"): not an instance: "+e.getType());
+					return;
+				}
+			}
+		}
+		// for all segments, including the last if it is an instance 
+		// Assuming that same instance may have multiple definitions (in different files), but all
+		// other elements are unique
+		if ((e==null) || e.getType().split("#")[0].equals("instance")){
+			OutlineElement [] de;
+			if (e!=null){
+				de=database.findAllDefinitions(e);
+			} else {
+				de=database.findTopLevelElements(hier[0],true); // find top level modules with specified name
+			}
+			if (de.length>0){
+				if (hier.length>1){
+					String subName=hier[1];
+					for (int i=2;i<hier.length;i++){
+						subName+="."+hier[i];
+					}
+					for (int i=0;i<de.length;i++){
+						recursiveFindChildren(list, subName, database, de[i]);
+					}
+				} else {
+					for (int i=0;i<de.length;i++){
+						list.add(de[i]);
+					}
+				}
+			}
+		} else {
+			list.add(e);
+		}
+		
+		
+	}
+	
+//	public OutlineElement [] findAllDefinitions(OutlineElement instance) {
+	
+	
+	
+	
+
+	public OutlineElement getChild(int index) {
+		if (index < m_Children.size())
+			return m_Children.get(index);
+		else
+			return null;
+	}
+
+	public String getType() {
+		return m_Type;
+	}
+	// Andrey - update type without changing hash (when width is found after the element was created)
+	public void updateType(String newType){
+		m_Type=newType;
+	}
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/ParserFactory.java vdt/src/com/elphel/vdt/veditor/parser/ParserFactory.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/ParserFactory.java	2016-06-24 10:29:40.856495517 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/ParserFactory.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,54 +1,75 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.parser;
-
-import net.sourceforge.veditor.parser.verilog.VerilogParser;
-import net.sourceforge.veditor.parser.verilog.VerilogParserReader;
-import net.sourceforge.veditor.parser.vhdl.VhdlParser;
-
-import org.eclipse.core.resources.IFile;
-import org.eclipse.core.resources.IProject;
-
-/**
- * generate Verilog or VHDL parser
- */
-abstract public class ParserFactory
-{
-	// don't instantiate
-	private ParserFactory()
-	{
-	}
-		
-	public static IParser createVerilogParser(String text, IProject project, IFile file)
-	{
-		VerilogParserReader reader = new VerilogParserReader(text, file);
-		return new VerilogParser(reader, project, file);
-	}
-
-	public static IParser createVerilogParser(ParserReader reader, IProject project, IFile file)
-	{	    
-		return new VerilogParser(reader, project, file);
-	}
-
-	public static IParser createVhdlParser(String text, IProject project, IFile file)
-	{
-	    ParserReader reader=new ParserReader(text);
-		return new VhdlParser(reader, project, file);
-	}
-
-	public static IParser createVhdlParser(ParserReader reader, IProject project, IFile file)
-	{
-		return new VhdlParser(reader, project, file);
-	}
-
-}
-
-
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.parser;
+
+import java.util.Map;
+
+import com.elphel.vdt.veditor.parser.verilog.VerilogParser;
+import com.elphel.vdt.veditor.parser.verilog.VerilogParserReader;
+import com.elphel.vdt.veditor.parser.vhdl.VhdlParser;
+
+import org.eclipse.core.resources.IFile;
+import org.eclipse.core.resources.IProject;
+
+/**
+ * generate Verilog or VHDL parser
+ */
+abstract public class ParserFactory
+{
+	// don't instantiate
+	private ParserFactory()
+	{
+	}
+		
+	public static IParser createVerilogParser(String text, IProject project, IFile file)
+	{
+		VerilogParserReader reader = new VerilogParserReader(text, file);
+		return new VerilogParser(reader, project, file);
+	}
+
+	public static IParser createVerilogParser(ParserReader reader, IProject project, IFile file)
+	{	    
+		return new VerilogParser(reader, project, file);
+	}
+
+/*
+  	public static IParser createVerilogParser(String text, IProject project, IFile file, Map<String,String> defines)
+	{
+		VerilogParserReader reader = new VerilogParserReader(text, file, defines);
+		return new VerilogParser(reader, project, file);
+	}
+*/
+
+	public static IParser createVhdlParser(String text, IProject project, IFile file)
+	{
+	    ParserReader reader=new ParserReader(text);
+		return new VhdlParser(reader, project, file);
+	}
+
+	public static IParser createVhdlParser(ParserReader reader, IProject project, IFile file)
+	{
+		return new VhdlParser(reader, project, file);
+	}
+
+}
+
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/ParserReader.java vdt/src/com/elphel/vdt/veditor/parser/ParserReader.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/ParserReader.java	2016-06-24 10:29:40.856495517 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/ParserReader.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,15 +1,26 @@
-/*******************************************************************************
- * Copyright (c) 2011 VEditor Team
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2011 VEditor Team
  *
  * Contributors:
  *    Ali Ghorashi - initial API and implementation
  *    KOBAYASHI Tadashi - add initialize method used from VerilogParserReader
  *******************************************************************************/
-package net.sourceforge.veditor.parser;
+package com.elphel.vdt.veditor.parser;
 
 import java.io.IOException;
 import java.io.InputStream;
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/verilog/Expression.java vdt/src/com/elphel/vdt/veditor/parser/verilog/Expression.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/verilog/Expression.java	2016-06-24 10:29:40.856495517 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/verilog/Expression.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,19 +1,32 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2012 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+/*******************************************************************************
+ * Copyright (c) 2004, 2012 KOBAYASHI Tadashi and others.
  *
  * Contributors:
  *    KOBAYASHI Tadashi - initial API and implementation
  *******************************************************************************/
 
-package net.sourceforge.veditor.parser.verilog;
+package com.elphel.vdt.veditor.parser.verilog;
 
 import java.util.ArrayList;
 import java.util.Iterator;
+import java.util.List;
 
+import com.elphel.vdt.veditor.parser.OutlineElement;
 public class Expression {
 	public static final int INVALID_WIDTH = -1;
 	public static final int UNFIXED_WIDTH = 0; // used for non width indicated constant.
@@ -30,31 +43,121 @@
 	private String stringValue = null;
 	private boolean validString = false;
 	private ArrayList<Identifier> references = null;
+	//Andrey: Adding position to be able to underline text of expression
+	public int beginLine=-1;
+	public int beginColumn=-1;
+	public int endLine=-1;
+	public int endColumn=-1;
 	boolean isAssignable = false;
+	private boolean contextDeterminedWidth=false;
+	// Andrey: used to keep track of port width dependence on parameters
+	protected List<String> m_Depends=new ArrayList<String>();
+	public boolean isContextDetermined(){
+		return contextDeterminedWidth;
+	}
+	public void setContextDetermined(){
+		contextDeterminedWidth=true;
+	}
+	public void addDepend(String dep){ // accepts both single dependency, or ":" separated list of them
+		if (dep==null) return;
+		if (!dep.contains(":")){
+			if (!m_Depends.contains(dep)) m_Depends.add(dep); // name#parameter or name#localparam
+		} else {
+			String [] deps= dep.split(":");
+			for (String singlDep:deps){
+				if (!m_Depends.contains(singlDep)) m_Depends.add(singlDep); // name#parameter or name#localparam
+			}
+		}
+	}
+	public void addDepend(OutlineElement oe){
+		if (oe==null) return;
+		String hash=oe.getShortName()+"#"+oe.getType().split("#")[0]; // name#type (name#parameter or name#localparam)
+		if (!m_Depends.contains(hash)) m_Depends.add(hash);
+	}
+	public void addAllDepends(OutlineElement oe){
+		if (oe==null) return;
+		addDepend(oe); // element itself
+		for (String hash:oe.getDepends())
+			if (!m_Depends.contains(hash)) m_Depends.add(hash);
+	}
+	public void addAllDepends(Expression expr){
+		if (expr==null) return;
+		for (String hash:expr.m_Depends)
+			if (!m_Depends.contains(hash)) m_Depends.add(hash);
+	}
+	public List<String> getDepends(){
+		return m_Depends;
+	}
+	public String encodeDepends(){
+		if (m_Depends.isEmpty()) return "";
+		String ed=m_Depends.remove(0);
+		for (String item:m_Depends) ed+=":"+item;
+		return ed;
+	}
+
+	
+	
 
 	public Expression() {
 	}
-
 	public Expression(int width) {
 		setWidth(width);
 	}
 
-	public Expression(int width, int value) {
+	public Expression(int width, int value, Identifier ident) {
 		setWidth(width);
 		setValue(value);
+		if (ident!=null) {
+			addReference(ident); // for parameters as arguments, keep track of usage
+			extendPosition(ident);
+		}
 	}
 
-	public Expression(int width, String value) {
+	public Expression(int width, String value, Identifier ident) {
 		setWidth(width);
 		setValue(value);
+		if (ident!=null){
+			addReference(ident); // for parameters as arguments, keep track of usage
+			extendPosition(ident);
+		}
 	}
 
 	public Expression(int width, Identifier ident) {
 		setWidth(width);
 		addReference(ident);
 		isAssignable = true;
+		extendPosition(ident);
+	}
+	
+	public void extendPosition(int line, int column){
+		if ((line<0) || (column<0)) return; // invalid new position
+		if (beginLine < 0){
+			beginLine =   line;
+			beginColumn = column;
+			endLine =     line;
+			endColumn =   column;
+		} else if (line < beginLine) {
+			beginLine =   line;
+			beginColumn = column;
+		} else if ((line == beginLine) && (column < beginColumn)){
+			beginColumn = column;
+		} else if (line > endLine) {
+			endLine =   line;
+			endColumn = column;
+		} else if ((line == endLine) && (column > endColumn)){
+			endColumn = column;
+		}  
+	}
+	public void extendPosition(Expression other){
+		if (other==null) return;
+		extendPosition(other.beginLine, other.beginColumn);
+		extendPosition(other.endLine, other.endColumn);
+	}
+	public void extendPosition(Token tok){
+		if (tok==null) return;
+		extendPosition(tok.beginLine, tok.beginColumn);
+		extendPosition(tok.endLine, tok.endColumn);
 	}
-
 	public void setWidth(int width) {
 		this.width = width;
 	}
@@ -82,6 +185,7 @@
 	public void setValue(int value) {
 		intValue = value;
 		valid = true;
+		validString = false;
 	}
 
 	public void setValue(String value) {
@@ -137,14 +241,15 @@
 		int idx = image.indexOf('\'');
 		int width;
 		if (idx < 0) {
-			if (preferences.intConst == false)
-				width = UNFIXED_WIDTH;
-			else
-				width = 32;
-			setValue(parseInt(image, 10));
+			width = preferences.intConst ? 32 : UNFIXED_WIDTH;
+			try {
+				setValue(parseInt(image, 10));
+			} catch (NumberFormatException e) {
+				valid = false;
+			}
 		} else {
 			if (idx == 0)
-				width = 32;
+				width = preferences.intConst ? 32 : UNFIXED_WIDTH;
 			else
 				width = parseInt(image.substring(0, idx), 10);
 			char rx = image.charAt(idx + 1);
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/verilog/Identifier.java vdt/src/com/elphel/vdt/veditor/parser/verilog/Identifier.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/verilog/Identifier.java	2016-06-24 10:29:40.856495517 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/verilog/Identifier.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,21 +1,42 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2012 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+/*******************************************************************************
+ * Copyright (c) 2004, 2012 KOBAYASHI Tadashi and others.
  *
  * Contributors:
  *    KOBAYASHI Tadashi - initial API and implementation
  *******************************************************************************/
 
-package net.sourceforge.veditor.parser.verilog;
+package com.elphel.vdt.veditor.parser.verilog;
 
 public class Identifier extends Token {
 	private static final long serialVersionUID = 1L;
-
+	private int lowBit=0;
 	private int width = 0;
 	private int dimension = 0;
+	private boolean rangeValid=true;
+	private String paramDepends; // identifier dependencies on parameters/localparam (only for "port#") name1#parameter:name2#localparam:...
+	
+	public void setEncodedDepends(String deps){
+		paramDepends=deps;
+	}
+	
+	public String getEncodedDepends(){
+		return paramDepends;
+	} 
 
 	public Identifier(Token ident) {
 		copy(ident);
@@ -32,17 +53,45 @@
 	public void copy(Identifier src) {
 		copy((Token) src);
 		width = src.width;
+		lowBit= src.lowBit;
 		dimension = src.dimension;
+		
 	}
 
 	public int getWidth() {
 		return width;
 	}
-
+	public int getLowBit() {
+		return lowBit;
+	}
+	public int [] getWidthBit(){
+		int [] range={width,lowBit};
+		return range;
+	}
+	
+	// Unused??
+/*	
 	public void setWidth(int width) {
 		this.width = width;
 	}
+*/	
+	public void setWidth(int width,int bit) {
+		this.width = width;
+		this.lowBit = bit;
+	}
+	public void setInvalidRange(){
+		rangeValid=false;
+	}
+	
+	public boolean isRangeValid(){
+		return rangeValid;
+	}
+	public void setWidth(int [] widthBit) {
+		this.width = widthBit[0];
+		this.lowBit = widthBit[1];
+	}
 
+	
 	public int getDimension() {
 		return dimension;
 	}
@@ -50,4 +99,36 @@
 	public void setDimension(int dimension) {
 		this.dimension = dimension;
 	}
+	// Andrey: Managing identifier start/end to include bit select for showing warnings
+	
+	public void extendPosition(int line, int column){
+		if ((line<0) || (column<0)) return; // invalid new position
+		if (beginLine < 0){
+			beginLine =   line;
+			beginColumn = column;
+			endLine =     line;
+			endColumn =   column;
+		} else if (line < beginLine) {
+			beginLine =   line;
+			beginColumn = column;
+		} else if ((line == beginLine) && (column < beginColumn)){
+			beginColumn = column;
+		} else if (line > endLine) {
+			endLine =   line;
+			endColumn = column;
+		} else if ((line == endLine) && (column > endColumn)){
+			endColumn = column;
+		}  
+	}
+	public void extendPosition(Expression other){
+		if (other==null) return;
+		extendPosition(other.beginLine, other.beginColumn);
+		extendPosition(other.endLine, other.endColumn);
+	}
+	public void extendPosition(Token tok){
+		if (tok==null) return;
+		extendPosition(tok.beginLine, tok.beginColumn);
+		extendPosition(tok.endLine, tok.endColumn);
+	}
+	
 }
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/verilog/InstanceStore.java vdt/src/com/elphel/vdt/veditor/parser/verilog/InstanceStore.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/verilog/InstanceStore.java	2016-06-24 10:29:40.856495517 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/verilog/InstanceStore.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,30 +1,47 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2013 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2013 KOBAYASHI Tadashi and others.
  *
  * Contributors:
  *    KOBAYASHI Tadashi - initial API and implementation
  *******************************************************************************/
-package net.sourceforge.veditor.parser.verilog;
+package com.elphel.vdt.veditor.parser.verilog;
 
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
 
+import org.eclipse.core.resources.IResource;
+
 public class InstanceStore {
 	
 	public static class Port {
 		private String name;
 		private int line;
+		private int startCol,endCol; // Andrey
 		private Expression signal;
 		
-		public Port(String name, int line, Expression signal) {
+		public Port(String name, int line, int startCol, int endCol, Expression signal) {
 			this.name = name;
 			this.line = line;
+			this.startCol = startCol;
+			this.endCol = endCol;
 			this.signal = signal;
+			
 		}
 
 		public String getName() {
@@ -34,40 +51,149 @@
 		public int getLine() {
 			return line;
 		}
+		public int getStartCol() {
+			return startCol;
+		}
+		public int getEndCol() {
+			return endCol;
+		}
 
 		public Expression getSignal() {
 			return signal;
 		}
 	}
+	//Andrey: Adding parameter connections
+	public static class Parameter {
+		private String name;
+		private int line;
+		private int startCol,endCol; // Andrey
+		private Expression signal;
+		
+		public Parameter(String name, int line, int startCol, int endCol, Expression signal) {
+			this.name = name;
+			this.line = line;
+			this.startCol = startCol;
+			this.endCol = endCol;
+			this.signal = signal;
+			
+		}
 
+		public String getName() {
+			return name;
+		}
+
+		public int getLine() {
+			return line;
+		}
+		public int getStartCol() {
+			return startCol;
+		}
+		public int getEndCol() {
+			return endCol;
+		}
+
+		public Expression getSignal() {
+			return signal;
+		}
+	}
+
+	
 	public static class Instance {
 		private String name; // module name
+		private String iName; // instance name (Andrey)
+		private String type;  // Andrey: type (instance, taskenable, functionreference)
+		private String moduleName; // Andrey
+		private int moduleLine; //andrey (for checking same module definition in the same file)
 		private int line;
+		private int endLine=-1;
+		private int beginColumn=-1;
+		private int endColumn=-1;
 		List<Port> ports = new ArrayList<Port>();
+		List<Parameter> parameters = new ArrayList<Parameter>();  // Andrey
 		boolean isNamedMap = false;
+		boolean isNamedMapParameters = false;
 
-		public Instance(String name, int line) {
+		public Instance(String name, String type, int line, String iName, String moduleName, int moduleLine) {
 			this.name = name;
+			this.type = type;
 			this.line = line;
+			this.iName = iName;
+			this.moduleName=moduleName;
+			this.moduleLine=moduleLine;
 		}
+		public Instance(String name, String type, int line, int beginColumn, int endLine, int endColumn,
+				String iName, String moduleName, int moduleLine) {
+			this.name = name;
+			this.type = type;
+			this.line = line;
+			this.beginColumn=beginColumn;
+			this.endLine=    endLine;
+			this.endColumn=  endColumn;
+			this.iName = iName;
+			this.moduleName=moduleName;
+			this.moduleLine=moduleLine;
+		}
+
+		
 		public void addPort(Port port) {
 			ports.add(port);
 		}
 		public Collection<Port> getPorts() {
 			return ports;
 		}
+
+		public void addParameter(Parameter parameter) {
+			parameters.add(parameter);
+		}
+		public Collection<Parameter> getParameters() {
+			return parameters;
+		}
+
+		
+		
 		public String getName() {
 			return name;
 		}
+		public String getType() {
+			return type;
+		}
+		public String getInstanceName() {
+			return iName;
+		}
+		
+		public String getModuleName() {
+			return moduleName;
+		}
+		public int getModuleLine(){
+			return moduleLine;
+		}
+		
 		public int getLine() {
 			return line;
 		}
+		public int getEndLine() {
+			return (endLine>=0)?endLine:line;
+		}
+		public int getBeginColumn() {
+			return beginColumn;
+		}
+		public int getEndColumn() {
+			return endColumn;
+		}
 		public void setNamedMap() {
 			isNamedMap = true;
 		}
+		public void setNamedMapParameters() {
+			isNamedMapParameters = true;
+		}
+
 		public boolean isNamedMap() {
 			return isNamedMap;
 		}
+		public boolean isNamedMapParameters() {
+			return isNamedMapParameters;
+		}
+		
 		public Port findPort(String name) {
 			for(Port port : ports) {
 				if (port.getName().equals(name)) {
@@ -76,29 +202,89 @@
 			}
 			return null;
 		}
+
+		public Parameter findParameter(String name) {
+			for(Parameter parameter : parameters) {
+				if (parameter.getName().equals(name)) {
+					return parameter;
+				}
+			}
+			return null;
+		}
 	}
 	
 	private List<Instance> instances = new ArrayList<Instance>();
 	private Instance current = null;
+	private List<Parameter> forward = null;
+	private boolean forwardIsNamedMap = false;
+
+
 	
 	public InstanceStore() {
 	}
 	
-	public void addInstance(String name, int line) {
+	public void addInstance(String name, String type, int line, String instanceName, String moduleName, int moduleLine) {
+		addInstance(name, type, line, -1,-1,-1, instanceName, moduleName, moduleLine);
+	}
+	public void addInstance(String name,  String type, int line, int beginColumn, int endLine, int endColumn,
+			String instanceName, String moduleName, int moduleLine) {
 		// The name is module name. A instance name is not needed.
-		current = new Instance(name, line);
+		current = new Instance(name, type, line, beginColumn, endLine, endColumn, instanceName, moduleName, moduleLine);
+		if (forward!=null){
+			for (Parameter parameter:forward){
+				current.addParameter(parameter);
+			}
+			if (forwardIsNamedMap){
+				current.setNamedMapParameters();
+			}
+			forward=null; // until new statement, each new statement will reset this to empty
+		}
 		instances.add(current);
 	}
-	
-	public void addPort(String name, int line, Expression signal) {
-		Port port = new Port(name, line, signal);
-		current.addPort(port);
+	// Andrey int startCol, int endCol
+//	public void addPort(String name, int line, int startCol, int endCol, Expression signal) {
+	public void addPort(String name, int line, int startCol, int endCol, Expression signal, IResource file) {
+		Port port = new Port(name, line, startCol, endCol, signal);
+		if (current !=null) {
+			current.addPort(port);
+			if (Character.isDigit(name.charAt(0)) == false) {
+				current.setNamedMap();
+			}
+		} else {
+			System.out.println("BUG: trying to add name="+name+" to null line="+line+ "start col="+startCol+" endCol" +endCol+" file="+file);
+		}
+	}
+
+	public void newStatement(){
+		forward= new ArrayList<Parameter>();
+		forwardIsNamedMap=false;
+	}
+	public void addParameter(String name, int line, int startCol, int endCol, Expression signal) {
+		Parameter parameter = new Parameter(name, line, startCol, endCol, signal);
+		if (forward!=null){
+			
+		}else {
+			System.out.println("No place to add parameter: "+name+" as no instance is being processed in line "+line);
+			return;
+		}
+		forward.add(parameter);
+//		current.addParameter(parameter);
 		if (Character.isDigit(name.charAt(0)) == false) {
-			current.setNamedMap();
+			forwardIsNamedMap=true;
 		}
 	}
 	
 	public Collection<Instance> collection() {
 		return instances;
 	}
+	
+	public Instance addDefparam(String moduleName, String instanceName, String parName, int line, int startCol, int endCol, Expression signal){
+		for (Instance inst:instances){
+			if (inst.moduleName.equals(moduleName) && inst.getInstanceName().equals(instanceName)){
+				Parameter parameter = new Parameter(parName, line, startCol, endCol, signal);
+				inst.addParameter(parameter);
+			}
+		}
+		return null;
+	}
 }
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/verilog/Operator.java vdt/src/com/elphel/vdt/veditor/parser/verilog/Operator.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/verilog/Operator.java	2016-06-24 10:29:40.856495517 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/verilog/Operator.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,22 +1,35 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2012 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+/*******************************************************************************
+ * Copyright (c) 2004, 2012 KOBAYASHI Tadashi and others.
  *
  * Contributors:
  *    KOBAYASHI Tadashi - initial API and implementation
  *******************************************************************************/
 
-package net.sourceforge.veditor.parser.verilog;
+package com.elphel.vdt.veditor.parser.verilog;
 
 public class Operator {
 
 	// semantic warning.
 	private static final String COMPARE_WIDTH_MISMATCH = "Compare bit width mismatch: %d and %d";
 	private static final String CONDITIONAL_WIDTH_MISMATCH = "Conditional operator bit width mismatch: %d ? %d : %d";
-	private static final String LOGICAL_WIDTH_MISMATCH = "Logical operator bit width mismatch: %d and %d";
+// The next is not a problem in Verilog:	
+//	private static final String LOGICAL_WIDTH_MISMATCH = "Logical operator bit width mismatch: %d and %d";
+	private static final String BITWISE_WIDTH_MISMATCH = "Bitwise operator bit width mismatch: %d and %d";
 
 	private String image;
 	private String warning = null;
@@ -33,26 +46,34 @@
 		return warning;
 	}
 	
-	public Expression operate(Expression arg) {
+	public Expression operate(Expression arg, VerilogParser.Preferences preferences) {
 		int width;
 		if (image.equals("~") || image.equals("+") || image.equals("-"))
 			width = arg.getWidth();
 		else
 			width = 1;
-		
+		Expression exp;
 		if (arg.isValid()) {
 			int value = getValue1(arg.intValue(), arg.getWidth());
-			return new Expression(width, value);
+			exp= new Expression(width, value, null);
 		} else {
-			return new Expression(width);
+			exp= new Expression(width);
+		}
+		exp.extendPosition(arg);
+		if (image.equals("~")) {
+			exp.setContextDetermined(); // result width may be extended to the left side width
 		}
+		return exp;
 	}
 	
 	private static final String opLeft = " / >> << ** >>> <<< ";
 	private static final String opLog = " && || ";
 	private static final String opCmp = " == != === !== < <= > >= ";
+	private static final String opBit = " & | ^ ~^ ^~ ";
+	private static final String contextDet = " + - * / % & | ^ ~^ ^~ ";
 	
-	public Expression operate(Expression arg1, Expression arg2) {
+	
+	public Expression operate(Expression arg1, Expression arg2, VerilogParser.Preferences preferences) {
 		String key = " " + image + " ";
 		int width1 = arg1.getWidth();
 		int width2 = arg2.getWidth();
@@ -64,11 +85,23 @@
 		} else if (opLeft.contains(key)) {
 			width = width1;
 		} else if (opLog.contains(key)) {
-			if (width1 != 1 || width2 != 1) {
-				warning = String.format(LOGICAL_WIDTH_MISMATCH,
-						arg1.getVisibleWidth(), arg2.getVisibleWidth());
-			}
+//			if (width1 != 1 || width2 != 1) {
+//				warning = String.format(LOGICAL_WIDTH_MISMATCH,
+//						arg1.getVisibleWidth(), arg2.getVisibleWidth());
+//			}
 			width = 1;
+		} else if (opBit.contains(key)) {
+			if (preferences.bitwiseWidth) {
+				if ((width1 != width2) && arg1.isFixedWidth() && arg2.isFixedWidth()) {
+					warning = String.format(BITWISE_WIDTH_MISMATCH,
+							arg1.getVisibleWidth(), arg2.getVisibleWidth());
+				}
+			}
+			if (width2 == 32 && arg2.isValid()) {
+				width = width1; // ?? Andrey
+			} else {
+				width = (width1 > width2) ? width1 : width2;
+			}
 		} else if (opCmp.contains(key)) {
 			if (width1 != width2 && arg1.isFixedWidth() && arg2.isFixedWidth()) {
 				warning = String.format(COMPARE_WIDTH_MISMATCH,
@@ -76,11 +109,11 @@
 			}
 			width = 1;
 		} else if (width2 == 32 && arg2.isValid()) {
-			width = width1;
+			width = width1;  // ?? Andrey Second is integer?
 		} else {
 			width = (width1 > width2) ? width1 : width2;
 		}
-		
+		Expression exp;
 		if (arg1.isValid() && arg2.isValid()) {
 			int value = 0;
 			if (arg1.isValidInt()) {
@@ -88,27 +121,61 @@
 			} else {
 				value = getValue2(arg1.stringValue(), arg2.stringValue());
 			}
-			return new Expression(width, value);
+			exp= new Expression(width, value, null);
 		} else {
-			return new Expression(width);
+			exp= new Expression(width);
+		}
+		exp.extendPosition(arg1);
+		exp.extendPosition(arg2);
+		if (contextDet.contains(key)) {
+			exp.setContextDetermined(); // result width may be extended to the left side width
 		}
+		return exp;
 	}
 	
-	public Expression operate(Expression cond, Expression arg1, Expression arg2) {
+	public Expression operate(Expression cond, Expression arg1, Expression arg2, VerilogParser.Preferences preferences) {
 		int widthc = cond.getVisibleWidth();
 		int width1 = arg1.getVisibleWidth();
 		int width2 = arg2.getVisibleWidth();
-		if (widthc != 1 || width1 != width2) {
+		int width=(width1 > width2)?width1:width2;
+		// if cond.isValid() (known constant) it is OK to have different width1 and width2 - only one will be selected
+		if (((widthc != 1) && preferences.conditionWidth) || (!cond.isValid() && (width1 != width2))) {
 			if (arg1.isFixedWidth() && arg2.isFixedWidth()) {
-				warning = String.format(CONDITIONAL_WIDTH_MISMATCH, widthc,
+//				warning = String.format("cond.isValid()="+cond.isValid()+":"+width1+":"+width2+":"+width+CONDITIONAL_WIDTH_MISMATCH, widthc,
+				warning = String.format(CONDITIONAL_WIDTH_MISMATCH, widthc,
 						width1, width2);
 			}
 		}
-		if (cond.isValid()) {
-			return (cond.intValue() != 0) ? arg1 : arg2;
-		} else {
-			return new Expression(arg1.getWidth());
-		}
+		Expression exp;
+/* Why was that edited? Remove after sufficient testing		
+//		if (cond.isValid()) {
+			exp= (cond.intValue() != 0) ? arg1 : arg2;
+			width=(cond.intValue() != 0) ? width1 : width2; // width from selected?
+//		} else {
+//			exp= new Expression(arg1.getWidth());
+//		}
+*/
+		// trying to restore that functionality
+		if (cond.isValid()) {
+			exp= (cond.intValue() != 0) ? arg1 : arg2;
+			width=(cond.intValue() != 0) ? width1 : width2; // width from selected?
+		} else {
+//			exp= new Expression(width); // maximal of width1 and width2
+			exp= arg1;
+			// is it OK to modify arg1, arg2 or should a new Expression be created?
+			exp.addAllDepends(arg2); //
+			exp.addReference(arg2); // 
+			exp.setWidth(width);
+//			warning="Depends="+exp.encodeDepends();
+//			warning="width="+width+"width1="+width1+"width2="+width2+"widthc="+widthc;
+		}
+
+		exp.extendPosition(cond);
+		exp.extendPosition(arg1);
+		exp.extendPosition(arg2);
+//		exp.setWidth(width);
+		return exp;
+		
 	}
 
 	private int getValue1(int value1, int width1) {
@@ -197,7 +264,7 @@
 		if (image.equals(">>") || image.equals(">>>"))
 			return value1 >> value2;
 		if (image.equals("<<") || image.equals("<<<"))
-			return value1 >> value2;
+			return value1 << value2;
 		if (image.equals("**")) {
 			// power
 			int ret = 1;
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/verilog/VariableStore.java vdt/src/com/elphel/vdt/veditor/parser/verilog/VariableStore.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/verilog/VariableStore.java	2016-06-24 10:29:40.856495517 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/verilog/VariableStore.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,49 +1,127 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2012 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+/*******************************************************************************
+ * Copyright (c) 2004, 2012 KOBAYASHI Tadashi and others.
  *
  * Contributors:
  *    KOBAYASHI Tadashi - initial API and implementation
  *******************************************************************************/
 
-package net.sourceforge.veditor.parser.verilog;
+package com.elphel.vdt.veditor.parser.verilog;
 
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
+import java.util.LinkedHashMap;
 import java.util.List;
+import java.util.Set;
 
-public class VariableStore {
+import com.elphel.vdt.veditor.VerilogPlugin;
+import com.elphel.vdt.veditor.parser.OutlineElement;
+import com.elphel.vdt.veditor.preference.PreferenceStrings;
 
+public class VariableStore {
+	public final static String TASK_NAME_SEPARATOR="##";
+//	public final static String GENERATE_BLOCK_SEPARATOR="."; // TODO: Andrey: change to smth else not to confuse with hierarchy 
+	public final static String GENERATE_BLOCK_SEPARATOR="+"; // Trying "+" - should not otherwise appear in names 
+// TODO: add end line, 	beginColumn, endColumn
 	public static class Symbol {
 		private String name;
 		private int line;
+		private int endLine=-1;
+		private int beginColumn=-1;
+		private int endColumn=-1;
 		private String[] types;
 		private int width = 1;
+		private int lowBit = 0; // Andrey: to verify reference is within the bit range
 		private int dimemsion = 0;
 		private int intValue = 0;
 		private String stringValue;
 		private boolean assignd = false;
+		private List<Integer> drivers = null; // line numbers where this signal is assigned
 		private boolean used = false;
+		private boolean defined = false;
 		private List<String> connections = null;
+		private String paramDepends=null; // identifier dependencies on parameters/localparam (only for "port#") name1#parameter:name2#localparam:...
+		private boolean validWidth=false;
+		private boolean validDim=false;
+		private OutlineElement outlineElement=null; //Andrey OutlineElement associated with this variable (to set lateDescription for hovering)
+		public OutlineElement getOutlineElement(){
+			return outlineElement;
+		}
+		public void setOutlineElement(OutlineElement element){
+			outlineElement=element;
+		}
+		public void clearDepends(){
+			paramDepends=null;
+		}
+		private void addDepend(String dep){
+			if (paramDepends==null) paramDepends=dep;
+			else if (!paramDepends.contains(dep)) paramDepends+=":"+dep;
+		}
+		
+		public void addDepends(String deps){
+			if ((deps==null) || (!deps.contains("#"))) return;
+			if (!deps.contains(":")) addDepend(deps);
+			else for (String dep:deps.split(":")) addDepend(dep);
+		}
+		
+		public String getEncodedDepends(){
+			return paramDepends;
+		} 
 
 		Symbol(String name, int line, String[] types) {
 			this.name = name;
 			this.line = line;
 			this.types = types;
 		}
+		Symbol(String name, int line, int beginColumn, int endLine, int endColumn, String[] types) {
+			this.name = name;
+			this.line = line;
+			this.beginColumn=beginColumn;
+			this.endLine=    endLine;
+			this.endColumn=  endColumn;
+			this.types = types;
+		}
 
-		public String getName() {
+		
+		public String getFullName() { // includes task name
+			return name;
+		}
+		public String getJustName() { // Does not include task name
+			if (name.contains(TASK_NAME_SEPARATOR)){
+				return name.split(TASK_NAME_SEPARATOR)[0];
+			}
 			return name;
 		}
 
 		public int getLine() {
 			return line;
 		}
+		public int getEndLine() {
+			return (endLine>=0)?endLine:line;
+		}
+		public int getBeginColumn() {
+			return beginColumn;
+		}
+		public int getEndColumn() {
+			return endColumn;
+		}
 
+		
 		public String[] getTypes() {
 			return types;
 		}
@@ -53,6 +131,20 @@
 					|| types[0].equals("localparam");
 		}
 
+		public boolean isLocalparam() {
+			return types[0].equals("localparam");
+		}
+		
+		
+		public boolean isGenvar() {
+			return types[1].equals("genvar");
+		}
+		
+
+		public String getTypes0() {
+			return  types[0];
+		}
+		
 		public boolean isVariable() {
 			return types[0].equals("variable") || types[0].equals("port");
 		}
@@ -74,7 +166,7 @@
 			if (idx >= types.length)
 				return false;
 			String modifier = types[idx];
-			if (modifier.contains("reg") || modifier.contains("integer"))
+			if (modifier.contains("reg") || modifier.contains("integer") || modifier.contains("real") || modifier.contains("time"))
 				return true;
 			else
 				return false;
@@ -89,15 +181,68 @@
 		}
 
 		public void setWidth(String bitRange) {
+			validWidth=false;
+			//Andrey: - setting undefined parameter width
+			if (bitRange.contains("?")){
+				width=0;
+				validWidth=true;
+				return;
+			}
+			if (bitRange.contains("X")){ // setting invalid width
+				width=0;
+				validWidth=false;
+				return;
+			}
+
+			//Andrey: Did not understand the reason genvar gets bitRange="[-1:0]"
+			// So I'll just make in undefined width here
+			if (bitRange.contains("[-1:0]")){
+				if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR)) {
+					System.out.println("Replacing [-1:0] assuming it is set for genvar to width=0 (undefined)");
+				}
+				width=0;
+				validWidth=true;
+				return;
+			}
+			
 			String[] bit = bitRange.split("[:\\[\\]]");
 			if (bit.length >= 3) {
-				width = Integer.parseInt(bit[1]) - Integer.parseInt(bit[2]) + 1;
+//				width = Integer.parseInt(bit[1]) - Integer.parseInt(bit[2]) + 1;
+				try {
+					width = Integer.parseInt(bit[1]) - Integer.parseInt(bit[2]);
+					validWidth=true;
+				} catch (Exception e){
+					return;
+				}
+				if (width<0) {
+					width=-width;
+					lowBit=Integer.parseInt(bit[1]);
+				} else {
+					lowBit=Integer.parseInt(bit[2]);
+				}
+				width++;
+			} else if (bit.length >= 2){
+				try {
+					lowBit=Integer.parseInt(bit[1]);
+					validWidth=true;
+				} catch (Exception e){
+					return;
+				}
 			}
 		}
-
+/*
 		public int getWidth() {
 			return width;
 		}
+*/		
+		public boolean isWidthValid(){
+			return validWidth;
+		}
+		
+		public int [] getWidthBit(){
+			int [] wb={width, lowBit};
+			return wb;
+		}
 
 		public String[] getConnections() {
 			if (connections == null)
@@ -144,9 +289,60 @@
 		}
 
 		public void setAssignd() {
-			this.assignd = true;
+			if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR)) {
+				System.out.println(name+".setAssignd(***)");
+			}
+			this.assignd = true;
+		}
+
+		public void setAssignd (int line) {
+			if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR)) {
+				System.out.println(name+".setAssignd("+line+")");
+			}
+			this.assignd = true;
+			if (line <0) return;
+			if (this.drivers == null) {
+				this.drivers = new ArrayList<Integer>();
+			}
+        	for (Integer i : this.drivers){
+        		if (line == i) return; // skip duplicates
+        	}
+			this.drivers.add(new Integer(line)); 
+		}
+
+		// Copy list of drivers to that of the OutlineElement
+		public void updateOEDrivers(boolean replace){
+			if ((this.outlineElement != null) && (this.drivers != null)){
+                if (this.outlineElement instanceof VerilogOutlineElementFactory.VerilogOutlineElement){
+                	VerilogOutlineElementFactory.VerilogOutlineElement ve=
+                                (VerilogOutlineElementFactory.VerilogOutlineElement) this.outlineElement;
+                	if (replace) {
+                		ve.removeDrivers();
+                	}
+        			if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR)) {
+        				System.out.println(name+".updateOEDrivers("+replace+")");
+        			}
+                	for (Integer i : this.drivers){
+                		ve.addDriver(i);
+            			if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR)) {
+            				System.out.print(i+", ");
+            			}
+                	}
+        			if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR)) {
+        				System.out.println();
+        			}
+                }
+			}
+		}
+		
+		public boolean isDefined() {
+			return defined;
 		}
 
+		public void setDefined() {
+			this.defined = true;
+		}
+		
 		public boolean isUsed() {
 			return used;
 		}
@@ -164,34 +360,64 @@
 		}
 	}
 
-	private HashMap<String, Symbol> symbols;
+	private LinkedHashMap<String, Symbol> symbols; // So the order of ports is consistent
 
 	public VariableStore() {
-		symbols = new HashMap<String, Symbol>();
+		symbols = new LinkedHashMap<String, Symbol>();
 	}
 
 	public Symbol addSymbol(String name, int line, String[] types,
-			String bitRange) {
-		return addSymbol(name, line, types, bitRange, 0);
+			String bitRange,
+			String depends
+			) {
+		return addSymbol(name, line, -1, -1, -1, types, bitRange, depends);
 	}
 
 	public Symbol addSymbol(String name, int line, String[] types,
-			String bitRange, int dim) {
+			String bitRange, int dim,
+			String depends
+			) {
+		return addSymbol(name, line, -1, -1, -1, types, bitRange, dim, depends);
+	}
+
+	public Symbol addSymbol(String name, int line, int beginColumn, int endLine, int endColumn,
+			String[] types,
+			String bitRange,
+			String depends
+			) {
+		return addSymbol(name, line, beginColumn, endLine, endColumn, types, bitRange, 0, depends);
+	}
+
+	public Symbol addSymbol(String name, int line, int beginColumn, int endLine, int endColumn,
+			String[] types,
+			String bitRange, int dim,
+			String depends
+			) { // bitRange="[-1:0] - genvar
 		if (symbols.containsKey(name)) {
 			return null; // redefinition error
 		} else {
-			Symbol sym = new Symbol(name, line, types);
+			Symbol sym = new Symbol(name, line, beginColumn, endLine, endColumn, types);
 			sym.setWidth(bitRange);
 			sym.setDimemsion(dim);
+			sym.addDepends(depends);
 			symbols.put(name, sym);
 			return sym;
 		}
 	}
+	
 
-	public Symbol addAssignedVariable(String name, List<String> generateBlock) {
+	public Symbol addAssignedVariable(String name, List<String> generateBlock, int line) {
 		Symbol sym = getVariableSymbol(name, generateBlock);
-		if (sym != null && sym.isVariable()) {
-			sym.setAssignd();
+		if (sym != null) {
+			if (!sym.isVariable()) {
+				// assigning to function itself, name should be "functionName<TASK_NAME_SEPARATOR>functionName"
+				if (!sym.isFunction() ||
+						!name.contains(TASK_NAME_SEPARATOR) ||
+						!name.split(TASK_NAME_SEPARATOR)[0].equals(name.split(TASK_NAME_SEPARATOR)[1])){
+					return null;
+				}
+			}
+			sym.setAssignd(line);
 			return sym;
 		}
 		return null;
@@ -209,11 +435,25 @@
 	public Symbol getVariableSymbol(String name, List<String> generateBlock) {
 		Symbol sym = symbols.get(name);
 		if (sym == null) {
+			String globalName=null;
+			if (name.contains(TASK_NAME_SEPARATOR)) {
+				globalName=name.split(TASK_NAME_SEPARATOR)[0];
+				sym = symbols.get(globalName);
+				if (sym!=null) return sym;
+			}
 			String head = "";
 			for (int i = 0; i < generateBlock.size() && sym == null; i++) {
-				head += generateBlock.get(i) + ".";
+				head += generateBlock.get(i) + GENERATE_BLOCK_SEPARATOR;
 				sym = symbols.get(head + name);
 			}
+			if (sym!=null) return sym;
+			if (globalName!=null) {
+				head = "";
+				for (int i = 0; i < generateBlock.size() && sym == null; i++) {
+					head += generateBlock.get(i) + GENERATE_BLOCK_SEPARATOR;
+					sym = symbols.get(head + globalName);
+				}
+			}
 		}
 		return sym;
 	}
@@ -221,16 +461,56 @@
 	public void addConnection(String name, List<String> generateBlock,
 			String connection) {
 		Symbol sym = getVariableSymbol(name, generateBlock);
+		if ((sym==null) && (name!=null) && name.contains(TASK_NAME_SEPARATOR)) {
+			sym = getVariableSymbol(name.split(TASK_NAME_SEPARATOR)[0], generateBlock);
+		}
 		if (sym != null) {
 			sym.addConnection(connection);
 		}
 	}
-
+    // added support for task local/global names (first look for local, then - for global)
 	public Symbol findSymbol(String name) {
-		return symbols.get(name);
+		Symbol sym=symbols.get(name);
+		if ((sym==null) && (name!=null) && name.contains(TASK_NAME_SEPARATOR)) {
+			String globalName=name.split(TASK_NAME_SEPARATOR)[0];
+			return 	symbols.get(globalName);		
+		}
+		return sym;
+	}
+	
+	public static String combineTaskName(String name, String taskName){
+		return name+TASK_NAME_SEPARATOR+taskName;
 	}
 
 	public Collection<Symbol> collection() {
 		return symbols.values();
 	}
+	public Set<String> getKeys(){
+		return symbols.keySet();
+	}
+	public Symbol getValue(String key){
+		return symbols.get(key);
+	}
+	public void putValue(String key, Symbol sym){
+		symbols.put(key,sym);
+	}
+	
+	public Symbol findPort(String name){
+		if (Character.isDigit(name.charAt(0))) {
+			int index = Integer.parseInt(name);
+			for (String  symName:symbols.keySet()){
+				Symbol sym=symbols.get(symName);
+				if (sym.isPort()){
+					if (index==0) {
+						return sym;
+					} else {
+						index--;
+					}
+				}
+			}
+			return null;
+		} else {
+			return symbols.get(name);
+		}
+	}
 }
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/verilog/VerilogOutlineElementFactory.java vdt/src/com/elphel/vdt/veditor/parser/verilog/VerilogOutlineElementFactory.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/verilog/VerilogOutlineElementFactory.java	2016-06-24 10:29:40.856495517 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/verilog/VerilogOutlineElementFactory.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,242 +1,570 @@
-/*******************************************************************************
- * Copyright (c) 2006 Ali Ghorashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    Ali Ghorashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.parser.verilog;
-
-import net.sourceforge.veditor.parser.OutlineElement;
-import net.sourceforge.veditor.parser.OutlineElementFactory;
-
-import org.eclipse.core.resources.IFile;
-
-/** 
- * Class factory for Verilog Outline Elements
- *
- */
-public class VerilogOutlineElementFactory extends OutlineElementFactory {
-	// type checkers
-	private boolean isModule(String type){return type.startsWith("module#");	}
-	private boolean isTask(String type)  { return type.startsWith("task#");	}
-	private boolean isFunction(String type)  { return type.startsWith("function#");	}
-	private boolean isInstance(String type) {return  type.startsWith("instance#"); }
-	private boolean isParameter(String type)
-	{
-		return type.startsWith("parameter#") || type.startsWith("localparam#");
-	}
-	private boolean isPort(String type)      {return  type.startsWith("port#"); }
-	private boolean isSignal(String type)    {return  type.startsWith("variable#"); }
-	private boolean isRegister(String type)    {return  type.startsWith("variable#reg#"); }
-	private boolean isWire(String type)    {return  type.startsWith("variable#wire#"); }
-	
-	/**
-	 * Outline element classes
-	 */
-	public class VerilogOutlineElement extends OutlineElement{
-		protected String m_ShortName;
-		protected String m_LongName;
-		protected String m_ImageName;
-		protected String[] m_TypeParts;
-		public VerilogOutlineElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
-			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
-			m_TypeParts=m_Type.split("#");
-			m_ShortName= m_Name;
-			if(m_TypeParts.length > 0){
-				m_LongName =  m_Name+" : "+m_TypeParts[0];
-			}
-			else{
-				m_LongName =  m_Name+" : "+m_Type;
-			}
-			m_ImageName="$nl$/icons/obj.gif";
-		}
-		public String GetImageName(){
-			return m_ImageName;
-		}
-		public String getShortName(){
-			return m_ShortName;
-		}
-		public String getLongName(){
-			return m_LongName;
-		}
-	}
-	public class VerilogModuleElement extends VerilogOutlineElement{
-		public VerilogModuleElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
-			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);					
-			m_ImageName="$nl$/icons/module.gif";
-		}
-	}
-	public class VerilogTaskElement extends VerilogOutlineElement{
-		public VerilogTaskElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
-			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);					
-			m_ImageName="$nl$/icons/t.gif";
-		}
-	}
-	public class VerilogInstanceElement extends VerilogOutlineElement{
-		
-		public VerilogInstanceElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
-			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);					
-			m_ImageName="$nl$/icons/yello_dia.gif";
-			
-			m_LongName=String.format("%s(%s)",name,getModuleType());
-			
-		}
-		
-		/**
-		 * Returns the type of this module instantiation
-		 * @return
-		 */
-		public String getModuleType(){
-			if(m_TypeParts.length > 1){
-				return m_TypeParts[1]; 
-			}
-			else{
-				return "";
-			}
-		}
-	}
-	public class VerilogFunctionElement extends VerilogOutlineElement{
-		public VerilogFunctionElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
-			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);					
-			m_ImageName="$nl$/icons/f.gif";
-		}
-	}
-	public class VerilogPortElement extends VerilogOutlineElement{
-		public static final int INPUT	=0;
-		public static final int OUTPUT	=1;
-		public static final int INOUT	=2;
-		private int m_Direction;
-		
-		public String GetDirectionString(){
-			switch(m_Direction){
-			case INPUT:
-				return "in";
-			case OUTPUT:
-				return "out";
-			case INOUT:
-				return "inout";
-			default:
-				return "";
-			}
-		}
-		public VerilogPortElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
-			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);					
-			if(type.toLowerCase().startsWith("port#input#")){
-				m_Direction=INPUT;
-				m_ImageName="$nl$/icons/port_in.gif";
-			}
-			else if (type.toLowerCase().startsWith("port#output#")){
-				m_Direction = OUTPUT;
-				m_ImageName="$nl$/icons/port_out.gif";
-			}
-			else{
-				m_Direction = INOUT;
-				m_ImageName="$nl$/icons/port_inout.gif";
-			}
-			m_LongName = String.format("%s :", name);
-			for (int i = 1; i < m_TypeParts.length; i++) {
-				if (i >= 4)
-					break; // remove last "cstyle"
-				m_LongName += String.format(" %s", m_TypeParts[i]);
-			}
-		}
-	}
-	public class VerilogParameterElement extends VerilogOutlineElement{
-		public VerilogParameterElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
-			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
-			m_ImageName="$nl$/icons/P.gif";
-			String value = GetValue();
-			m_LongName = String.format("%s : %s %s", name, m_TypeParts[0], value);
-		}
-		
-		public boolean isLocal() {
-			return m_Type.startsWith("localparam#");
-		}
-		
-		public String GetValue(){
-			if(m_TypeParts.length > 3)
-				return m_TypeParts[3];			
-			else
-				return "";
-		}
-	}
-	public class VerilogSignalElement extends VerilogOutlineElement{		
-		public VerilogSignalElement(String name, String type, int startLine, int startCol, int endLine, int endCol, IFile file, boolean bVisible) {
-			super(name, type, startLine, startCol, endLine, endCol, file, bVisible);
-			m_ImageName = "$nl$/icons/signal.gif";
-			m_LongName = String.format("%s :", name);
-			int len = m_TypeParts.length;
-			boolean isVariable = m_TypeParts[0].equals("variable");
-			if (isVariable && len > 3) {
-				len = 3;
-			}
-			for (int i = 1; i < len; i++) {
-				m_LongName += String.format(" %s", m_TypeParts[i]);
-			}
-			if (isVariable && m_TypeParts.length >= 3) {
-				int dim = Integer.parseInt(m_TypeParts[3]);
-				for (int i = 0; i < dim; i++) {
-					m_LongName += "[]";
-				}
-			}
-		}
-	}
-
-	public class VerilogWireElement extends VerilogSignalElement{		
-		public VerilogWireElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
-			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);			
-			m_ImageName="$nl$/icons/wire_signal.gif";						
-		}	
-	}
-	public class VerilogRegElement extends VerilogSignalElement{		
-		public VerilogRegElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
-			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);			
-			m_ImageName="$nl$/icons/register_signal.gif";						
-		}	
-	}
-	public class VerilogGroupElement extends VerilogSignalElement{		
-		public VerilogGroupElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
-			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);			
-			m_ImageName="$nl$/icons/obj.gif";						
-		}	
-	}
-	
-	/**
-	 * Class factory function
-	 */
-	public OutlineElement CreateElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file){
-		if (isModule(type)){
-			return new VerilogModuleElement(name,type,startLine,startCol,endLine,endCol,file,true);
-		}
-		else if (isTask(type)){
-			return new VerilogTaskElement(name,type,startLine,startCol,endLine,endCol,file,true);
-		}
-		else if (isFunction(type)){
-			return new VerilogFunctionElement(name,type,startLine,startCol,endLine,endCol,file,true);
-		}
-		else if (isInstance(type)){
-			return new VerilogInstanceElement(name,type,startLine,startCol,endLine,endCol,file,true);
-		}
-		else if (isPort(type)){
-			return new VerilogPortElement(name,type,startLine,startCol,endLine,endCol,file,true);
-		}
-		else if (isParameter(type)){
-			return new VerilogParameterElement(name,type,startLine,startCol,endLine,endCol,file,true);
-		}
-		else if (isWire(type)){
-			return new VerilogWireElement(name,type,startLine,startCol,endLine,endCol,file,true);
-		}
-		else if (isRegister(type)){
-			return new VerilogRegElement(name,type,startLine,startCol,endLine,endCol,file,true);
-		}
-		else if (isSignal(type)){
-			return new VerilogSignalElement(name,type,startLine,startCol,endLine,endCol,file,true);
-		}
-
-		return new VerilogOutlineElement(name,type,startLine,startCol,endLine,endCol,file,true);
-	}
-}
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2006 Ali Ghorashi and others.
+ *
+ * Contributors:
+ *    Ali Ghorashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.parser.verilog;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import com.elphel.vdt.veditor.VerilogPlugin;
+import com.elphel.vdt.veditor.parser.OutlineElement;
+import com.elphel.vdt.veditor.parser.OutlineElementFactory;
+import com.elphel.vdt.veditor.preference.PreferenceStrings;
+//import com.elphel.vdt.veditor.parser.verilog.Expression.java;
+
+
+import org.eclipse.core.resources.IFile;
+
+/** 
+ * Class factory for Verilog Outline Elements
+ *
+ */
+public class VerilogOutlineElementFactory extends OutlineElementFactory {
+	// type checkers
+	// Andrey - changed to static to use from elements
+	private static boolean isModule(String type){return type.startsWith("module#");	}
+	private static boolean isTask(String type)  { return type.startsWith("task#");	}
+	private static boolean isTaskEnable(String type)  { return type.startsWith("taskenable#");	}
+	private static boolean isFunction(String type)  { return type.startsWith("function#"); }
+	private static boolean isFunctionReference(String type)  { return type.startsWith("functionreference#"); }
+	private static boolean isInstance(String type) {return  type.startsWith("instance#"); }
+	private static boolean isDefparam(String type) {return  type.startsWith("defparam#"); }
+	private static boolean isParameter(String type)
+	{
+		return type.startsWith("parameter#") || type.startsWith("localparam#");
+	}
+	private static boolean isPort(String type)      {return  type.startsWith("port#"); }
+	private static boolean isSignal(String type)    {return  type.startsWith("variable#"); }
+	private static boolean isRegister(String type)  {return  type.startsWith("variable#reg#"); }
+	private static boolean isInteger(String type)   {return  type.startsWith("variable#integer#"); }
+	private static boolean isReal(String type)      {return  type.startsWith("variable#real#"); }
+	private static boolean isTime(String type)      {return  type.startsWith("variable#time#"); }
+	private static boolean isSequential(String type){return  isRegister(type) || isInteger(type) || isReal(type) || isTime(type); }
+	private boolean isWire(String type)    {return  type.startsWith("variable#wire#"); }
+	
+	/**
+	 * Outline element classes
+	 */
+	public class VerilogOutlineElement extends OutlineElement{
+		protected String m_ShortName;
+		protected String m_LongName;
+		protected String m_ImageName;
+		protected String[] m_TypeParts;
+		protected List<Integer> m_Drivers;
+		public VerilogOutlineElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
+			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
+			m_TypeParts=m_Type.split("#");
+			m_ShortName= m_Name;
+			if(m_TypeParts.length > 0){
+				m_LongName =  m_Name+" : "+m_TypeParts[0];
+			}
+			else{
+				m_LongName =  m_Name+" : "+m_Type;
+			}
+			m_ImageName="$nl$/icons/obj.gif";
+			m_Drivers = null;
+		}
+		public void removeDrivers(){
+			m_Drivers = null;
+		}
+		public void addDriver(int line){
+			if (m_Drivers == null) {
+				m_Drivers = new ArrayList<Integer>();
+			}
+			m_Drivers.add(new Integer(line));
+		}
+		public List<Integer> getDrivers(){
+			return m_Drivers;
+		}
+		public void addAllDepends(Expression expr){
+			if (expr==null) return;
+			for (String hash:expr.getDepends())
+				if (!m_Depends.contains(hash)) m_Depends.add(hash);
+		}
+		
+		public String GetImageName(){
+			return m_ImageName;
+		}
+		public String getShortName(){
+			return m_ShortName;
+		}
+		public String getLongName(){
+			return m_LongName;
+		}
+		// Andrey
+		public String GetValue(){
+			return "";
+		}
+		public boolean isValidInt(){
+			return false; // parameter overwrites
+		}
+		
+		public boolean isInstance(){
+			return VerilogOutlineElementFactory.isInstance(m_Type);
+		}
+		public boolean isModule(){
+			return VerilogOutlineElementFactory.isModule(m_Type);
+		}
+		public boolean isRegister(){
+			return VerilogOutlineElementFactory.isRegister(m_Type);
+		}
+
+		public boolean isInteger(){
+			return VerilogOutlineElementFactory.isInteger(m_Type);
+		}
+		public boolean isReal(){
+			return VerilogOutlineElementFactory.isReal(m_Type);
+		}
+		public boolean isSequential(){
+			return VerilogOutlineElementFactory.isSequential(m_Type);
+		}
+		
+		public boolean isParameter(){
+			return VerilogOutlineElementFactory.isParameter(m_Type);
+		}
+		public boolean isDefparam(){
+			return VerilogOutlineElementFactory.isDefparam(m_Type);
+		}
+		public boolean isPort(){
+			return VerilogOutlineElementFactory.isPort(m_Type);
+		}
+		public int getDimension(){
+			return 0;
+		}
+/*		
+		public int getWidth(){
+			if (m_TypeParts.length<3) return 0;
+			String s=m_TypeParts[2].trim();
+			if (s.startsWith("[")) s=s.substring(1);
+			if (s.endsWith("]")) s=s.substring(0,s.length()-1);
+			if (s.contains(":")){
+				String [] ss=s.split(":");
+				int si=0,ei=0;
+				try {
+					si=Integer.parseInt(ss[0]);
+					ei=Integer.parseInt(ss[1]);
+				} catch (Exception e){
+					return 0;
+				}
+				ei-=si;
+				if (ei<0) ei=-ei;
+				return ei+1;
+			}
+			return 0;
+		}
+*/		
+		// Andrey: get {lowbit,highbit}
+		// in get Width [n] -> 0, [n:n] -> 1, making both ->1
+		public int [] getWidthBit(){
+			int shft=isPort()?1:0; // in port, all segments in m_TypeParts are shifted by 1
+			//variable#wire#[31:0]#0 vs. port#input#wire#[31:0]#0
+			int [] noRange={0,0};
+			if (m_TypeParts.length<(shft+3)) { //3
+				return noRange;
+			}
+			String s=m_TypeParts[shft+2].trim(); //2
+			if (s.startsWith("[")) s=s.substring(1);
+			if (s.endsWith("]")) s=s.substring(0,s.length()-1);
+			int si=0,ei=0;
+			if (s.contains(":")){
+				String [] ss=s.split(":");
+				try {
+					si=Integer.parseInt(ss[0]);
+					ei=Integer.parseInt(ss[1]);
+				} catch (Exception e){
+					return noRange;
+				}
+				if (si<ei){
+					int tmp=si;
+					si=ei;
+					ei=tmp;
+				}
+				int [] range={si-ei+1,ei}; // width,low bit, 
+				return range;
+			} else {
+				try {
+					si=Integer.parseInt(s);
+				} catch (Exception e){
+					return noRange;
+				}
+				int [] range={1,si};
+				return range;
+			}
+		}
+	}
+	
+	//TODO: Make an action in Editor context menu, so right-click will give a selection of choices - what to copy as module instance template
+	public class VerilogModuleElement extends VerilogOutlineElement{
+		final static private String HEADER_COMMENT="%s/* Instance template for module %s */\n";
+		private boolean parametricPorts=false; // port widths depend on parameters
+		public void setParametricPorts(boolean parametricPorts){
+			this.parametricPorts=parametricPorts;
+			if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR)) {
+				System.out.println("VerilogModuleElement.setParametricPorts("+parametricPorts+") : "+getName());
+			}
+		}
+		public boolean getParametricPorts(){
+			return parametricPorts;
+		}
+
+		public VerilogModuleElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
+			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);					
+			m_ImageName="$nl$/icons/module.gif";
+			if(m_TypeParts.length > 1){
+				m_LongName =  m_Name+" : "+m_TypeParts[1];
+				if (m_TypeParts[1].equals("primitive")){
+					m_ImageName="$nl$/icons/primitive.png";
+				}
+			} else if(m_TypeParts.length > 0){
+				m_LongName =  m_Name+" : "+m_TypeParts[0];
+			} else{
+				m_LongName =  m_Name+" : "+m_Type;
+			}
+		}
+		// TODO: Add configurable template
+		public String getInstanceTemplate(){
+			boolean addComments=VerilogPlugin.getPreferenceString(PreferenceStrings.INST_TEMPLATE).equals(PreferenceStrings.INST_TEMPLATE_COMMENTED);
+			boolean multiline=  VerilogPlugin.getPreferenceString(PreferenceStrings.INST_TEMPLATE).equals(PreferenceStrings.INST_TEMPLATE_MULTI) || addComments;
+			boolean noParams=   VerilogPlugin.getPreferenceString(PreferenceStrings.INST_TEMPLATE).equals(PreferenceStrings.INST_TEMPLATE_COMPACT);
+			return getInstanceTemplate(addComments, multiline, noParams);
+		}
+		public String getInstanceTemplate( boolean addComments, boolean multiline, boolean noParams) {
+			String indent;
+			if (VerilogPlugin.getPreferenceString(PreferenceStrings.INDENT_TYPE).equals("Tab")){
+				indent="\t";
+			} else {
+				indent="";
+				for (int i=0;i<VerilogPlugin.getPreferenceInt(PreferenceStrings.INDENT_SIZE);i++) indent+=" ";
+			}
+			String sep="\n",sep1="\n";
+			if (!multiline) {
+				indent="";
+				sep=" ";
+				sep1="";
+			}
+			String startParams=" #("+sep1;
+			String itemParam=    indent+indent+".%s(%s),"+sep;
+			String itemParamLast=indent+indent+".%s(%s)"+sep1+indent+")";
+			String instanceFormat=" %s_i ("+sep1;
+			String itemPort=     indent+indent+".%s(),%s"+sep;
+			String itemPortLast= indent+indent+".%s()%s"+sep1+indent+");\n";
+			List <VerilogParameterElement> parameterList= new ArrayList<VerilogParameterElement>();
+			List <VerilogPortElement>      portList=      new ArrayList<VerilogPortElement>();
+			OutlineElement[] children=getChildren();
+			for (OutlineElement oe:children) { // no localparams!
+				if (!noParams && (oe instanceof VerilogParameterElement) && !((VerilogParameterElement) oe).isLocal()) {
+					parameterList.add((VerilogParameterElement) oe);
+				} else if (oe instanceof VerilogPortElement) {
+					portList.add((VerilogPortElement) oe);
+				}
+			}
+			String result=String.format(HEADER_COMMENT, indent, m_Name);
+			result+=indent+m_Name;
+			if (parameterList.size()>0){
+				result+=startParams;
+				for (int i=0;i<parameterList.size();i++){
+					VerilogParameterElement param =parameterList.get(i);
+					String format=(i<(parameterList.size()-1))?itemParam:itemParamLast;
+					String value=(param.m_TypeParts.length > 3)?param.m_TypeParts[3]:"";
+					result+=String.format(format, param.getName(),value);
+				}
+			}
+			result+=String.format(instanceFormat, m_Name);
+			if (portList.size()==0){
+				result+=indent+");";
+			} else {
+				for (int i=0;i<portList.size();i++){
+					VerilogPortElement port =portList.get(i);
+					String format=(i<(portList.size()-1))?itemPort:itemPortLast;
+					String comment= addComments?((port.m_TypeParts.length > 3)?(" // "+port.m_TypeParts[1]+port.m_TypeParts[3]+" "+port.m_TypeParts[2]):
+						((port.m_TypeParts.length > 2)?(" // "+port.m_TypeParts[1]+" "+port.m_TypeParts[2]):
+							((port.m_TypeParts.length > 1)?(" // "+port.m_TypeParts[1]):""))):"";
+					result+=String.format(format, port.getName(),comment);
+				}
+			}
+			return result;
+		}
+		
+	}
+	public class VerilogTaskElement extends VerilogOutlineElement{
+		public VerilogTaskElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
+			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);					
+			m_ImageName="$nl$/icons/t.gif";
+		}
+	}
+	public class VerilogTaskEnableElement extends VerilogOutlineElement{
+		public VerilogTaskEnableElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
+			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);					
+			m_ImageName="$nl$/icons/te.png";
+			if(m_TypeParts.length > 1){
+//				m_LongName =  m_TypeParts[1]+" : "+m_TypeParts[0];
+				m_LongName =  m_TypeParts[1]+" : task enable";
+			} else{
+				m_LongName =  m_Name+" : "+m_Type;
+			}
+		}
+	}
+	public class VerilogFunctionElement extends VerilogOutlineElement{
+		public VerilogFunctionElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
+			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);					
+			m_ImageName="$nl$/icons/f.gif";
+			if(m_TypeParts.length > 1){
+				m_LongName =  m_Name+" : "+m_TypeParts[0]+m_TypeParts[1];
+			} else if(m_TypeParts.length > 0){
+				m_LongName =  m_Name+" : "+m_TypeParts[0];
+			} else{
+				m_LongName =  m_Name+" : "+m_Type;
+			}
+		}
+	}
+	public class VerilogFunctionReferenceElement extends VerilogSignalElement{
+		public VerilogFunctionReferenceElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
+			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);					
+			m_ImageName="$nl$/icons/fr.png";
+			if(m_TypeParts.length > 2){
+//				m_LongName =  m_TypeParts[1]+m_TypeParts[2]+" : "+m_TypeParts[0];
+				m_LongName =  m_TypeParts[1]+" : function reference"+m_TypeParts[2];
+			}else if(m_TypeParts.length > 1){
+				m_LongName =  m_TypeParts[1]+" : "+m_TypeParts[0];
+			} else{
+				m_LongName =  m_Name+" : "+m_Type;
+			}
+		}
+	}
+	
+	public class VerilogInstanceElement extends VerilogOutlineElement{
+		
+		public VerilogInstanceElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
+			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);					
+			m_ImageName="$nl$/icons/yello_dia.gif";
+			if (name.contains(":")){
+				m_LongName=String.format("%s : primitive instance",getModuleType());
+			} else {
+				m_LongName=String.format("%s(%s)",name,getModuleType());
+			}
+			
+		}
+		
+		/**
+		 * Returns the type of this module instantiation
+		 * @return
+		 */
+		public String getModuleType(){
+			if(m_TypeParts.length > 1){
+				return m_TypeParts[1]; 
+			}
+			else{
+				return "";
+			}
+		}
+	}
+	public class VerilogPortElement extends VerilogOutlineElement{
+		public static final int INPUT	=0;
+		public static final int OUTPUT	=1;
+		public static final int INOUT	=2;
+		private int m_Direction;
+		
+		public String getLongName(){
+			String [] names=m_LongName.split(" : ");
+			if (m_Parent !=null && (m_Parent instanceof VerilogTaskElement)){
+				return names[0]+" : task "+names[1];
+			} else if (m_Parent !=null && (m_Parent instanceof VerilogFunctionElement)){
+				return names[0]+" : function "+names[1];
+			} else if ((m_Children==null) || m_Children.isEmpty()){
+				return names[0]+" : module "+names[1];
+			} else {
+				return names[0]+" : instance "+names[1];
+			}
+		}
+		
+		public String GetDirectionString(){
+			switch(m_Direction){
+			case INPUT:
+				return "in";
+			case OUTPUT:
+				return "out";
+			case INOUT:
+				return "inout";
+			default:
+				return "";
+			}
+		}
+		public VerilogPortElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
+			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);					
+			if(type.toLowerCase().startsWith("port#input#")){
+				m_Direction=INPUT;
+				m_ImageName="$nl$/icons/port_in.gif";
+			}
+			else if (type.toLowerCase().startsWith("port#output#")){
+				m_Direction = OUTPUT;
+				m_ImageName="$nl$/icons/port_out.gif";
+			}
+			else{
+				m_Direction = INOUT;
+				m_ImageName="$nl$/icons/port_inout.gif";
+			}
+			m_LongName = String.format("%s :", name);
+			for (int i = 1; i < m_TypeParts.length; i++) {
+				if (i >= 4)
+					break; // remove last "cstyle"
+				m_LongName += String.format(" %s", m_TypeParts[i]);
+			}
+		}
+	}
+	public class VerilogParameterElement extends VerilogOutlineElement{
+		public VerilogParameterElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
+			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
+			m_ImageName="$nl$/icons/P.gif";
+			String value = GetValue();
+			m_LongName = String.format("%s : %s %s", name, m_TypeParts[0], value);
+		}
+
+		public String getLongName(){
+			String [] names=m_LongName.split(" : ");
+			if ((m_Children==null) || m_Children.isEmpty()){
+				return names[0]+" : module "+names[1];
+			} else {
+				return names[0]+" : instance "+names[1];
+			}
+		}
+		
+		public boolean isLocal() {
+			return m_Type.startsWith("localparam#");
+		}
+
+		public boolean isDefparam() {
+			return m_Type.startsWith("defparam#");
+		}
+		
+		public String[] getDefparamSegments(){
+			return m_Name.split("\\.");
+		}
+		
+		public String GetValue(){
+			if(m_TypeParts.length > 3)
+				return m_TypeParts[3];			
+			else
+				return "";
+		}
+		public boolean isValidInt(){
+			String sv=GetValue();
+			try {
+				Integer.parseInt(sv);
+				return true;
+			} catch (Exception e){
+				return false;
+			}
+		}
+	}
+	public class VerilogSignalElement extends VerilogOutlineElement{		
+		public VerilogSignalElement(String name, String type, int startLine, int startCol, int endLine, int endCol, IFile file, boolean bVisible) {
+			super(name, type, startLine, startCol, endLine, endCol, file, bVisible);
+			m_ImageName = "$nl$/icons/signal.gif";
+			m_LongName = String.format("%s :", name);
+			int len = m_TypeParts.length;
+			boolean isVariable = m_TypeParts[0].equals("variable");
+			if (isVariable && len > 3) {
+				len = 3;
+			}
+			for (int i = 1; i < len; i++) {
+				m_LongName += String.format(" %s", m_TypeParts[i]);
+			}
+			if (isVariable && m_TypeParts.length >= 3) {
+				int dim = Integer.parseInt(m_TypeParts[3]);
+				for (int i = 0; i < dim; i++) {
+					m_LongName += "[]";
+				}
+			}
+		}
+		public int getDimension(){ // may be valid only for some types?
+			boolean isVariable = m_TypeParts[0].equals("variable");
+			if (!isVariable || (m_TypeParts.length<4)) return 0;
+			try {
+				return Integer.parseInt(m_TypeParts[3]);
+			} catch (Exception e){
+				return 0;
+			}
+		}
+	}
+
+	public class VerilogWireElement extends VerilogSignalElement{		
+		public VerilogWireElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
+			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);			
+			m_ImageName="$nl$/icons/wire_signal.gif";						
+		}	
+	}
+	public class VerilogRegElement extends VerilogSignalElement{		
+		public VerilogRegElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
+			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);			
+			m_ImageName="$nl$/icons/register_signal.gif";						
+		}	
+	}
+	public class VerilogGroupElement extends VerilogSignalElement{		
+		public VerilogGroupElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
+			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);			
+			m_ImageName="$nl$/icons/obj.gif";						
+		}	
+	}
+	
+	/**
+	 * Class factory function
+	 */
+	public OutlineElement CreateElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file){
+		if (isModule(type)){
+			return new VerilogModuleElement(name,type,startLine,startCol,endLine,endCol,file,true);
+		}
+		else if (isTask(type)){
+			return new VerilogTaskElement(name,type,startLine,startCol,endLine,endCol,file,true);
+		}
+		else if (isTaskEnable(type)){
+			return new VerilogTaskEnableElement(name,type,startLine,startCol,endLine,endCol,file,true);
+		}
+		else if (isFunction(type)){
+			return new VerilogFunctionElement(name,type,startLine,startCol,endLine,endCol,file,true);
+		}
+		else if (isFunctionReference(type)){
+			return new VerilogFunctionReferenceElement(name,type,startLine,startCol,endLine,endCol,file,true);
+		}
+		else if (isInstance(type)){
+			return new VerilogInstanceElement(name,type,startLine,startCol,endLine,endCol,file,true);
+		}
+		else if (isPort(type)){
+			return new VerilogPortElement(name,type,startLine,startCol,endLine,endCol,file,true);
+		}
+		else if (isParameter(type)){
+			return new VerilogParameterElement(name,type,startLine,startCol,endLine,endCol,file,true);
+		}
+		else if (isDefparam(type)){
+			return new VerilogParameterElement(name,type,startLine,startCol,endLine,endCol,file,true); // try same as parameter?
+		}
+		else if (isWire(type)){
+			return new VerilogWireElement(name,type,startLine,startCol,endLine,endCol,file,true);
+		}
+		else if (isRegister(type)){
+			return new VerilogRegElement(name,type,startLine,startCol,endLine,endCol,file,true);
+		}
+		else if (isSignal(type)){
+			return new VerilogSignalElement(name,type,startLine,startCol,endLine,endCol,file,true);
+		}
+
+		return new VerilogOutlineElement(name,type,startLine,startCol,endLine,endCol,file,true);
+	}
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/verilog/VerilogParserCore.jj vdt/src/com/elphel/vdt/veditor/parser/verilog/VerilogParserCore.jj
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/verilog/VerilogParserCore.jj	2016-06-24 10:29:40.856495517 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/verilog/VerilogParserCore.jj	2016-06-24 10:29:40.820496516 -0600
@@ -1,1430 +1,2002 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2012 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-
-options {
-	JAVA_UNICODE_ESCAPE = true ;
-	STATIC = false ;
-}
-
-PARSER_BEGIN(VerilogParserCore)
-
-package net.sourceforge.veditor.parser.verilog;
-
-public abstract class VerilogParserCore
-{
-	public static final int STATEMENT = 0;
-	public static final int ASSIGN_STMT = 1;
-	public static final int INITIAL_BLOCK = 2;
-	public static final int ALWAYS_BLOCK = 3;
-
-	protected abstract void begin(int mode);
-	protected abstract void end(int mode);
-	protected abstract void beginOutlineElement(Token begin, String name, String type);
-	protected abstract void endOutlineElement(Token end, String name, String type);
-
-	protected void beginOutlineElement(Token begin, String type) {
-		beginOutlineElement(begin, begin.image, type);
-	}
-	protected void endOutlineElement(Token end, String type) {
-		endOutlineElement(end, end.image, type);
-	}
-
-	protected abstract void addCollapsible(int startLine,int endLine);
-	protected abstract Expression operator(Expression arg, Token op);
-	protected abstract Expression operator(Expression arg1, Token op, Expression arg2);
-	protected abstract Expression operator(Expression arg1, Token op, Expression arg2, Expression arg3);
-	protected abstract Expression variableReference(Identifier ident);
-	protected abstract Expression functionReference(Identifier ident);
-
-	protected abstract void parameterAssignment(String name, Expression value);
-	protected abstract void variableAssignment(Identifier ident);
-	protected abstract void taskReference(Identifier ident);
-	protected abstract void variableConnection(Expression arg, String module, Identifier port);
-	protected abstract void variableConnection(Expression arg, String module, int portIndex);
-	protected abstract void evaluateAssignment(Token asn, int lvalue, Expression exp);
-	protected abstract void beginGenerateBlock(Identifier block);
-	protected abstract void endGenerateBlock(Identifier block);
-}
-
-PARSER_END(VerilogParserCore)
-
-//
-// operation for /* */
-//
-MORE :
-{
-	"/*" : IN_MULTI_LINE_COMMENT
-}
-
-<IN_MULTI_LINE_COMMENT>
-SKIP :
-{
-	<MULTI_LINE_COMMENT: "*/"> : DEFAULT
-}
-
-<IN_MULTI_LINE_COMMENT>
-MORE :
-{
-	< ~[] >
-}
-
-//
-// operation for (* *)
-//
-MORE :
-{
-	<"(*" ~[")"]> : IN_PROPERTY
-}
-
-<IN_PROPERTY>
-SKIP :
-{
-	<PROPERTY_COMMENT: "*)"> : DEFAULT
-}
-
-<IN_PROPERTY>
-MORE :
-{
-	< ~[] >
-}
-
-SKIP :
-{
-	" " | "\t" | "\r" | "\n" | "\f"
-}
-
-SPECIAL_TOKEN :
-{
-	<SINGLE_LINE_COMMENT: "//" (~["\n"])* >
-}
-
-TOKEN :
-{
-	<MODULE: "module">
-|	<ENDMODULE: "endmodule">
-|	<BEGIN: "begin">
-|	<END: "end">
-|	<FORK: "fork">
-|	<JOIN: "join">
-|	<SPECIFY: "specify">
-|	<ENDSPECIFY:"endspecify">
-|	<IF: "if">
-|	<ELSE: "else">
-|	<WHILE: "while">
-|	<FOR: "for">
-|	<FOREVER: "forever">
-|	<REPEAT: "repeat">
-|	<WAIT: "wait">
-|	<CASE: ("case" | "casex" | "casez") >
-|	<DEFAULT_LABEL: "default">
-|	<ENDCASE: "endcase">
-|	<FUNCTION: "function">
-|	<ENDFUNCTION: "endfunction">
-|	<TASK: "task">
-|	<ENDTASK: "endtask">
-|	<GENERATE: "generate">
-|	<ENDGENERATE: "endgenerate">
-|	<INPUT: "input">
-|	<OUTPUT: "output">
-|	<INOUT: "inout">
-|	<INTEGER: "integer">
-|	<REG: "reg">
-|  < WIRE: "wire" >
-|	<EVENT: "event">
-|	<GENVAR: "genvar">
-|	<REAL: "real">
-|	<PARAMETER: "parameter"> 
-|	<LOCALPARAM: "localparam">
-|	<SIGNED: "signed">
-|	<PROPERTY: "property" >
-|	<ENDPROPERTY: "endproperty" >
-|	<ASSERT: "assert" | "cover">
-|  <ASSIGN: "assign" >
-|  <DEASSIGN: "deassign" >
-|  <FORCE : "force" >
-|  <RELEASE: "release" >
-|  < TIME: "time" >
-|  < REALTIME: "realtime" >
-|  < DEFPARAM: "defparam" >
-|  < OR: "or" >
-|  < DISABLE: "disable" >
-|   <ALWAYS: "always" >
-|   <INITIAL: "initial" >
-|  < EDGE: ( "posedge" | "negedge" ) >
-|  < SUPPLY : ( "supply0" | "supply1" ) >
-|  < NET_TYPE: ( "tri" | "tri1" | "wand" | "triand" | "tri0" | "wor" | "trior" ) >
-|  < STRENGTH: ("strong0" | "strong1" | "pull0" | "pull1" | "weak0" | "weak1" |"highz0" | "highz1" ) >
-|   <PRIM_1IN_XOUT: ( "and" | "xor" | "nand" | "nor" | "xnor")>
-|   <PRIM_1OUT_XIN: ( "buf" | "not" )>
-|   <PRIM_1OUT_1IN_1CNTL: ( "bufif0" | "bufif1" | "notif0" | "notif1" | "pmos" | "nmos" | "rpmos" | "rnmos")>
-|   <PRIM_1OUT: ( "pullup" | "pulldown")>
-|   <PRIM_1OUT_1IN_NC_PC: ("cmos" | "rcmos" )>
-|   <PRIM_BI: ("tran" |  "rtran" | "tranif0" | "rtranif0" | "rtranif1")>
-|	<LPAREN: "(" >
-|	<RPAREN: ")" >
-|	<LBRACE: "{" >
-|	<RBRACE: "}" >
-|	<LBRACKET: "[" >
-|	<RBRACKET: "]" >
-|	<EOS: ";" >
-|	<PARA: "#" >
-|	<AT: "@" >
-|	<DOLLAR: "$" >
-|	<COMMA: "," >
-|  < DOT: "." >
-//|	<OTHER: "[.]" >
-}
-
-TOKEN :
-{
-  < AGN: "=" >
-| < GT: ">" >
-| < LT: "<" >
-| < BANG: "!" >
-| < TILDE: "~" >
-| < HOOK: "?" >
-| < COLON: ":" >
-| < PCOLON: "+:" >
-| < MCOLON: "-:" >
-| < EQ: "==" >
-| < LE: "<=" >
-| < GE: ">=" >
-| < NE: "!=" >
-| < SC_OR: "||" >
-| < SC_AND: "&&" >
-| < PLUS: "+" >
-| < MINUS: "-" >
-| < STAR: "*" >
-| < SLASH: "/" >
-| < BIT_AND: "&" >
-| < BIT_OR: "|" >
-| < XOR: "^" >
-| < REM: "%" >
-| < LSHIFT: "<<" >
-| < RSHIFT: ">>" >
-| < NEG_AND: "~&" >
-| < NEG_OR: "~|" >
-| < NEG_XOR: "~^" >
-| < XOR_NEG: "^~" >
-| < EQ_C: "===" >
-| < NE_C: "!==" >
-| < POWER: "**" >
-| < ALSHIFT: "<<<" >
-| < ARSHIFT: ">>>" >
-}
-
-TOKEN :
-{
-  < IDENT :
-  	 // No matching macro means simple identifier
-     ("`")? < LETTER > (< LETTER > | ["0"-"9"] )*
-   | < BACKSLASH > (~[ " " ])+
-     >
-| < SYSTEM_IDENT:
-     "$" < LETTER > (< LETTER > | ["0"-"9"])*
-     >
-| < #LETTER : [ "a"-"z", "A"-"Z", "_" ] >
-| < #BACKSLASH : "\\" >
-}
-
-TOKEN :
-{
-  < INTEGER_LITERAL :
-    < NUMBER_LITERAL >
-  | < DECIMAL_LITERAL >
-  | < HEX_LITERAL >
-  | < OCTAL_LITERAL >
-  | < BINARY_LITERAL >
-    >
-| < #NUMBER_LITERAL : ([ "0"-"9", "_" ])+ >
-| < #DECIMAL_LITERAL : ([ "0"-"9" ])* "'" (["s", "S"])? [ "d", "D" ] ([" ", "\t"])* ([ "0"-"9", "_", "x", "X", "z", "Z", "?"])* >
-| < #HEX_LITERAL : ([ "0"-"9" ])* "'" (["s", "S"])? [ "h", "H" ] ([" ", "\t"])* ([ "0"-"9", "a"-"f", "A"-"F", "_", "x", "X", "z", "Z", "?" ])+ >
-| < #OCTAL_LITERAL : ([ "0"-"9" ])* "'" (["s", "S"])? [ "o", "O" ] ([" ", "\t"])* ([ "0"-"7", "_", "x", "X", "z", "Z", "?" ])* >
-| < #BINARY_LITERAL : ([ "0"-"9" ])* "'" (["s", "S"])? [ "b", "B" ] ([" ", "\t"])* ([ "0"-"1", "_", "x", "X", "z", "Z", "?" ])* >
-| < REAL_LITERAL :
-    ([ "0"-"9" ])+ "." ([ "0"-"9" ])*
-  | ([ "0"-"9" ])+ ( "." ([ "0"-"9" ])*)? [ "e", "E" ] ([ "+", "-" ])? ([ "0"-"9" ])+ >
-| < STRING_LITERAL:
-      "\""
-      (   (~["\"","\n","\r"])
-        | ("\\"
-            ( ["n","t","b","r","f","\\","'","\""]
-            | ["0"-"7"] ( ["0"-"7"] )?
-            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
-            )
-          )
-      )*
-      "\""  >
-}
-
-void verilogText() :
-{}
-{
-	( moduleDecl() )*
-}
-
-void moduleDecl() :
-{
-	Identifier name;
-	Token end;
-}
-{
-	( <IDENT>)* // ignore preprocessor directive
-	< MODULE > name = identifier()
-	{
-		beginOutlineElement(name, "module#");
-	}
-	[ "#" "(" [ parameterArg() ( "," parameterArg() )* ] ")"  ]
-	[ "(" [ argument() ( "," argument() )* ] ")" ]
-	";"
-	( moduleItem() )*
-	end = < ENDMODULE >
-	{
-	    endOutlineElement(end, name. image, "module#");
-	}
-}
-
-void parameterArg() :
-{
-	Token name,value;
-	String mod, range;
-}
-{ 
-	<PARAMETER> mod = parameterModifier() range = bitRange()
-	parameterAssign("parameter", mod, range)
-}
-
-String parameterModifier() :
-{
-	String ret = " ";
-}
-{
-	(
-		("real" | "integer" | "signed" )
-		{
-			ret += token.image + " ";
-		}
-	)*
-	{
-		return ret;
-	}
-}
-
-
-void parameterAssign(String type, String mod, String range) :
-{
-	Identifier name;
-	Expression value;
-}
-{
-	name = identifier()
-	"="
-	value = constantExpression()
-	{
-		String types = type + "#" + mod + "#" + range + "#" + value.toString();
-		beginOutlineElement(name, types);
-		parameterAssignment(name.image, value);
-		endOutlineElement(name, types);
-	}
-}
-
-void argument() :
-{
-	Token direction;
-	Identifier name;
-	String modifier="";
-	String range;
-	Token asn;
-	Expression exp;
-}
-{
-		// C++ style argument
-		( direction=<INPUT>  | direction=<OUTPUT>  | direction=<INOUT> )
-		modifier = variableModifier()
-		range = bitRange()
-		name = identifier()
-		{
-			String types = "port#" + direction.image + "#" + modifier + "#" + range;
-			beginOutlineElement(name, types);
-			endOutlineElement(name, types);
-		}
-		[
-			asn = "=" exp = expression()
-			{
-				variableAssignment(name);
-				evaluateAssignment(asn, name.getWidth(), exp);
-			}
-		]
-	|
-		// C style argument, portDecl will add it to OutlineContainer
-		identifier()
-}
-
-void moduleItem() :
-{}
-{
-	moduleOrGenerateItem()
-| 	portDecl()
-|	<SPECIFY> {begin(STATEMENT);} skipTo( ENDSPECIFY ) {end(STATEMENT);}
-|	generate()
-|	<PROPERTY> skipTo(ENDPROPERTY)
-}
-
-void moduleOrGenerateItem() :
-{}
-{
-	variableDecl()
-|	parameterDecl()
-|	taskDecl()
-|	functionDecl()
-| <DEFPARAM> {begin(STATEMENT);} skipTo( EOS ) {end(STATEMENT);}
-|  assign()
-|  primitiveInstance()
-|  LOOKAHEAD(3) moduleInstance()
-|	initialAlways() // initial and always
-|	<ASSERT>  skipTo(EOS)
-|	identifier() ":" <ASSERT>  skipTo(EOS)
-| 	";"
-}
-
-void portDecl() :
-{
-	Token direction;
-	String modifier;
-	String range;
-}
-{
-	( direction=<INPUT>  | direction=<OUTPUT>  | direction=<INOUT> )
-	modifier = variableModifier()
-	{ begin(STATEMENT); }
-	range = bitRange()
-	portDeclSingle(direction, modifier, range)
-	("," portDeclSingle(direction, modifier, range))* ";"
-	{ end(STATEMENT); }
-}
-
-String variableModifier() :
-{
-	String ret = "";
-}
-{
-	(
-		( "real" | "realtime" | "integer" | "wire" | "reg" | "signed" | "time" )
-		{
-			ret += token.image + " ";
-		}
-	)*
-	{
-		return ret;
-	}
-}
-
-void portDeclSingle(Token direction, String modifier, String range) :
-{
-	Identifier name;
-	Token asn;
-	Expression exp;
-}
-{
-	name = identifier()
-	{
-		String type = "port#" + direction.image + "#" + modifier + "#" + range + "#cstyle";
-		beginOutlineElement(name, type);
-		endOutlineElement(name, type);
-	}
-	[
-		asn = "=" exp = expression()
-		{
-			variableAssignment(name);
-			evaluateAssignment(asn, name.getWidth(), exp);
-		}
-	]
-}
- 
-void primitiveInstance():
-{
-	String prim;
-}
-{
-	(     <PRIM_1IN_XOUT> | "or"
-      	| <PRIM_1OUT_XIN>      
-		| <PRIM_1OUT_1IN_1CNTL>
-		| <PRIM_1OUT>
-		| <PRIM_1OUT_1IN_NC_PC>
-		| <PRIM_BI>
-	) { prim = token.image;}
-	[ LOOKAHEAD(2) strength() ] [ delay3() ]
-	[ identifier() bitRange() ] "(" portConnect(prim) ")"
-	( "," identifier() bitRange() "(" portConnect(prim) ")" )*
-	";"
-}
-
-void moduleInstance():
-{
-	Identifier module, inst;
-	Token iend ;
-}
-{ 
-	module = identifier() 
-	{ begin(STATEMENT); }
-	
-	(   //module instantiation
-		(   [ "#" ( identifier() | number() | "(" parameterConnect() ")" ) ]
-			inst = identifier()
-			{
-				beginOutlineElement(module, inst.image, "instance#"+module.image);
-			}
-			[ "(" [ portConnect(module.image) ] ")" ]
-		    iend = ";"
-		    {			
-				endOutlineElement(iend, inst.image, "instance#"+module.image);
-				addCollapsible(module.beginLine, iend.endLine);
-		     }
-		 )
-	 |   //user defined primitive	 
-		 (  "(" portConnect(module.image) ")"
-		 	iend = ";"
-		 )
-	)
-	{ end(STATEMENT); }
-}
-
-void parameterConnect() :
-{}
-{
-	"." identifier() "(" [ constantExpression() ] ")" ( "," "." identifier() "(" [ constantExpression() ] ")" )*
-|	constantExpression() ( "," constantExpression() )*	
-}
-
-void portConnect(String module) :
-{
-	int count = 0;
-}
-{
-	count = portConnectSingle(module, count)
-	( "," count = portConnectSingle(module, count) )*
-}
-
-int portConnectSingle(String module, int count) :
-{
-	Identifier port;
-	Expression arg = null;
-}
-{
-	"." port = identifier() "(" [ arg = expression() ] ")"
-	{
-		variableConnection(arg, module, port);
-		return count + 1;
-	}
-|	arg = expression()
-	{
-		variableConnection(arg, module, count);
-		return count + 1;
-	}
-}
-
-void assign() :
-{
-	int width;
-	Token asn;
-	Expression exp;
-}
-{
-	"assign"
-	{begin(ASSIGN_STMT); }
-	[ strength() ] [ delay3() ]
-	width = lvalue() asn = "=" exp = expression()
-	{
-		evaluateAssignment(asn, width, exp);
-	}
-	(
-		"," width = lvalue() asn = "=" exp = expression()
-		{
-			evaluateAssignment(asn, width, exp);
-		}
-	)*
-	";"
-	{end(ASSIGN_STMT); }
-}
-
-void variableDecl():
-{
-	Token variable;
-	String type;
-	String range;
-}
-{
-	type = variableType()
-	{ begin(STATEMENT); }
-	[ strength() ]
-	[ "signed" 	{ type += " signed";}	]
-	range = bitRange()
-	[ delay3() ]
-	variableDeclSingle(type, range) ( "," variableDeclSingle(type, range) )* ";"
-	{ end(STATEMENT); }
-}
-
-String variableType() :
-{
-	String type;
-}
-{
-	 type = netType()
-	 {
-	 	return type;
-	}
-|	( "reg" | "real" | "integer" | "event" |"genvar" | "time" | "realtime" )
-	{
-		return token.image;
-	}
-}
-
-void variableDeclSingle(String mod, String range) :
-{
-	Identifier variable;
-	Token asn;
-	Expression exp;
-	int dimension = 0;
-}
-{
-	variable = identifier()
-	("[" constantExpression() ":" constantExpression() "]" { dimension++; })*
-	{
-		String type = "variable#" + mod + "#" + range + "#" + dimension;
-		beginOutlineElement(variable, type);
-		endOutlineElement(variable, type);
-	}
-	[
-		asn = "=" exp = expression()
-		{
-			variableAssignment(variable);
-			evaluateAssignment(asn, variable.getWidth(), exp);
-		}
-	]
-}
-
-void delay3() :
-{}
-{
-	"#"
-	(
-		LOOKAHEAD(3)
-		delayValue()
-	| 	"(" minTypMaxExpresstion() [ "," minTypMaxExpresstion() ["," minTypMaxExpresstion() ] ] ")"
-	)
-}
-
-void parameterDecl():
-{
-	String type;
-	String mod, range;
-}
-{ 
-	(
-		<PARAMETER>  {type = "parameter";}
-	|	<LOCALPARAM> {type = "localparam";}
-	)
-	mod = parameterModifier()
-	range = bitRange()
-	parameterAssign(type, mod, range) ( "," parameterAssign(type, mod, range) )* ";"
-}
-
-void initialAlways():
-{
-	Token start;
-}
-{
-	( start = <INITIAL> | start = <ALWAYS> )
-	{
-		if (start.image.equals("initial"))
-			begin(INITIAL_BLOCK);
-		else
-			begin(ALWAYS_BLOCK);
-	} 
-	statement() 
-	{
-		if (start.image.equals("initial"))
-			end(INITIAL_BLOCK);
-		else
-			end(ALWAYS_BLOCK);
-		addCollapsible(start.beginLine,token.endLine);
-	}
-}
-
-void statement() :
-{
-	Token end;
-}
-{
- 	assignOrTaskEnable()
-| 	proceduralContinuousAssignment()
-|  proceduralTimingControlStatement()
-|	ifStatement()
-|	caseStatement()
-|	whileStatement()
-|	forStatement()
-|	foreverStatement()
-|	repeatStatement()
-|	waitStatement()
-| 	"disable" identifier() ";"
-|  "->" identifier() ";"
-|	block()
-|  ";"
-}
-
-void assignOrTaskEnable() :
-{
-	Identifier ident;
-	Token asn;
-	Expression exp;
-	int width;
-}
-{
-	ident = complexIdentifier()
-	(
-		(asn = "="  | asn = "<=") [delayOrEventControl() ] exp = expression() ";"
-		{
-			variableAssignment(ident);
-			evaluateAssignment(asn, ident.getWidth(), exp);
-		}
-	| 	[ "(" expression() ("," expression())* ")"] ";"
-		{
-			taskReference(ident);
-		}
-	)
-|	width = lvalueConcatenation() (asn = "="  | asn = "<=") [delayOrEventControl() ] exp = expression() ";"
-	{
-		evaluateAssignment(asn, width, exp);	
-	}
-|	<SYSTEM_IDENT> [ "(" expression() ("," expression())* ")"] ";"
-}
-
-void delayOrEventControl() :
-{}
-{
-	delayContol() | eventContol()
-}
-
-void delayContol() :
-{}
-{
-	"#" ( delayValue() | "(" minTypMaxExpresstion() ")" )
-}
-
-void delayValue() :
-{}
-{
-	number() | identifier()
-}
-
-void eventContol() :
-{}
-{
- 	"@"
-	(	identifier()
-	|	 "*"
-	|	"(" (eventExpression() | "*" ) ")"
-	)
-}
-
-void eventExpression():
-{}
-{
-	( expression() | < EDGE > expression() )
-	( ("," | "or") ( expression() | < EDGE > expression() ) )*
-	// 'repeat' '(' expression ')' event_control -> ignored
-}
-
-void proceduralContinuousAssignment() :
-{
-	int width;
-	Token asn;
-	Expression exp;
-}
-{
-	"assign" width = lvalue() asn = "=" exp = expression() ";"
-	{
-		evaluateAssignment(asn, width, exp);
-	}
-|	"deassign" lvalue() ";"
-|	"force"  width = lvalue() asn = "=" exp = expression() ";"
-	{
-		evaluateAssignment(asn, width, exp);
-	}
-|	"release" lvalue() ";"
-}
-
-void proceduralTimingControlStatement() :
-{}
-{
-	delayOrEventControl() statement()
-}
-
-void ifStatement() :
-{}
-{
-	<IF> "(" expression() ")" statement()
-	[ LOOKAHEAD(1) <ELSE> statement() ]
-}
-
-void caseStatement() :
-{}
-{
-	<CASE>"(" expression() ")"
-	(
-		expression() ("," expression())* ":" statement()
-	| 	"default" [":"] statement()
-	)+
-	<ENDCASE>
-}
-
-void whileStatement() :
-{}
-{
-	<WHILE> "(" expression() ")" statement()
-}
-
-void forStatement() :
-{}
-{
-	<FOR> "("
-	lvalue() "=" expression() ";"
-	expression() ";"
-	lvalue() "=" expression() ")"
-	statement()
-}
-
-void foreverStatement() :
-{}
-{
-	<FOREVER> statement()
-}
-
-void repeatStatement() :
-{}
-{
-	<REPEAT> "(" expression() ")" statement()
-}
-
-void waitStatement() :
-{}
-{
-	<WAIT> "(" expression() ")" statement()
-}
-
-void block() :
-{}
-{
-	( <BEGIN> | <FORK> )
-	[ ":" identifier() ( blockItem() )* ]
-	( statement() )*
-	(<END> | <JOIN> )
-}
-
-void blockItem():
-{}
-{
-	parameterDecl()	
-| 	variableDecl()
-}
-  
-void functionDecl():
-{}
-{
-	<FUNCTION> {begin(STATEMENT);} function() {end(STATEMENT);}
-}
-
-void taskDecl():
-{}
-{
-	<TASK> {begin(STATEMENT);} task() {end(STATEMENT);}
-}
-
-void function() :
-{
-	String range;
-	Identifier name;
-	Token end ;
-}
-{
-	variableModifier() range = bitRange() name = identifier()
-	[ "(" skipTo(RPAREN) ]
-	";"
-	{
-		beginOutlineElement(name, "function#" + range);
-	}
-	end = skipTo( ENDFUNCTION )
-	{		
-		endOutlineElement(end, name.image, "function#" + range);
-		addCollapsible(name.beginLine, end.endLine);				
-	}
-}
-
-void task() :
-{
-	Identifier name;
-	Token end ;
-}
-{
-	name = identifier() ";"
-	{
-		beginOutlineElement(name, "task#");
-	}
-	end = skipTo( ENDTASK )
-	{	
-		endOutlineElement(end, name.image, "task#");
-		addCollapsible(name.beginLine, end.endLine);
-	}
-}
-
-void generate() :
-{}
-{
-	<GENERATE>
-	( generateItem() )*
-	<ENDGENERATE>
-}
-
-void generateItem() :
-{
-	Identifier block = null;
-}
-{
-	moduleOrGenerateItem()
-|  generateIfStatement()
-|  generateCaseStatement()
-|  generateForStatement()
-|	(
-		<BEGIN> [ ":" block = identifier() ]
-		{
-			if (block != null)
-				beginGenerateBlock(block);
-		}
-		( generateItem() )*
-		<END> 
-		{
-			if (block != null) {
-				endGenerateBlock(block);
-			}
-		}
-	)
-}
-
-void generateIfStatement() :
-{}
-{
-	<IF> "(" constantExpression() ")" generateItem()
-	[ LOOKAHEAD(1) <ELSE> generateItem() ]
-}
-
-void generateCaseStatement() :
-{}
-{
-	<CASE> "(" constantExpression() ")"
-	(
-		constantExpression() ("," constantExpression())* ":" generateItem()
-	| 	"default" ":" generateItem()
-	)+
-	<ENDCASE>
-}
-
-void generateForStatement() :
-{}
-{
-	<FOR> "("
-	lvalue() "=" expression() ";"
-	expression() ";"
-	lvalue() "=" expression() ")"
-	generateItem()
-}
-
-
-String netType() :
-{}
-{
-	( "wire" | < NET_TYPE > | < SUPPLY > )
-	{
-		return token.image;
-	}
-}
-
-void strength() :
-{}
-{
-	"(" ( < STRENGTH > | < SUPPLY > ) ["," ( < STRENGTH > | < SUPPLY > ) ]")"
-}
-
-int lvalue() :
-{
-	int width;
-	Identifier ident;
-}
-{
-	ident = complexIdentifier()
-	{
-		variableAssignment(ident);
-		return ident.getWidth();
-	}
-|	width = lvalueConcatenation()
-	{
-		return width;
-	}
-}
-
-int lvalueConcatenation() :
-{
-	int width;
-	int ret;
-}
-{
-	"{" ret = lvalue()
-	(	","
-		width = lvalue()
-		{
-			if (width == 0 || ret == 0)
-				ret = 0;
-			else
-				ret += width;
-		}
-	)*
-	"}"
-	{
-		return ret;
-	}
-}
-
-Identifier identifier() :
-{
-	Token token;
-}
-{
-	token = < IDENT >
-	{
-		return new Identifier(token);
-	}
-}
-
-Expression constantExpression() :
-{
-	Expression ret;
-}
-{
-	ret = expression()
-	{
-		return ret;
-	}
-}
-    
-Expression expression() :
-{
-	Expression ret, exp1, exp2;
-	Token op;
-}
-{
-	ret = logicalOrExpresstion()
-	[
-		op = "?" exp1 = expression() ":" exp2 = expression()
-		{
-			ret = operator(ret, op, exp1, exp2);
-		}
-	]
-	{
-	 	return ret;
-	}
-}
-
-Expression logicalOrExpresstion() :
-{
-	Expression ret, exp;
-	Token op;
-}
-{
-	ret = logicalAndExpresstion()
-	( op = "||" exp = logicalAndExpresstion() { ret = operator(ret, op, exp); } )*
-	{
-		return ret;
-	}
-}
-
-Expression logicalAndExpresstion() :
-{
-	Expression ret, exp;
-	Token op;
-}
-{
-	ret = bitOrExpresstion()
-	( op = "&&" exp = bitOrExpresstion() { ret = operator(ret, op, exp); } )*
-	{
-		return ret;
-	}
-}
-
-Expression bitOrExpresstion() :
-{
-	Expression ret, exp;
-	Token op;
-}
-{
-	ret = bitAndExpresstion()
-	( op = "|" exp = bitAndExpresstion() { ret = operator(ret, op, exp); } )*
-	{
-		return ret;
-	}
-}
-
-Expression bitAndExpresstion() :
-{
-	Expression ret, exp;
-	Token op;
-}
-{
-	ret = equalityExpression()
-	(
-		(op = "&" | op = "^" | op = "~^" | op = "^~")
-		exp = equalityExpression() { ret = operator(ret, op, exp); }
-	)*
-	{
-		return ret;
-	}
-}
-
-Expression equalityExpression() :
-{
-	Expression ret, exp;
-	Token op;
-}
-{
-	ret = relationalExpression()
-	(
-		(op = "==" | op = "===" | op = "!=" | op = "!==")
-		exp = relationalExpression() { ret = operator(ret, op, exp); }
-	)*
-	{
-		return ret;
-	}
-}
-
-Expression relationalExpression() :
-{
-	Expression ret, exp;
-	Token op;
-}
-{
-	ret = shiftExpression()
-	(
-		(op = "<" | op = "<=" | op = ">" | op = ">=")
-		exp = shiftExpression() { ret = operator(ret, op, exp); }
-	)*
-	{
-		return ret;
-	}
-}
-
-Expression shiftExpression() :
-{
-	Expression ret, exp;
-	Token op;
-}
-{
-	ret = addExpression()
-	(
-		(op = "<<" | op = ">>" | op = "<<<" | op = ">>>")
-		exp = addExpression() { ret = operator(ret, op, exp); }
-	)*
-	{
-		return ret;
-	}
-}
-
-Expression addExpression() :
-{
-	Expression ret, exp;
-	Token op;
-}
-{
-	ret = multiplyExpression()
-	(
-		(op = "+" | op = "-" )
-		exp = multiplyExpression() { ret = operator(ret, op, exp); }
-	)*
-	{
-		return ret;
-	}
-}
-
-Expression multiplyExpression() :
-{
-	Expression ret, exp;
-	Token op;
-}
-{
-	ret = unaryExpression()
-	(
-		(op = "*" | op = "/" | op = "%" | op = "**")
-		exp = unaryExpression() { ret = operator(ret, op, exp); }
-	)*
-	{
-		return ret;
-	}
-}
-
-Expression unaryExpression() :
-{
-	Expression ret, exp;
-	Token op = null;
-}
-{
-	[ op = unaryOperator() ]
-	ret = primary()
-	{
-		if (op != null)
-			return operator(ret, op);
-		else
-			return ret;
-	}
-}
-
-Expression primary() :
-{
-	Expression ret;
-	Identifier ident;
-	boolean isFunc = false;
-}
-{
-	(
-		ret = number()
-	|  ident = complexIdentifier() [ functionArgs() {isFunc = true; }]
-		{
-			if (isFunc) {
-				ret = functionReference(ident);
-			} else {
-				ret = variableReference(ident);
-			}
-		}
-	|	< SYSTEM_IDENT > (<SYSTEM_IDENT >)* [ LOOKAHEAD(2) functionArgs()]
-		{
-			ret = new Expression();
-		}
-	|	ret = concatenation()
-	|	"(" ret = minTypMaxExpresstion() ")"
-	)
-	{
-	 	if (ret == null)
-	 		return new Expression();
-		else
-			return ret;
-	}
-}
-
-Identifier complexIdentifier() :
-{
-	Identifier ident, concat;
-}
-{
-	ident = identifier() bitOrAry(ident)
-	(
-		"." concat = identifier() bitOrAry(concat)
-		{
-			ident.endLine = concat.endLine;
-			ident.endColumn = concat.endColumn;
-			ident.image += "." + concat.image;
-			ident.setWidth(concat.getWidth());
-			ident.setDimension(concat.getDimension());
-		}
-	)*
-	{
-		return ident;
-	}
-}
-
-Expression minTypMaxExpresstion() :
-{
-	Expression exp;
-}
-{
-	exp = expression()
-	[
-		":" expression()
-		":" expression()
-	]
-	{
-		return exp;
-	}
-}
-
-void bitOrAry(Identifier ident) :
-{
-	int width = 0;
-	int dim = 0;
-	Expression msb, lsb;
-	Token token;
-}
-{
-  	(
-		"[" msb = expression() { width = 1;  dim++; }
-		[
-			( token = ":" | token = "+:" | token = "-:" ) lsb = expression()
-			{
-				if (token.image.equals(":")) {
-					if (msb.isValid() && lsb.isValid())
-						width = msb.intValue() - lsb.intValue() + 1;
-					else
-						width = 0;
-				} else {
-					if (lsb.isValid())
-						width = lsb.intValue();
-					else
-						width = 0;
-				}
-			}
-		]
-		"]"
-	)*
-	{
-		ident.setWidth(width);
-		ident.setDimension(dim);
-	}
-}
-
-String bitRange() :
-{
-	Expression msb, lsb;
-}
-{
-	[
-		"[" msb = expression()  ":" lsb = expression() "]" 
-		{
-			if (msb.isValid() && lsb.isValid())
-				return "[" + msb.intValue() + ":" + lsb.intValue() + "]";
-			else
-				return "";
-		}
-	]
-	{
-		return "";
-	}
-}
-
-Token unaryOperator() :
-{}
-{
-	( "~" | "+" |  "-" |  "!" |  "&" |  "~&" | "|" |  "~|" |  "^" |  "~^" |  "^~" )
-	{
-		return token;
-	}
-}
-
-Expression concatenation() :
-{
-	int width;
-	int value;
-	boolean valid;
-	boolean assignable;
-	Expression exp;
-	Expression refs = new Expression();
-}
-{
-	"{" exp = expression()
-	{
-		width = exp.getWidth();
-		value = exp.intValue();
-		valid = exp.isValid();
-		assignable = exp.isAssignable();
-		refs.addReference(exp);
-	}
-	[
-		( "," exp = expression()
-		{
-			if (width == 0 || exp.getWidth() == 0)
-				width = 0;
-			else
-				width += exp.getWidth();
-			value = (value << width) | exp.intValue();
-			valid = valid && exp.isValid();
-			assignable = assignable && exp.isAssignable();
-			refs.addReference(exp);
-		}
-		)+
-	|	"{" exp = expression() "}"
-		{
-			width = valid ? value : 0;
-			value = exp.intValue();
-			valid = exp.isValid();
-			assignable = exp.isAssignable();
-			refs = exp;
-		}
-	]
-	"}"
-	{
-		Expression ret = new Expression(width);
-		if (valid)
-			ret.setValue(value);
-		ret.setAssignable(assignable);
-		ret.addReference(refs);
-		return ret;
-	}
-}
-
-void functionArgs():
-{}
-{
-	"(" expression() ( "," expression() )* ")"
-}
-
-Expression number() :
-{
-	Expression ret = new Expression();
-}
-{
-	(
-	< INTEGER_LITERAL > { ret.parseIntegerLiteral(token.image); }
-	|  < REAL_LITERAL > { ret.parseRealLiteral(token.image); }
-	|  < STRING_LITERAL > { ret.parseStringLiteral(token.image); }
-	)
-	{
-		return ret;
-	}	
-}
-
-
-JAVACODE
-void unexpectedEof(Token token)
-{
-	ParseException ex = new ParseException("unexpected EOF");
-	ex.currentToken = token;
-	throw ex;
-}
-
-JAVACODE
-Token skipTo(int skip)
-{
-	Token current = token;
-	Token token ;
-	StringBuffer image = new StringBuffer();
-
-	for(;;)
-	{
-		token = getToken(1);
-		if (token.kind == EOF)
-			unexpectedEof(current);
-		if (token.kind == skip)
-		{
-			getNextToken();
-			break ;
-		}
-
-		image.append(token.image);
-		getNextToken();
-	}
-	token.image = image.toString();
-	return token ;
-}
-
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+/*******************************************************************************
+ * Copyright (c) 2004, 2012 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+
+options {
+	JAVA_UNICODE_ESCAPE = true ;
+	STATIC = false ;
+}
+
+PARSER_BEGIN(VerilogParserCore)
+
+package com.elphel.vdt.veditor.parser.verilog;
+
+public abstract class VerilogParserCore
+{
+	public static final int STATEMENT = 0;
+	public static final int ASSIGN_STMT = 1;
+	public static final int INITIAL_BLOCK = 2;
+	public static final int ALWAYS_BLOCK = 3;
+	protected static enum PORT_TYPE {INSTANCE, PRIMITIVE, TASK, FUNCTION, SYSTEM_TASK, SYSTEM_FUNCTION};
+
+	protected abstract void begin(int mode);
+	protected abstract void end(int mode);
+	protected abstract void beginOutlineElement(Token begin, String name, String type);
+	protected abstract void endOutlineElement(Token end, String name, String type);
+
+	protected void beginOutlineElement(Token begin, String type) {
+		beginOutlineElement(begin, begin.image, type);
+	}
+	protected void endOutlineElement(Token end, String type) {
+		endOutlineElement(end, end.image, type);
+	}
+
+	protected abstract void addCollapsible(int startLine,int endLine);
+	protected abstract Expression operator(Expression arg, Token op);
+	protected abstract Expression operator(Expression arg1, Token op, Expression arg2);
+	protected abstract Expression operator(Expression arg1, Token op, Expression arg2, Expression arg3);
+	protected abstract Expression variableReference(Identifier ident);
+	protected abstract void badBitRange(Identifier ident,String badRange);
+	
+	protected abstract Expression functionReference(Identifier ident);
+
+	protected abstract void parameterAssignment(String name, Expression value, int line);
+	protected abstract void variableAssignment(Identifier ident);
+	protected abstract void taskReference(Identifier ident);
+	protected abstract void namedPortConnection(Expression arg, String module, Identifier port, PORT_TYPE port_type);
+	protected abstract void positionalPortConnection(Expression arg, String module, int portIndex, PORT_TYPE port_type);
+	protected abstract void primitivePortConnection(Expression arg, boolean inp, boolean out, PORT_TYPE port_type, int line);
+	
+	protected abstract void namedParameterConnection(Expression arg, String module, Identifier parameter);
+	protected abstract void positionalParameterConnection(Expression arg, String module, int parameterIndex);
+	
+	protected abstract void evaluateAssignment(Token asn, int lvalue, Expression exp);
+	protected abstract void beginGenerateBlock(Identifier block);
+	protected abstract void endGenerateBlock(Identifier block);
+	protected abstract void setIdentifierUsed(Identifier ident); // Andrey - parameters used in delays
+	
+}
+
+PARSER_END(VerilogParserCore)
+
+//
+// operation for /* */
+//
+MORE :
+{
+	"/*" : IN_MULTI_LINE_COMMENT
+}
+
+<IN_MULTI_LINE_COMMENT>
+SKIP :
+{
+	<MULTI_LINE_COMMENT: "*/"> : DEFAULT
+}
+
+<IN_MULTI_LINE_COMMENT>
+MORE :
+{
+	< ~[] >
+}
+
+//
+// operation for (* *)
+//
+MORE :
+{
+	<"(*" ~[")"]> : IN_PROPERTY
+}
+
+<IN_PROPERTY>
+SKIP :
+{
+	<PROPERTY_COMMENT: "*)"> : DEFAULT
+}
+
+<IN_PROPERTY>
+MORE :
+{
+	< ~[] >
+}
+
+SKIP :
+{
+	" " | "\t" | "\r" | "\n" | "\f"
+}
+
+SPECIAL_TOKEN :
+{
+	<SINGLE_LINE_COMMENT: "//" (~["\n"])* >
+}
+
+TOKEN :
+{
+	<MODULE: "module">
+|	<ENDMODULE: "endmodule">
+| 	<PRIMITIVE: "primitive">
+|	<ENDPRIMITIVE: "endprimitive">
+| 	<TABLE:    "table">
+|	<ENDTABLE: "endtable">
+|	<BEGIN: "begin">
+|	<END: "end">
+|	<FORK: "fork">
+|	<JOIN: "join">
+|	<SPECIFY: "specify">
+|	<ENDSPECIFY:"endspecify">
+|	<IF: "if">
+|	<ELSE: "else">
+|	<WHILE: "while">
+|	<FOR: "for">
+|	<FOREVER: "forever">
+|	<REPEAT: "repeat">
+|	<WAIT: "wait">
+|	<CASE: ("case" | "casex" | "casez") >
+|	<DEFAULT_LABEL: "default">
+|	<ENDCASE: "endcase">
+|	<FUNCTION: "function">
+|	<ENDFUNCTION: "endfunction">
+|	<TASK: "task">
+|	<ENDTASK: "endtask">
+|	<GENERATE: "generate">
+|	<ENDGENERATE: "endgenerate">
+|	<INPUT: "input">
+|	<OUTPUT: "output">
+|	<INOUT: "inout">
+|	<INTEGER: "integer">
+|	<REG: "reg">
+|  < WIRE: "wire" >
+|	<EVENT: "event">
+|	<GENVAR: "genvar">
+|	<REAL: "real">
+|	<PARAMETER: "parameter"> 
+|	<LOCALPARAM: "localparam">
+|	<SIGNED: "signed">
+|	<PROPERTY: "property" >
+|	<ENDPROPERTY: "endproperty" >
+|	<ASSERT: "assert" | "cover">
+|  <ASSIGN: "assign" >
+|  <DEASSIGN: "deassign" >
+|  <FORCE : "force" >
+|  <RELEASE: "release" >
+|  < TIME: "time" >
+|  < REALTIME: "realtime" >
+|  < DEFPARAM: "defparam" >
+|  < OR: "or" >
+|  < DISABLE: "disable" >
+|   <ALWAYS: "always" >
+|   <INITIAL: "initial" >
+|  < EDGE: ( "posedge" | "negedge" ) >
+|  < SUPPLY : ( "supply0" | "supply1" ) >
+|  < NET_TYPE: ( "tri" | "tri1" | "wand" | "triand" | "tri0" | "wor" | "trior" ) >
+|  < STRENGTH: ("strong0" | "strong1" | "pull0" | "pull1" | "weak0" | "weak1" |"highz0" | "highz1" ) >
+|   <PRIM_1IN_XOUT: ( "and" | "xor" | "nand" | "nor" | "xnor")>
+|   <PRIM_1OUT_XIN: ( "buf" | "not" )>
+|   <PRIM_1OUT_1IN_1CNTL: ( "bufif0" | "bufif1" | "notif0" | "notif1" | "pmos" | "nmos" | "rpmos" | "rnmos")>
+|   <PRIM_1OUT: ( "pullup" | "pulldown")>
+|   <PRIM_1OUT_1IN_NC_PC: ("cmos" | "rcmos" )>
+|   <PRIM_BI: ("tran" |  "rtran" | "tranif0" | "rtranif0" | "rtranif1")>
+|	<LPAREN: "(" >
+|	<RPAREN: ")" >
+|	<LBRACE: "{" >
+|	<RBRACE: "}" >
+|	<LBRACKET: "[" >
+|	<RBRACKET: "]" >
+|	<EOS: ";" >
+|	<PARA: "#" >
+|	<AT: "@" >
+|	<DOLLAR: "$" >
+|	<COMMA: "," >
+|  < DOT: "." >
+//|	<OTHER: "[.]" >
+}
+
+TOKEN :
+{
+  < AGN: "=" >
+| < GT: ">" >
+| < LT: "<" >
+| < BANG: "!" >
+| < TILDE: "~" >
+| < HOOK: "?" >
+| < COLON: ":" >
+| < PCOLON: "+:" >
+| < MCOLON: "-:" >
+| < EQ: "==" >
+| < LE: "<=" >
+| < GE: ">=" >
+| < NE: "!=" >
+| < SC_OR: "||" >
+| < SC_AND: "&&" >
+| < PLUS: "+" >
+| < MINUS: "-" >
+| < STAR: "*" >
+| < SLASH: "/" >
+| < BIT_AND: "&" >
+| < BIT_OR: "|" >
+| < XOR: "^" >
+| < REM: "%" >
+| < LSHIFT: "<<" >
+| < RSHIFT: ">>" >
+| < NEG_AND: "~&" >
+| < NEG_OR: "~|" >
+| < NEG_XOR: "~^" >
+| < XOR_NEG: "^~" >
+| < EQ_C: "===" >
+| < NE_C: "!==" >
+| < POWER: "**" >
+| < ALSHIFT: "<<<" >
+| < ARSHIFT: ">>>" >
+}
+
+TOKEN :
+{
+  < IDENT :
+  	 // No matching macro means simple identifier
+     ("`")? < LETTER > (< LETTER > | ["0"-"9"] )*
+   | < BACKSLASH > (~[ " " ])+
+     >
+| < SYSTEM_IDENT:
+     "$" < LETTER > (< LETTER > | ["0"-"9"])*
+     >
+| < #LETTER : [ "a"-"z", "A"-"Z", "_" ] >
+| < #BACKSLASH : "\\" >
+}
+
+TOKEN :
+{
+  < INTEGER_LITERAL :
+    < NUMBER_LITERAL >
+  | < DECIMAL_LITERAL >
+  | < HEX_LITERAL >
+  | < OCTAL_LITERAL >
+  | < BINARY_LITERAL >
+    >
+| < #NUMBER_LITERAL : ([ "0"-"9", "_" ])+ >
+| < #DECIMAL_LITERAL : ([ "0"-"9" ])* "'" (["s", "S"])? [ "d", "D" ] ([" ", "\t"])* ([ "0"-"9", "_", "x", "X", "z", "Z", "?"])* >
+| < #HEX_LITERAL : ([ "0"-"9" ])* "'" (["s", "S"])? [ "h", "H" ] ([" ", "\t"])* ([ "0"-"9", "a"-"f", "A"-"F", "_", "x", "X", "z", "Z", "?" ])+ >
+| < #OCTAL_LITERAL : ([ "0"-"9" ])* "'" (["s", "S"])? [ "o", "O" ] ([" ", "\t"])* ([ "0"-"7", "_", "x", "X", "z", "Z", "?" ])* >
+| < #BINARY_LITERAL : ([ "0"-"9" ])* "'" (["s", "S"])? [ "b", "B" ] ([" ", "\t"])* ([ "0"-"1", "_", "x", "X", "z", "Z", "?" ])* >
+| < REAL_LITERAL :
+    ([ "0"-"9" ])+ "." ([ "0"-"9" ])*
+  | ([ "0"-"9" ])+ ( "." ([ "0"-"9" ])*)? [ "e", "E" ] ([ "+", "-" ])? ([ "0"-"9" ])+ >
+| < STRING_LITERAL:
+      "\""
+      (   (~["\"","\n","\r"])
+        | ("\\"
+            ( ["n","t","b","r","f","\\","'","\""]
+            | ["0"-"7"] ( ["0"-"7"] )?
+            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
+            )
+          )
+      )*
+      "\""  >
+}
+
+void verilogText() :
+{}
+{
+	( moduleOrPrimitiveDecl() )*
+}
+
+void moduleOrPrimitiveDecl() :
+{}
+{
+	moduleDecl()
+| 	primitiveDecl()  }
+
+void moduleDecl() :
+{
+	Identifier name;
+	Token end;
+}
+{
+	( <IDENT>)* // ignore preprocessor directive
+	< MODULE > name = identifier()
+	{
+		beginOutlineElement(name, "module#");
+	}
+	[ "#" "(" [ parameterArg() ( "," parameterArg() )* ] ")"  ]
+	[ "(" [ argument() ( "," argument() )* ] ")" ]
+	";"
+	( moduleItem() )*
+	end = < ENDMODULE >
+	{
+	    endOutlineElement(end, name. image, "module#");
+	}
+}
+
+void primitiveDecl() :
+{
+	Identifier name;
+	Token end;
+}
+{
+//	( <IDENT>)* // ignore preprocessor directive
+	< PRIMITIVE > name = identifier()
+	{
+		beginOutlineElement(name, "module#primitive");
+	}
+	[ "(" [ argument() ( "," argument() )* ] ")" ]
+	";"
+	( primitiveItem() )*
+	end = < ENDPRIMITIVE >
+	{
+	    endOutlineElement(end, name. image, "module#primitive");
+	}
+}
+
+void primitiveItem() :
+{}
+{
+ 	portDecl()
+|  	variableDecl()
+| 	tableDecl()
+}
+
+void tableDecl() :
+{
+	Token start ; 
+}
+{
+  	start = < TABLE > 
+	skipTo( ENDTABLE )
+	{	
+		addCollapsible(start.beginLine, token.endLine);
+	}
+	{end(STATEMENT);}
+}
+
+
+
+
+void parameterArg() :
+{
+	Token name,value;
+	String mod, range;
+}
+{ 
+	<PARAMETER> mod = parameterModifier()
+//	range = bitRange()
+	range = bitRangeWithDepend()
+	parameterAssign("parameter", mod, range)
+}
+
+String parameterModifier() :
+{
+	String ret = " ";
+}
+{
+	(
+		("real" | "integer" | "signed" )
+		{
+			ret += token.image + " ";
+		}
+	)*
+	{
+		return ret;
+	}
+}
+
+
+void defparamAssign(String type, String mod, String range) :
+{
+	Identifier name;
+	Expression value;
+}
+{
+	name = complexIdentifier()
+	"="
+	value = constantExpression()
+	{
+		String types = type + "#" + mod + "#" + range + "#" + value.toString();
+		beginOutlineElement(name, types);
+		parameterAssignment(name.image, value, value.beginLine);
+		endOutlineElement(name, types);
+	}
+}
+
+void parameterAssign(String type, String mod, String range) :
+{
+	Identifier name;
+	Expression value;
+	int pos;
+	String [] deps;
+}
+{
+	name = identifier()
+	"="
+	value = constantExpression()
+	{
+  		pos=range.indexOf("]");
+  		if (( pos >0 ) && ( pos < ( range.length() - 1 )))	{ // contains dependencies
+  			deps=range.split( "]" );
+  			range=deps[0] + "]";
+        	name.setEncodedDepends(deps[1]);
+  		}
+		String types = type + "#" + mod + "#" + range + "#" + value.toString();
+		beginOutlineElement(name, types);
+		parameterAssignment(name.image, value, value.beginLine);
+		endOutlineElement(name, types);
+	}
+}
+
+
+
+
+void argument() :
+{
+	Token direction;
+	Identifier name;
+	String modifier="";
+	String range;
+	Token asn;
+	Expression exp;
+	int pos;
+	String [] deps;
+}
+{
+		// C++ style argument
+		( direction=<INPUT>  | direction=<OUTPUT>  | direction=<INOUT> )
+		modifier = variableModifier()
+//		range = bitRange()
+		range= bitRangeWithDepend()
+		name = identifier()
+		{
+	  		pos=range.indexOf("]");
+	  		if (( pos >0 ) && ( pos < ( range.length() - 1 )))	{ // contains dependencies
+	  			deps=range.split( "]" );
+	  			range=deps[0] + "]";
+//	        	name.addEncodedDeps(deps[1]);
+	        	name.setEncodedDepends(deps[1]);
+	  		}
+			String types = "port#" + direction.image + "#" + modifier + "#" + range;
+			beginOutlineElement(name, types);
+			endOutlineElement(name, types);
+		}
+		[
+			asn = "=" exp = expression()
+			{
+				variableAssignment(name);
+				evaluateAssignment(asn, name.getWidth(), exp);
+			}
+		]
+	|
+		// C style argument, portDecl will add it to OutlineContainer
+		identifier()
+}
+
+void functionArgument() :
+{
+	Token direction;
+	Identifier name;
+	String modifier="";
+	String range;
+	Token asn;
+	Expression exp;
+	int pos;
+	String [] deps;
+}
+{
+		// C++ style argument
+		direction=<INPUT>
+		modifier = variableModifier()
+//		range = bitRange()
+		range= bitRangeWithDepend()
+		name = identifier()
+		{
+	  		pos=range.indexOf("]");
+	  		if (( pos >0 ) && ( pos < ( range.length() - 1 )))	{ // contains dependencies
+	  			deps=range.split( "]" );
+	  			range=deps[0] + "]";
+//	        	name.addEncodedDeps(deps[1]);
+	        	name.setEncodedDepends(deps[1]);
+	  		}
+			String types = "port#" + direction.image + "#" + modifier + "#" + range;
+			beginOutlineElement(name, types);
+			endOutlineElement(name, types);
+		}
+		[
+			asn = "=" exp = expression()
+			{
+				variableAssignment(name);
+				evaluateAssignment(asn, name.getWidth(), exp);
+			}
+		]
+	|
+		// C style argument, portDecl will add it to OutlineContainer
+		identifier()
+}
+
+
+void moduleItem() :
+{}
+{
+	moduleOrGenerateItem()
+| 	portDecl()
+|	<SPECIFY> {begin(STATEMENT);} skipTo( ENDSPECIFY ) {end(STATEMENT);}
+|	generate()
+|	<PROPERTY> skipTo(ENDPROPERTY)
+}
+
+void moduleOrGenerateItem() :
+{}
+{
+	variableDecl()
+|	parameterDecl()
+|   defparamDecl()
+|	taskDecl()
+|	functionDecl()
+|  assign()
+|  primitiveInstance()
+|  LOOKAHEAD(3) moduleInstance()
+|	initialAlways() // initial and always
+|	<ASSERT>  skipTo(EOS)
+|	identifier() ":" <ASSERT>  skipTo(EOS)
+| 	";"
+}
+//| <DEFPARAM> {begin(STATEMENT);} skipTo( EOS ) {end(STATEMENT);}
+
+void portDecl() :
+{
+	Token direction;
+	String modifier;
+	String range;
+}
+{
+	( direction=<INPUT>  | direction=<OUTPUT>  | direction=<INOUT> )
+	modifier = variableModifier()
+	{ begin(STATEMENT); }
+	range = bitRangeWithDepend()
+	portDeclSingle(direction, modifier, range)
+	("," portDeclSingle(direction, modifier, range))* ";"
+	{ end(STATEMENT); }
+}
+
+void functionPortDecl() :
+{
+	Token direction;
+	String modifier;
+	String range;
+}
+{
+	direction=<INPUT>
+	modifier = variableModifier()
+	{ begin(STATEMENT); }
+	range = bitRangeWithDepend()
+	portDeclSingle(direction, modifier, range)
+	("," portDeclSingle(direction, modifier, range))* ";"
+	{ end(STATEMENT); }
+}
+
+
+String variableModifier() :
+{
+	String ret = "";
+}
+{
+	(
+		( "real" | "realtime" | "integer" | "wire" | "reg" | "signed" | "time" )
+		{
+			ret += token.image + " ";
+		}
+	)*
+	{
+		return ret;
+	}
+}
+
+void portDeclSingle(Token direction, String modifier, String range) :
+{
+	Identifier name;
+	Token asn;
+	Expression exp;
+	int pos;
+	String [] deps;
+}
+{
+	name = identifier()
+	{
+	  	pos=range.indexOf("]");
+	  	if (( pos >0 ) && ( pos < ( range.length() - 1 )))	{ // contains dependencies
+	  		deps=range.split( "]" );
+	  		range=deps[0] + "]";
+//	        name.addEncodedDeps(deps[1]);
+	        name.setEncodedDepends(deps[1]);
+	  	}
+		String type = "port#" + direction.image + "#" + modifier + "#" + range + "#cstyle";
+		beginOutlineElement(name, type);
+		endOutlineElement(name, type);
+	}
+	[
+		asn = "=" exp = expression()
+		{
+			variableAssignment(name);
+			evaluateAssignment(asn, name.getWidth(), exp);
+		}
+	]
+}
+/* 
+void primitiveInstance():
+{
+	String prim;
+}
+{
+	(     <PRIM_1IN_XOUT> | "or"
+      	| <PRIM_1OUT_XIN>      
+		| <PRIM_1OUT_1IN_1CNTL>
+		| <PRIM_1OUT>
+		| <PRIM_1OUT_1IN_NC_PC>
+		| <PRIM_BI>
+	) { prim = token.image;}
+	[ LOOKAHEAD(2) strength() ] [ delay3() ]
+	[ identifier() bitRange() ] "(" portConnect(prim) ")"
+	( "," identifier() bitRange() "(" portConnect(prim) ")" )*
+	";"
+}
+
+void moduleInstanceOld():
+{
+	Identifier module, inst;
+	Token iend ;
+}
+{ 
+	module = identifier() 
+	{ begin(STATEMENT); }
+	
+	(   //module instantiation
+		(   [ "#" ( identifier() | number() | "(" parameterConnectOld() ")" ) ]
+			inst = identifier()
+			{
+				beginOutlineElement(module, inst.image, "instance#"+module.image);
+			}
+			[ "(" [ portConnect(module.image) ] ")" ]
+		    iend = ";"
+		    {			
+				endOutlineElement(iend, inst.image, "instance#"+module.image);
+				addCollapsible(module.beginLine, iend.endLine);
+		     }
+		 )
+	 |   //user defined primitive	 
+		 (  "(" portConnect(module.image) ")"
+		 	iend = ";"
+		 )
+	)
+	{ end(STATEMENT); }
+}
+*/
+
+void moduleInstance():
+{
+	Identifier module, inst;
+	Token iend ;
+}
+{ 
+	module = identifier() 
+	{ begin(STATEMENT); }
+	
+	(   //module instantiation: Andrey: Really module name should be passed, not instance? Yes, that should be module
+		(   [ "#" ( singleParameterConnect(module.image) | "(" parameterConnect(module.image) ")" ) ]
+			inst = identifier()
+			{
+				beginOutlineElement(module, inst.image, "instance#"+module.image);
+			}
+			[ "(" [ portConnect(module.image, PORT_TYPE.INSTANCE) ] ")" ]
+		    iend = ";"
+		    {			
+				endOutlineElement(iend, inst.image, "instance#"+module.image);
+				addCollapsible(module.beginLine, iend.endLine);
+		     }
+		 )
+	 |   //user defined primitive	 
+		 (  "("
+		 	{	         	beginOutlineElement(module, module.image+":"+module.beginLine+":"+module.beginColumn, "instance#"+module.image);
+		 	}
+		    portConnect(module.image, PORT_TYPE.PRIMITIVE) ")"
+		    iend = ";"
+		    {			
+				endOutlineElement(iend, module.image+":"+module.beginLine+":"+module.beginColumn, "instance#"+module.image);
+				addCollapsible(module.beginLine, iend.endLine);
+		    }
+		 )
+	)
+	{ end(STATEMENT); }
+}
+
+// just identifier or number ( module_name # ident module_instance_name (...);
+void singleParameterConnect(String module) :
+{
+	Expression arg = null;
+}
+{
+  ( arg = number() | arg = identifierExpression() )
+  {
+    positionalParameterConnection(arg, module, 0); // single parameter  }
+}
+
+Expression identifierExpression() :
+{	Expression ret;
+	Identifier ident;
+}
+{
+  ident=identifier()
+  {	return variableReference(ident);
+  }}
+
+void parameterConnectOld() :
+{
+	Expression arg = null;
+}
+{
+	"." identifier() "(" [ constantExpression() ] ")" ( "," "." identifier() "(" [ constantExpression() ] ")" )*
+|	constantExpression() ( "," constantExpression() )*	
+}
+
+void parameterConnect(String module) :
+{
+	int count = 0;
+}
+{
+	count = parameterConnectSingle(module, count)
+	( "," count = parameterConnectSingle(module, count) )*
+}
+
+int parameterConnectSingle(String module, int count) :
+{
+	Identifier parameter;
+	Expression arg = null;
+}
+{
+	"." parameter = identifier() "(" [ arg = constantExpression() ] ")"
+	{
+		namedParameterConnection(arg, module, parameter);
+		return count + 1;
+	}
+|	arg = constantExpression()
+	{
+		positionalParameterConnection(arg, module, count);
+		return count + 1;
+	}
+}
+
+
+void portConnect(String module, PORT_TYPE port_type) :
+{
+	int count = 0;
+}
+{
+	count = portConnectSingle(module, count, port_type)
+	( "," count = portConnectSingle(module, count, port_type) )*
+}
+
+int portConnectSingle(String module, int count, PORT_TYPE port_type) :
+{
+	Identifier port;
+	Expression arg = null;
+}
+{
+	"." port = identifier() "(" [ arg = expression() ] ")"
+	{
+		namedPortConnection(arg, module, port, port_type); //PORT_TYPE.INSTANCE); //TODO: make variable
+		return count + 1;
+	}
+|	arg = expression()
+	{
+		positionalPortConnection(arg, module, count, port_type); //count, PORT_TYPE.INSTANCE); //TODO: make variable
+		return count + 1;
+	}
+}
+
+// Handling primitive in/outs
+void primitiveInstance():
+{}
+{
+   primitiveInstance_1out_xin()
+|  primitiveInstance_xout_1in()
+|  primitiveInstance_2inout_1in()
+}
+
+void primitiveInstance_1out_xin():
+{}
+{
+	(     <PRIM_1OUT_XIN>      
+		| <PRIM_1OUT_1IN_1CNTL>
+		| <PRIM_1OUT>
+		| <PRIM_1OUT_1IN_NC_PC>
+	)
+	[ LOOKAHEAD(2) strength() ] [ delay3() ]
+	[ identifier() bitRange() ]   "(" portConnectOut() ( "," portConnectIn() )* ")"
+	( "," identifier() bitRange() "(" portConnectOut() ( "," portConnectIn() )* ")" )*
+	";"
+}
+
+void primitiveInstance_xout_1in():
+{}
+{
+	(     <PRIM_1IN_XOUT> | "or" // "or" can not be added to other primitives - probably conflicts with other use
+	)
+	[ LOOKAHEAD(2) strength() ] [ delay3() ]
+//	[ identifier() bitRange() ]   "(" portConnectOut() ( LOOKAHEAD(2) "," portConnectOut() )* "," portConnectIn() ")"
+//	( "," identifier() bitRange() "(" portConnectOut() ( LOOKAHEAD(2) "," portConnectOut() )* "," portConnectIn() ")" )*
+	[ identifier() bitRange() ]   "(" portConnectOut() "," ( LOOKAHEAD(2)  portConnectOut()  "," )* portConnectIn() ")"
+	( "," identifier() bitRange() "(" portConnectOut() "," ( LOOKAHEAD(2)  portConnectOut()  "," )* portConnectIn() ")" )*
+	";"
+}
+void primitiveInstance_2inout_1in():
+{}
+{
+	(     <PRIM_BI>
+	)
+	[ LOOKAHEAD(2) strength() ] [ delay3() ]
+	[ identifier() bitRange() ]   "(" portConnectInOut() "," portConnectInOut()  "," portConnectIn() ")"
+	( "," identifier() bitRange() "(" portConnectInOut() "," portConnectInOut()  "," portConnectIn() ")" )*
+	";"
+}
+
+
+void portConnectIn() :
+{
+	Expression arg = null; 
+}
+{	arg = expression()
+	{
+		primitivePortConnection(arg, true, false, PORT_TYPE.PRIMITIVE, arg.beginLine); //TODO: make variable to use for system tasks/func?
+	}
+}
+
+void portConnectOut() :
+{
+	Expression arg = null; 
+}
+{
+	arg = expression()
+	{
+		primitivePortConnection(arg, false, true, PORT_TYPE.PRIMITIVE, arg.beginLine); //TODO: make variable to use for system tasks/func?
+	}
+}
+
+void portConnectInOut() :
+{
+	Expression arg = null; 
+}
+{
+	arg = expression()
+	{
+		primitivePortConnection(arg, false, true, PORT_TYPE.PRIMITIVE, arg.beginLine); //TODO: make variable to use for system tasks/func?
+	}
+}
+
+
+void assign() :
+{
+	int width;
+	Token asn;
+	Expression exp;
+}
+{
+	"assign"
+	{begin(ASSIGN_STMT); }
+	[ strength() ] [ delay3() ]
+	width = lvalue() asn = "=" exp = expression()
+	{
+		evaluateAssignment(asn, width, exp);
+	}
+	(
+		"," width = lvalue() asn = "=" exp = expression()
+		{
+			evaluateAssignment(asn, width, exp);
+		}
+	)*
+	";"
+	{end(ASSIGN_STMT); }
+}
+
+void variableDecl():
+{
+	Token variable;
+	String type;
+	String range;
+}
+{
+	type = variableType()
+	{ begin(STATEMENT); }
+	[ strength() ]
+	[ "signed" 	{ type += " signed";}	]
+	range = bitRange()
+	[ delay3() ]
+	variableDeclSingle(type, range) ( "," variableDeclSingle(type, range) )* ";"
+	{ end(STATEMENT); }
+}
+
+String variableType() :
+{
+	String type;
+}
+{
+	 type = netType()
+	 {
+	 	return type;
+	}
+|	( "reg" | "real" | "integer" | "event" |"genvar" | "time" | "realtime" )
+	{
+		return token.image;
+	}
+}
+
+void variableDeclSingle(String mod, String range) :
+{
+	Identifier variable;
+	Token asn;
+	Expression exp;
+	int dimension = 0;
+}
+{
+	variable = identifier()
+	("[" constantExpression() ":" constantExpression() "]" { dimension++; })*
+	{
+		String type = "variable#" + mod + "#" + range + "#" + dimension;
+		beginOutlineElement(variable, type);
+		endOutlineElement(variable, type);
+	}
+	[
+		asn = "=" exp = expression()
+		{
+			variableAssignment(variable);
+			evaluateAssignment(asn, variable.getWidth(), exp);
+		}
+	]
+}
+
+void delay3() :
+{}
+{
+	"#"
+	(
+		LOOKAHEAD(3)
+		delayValue()
+	| 	"(" minTypMaxExpresstion() [ "," minTypMaxExpresstion() ["," minTypMaxExpresstion() ] ] ")"
+	)
+}
+
+void parameterDecl():
+{
+	String type;
+	String mod, range;
+}
+{ 
+	(
+		<PARAMETER>  {type = "parameter";}
+	|	<LOCALPARAM> {type = "localparam";}
+	)
+	mod = parameterModifier()
+//	range = bitRange()
+	range = bitRangeWithDepend()
+	parameterAssign(type, mod, range) ( "," parameterAssign(type, mod, range) )* ";"
+}
+
+void defparamDecl():
+{
+	String type;
+	String mod, range;
+}
+{ 
+	(
+		<DEFPARAM>   {type = "defparam";}
+	)
+	mod = parameterModifier()
+//	range = bitRange()
+	range = bitRangeWithDepend()
+	defparamAssign(type, mod, range) ( "," parameterAssign(type, mod, range) )* ";"
+}
+
+
+
+
+void initialAlways():
+{
+	Token start;
+}
+{
+	( start = <INITIAL> | start = <ALWAYS> )
+	{
+		if (start.image.equals("initial"))
+			begin(INITIAL_BLOCK);
+		else
+			begin(ALWAYS_BLOCK);
+	} 
+	statement() 
+	{
+		if (start.image.equals("initial"))
+			end(INITIAL_BLOCK);
+		else
+			end(ALWAYS_BLOCK);
+		addCollapsible(start.beginLine,token.endLine);
+	}
+}
+
+void statement() :
+{
+	Token end;
+}
+{
+ 	assignOrTaskEnable()
+| 	proceduralContinuousAssignment()
+|  proceduralTimingControlStatement()
+|	ifStatement()
+|	caseStatement()
+|	whileStatement()
+|	forStatement()
+|	foreverStatement()
+|	repeatStatement()
+|	waitStatement()
+| 	"disable" identifier() ";"
+|  "->" identifier() ";"
+|	block()
+|  ";"
+}
+
+void assignOrTaskEnable() :
+{
+	Identifier ident;
+	Token asn;
+	Expression exp;
+	int width;
+	Token iend;
+}
+{
+	ident = complexIdentifier()
+	(
+		(asn = "="  | asn = "<=") [delayOrEventControl() ] exp = expression() ";"
+		{
+			variableAssignment(ident);
+			evaluateAssignment(asn, ident.getWidth(), exp);
+		}
+	| 	( "("
+	     {	         beginOutlineElement(ident, ident.image+":"+ident.beginLine+":"+ident.beginColumn, "taskenable#"+ident.image);
+	     }
+	      portConnect(ident.image, PORT_TYPE.TASK)
+	       ")" 
+	      iend = ";"
+      |
+	      iend = ";"
+	      {	         beginOutlineElement(ident, ident.image+":"+ident.beginLine+":"+ident.beginColumn, "taskenable#"+ident.image);
+
+	      }
+      
+        ) 	      
+		{
+		    endOutlineElement(iend, ident.image+":"+ident.beginLine+":"+ident.beginColumn, "taskenable#"+ident.image);
+			addCollapsible(ident.beginLine, iend.endLine);
+			taskReference(ident);
+		}
+ )
+| 	width = lvalueConcatenation() (asn = "="  | asn = "<=") [delayOrEventControl() ] exp = expression() ";"
+	{
+		evaluateAssignment(asn, width, exp);	
+	}
+|	<SYSTEM_IDENT> [ "(" expression() ("," expression())* ")"] ";"
+}
+
+
+void delayOrEventControl() :
+{}
+{
+	delayContol() | eventContol()
+}
+
+void delayContol() :
+{}
+{
+	"#" ( delayValue() | "(" minTypMaxExpresstion() ")" )
+}
+
+void delayValue() :
+{}
+{
+//	number() | identifier()
+	number() | identifierUsed()
+}
+
+void identifierUsed() :
+{
+  Identifier ident;}
+{	ident = identifier()
+	{		setIdentifierUsed(ident);
+	}
+}
+
+
+void eventContol() :
+{}
+{
+ 	"@"
+	(	identifier()
+	|	 "*"
+	|	"(" (eventExpression() | "*" ) ")"
+	)
+}
+
+void eventExpression():
+{}
+{
+	( expression() | < EDGE > expression() )
+	( ("," | "or") ( expression() | < EDGE > expression() ) )*
+	// 'repeat' '(' expression ')' event_control -> ignored
+}
+
+void proceduralContinuousAssignment() :
+{
+	int width;
+	Token asn;
+	Expression exp;
+}
+{
+	"assign" width = lvalue() asn = "=" exp = expression() ";"
+	{
+		evaluateAssignment(asn, width, exp);
+	}
+|	"deassign" lvalue() ";"
+|	"force"  width = lvalue() asn = "=" exp = expression() ";"
+	{
+		evaluateAssignment(asn, width, exp);
+	}
+|	"release" lvalue() ";"
+}
+
+void proceduralTimingControlStatement() :
+{}
+{
+	delayOrEventControl() statement()
+}
+
+void ifStatement() :
+{}
+{
+	<IF> "(" expression() ")" statement()
+	[ LOOKAHEAD(1) <ELSE> statement() ]
+}
+
+void caseStatement() :
+{}
+{
+	<CASE>"(" expression() ")"
+	(
+		expression() ("," expression())* ":" statement()
+	| 	"default" [":"] statement()
+	)+
+	<ENDCASE>
+}
+
+void whileStatement() :
+{}
+{
+	<WHILE> "(" expression() ")" statement()
+}
+
+void forStatement() :
+{}
+{
+	<FOR> "("
+	lvalue() "=" expression() ";"
+	expression() ";"
+	lvalue() "=" expression() ")"
+	statement()
+}
+
+void foreverStatement() :
+{}
+{
+	<FOREVER> statement()
+}
+
+void repeatStatement() :
+{}
+{
+	<REPEAT> "(" expression() ")" statement()
+}
+
+void waitStatement() :
+{}
+{
+	<WAIT> "(" expression() ")" statement()
+}
+
+void block() :
+{}
+{
+	( <BEGIN> | <FORK> )
+	[ ":" identifier() ( blockItem() )* ]
+	( statement() )*
+	(<END> | <JOIN> )
+}
+
+void blockItem():
+{}
+{
+	parameterDecl()	
+| 	variableDecl()
+|   defparamDecl()
+}
+  
+void functionDecl():
+{}
+{
+	<FUNCTION> {begin(STATEMENT);} function() {end(STATEMENT);}
+}
+
+void taskDecl():
+{}
+{
+	<TASK> {begin(STATEMENT);} task() {end(STATEMENT);}
+}
+
+void functionOld() :
+{
+	String range;
+	Identifier name;
+	Token end ;
+}
+{
+	variableModifier() range = bitRange() name = identifier()
+	[ "(" skipTo(RPAREN) ]
+	";"
+	{
+		beginOutlineElement(name, "function#" + range);
+	}
+	end = skipTo( ENDFUNCTION )
+	{		
+		endOutlineElement(end, name.image, "function#" + range);
+		addCollapsible(name.beginLine, end.endLine);				
+	}
+}
+
+void function() : // changed bitRange - > bitRangeWithDepend(), but it seems function [parameter:0] already worked
+{
+	String range;
+	Identifier name;
+	Token end ;
+	int pos; 
+	String [] deps;
+}
+{
+	variableModifier()
+//	range = bitRange()
+	range= bitRangeWithDepend()
+	name = identifier()
+	{
+  		pos=range.indexOf("]");
+  		if (( pos >0 ) && ( pos < ( range.length() - 1 )))	{ // contains dependencies
+  			deps=range.split( "]" );
+  			range=deps[0] + "]";
+        	name.setEncodedDepends(deps[1]);
+  		}
+		beginOutlineElement(name, "function#" + range);
+	}
+	[ "(" [ functionArgument() ( "," functionArgument() )* ] ")" ] // function declaration may have module-style ports declared
+	";"
+	( functionItem() )*
+	statement() // TODO: limit what is allowed in a function
+	
+	end = < ENDFUNCTION >
+	{		
+		endOutlineElement(end, name.image, "function#" + range);
+		addCollapsible(name.beginLine, end.endLine);				
+	}
+}
+
+void functionItem() :
+{
+}
+{
+  	functionPortDecl()
+|  	variableDecl()
+|   parameterDecl()
+|   defparamDecl()
+}
+
+
+void taskOld() :
+{
+	Identifier name;
+	Token end ;
+}
+{
+	name = identifier() ";"
+	{
+		beginOutlineElement(name, "task#");
+	}
+	( taskItem() )*
+	statement()	  
+	end = < ENDTASK >
+	{	
+		endOutlineElement(end, name.image, "task#");
+		addCollapsible(name.beginLine, end.endLine);
+	}
+}
+
+void task() :
+{
+	Identifier name;
+	Token end ;
+}
+{
+	name = identifier()
+	{
+		beginOutlineElement(name, "task#");
+	}
+	[ "(" [ argument() ( "," argument() )* ] ")" ] // task also may have module-style ports declared
+	";"
+	( taskItem() )*
+	statement()
+	  
+	end = < ENDTASK >
+	{	
+		endOutlineElement(end, name.image, "task#");
+		addCollapsible(name.beginLine, end.endLine);
+	}
+}
+
+void taskItem() :
+{}
+{
+  	portDecl()
+|	variableDecl()
+|   parameterDecl()
+|   defparamDecl()
+}
+
+void generate() :
+{}
+{
+	<GENERATE>
+	( generateItem() )*
+	<ENDGENERATE>
+}
+
+void generateItem() :
+{
+	Identifier block = null;
+}
+{
+	moduleOrGenerateItem()
+|  generateIfStatement()
+|  generateCaseStatement()
+|  generateForStatement()
+|	(
+		<BEGIN> [ ":" block = identifier() ]
+		{
+			if (block != null)
+				beginGenerateBlock(block);
+		}
+		( generateItem() )*
+		<END> 
+		{
+			if (block != null) {
+				endGenerateBlock(block);
+			}
+		}
+	)
+}
+
+void generateIfStatement() :
+{}
+{
+	<IF> "(" constantExpression() ")" generateItem()
+	[ LOOKAHEAD(1) <ELSE> generateItem() ]
+}
+
+void generateCaseStatement() :
+{}
+{
+	<CASE> "(" constantExpression() ")"
+	(
+		constantExpression() ("," constantExpression())* ":" generateItem()
+	| 	"default" ":" generateItem()
+	)+
+	<ENDCASE>
+}
+
+void generateForStatement() :
+{}
+{
+	<FOR> "("
+	lvalue() "=" expression() ";"
+	expression() ";"
+	lvalue() "=" expression() ")"
+	generateItem()
+}
+
+
+String netType() :
+{}
+{
+	( "wire" | < NET_TYPE > | < SUPPLY > )
+	{
+		return token.image;
+	}
+}
+
+void strength() :
+{}
+{
+	"(" ( < STRENGTH > | < SUPPLY > ) ["," ( < STRENGTH > | < SUPPLY > ) ]")"
+}
+
+int lvalue() :
+{
+	int width;
+	Identifier ident;
+}
+{
+	ident = complexIdentifier()
+	{
+		variableAssignment(ident);
+		return ident.getWidth();
+	}
+|	width = lvalueConcatenation()
+	{
+		return width;
+	}
+}
+
+int lvalueConcatenation() :
+{
+	int width;
+	int ret;
+}
+{
+	"{" ret = lvalue()
+	(	","
+		width = lvalue()
+		{
+			if (width == 0 || ret == 0)
+				ret = 0;
+			else
+				ret += width;
+		}
+	)*
+	"}"
+	{
+		return ret;
+	}
+}
+
+Identifier identifier() :
+{
+	Token token;
+}
+{
+	token = < IDENT >
+	{
+		return new Identifier(token);
+	}
+}
+
+Expression constantExpression() :
+{
+	Expression ret;
+}
+{
+	ret = expression()
+	{
+		return ret;
+	}
+}
+    
+Expression expression() :
+{
+	Expression ret, exp1, exp2;
+	Token op;
+}
+{
+	ret = logicalOrExpresstion()
+	[
+		op = "?" exp1 = expression() ":" exp2 = expression()
+		{
+			ret = operator(ret, op, exp1, exp2);
+		}
+	]
+	{
+	 	return ret;
+	}
+}
+
+Expression logicalOrExpresstion() :
+{
+	Expression ret, exp;
+	Token op;
+}
+{
+	ret = logicalAndExpresstion()
+	( op = "||" exp = logicalAndExpresstion() { ret = operator(ret, op, exp); } )*
+	{
+		return ret;
+	}
+}
+
+Expression logicalAndExpresstion() :
+{
+	Expression ret, exp;
+	Token op;
+}
+{
+	ret = bitOrExpresstion()
+	( op = "&&" exp = bitOrExpresstion() { ret = operator(ret, op, exp); } )*
+	{
+		return ret;
+	}
+}
+
+Expression bitOrExpresstion() :
+{
+	Expression ret, exp;
+	Token op;
+}
+{
+	ret = bitAndExpresstion()
+	( op = "|" exp = bitAndExpresstion() { ret = operator(ret, op, exp); } )*
+	{
+		return ret;
+	}
+}
+
+Expression bitAndExpresstion() :
+{
+	Expression ret, exp;
+	Token op;
+}
+{
+	ret = equalityExpression()
+	(
+		(op = "&" | op = "^" | op = "~^" | op = "^~")
+		exp = equalityExpression() { ret = operator(ret, op, exp); }
+	)*
+	{
+		return ret;
+	}
+}
+
+Expression equalityExpression() :
+{
+	Expression ret, exp;
+	Token op;
+}
+{
+	ret = relationalExpression()
+	(
+		(op = "==" | op = "===" | op = "!=" | op = "!==")
+		exp = relationalExpression() { ret = operator(ret, op, exp); }
+	)*
+	{
+		return ret;
+	}
+}
+
+Expression relationalExpression() :
+{
+	Expression ret, exp;
+	Token op;
+}
+{
+	ret = shiftExpression()
+	(
+		(op = "<" | op = "<=" | op = ">" | op = ">=")
+		exp = shiftExpression() { ret = operator(ret, op, exp); }
+	)*
+	{
+		return ret;
+	}
+}
+
+Expression shiftExpression() :
+{
+	Expression ret, exp;
+	Token op;
+}
+{
+	ret = addExpression()
+	(
+		(op = "<<" | op = ">>" | op = "<<<" | op = ">>>")
+		exp = addExpression() { ret = operator(ret, op, exp); }
+	)*
+	{
+		return ret;
+	}
+}
+
+Expression addExpression() :
+{
+	Expression ret, exp;
+	Token op;
+}
+{
+	ret = multiplyExpression()
+	(
+		(op = "+" | op = "-" )
+		exp = multiplyExpression() { ret = operator(ret, op, exp); }
+	)*
+	{
+		return ret;
+	}
+}
+
+Expression multiplyExpression() :
+{
+	Expression ret, exp;
+	Token op;
+}
+{
+	ret = unaryExpression()
+	(
+		(op = "*" | op = "/" | op = "%" | op = "**")
+		exp = unaryExpression() { ret = operator(ret, op, exp); }
+	)*
+	{
+		return ret;
+	}
+}
+
+Expression unaryExpression() :
+{
+	Expression ret, exp;
+	Token op = null;
+}
+{
+	[ op = unaryOperator() ]
+	ret = primary()
+	{
+		if (op != null)
+			return operator(ret, op);
+		else
+			return ret;
+	}
+}
+
+Expression primary() :
+{
+	Expression ret;
+	Identifier ident;
+	boolean isFunc = false;
+}
+{
+	(
+		ret = number()
+	|  ident = complexIdentifier() [ functionArgs(ident) {isFunc = true; }]
+		{
+			if (isFunc) {
+				ret = functionReference(ident);
+			} else {
+				ret = variableReference(ident);
+			}
+		}
+	|	< SYSTEM_IDENT > (<SYSTEM_IDENT >)* [ LOOKAHEAD(2) sysFunctionArgs()]
+		{
+			ret = new Expression();
+		}
+	|	ret = concatenation()
+	|	"(" ret = minTypMaxExpresstion() ")"
+	)
+	{
+	 	if (ret == null)
+	 		return new Expression();
+		else
+			return ret;
+	}
+}
+
+Identifier complexIdentifier() :
+{
+	Identifier ident, concat;
+	Token token;
+}
+{
+	ident = identifier() bitOrAry(ident)
+	(
+//	   LOOKAHEAD(2) 
+//		"." concat = identifier() bitOrAry(concat)
+// "." is used for hierarchical names, "+" (now) for generated block to variable separator
+		( token= "@" | token= ".")  concat = identifier() bitOrAry(concat)
+		{
+			ident.endLine = concat.endLine;
+			ident.endColumn = concat.endColumn;
+			ident.image += token.image + concat.image;
+			ident.setWidth(concat.getWidthBit());
+			ident.setDimension(concat.getDimension());
+			ident.setEncodedDepends(concat.getEncodedDepends()); //Andrey: trying to add dependency on parameters used in bit selection
+		}
+	)*
+	{
+		return ident;
+	}
+}
+
+Expression minTypMaxExpresstion() :
+{
+	Expression exp;
+}
+{
+	exp = expression()
+	[
+		":" expression()
+		":" expression()
+	]
+	{
+		return exp;
+	}
+}
+
+void bitOrAry(Identifier ident) :
+{
+	int width = 0;
+	int lowBit = 0;
+	int dim = 0;
+	Expression msb=null, lsb;
+	Token token=null;
+}
+{
+  	(
+		"[" msb = expression() {
+		   	width = 1;
+		   	dim++;
+		   	if (msb.isValid())
+				lowBit = msb.intValue();
+			else
+			    badBitRange(ident, msb.stringValue());
+		   }
+		[
+			( token = ":" | token = "+:" | token = "-:" ) lsb = expression()
+			{
+				msb.addAllDepends(lsb);
+				if (token.image.equals(":"))
+				 {
+					if (msb.isValid() && lsb.isValid())
+					{						width = msb.intValue() - lsb.intValue() + 1;
+						lowBit = lsb.intValue();
+				    }
+			        else
+			        {						width = 0;
+						lowBit = 0;
+					   	if (!lsb.isValid())
+						    badBitRange(ident, lsb.stringValue());
+					}
+				} else if (token.image.equals("+:")){ // indexed part-select
+					if (lsb.isValid())						width = lsb.intValue();
+					else					{						width = 0;
+					    badBitRange(ident, lsb.stringValue());
+					}
+					if (msb.isValid())
+						lowBit = msb.intValue();
+			        else
+						lowBit = 0;
+				} else if (token.image.equals("-:")){ // indexed part-select
+					if (lsb.isValid())
+						width = lsb.intValue();
+					else
+						width = 0;
+					if (msb.isValid())
+						lowBit = msb.intValue()-width +((width >0)?1:0);
+			        else
+						lowBit = 0;
+				   	if (!lsb.isValid() && !msb.isValid())
+						badBitRange(ident, lsb.stringValue());
+				} else { // dead code?
+					if (lsb.isValid())
+					{						width = lsb.intValue();
+//						width = 1;
+//						lowBit = lsb.intValue();
+					}
+					else
+					{						width = 0;
+					    badBitRange(ident, lsb.stringValue());
+					}
+				}
+			}
+		]
+		token =  "]"
+	)*
+	{
+		ident.setWidth(width,lowBit);
+		ident.setDimension(dim);
+		ident.extendPosition(token); // is token pointing to "]" ?
+		if (msb!=null) ident.setEncodedDepends(msb.encodeDepends());
+	}
+}
+
+String bitRangeWithDepend() :
+{
+	Expression msb, lsb;
+	String depends;
+}
+{
+	[
+		"[" msb = expression()  ":" lsb = expression() "]" 
+		{
+			msb.addAllDepends(lsb);
+			depends=msb.encodeDepends();
+			if (msb.isValid() && lsb.isValid())			{
+				return "[" + msb.intValue() + ":" + lsb.intValue() + "]" + depends;
+			}
+			else
+				return "[X]" + depends; // invalid width
+		}
+	]
+	{
+		return ""; // No bit range
+	}
+}
+
+//TODO: Andrey:  bitRange() maybe needed to be upgraded to bitRangeWithDepend(), as for ports
+String bitRange() :
+{
+	Expression msb, lsb;
+}
+{
+	[
+		"[" msb = expression()  ":" lsb = expression() "]" 
+		{
+			if (msb.isValid() && lsb.isValid())
+				return "[" + msb.intValue() + ":" + lsb.intValue() + "]";
+			else
+				return "";
+		}
+	]
+	{
+		return "";
+	}
+}
+
+Token unaryOperator() :
+{}
+{
+	( "~" | "+" |  "-" |  "!" |  "&" |  "~&" | "|" |  "~|" |  "^" |  "~^" |  "^~" )
+	{
+		return token;
+	}
+}
+
+Expression concatenation() :
+{
+	int width;
+	int value;
+	boolean valid;
+	boolean assignable;
+	Expression exp;
+	Expression refs = new Expression();
+}
+{
+	"{" exp = expression()
+	{
+		width = exp.getWidth();
+		value = exp.intValue();
+		valid = exp.isValid();
+		assignable = exp.isAssignable();
+		refs.addReference(exp);
+		refs.extendPosition(exp);
+	}
+	[
+		( "," exp = expression()
+		{
+			if (width == 0 || exp.getWidth() == 0)
+				width = 0;
+			else
+				width += exp.getWidth();
+			value = (value << width) | exp.intValue();
+			valid = valid && exp.isValid();
+			assignable = assignable && exp.isAssignable();
+			refs.addReference(exp);
+			refs.extendPosition(exp);
+		}
+		)+
+	|	"{" exp = expression() "}"
+		{
+			width = valid ? (value * exp.getWidth()) : 0;
+			value = exp.intValue();
+			valid = exp.isValid();
+			assignable = exp.isAssignable();
+			exp.extendPosition(refs);
+			refs = exp;
+		}
+	]
+	"}"
+	{
+		Expression ret = new Expression(width);
+		if (valid)
+			ret.setValue(value);
+		ret.setAssignable(assignable);
+		ret.addReference(refs);
+		ret.extendPosition(refs);
+		return ret;
+	}
+}
+// for system functions - no checks of arguments
+void sysFunctionArgs():
+{}
+{
+	"(" expression() ( "," expression() )* ")"
+}
+// for normal functions
+void functionArgs(Identifier ident):
+{
+	Token iend;
+}
+{
+	"("
+	     {
+	         beginOutlineElement(ident, ident.image+":"+ident.beginLine+":"+ident.beginColumn, "functionreference#"+ident.image);
+	     }
+	      portConnect(ident.image, PORT_TYPE.FUNCTION) 
+	      iend= ")"
+		{
+		    endOutlineElement(iend, ident.image+":"+ident.beginLine+":"+ident.beginColumn, "functionreference#"+ident.image);
+			addCollapsible(ident.beginLine, iend.endLine);
+		}
+}
+
+
+Expression number() :
+{
+	Expression ret = new Expression();
+}
+{
+	(
+	< INTEGER_LITERAL > { ret.parseIntegerLiteral(token.image); }
+	|  < REAL_LITERAL > { ret.parseRealLiteral(token.image); }
+	|  < STRING_LITERAL > { ret.parseStringLiteral(token.image); }
+	)
+	{
+	    ret.extendPosition(token);
+		return ret;
+	}	
+}
+
+
+JAVACODE
+void unexpectedEof(Token token)
+{
+	ParseException ex = new ParseException("unexpected EOF");
+	ex.currentToken = token;
+	throw ex;
+}
+
+JAVACODE
+Token skipTo(int skip)
+{
+	Token current = token;
+	Token token ;
+	StringBuffer image = new StringBuffer();
+
+	for(;;)
+	{
+		token = getToken(1);
+		if (token.kind == EOF)
+			unexpectedEof(current);
+		if (token.kind == skip)
+		{
+			getNextToken();
+			break ;
+		}
+
+		image.append(token.image);
+		getNextToken();
+	}
+	token.image = image.toString();
+	return token ;
+}
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/verilog/VerilogParser.java vdt/src/com/elphel/vdt/veditor/parser/verilog/VerilogParser.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/verilog/VerilogParser.java	2016-06-24 10:29:40.856495517 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/verilog/VerilogParser.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,888 +1,2729 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2012 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-
-package net.sourceforge.veditor.parser.verilog;
-
-import java.io.IOException;
-import java.io.Reader;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-import net.sourceforge.veditor.VerilogPlugin;
-import net.sourceforge.veditor.parser.HdlParserException;
-import net.sourceforge.veditor.parser.IParser;
-import net.sourceforge.veditor.parser.OutlineContainer;
-import net.sourceforge.veditor.parser.OutlineDatabase;
-import net.sourceforge.veditor.parser.OutlineElement;
-import net.sourceforge.veditor.parser.OutlineElementFactory;
-import net.sourceforge.veditor.parser.OutlineContainer.Collapsible;
-import net.sourceforge.veditor.parser.ParserReader;
-import net.sourceforge.veditor.preference.PreferenceStrings;
-
-import org.eclipse.core.resources.IFile;
-import org.eclipse.core.resources.IMarker;
-import org.eclipse.core.resources.IProject;
-
-/**
- * implementation class of VerilogParserCore<p/>
- * for separating definition from JavaCC code 
- */
-public class VerilogParser extends VerilogParserCore implements IParser, PreferenceStrings
-{
-	// these are semantic error.
-	private static final String DUPLICATE_PARAM = "Duplicate parameter %s";
-	private static final String DUPLICATE_SIGNAL = "Duplicate signal %s";
-	private static final String DUPLICATE_TASK = "Duplicate task %s";
-	private static final String DUPLICATE_FUNCTION = "Duplicate function %s";
-	private static final String CANNOT_RESOLVED_TASK = "%s cannot be resolved to a task";
-	private static final String CANNOT_RESOLVED_FUNCTION = "%s cannot be resolved to a function";
-	private static final String ASSIGN_WIRE = "The wire %s assign in initial or always block";
-	private static final String ASSIGN_REG = "The reg %s assign in assign statement";
-
-	// these are semantic warning.
-	private static final String CANNOT_RESOLVED_SIGNAL = "%s cannot be resolved to a signal or parameter";
-	private static final String NOT_ASSIGNED_AND_USED = "The signal %s is not assigned and used";
-	private static final String NOT_USED = "The value of %s is not used";
-	private static final String NOT_USED_TASK = "The task %s is not used";
-	private static final String NOT_USED_FUNCTION = "The function %s is not used";
-	private static final String NOT_ASSIGNED = "The signal %s is not assigned";
-	private static final String REG_CONNECT_OUTPUT = "The register %s cannot be connected to output port";
-	private static final String ASSIGN_WIDTH_MISMATCH = "Assignment bit width mismatch: %s";
-	private static final String BOTH_ASSIGNMENT = "Both blocking and non-blocking assinments in a initial or always block";
-	private static final String BLOCKING_ALWAYS = "Blocking assinments in always block";
-	private static final String CANNOT_RESOLVED_MODULE = "The module %s is not found in the project";
-	private static final String MODULE_HAS_NO_PORT = "The module %s does not have port %s.";
-	private static final String BAD_PORT_CONNECTION = "The signal cannot connect to output or inout port %s";
-	private static final String UNCONNECTED_PORT = "The port %s in module %s does not connected.";
-
-	private static final int NO_ASSIGN = 0;
-	private static final int NON_BLOCKING = 1;
-	private static final int BLOCKING = 2;
-	
-	private IFile m_File;
-	private ParserReader m_Reader;
-	private IProject m_Project;
-	private static OutlineElementFactory m_OutlineElementFactory = new VerilogOutlineElementFactory();
-	private OutlineContainer m_OutlineContainer;
-	private int m_Context;
-	private int blockContext;
-	private int blockStatus;
-	private Pattern[] taskTokenPattern;
-	private boolean isPortConnect;
-	private VariableStore variableStore;
-	private InstanceStore instanceStore = new InstanceStore();
-	private List<String> generateBlock = new ArrayList<String>();
-	private List<VariableStore> variableStoreList = new ArrayList<VariableStore>();
-	
-	private Preferences preferences = new Preferences();
-	
-	public VerilogParser(ParserReader reader, IProject project, IFile file) {
-		super(reader);
-		m_Context = IParser.OUT_OF_MODULE;
-		m_Reader = reader;
-		m_Project = project;
-		m_File = file;
-		m_OutlineContainer = null;
-		blockContext = STATEMENT; // no check of block or assign statement
-
-		// if project == null, the context scanning is running
-		// no update outline and error markers 
-
-		if (project != null) {
-			// in outline scanning
-			OutlineDatabase database;
-			database = OutlineDatabase.getProjectsDatabase(project);
-			if (database != null) {
-				m_OutlineContainer = database.getOutlineContainer(file);
-			}
-		}
-		
-		taskTokenPattern=new Pattern[taskCommentTokens.length];
-        for(int i=0; i< taskCommentTokens.length;i++){
-            String regex=".*\\b("+taskCommentTokens[i]+")(\\b.*)";
-            taskTokenPattern[i]= Pattern.compile(regex);
-        }
-	}
-	
-	// called by VerilogParserCore
-	protected void beginOutlineElement(Token begin, String name, String type) {
-		if (type.equals("module#")) {
-			m_Context = IParser.IN_MODULE;
-			variableStore = new VariableStore();
-		}
-		if (m_OutlineContainer != null) {
-			int line = begin.beginLine;
-			m_OutlineContainer.beginElement(name, type, line,
-					begin.beginColumn, m_File, m_OutlineElementFactory);
-			String[] types = type.split("#");
-			if (types[0].equals("parameter") || types[0].equals("localparam")) {
-				String bitRange = (types.length > 2) ? types[2] : "";
-				if (bitRange.equals(""))
-					bitRange = "[31:0]";
-				VariableStore.Symbol ref;
-				ref = variableStore.addSymbol(name, line, types, bitRange);
-				if (ref == null) {
-					warning(line, DUPLICATE_PARAM, name);
-				} 
-			} else if (types[0].equals("task")) {
-				addTask(name, line, types);
-			} else if (types[0].equals("function")) {
-				addFunciton(name, line, types);
-			} else if (types[0].equals("instance")) {
-				isPortConnect = true;
-				instanceStore.addInstance(types[1], line);
-			} else {
-				addVariable(name, line, types);
-			}
-		}
-	}
-
-	private void addTask(String name, int line, String[] types) {
-		VariableStore.Symbol ref = variableStore.findSymbol(name);
-		if (ref == null) {
-			ref = variableStore.addSymbol(name, line, types, "");
-		} else {
-			if (ref.isTask() == false || ref.isAssignd()) {
-				warning(line, DUPLICATE_TASK, name);
-				return;
-			}
-		}
-		ref.setAssignd();
-	}
-
-	private void addFunciton(String name, int line, String[] types) {
-		String bitRange = (types.length > 1) ? types[1] : "";
-		VariableStore.Symbol ref = variableStore.findSymbol(name);
-		if (ref == null) {
-			ref = variableStore.addSymbol(name, line, types, bitRange);
-		} else {
-			if (ref.isFunction() == false || ref.isAssignd()) {
-				warning(line, DUPLICATE_FUNCTION, name);
-				return;
-			}
-			ref.setWidth(bitRange);
-		}
-		ref.setAssignd();
-	}
-
-	private void addVariable(String name, int line, String[] types) {
-		String bitRange = null;
-		int dim = 0;
-		if (types[0].equals("variable")) {
-			if (types[1].contains("genvar"))
-				bitRange = "[-1:0]"; // unfixed
-			else if (types[1].contains("integer"))
-				bitRange = "[31:0]";
-			else
-				bitRange = (types.length > 2) ? types[2] : "";
-			dim = (types.length > 3) ? Integer.parseInt(types[3]) : 0;
-		} else if (types[0].equals("port")) {
-			bitRange = (types.length > 3) ? types[3] : "";
-		}
-		if (bitRange != null) {
-			String head = "";
-			for(int i = 0; i < generateBlock.size(); i++) {
-				head += generateBlock.get(i) + ".";
-			}
-			name = head + name;
-			
-			if (variableStore.addSymbol(name, line, types, bitRange, dim) == null) {
-				// c-style port declaration can add reg or wire modifiers.
-				if (types[0].equals("variable")) {
-					VariableStore.Symbol ref = variableStore.findSymbol(name);
-					if (ref.containsType("cstyle")) {
-						ref.addModifier(types[1]);
-						return;
-					}
-				}
-				warning(line, DUPLICATE_SIGNAL, name);
-			}
-		}
-	}
-
-	protected void endOutlineElement(Token end, String name, String type) {
-		if (type.equals("module#")) {
-			m_Context = IParser.OUT_OF_MODULE;
-			variableStoreList.add(variableStore);
-		}
-		if (m_OutlineContainer != null) {
-			if (type.startsWith("instance#")) {
-				isPortConnect = false;
-			}
-			m_OutlineContainer.endElement(name, type, end.endLine,
-					end.endColumn, m_File);
-		}
-	}
-	
-	protected void parameterAssignment(String name, Expression value) {
-		VariableStore.Symbol sym;
-		sym = variableStore.getVariableSymbol(name, generateBlock);
-		if (sym != null) {
-			if (value.isValidInt())
-				sym.setValue(value.intValue());
-			else
-				sym.setValue(value.toString());
-			sym.setAssignd();
-		}
-	}
-	
-	private void updateConnection(OutlineDatabase database, VariableStore.Symbol sym) {
-		String conns[] = sym.getConnections();
-		if (conns == null)
-			return;
-		for (String conn : conns) {
-			String[] csplit = conn.split("#");
-			String moduleName = csplit[0];
-			String portName = csplit[1];
-			OutlineElement module = database.findTopLevelElement(moduleName);
-			if (module != null) {
-				OutlineElement port = findPortInModule(module, portName);
-				if (port != null) {
-					String type = port.getType();
-					if (type.startsWith("port#input")) {
-						sym.setUsed();
-					} else if (type.startsWith("port#output")) {
-						if (sym.isReg()) {
-							int line = Integer.parseInt(csplit[2]);
-							warning(line, REG_CONNECT_OUTPUT, sym.getName());
-						}
-						sym.setAssignd();
-					} else if (type.startsWith("port#inout")) {
-						sym.setUsed();
-						sym.setAssignd();
-					}
-				}
-			}
-		}
-	}
-	
-	private OutlineElement findPortInModule(OutlineElement module, String name) {
-		OutlineElement port;
-		if (Character.isDigit(name.charAt(0))) {
-			int index = Integer.parseInt(name);
-			port = module.getChild(index);
-		} else {
-			port = module.findChild(name);
-		}
-		if (port == null)
-			return null;
-		if (port.getType().startsWith("port#")) {
-			return port;
-		} else {
-			return null;
-		}
-	}
-
-	private void checkVariables(VariableStore store) {
-		OutlineDatabase database = OutlineDatabase.getProjectsDatabase(m_Project);
-		
-		for (VariableStore.Symbol sym : store.collection()) {
-			updateConnection(database, sym);
-
-			boolean notUsed = false;
-			boolean notAssigned = false;
-			if (sym.isUsed() == false && sym.containsType("output") == false) {
-				notUsed = true;
-			}
-			if (sym.isAssignd() == false && sym.containsType("input") == false) {
-				notAssigned = true;
-			}
-			if (notUsed || notAssigned) {
-				int line = sym.getLine();
-				String name = sym.getName();
-				if (sym.isTask()) {
-					if (notUsed) {
-						if (preferences.noUsed)
-							warning(line, NOT_USED_TASK, name);
-					} else {
-						warning(line, CANNOT_RESOLVED_TASK, name);
-					}
-				} else if (sym.isFunction()) {
-					if (notUsed) {
-						if (preferences.noUsed)
-							warning(line, NOT_USED_FUNCTION, name);
-					} else {
-						warning(line, CANNOT_RESOLVED_FUNCTION, name);
-					}
-				} else if (preferences.noUsed) {
-					if (notUsed && notAssigned)
-						warning(line, NOT_ASSIGNED_AND_USED, name);
-					else if (notUsed)
-						warning(line, NOT_USED, name);
-					else
-						warning(line, NOT_ASSIGNED, name);
-				}
-			}
-		}
-	}
-
-	private void checkInstance()  {
-		OutlineDatabase database = OutlineDatabase.getProjectsDatabase(m_Project);
-
-		InstanceStore store = instanceStore;
-		for(InstanceStore.Instance inst : store.collection()) {
-			String moduleName = inst.getName();
-			OutlineElement module = database.findTopLevelElement(moduleName);
-			if (module == null) {
-				if (preferences.unresolvedModule) {
-					int line = inst.getLine();
-					warning(line, CANNOT_RESOLVED_MODULE, moduleName);
-				}
-			} else {
-				if (preferences.moduleConnection) {
-					checkInstancePort(inst, module);
-				}
-			}
-		}
-	}
-
-	private void checkInstancePort(InstanceStore.Instance inst, OutlineElement module) {
-		String moduleName = inst.getName();
-
-		// scan all port in instance.
-		for (InstanceStore.Port port : inst.getPorts()) {
-			String name = port.getName();
-			int line = port.getLine();
-			OutlineElement eport = findPortInModule(module, name);
-			if (eport == null) {
-				warning(line, MODULE_HAS_NO_PORT, moduleName, name);
-			} else {
-				String type = eport.getType();
-				if (type.startsWith("port#input") == false) {
-					Expression signal = port.getSignal();
-					if (signal != null && signal.isAssignable() == false) {
-						warning(line, BAD_PORT_CONNECTION, name);
-					}
-				}
-			}
-		}
-
-		if (inst.isNamedMap() == false)
-			return;
-
-		// scan all port in module definition.
-		for (OutlineElement child : module.getChildren()) {
-			String type = child.getType();
-			if (type.startsWith("port#")) {
-				String portName = child.getName();
-				if (inst.findPort(portName) == null) {
-					int line = inst.getLine();
-					warning(line, UNCONNECTED_PORT, portName, moduleName);
-				}
-			}
-		}
-	}
-	
-	protected void addCollapsible(int startLine, int endLine) {
-		if (m_OutlineContainer != null) {
-			Collapsible c = m_OutlineContainer.new Collapsible(startLine,
-					endLine);
-			m_OutlineContainer.addCollapsibleRegion(c);
-		}
-	}
-
-	protected void begin(int mode) {
-		m_Context = IParser.IN_STATEMENT;
-		blockContext = mode;
-		blockStatus = NO_ASSIGN;
-	}
-
-	protected void end(int mode) {
-		m_Context = IParser.IN_MODULE;
-		blockContext = STATEMENT; // no check of block or assign statement
-	}
-	
-	protected Expression operator(Expression arg, Token op) {
-		Operator ope = new Operator(op.image);
-		Expression ret = ope.operate(arg);
-		if (ope.isWarning())
-			warning(op.beginLine, ope.getWarning());
-		ret.addReference(arg);
-		return ret;
-	}
-
-	protected Expression operator(Expression arg1, Token op, Expression arg2) {
-		Operator ope = new Operator(op.image);
-		Expression ret = ope.operate(arg1, arg2);
-		if (ope.isWarning())
-			warning(op.beginLine, ope.getWarning());
-		ret.addReference(arg1);
-		ret.addReference(arg2);
-		return ret;
-	}
-
-	protected Expression operator(Expression arg1, Token op, Expression arg2,
-			Expression arg3) {
-		Operator ope = new Operator(op.image);
-		Expression ret = ope.operate(arg1, arg2, arg3);
-		if (ope.isWarning())
-			warning(op.beginLine, ope.getWarning());
-		return ret;
-	}
-
-	protected Expression variableReference(Identifier ident) {
-		if (m_OutlineContainer != null) {
-			String name = ident.image;
-			if (name.contains("."))
-				return new Expression();
-			int line = ident.beginLine;
-			VariableStore.Symbol sym;
-			if (isPortConnect) {
-				// I cannot decide whether the variable is referred or assigned.
-				sym = variableStore.getVariableSymbol(name, generateBlock);
-			} else {
-				sym = variableStore.addUsedVariable(name, generateBlock);
-			}
-			if (sym == null) {
-				if (preferences.unresolved)
-					warning(line, CANNOT_RESOLVED_SIGNAL, name);
-			} else {
-				int width = ident.getWidth();
-				if (width == 0) {
-					width = sym.getWidth(); // doesn't have bit range
-				} else if (width == 1) {
-					if (ident.getDimension() <= sym.getDimemsion())
-						width = sym.getWidth();
-				}
-				if (sym.isParameter()) {
-					if (sym.isValidInt())
-						return new Expression(width, sym.getValue());
-					else
-						return new Expression(width, sym.toString());
-				} else {
-					Expression exp = new Expression(width, ident);
-					return exp;
-				}
-			}
-		}
-		return new Expression();
-	}
-
-	protected void taskReference(Identifier ident) {
-		if (m_OutlineContainer != null) {
-			String name = ident.image;
-			if (name.contains("."))
-				return;
-			int line = ident.beginLine;
-			VariableStore.Symbol sym = variableStore.findSymbol(name);
-			if (sym == null) {
-				String[] types = {"task"};
-				sym = variableStore.addSymbol(name, line, types, "");
-			}
-			sym.setUsed();
-		}
-	}
-
-	protected Expression functionReference(Identifier ident) {
-		if (m_OutlineContainer != null) {
-			String name = ident.image;
-			if (name.contains("."))
-				return new Expression();
-			int line = ident.beginLine;
-			VariableStore.Symbol sym = variableStore.findSymbol(name);
-			if (sym == null) {
-				String[] types = {"function", ""};
-				sym = variableStore.addSymbol(name, line, types, "");
-				sym.setUsed();
-			} else {
-				int width = ident.getWidth();
-				if (width == 0)
-					width = sym.getWidth(); // doesn't have bit range
-				Expression exp = new Expression(width);
-				exp.addReference(ident);
-				sym.setUsed();
-				return exp;
-			}
-		}
-		return new Expression();
-	}
-
-	protected void variableAssignment(Identifier ident) {
-		if (m_OutlineContainer != null) {
-			String name = ident.image;
-			int line = ident.beginLine;
-			VariableStore.Symbol sym = variableStore.addAssignedVariable(name, generateBlock);
-			if (sym == null || sym.isVariable() == false) {
-				if (preferences.unresolved)
-					warning(line, CANNOT_RESOLVED_SIGNAL, name);
-			} else {
-				int width = ident.getWidth();
-				if (width <= 1 && sym.getDimemsion() >= ident.getDimension())
-					ident.setWidth(sym.getWidth());
-				if (blockContext == ASSIGN_STMT && sym.isReg()) {
-					warning(line, ASSIGN_REG, name);
-				} else if ((blockContext == INITIAL_BLOCK || blockContext == ALWAYS_BLOCK)
-						&& sym.isReg() == false) {
-					warning(line, ASSIGN_WIRE, name);
-				}
-			}
-		}
-	}
-
-	/**
-	 * Evaluate positional port connection.
-	 */
-	protected void variableConnection(Expression arg, String module, int portIndex) {
-		if (arg == null)
-			return;
-
-		// Don't add port to instanceStore.
-		// The connection check is available in named port connection only.
-		
-		Identifier[] idents = arg.getReferences();
-		if (idents == null)
-			return;
-
-		String name = Integer.toString(portIndex);
-		variableConnection(arg, module, name, idents[0].beginLine);
-	}
-
-	/**
-	 * Evaluate named port connection.
-	 */
-	protected void variableConnection(Expression arg, String module, Identifier port) {
-		if (m_OutlineContainer == null)
-			return;
-
-		int line = port.beginLine;
-		String portName = port.image;
-		instanceStore.addPort(portName, line, arg);
-
-		if (arg != null)
-			variableConnection(arg, module, portName, line);
-	}
-	
-	private void variableConnection(Expression arg, String module, String portName, int line) {
-		Identifier[] idents = arg.getReferences();
-		if (idents == null)
-			return;
-
-		for (Identifier ident : idents) {
-			if (preferences.moduleConnection) {
-				if (arg.isAssignable()) {
-					// The decision of input or output is delayed, just recorded now.
-					variableStore.addConnection(ident.image, generateBlock,
-							module + "#" + portName + "#" + line);
-				} else {
-					// Expression must be used as input only.
-					variableStore.addUsedVariable(ident.image, generateBlock);
-				}
-			} else {
-				// no checking module port connection, assume inout port.
-				variableStore.addAssignedVariable(ident.image, generateBlock);
-				variableStore.addUsedVariable(ident.image, generateBlock);
-			}
-		}
-	}
-	
-	protected void evaluateAssignment(Token asn, int lvalue, Expression exp) {
-		if (m_OutlineContainer == null)
-			return;
-
-		if (blockContext == INITIAL_BLOCK || blockContext == ALWAYS_BLOCK) {
-			if (preferences.blocking) {
-				if (asn.image.equals("=")) {
-					if (blockStatus == NON_BLOCKING) {
-						warning(asn.beginLine, BOTH_ASSIGNMENT);
-					} else {
-						blockStatus = BLOCKING;
-					}
-				} else {
-					if (blockStatus == BLOCKING) {
-						warning(asn.beginLine, BOTH_ASSIGNMENT);
-					} else {
-						blockStatus = NON_BLOCKING;
-					}
-				}
-			}
-		}
-
-		if (blockContext == ALWAYS_BLOCK) {
-			if (preferences.blockingAlways && asn.image.equals("=")) {
-				warning(asn.beginLine, BLOCKING_ALWAYS);
-			}
-		}
-
-		if (exp.isFixedWidth() == false || lvalue == 0)
-			return;
-
-		int width = exp.getWidth();
-		if (preferences.intConst == false) {
-			if (width == 32 && exp.isValid())
-				return;
-		}
-		if (preferences.bitWidth && exp.isValidWidth() && lvalue != width) {
-			String message = "from " + width + " to " + lvalue;
-			warning(asn.beginLine, ASSIGN_WIDTH_MISMATCH, message);
-		}
-	}
-
-	protected void beginGenerateBlock(Identifier block) {
-		generateBlock.add(block.image);
-	}
-	
-	protected void endGenerateBlock(Identifier block) {
-		generateBlock.remove(generateBlock.size() - 1);
-	}
-
-	private void warning(int line, String format, String arg1, String arg2) {
-		String message = String.format(format, arg1, arg2);
-		VerilogPlugin.setWarningMarker(m_File, line, message);
-	}
-
-	private void warning(int line, String format, String arg) {
-		String message = String.format(format, arg);
-		VerilogPlugin.setWarningMarker(m_File, line, message);
-	}
-
-	private void warning(int line, String message) {
-		VerilogPlugin.setWarningMarker(m_File, line, message);
-	}
-
-	public int getContext() {
-		return m_Context;
-	}
-	
-	private void close() {
-		try {
-			m_Reader.close();
-		} catch (IOException e) {
-		}
-	}
-
-	public void parse() throws HdlParserException
-	{
-		try {
-			m_Reader.reset();
-		} catch (IOException e) {			
-		}
-		
-		if (m_OutlineContainer != null) {
-			VerilogPlugin.deleteMarkers(m_File);
-			preferences.updatePreferences();
-			Expression.setPreferences(preferences);
-		}
-		try
-		{
-			//start by looking for modules
-			verilogText();
-		}
-		catch(ParseException e){
-
-			if (m_OutlineContainer != null) {
-				// add error marker in outline scanning 
-				VerilogPlugin.setErrorMarker(m_File, e.currentToken.beginLine,
-						e.getMessage());
-			}
-			close();
-
-			//convert the exception to a generic one
-			throw new HdlParserException(e);
-		}
-
-		if (m_OutlineContainer != null) {
-			parseLineComment();
-		}
-		close();
-		
-		for(VariableStore store : variableStoreList) {
-			checkVariables(store);
-		}
-		checkInstance();
-	}
-	 
-	/**
-     * Checks to see if a comment contains a task token
-     * @param comment The comment to check
-     * @param msg String array to receive the message type associated with the string
-     * @return The string of the Token. null if the comment does not have a task token
-     */
-    protected String getTaskToken(String comment,String []msg ){
-                
-        for(Pattern pattern:taskTokenPattern){          
-            Matcher matcher= pattern.matcher(comment);
-            if(matcher.find()){             
-                msg[0]=matcher.group(1)+matcher.group(2);
-                return matcher.group(1);
-            }
-        }
-        //if we get here, no task was found
-        return null;
-    }
-    /**
-     * Adds a task to the given line based on the comment token
-     * @param type
-     * @param line
-     */
-    protected void addTaskToLine(String type,String msg, int line){
-        //The first marker is considered high priority
-        if(type.startsWith(taskCommentTokens[0])){
-            VerilogPlugin.setTaskMarker(m_File, line, msg,IMarker.PRIORITY_HIGH);
-        }
-        else{
-            VerilogPlugin.setTaskMarker(m_File, line, msg,IMarker.PRIORITY_NORMAL);
-        }
-    }
-    
-    /**
-     * Removes a task from the given line
-     * @param line Line number to remove the task from
-     */
-    protected void removeTaskFromLine(int line){
-        VerilogPlugin.clearAutoTaskMarker(m_File, line);
-    }
-    
-    /**
-     * Removes all the auto generated tasks from the file
-     */
-    protected void clearAutoTasks(){
-        VerilogPlugin.clearAllAutoTaskMarkers(m_File);
-    }
-    
-    
-	/**
-	 * parse line comment for collapse
-	 */
-	private void parseLineComment() {
-		try {
-			m_Reader.reset();
-			clearAutoTasks();
-
-			boolean continued = false;
-			int startLine = -1;
-			int line = 1;
-			boolean validLine = false;
-			int c = m_Reader.read();
-			while (c != -1) {
-				switch (c) {
-				case '\n':
-					if (continued == true) {
-						continued = false;
-						if (line - startLine >= 2)
-							addCollapsible(startLine, line - 1);
-					}
-					line++;
-					validLine = false;
-					c = m_Reader.read();
-					break;
-				case '/':
-					c = m_Reader.read();
-					if (!validLine && c == '/') {
-						if (continued == false) {
-							startLine = line;
-							continued = true;
-						}
-
-						String comment = getLineComment(m_Reader);
-						if (comment != null){
-						    String []msg=new String[1];								
-                        
-                            addComment(line, comment);
-                            //check to see if we need to add a task
-                            String taskToken=getTaskToken(comment,msg);
-                            if(taskToken != null){                                  
-                                addTaskToLine(taskToken, msg[0], line);
-                            }                               
-                        }
-						line++;
-					}
-					break;
-				default:
-					if (!Character.isWhitespace((char)c)){
-						validLine = true;
-					}
-					c = m_Reader.read();
-					break;
-				}
-			}
-		} catch (IOException e) {
-		}
-	}
-
-	private String getLineComment(Reader reader) throws IOException
-	{
-		StringBuffer str = new StringBuffer();
-		boolean enable = false;
-
-		//  copy to StringBuffer
-		int c = reader.read();
-		while (c != '\n' && c != -1)
-		{
-			if (Character.isLetterOrDigit((char)c) || enable)
-			{
-				str.append((char)c);
-				enable = true;
-			}
-			c = reader.read();
-		}
-
-		// delete tail
-		for (int i = str.length() - 1; i >= 0; i--)
-		{
-			char ch = str.charAt(i);
-			if (!Character.isSpaceChar(ch))
-				break;
-			else
-				str.deleteCharAt(i);
-		}
-
-		if (str.length() != 0)
-			return str.toString();
-		else
-			return null;
-	}
-
-	private void addComment(int line, String comment)
-	{
-		// ignore continuous comments
-		if (prevCommentLine + 1 == line)
-		{
-			prevCommentLine = line;
-			return;
-		}
-
-		prevCommentLine = line;
-
-		//TODO need to add the comment functionality back in
-	}
-	private int prevCommentLine;
-
-	// preferences
-	public static class Preferences {
-		public boolean unresolved;
-		public boolean noUsed;
-		public boolean bitWidth;
-		public boolean intConst;
-		public boolean blocking;
-		public boolean blockingAlways;
-		public boolean unresolvedModule;
-		public boolean moduleConnection;
-
-		public void updatePreferences() {
-			unresolved = get(WARNING_UNRESOLVED);
-			noUsed = get(WARNING_NO_USED_ASIGNED);
-			bitWidth = get(WARNING_BIT_WIDTH);
-			intConst = get(WARNING_INT_CONSTANT);
-			blocking = get(WARNING_BLOCKING_ASSIGNMENT);
-			blockingAlways = get(WARNING_BLOCKING_ASSIGNMENT_IN_ALWAYS);
-			unresolvedModule = get(WARNING_UNRESOLVED_MODULE);
-			moduleConnection = get(WARNING_MODULE_CONNECTION);
-		}
-
-		private boolean get(String key) {
-			return VerilogPlugin.getPreferenceBoolean(key);
-		}
-	}
-}
-
-
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+/*******************************************************************************
+ * Copyright (c) 2004, 2012 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+
+package com.elphel.vdt.veditor.parser.verilog;
+
+import java.io.BufferedReader;
+import java.io.File;
+//import java.io.File;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.Reader;
+import java.util.ArrayList;
+import java.util.HashSet;
+//import java.util.Collection;
+//import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import com.elphel.vdt.VerilogUtils;
+import com.elphel.vdt.core.launching.VDTErrorParser;
+import com.elphel.vdt.ui.MessageUI;
+import com.elphel.vdt.veditor.VerilogPlugin;
+import com.elphel.vdt.veditor.document.HdlDocument;
+import com.elphel.vdt.veditor.editor.HdlEditor;
+import com.elphel.vdt.veditor.parser.HdlParserException;
+import com.elphel.vdt.veditor.parser.IParser;
+import com.elphel.vdt.veditor.parser.OutlineContainer;
+import com.elphel.vdt.veditor.parser.OutlineDatabase;
+import com.elphel.vdt.veditor.parser.OutlineElement;
+import com.elphel.vdt.veditor.parser.OutlineElementFactory;
+import com.elphel.vdt.veditor.parser.OutlineContainer.Collapsible;
+import com.elphel.vdt.veditor.parser.ParserReader;
+//import com.elphel.vdt.veditor.parser.verilog.InstanceStore.Instance;
+//import com.elphel.vdt.veditor.parser.verilog.InstanceStore.Port;
+import com.elphel.vdt.veditor.parser.verilog.VariableStore.Symbol;
+import com.elphel.vdt.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogModuleElement;
+import com.elphel.vdt.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogOutlineElement;
+//import com.elphel.vdt.veditor.parser.verilog.VerilogOutlineElementFactory.VerilogParameterElement;
+import com.elphel.vdt.veditor.preference.PreferenceStrings;
+import com.elphel.vdt.veditor.parser.ParserFactory;
+
+import org.eclipse.core.resources.IFile;
+import org.eclipse.core.resources.IMarker;
+import org.eclipse.core.resources.IProject;
+import org.eclipse.core.runtime.CoreException;
+import org.eclipse.core.runtime.IPath;
+
+
+/**
+ * implementation class of VerilogParserCore<p/>
+ * for separating definition from JavaCC code 
+ */
+
+public class VerilogParser extends VerilogParserCore implements IParser, PreferenceStrings
+{
+	// these are semantic error.
+	private static final String DUPLICATE_MODULE = "Duplicate module %s, also defined in %s";
+	private static final String DUPLICATE_PARAM = "Duplicate parameter %s";
+	private static final String DUPLICATE_SIGNAL = "Duplicate signal %s";
+	private static final String DUPLICATE_TASK = "Duplicate task %s";
+	private static final String DUPLICATE_FUNCTION = "Duplicate function %s";
+	private static final String CANNOT_RESOLVED_TASK = "%s cannot be resolved to a task";
+	private static final String CANNOT_RESOLVED_FUNCTION = "%s cannot be resolved to a function";
+	private static final String ASSIGN_WIRE = "The wire %s assign in initial or always block";
+	private static final String ASSIGN_REG = "Sequential variable %s assignment in assign statement";
+	private static final String ASSIGN_ILLEGAL = "Can not assign value to %s of type %s";
+	private static final String FUNCTION_NOT_INPUT = "Illegal port %s for function %s: Only input ports are allowed";
+	
+
+	// these are semantic warning.
+	private static final String CANNOT_RESOLVED_SIGNAL = "%s cannot be resolved to a signal or parameter";
+	private static final String NOT_ASSIGNED_AND_USED = "The signal %s is not assigned and used";
+	private static final String NOT_USED = "The value of %s is not used";
+	private static final String NOT_USED_TASK = "The task %s is not used";
+	private static final String NOT_USED_FUNCTION = "The function %s is not used";
+	private static final String NOT_ASSIGNED_FUNCTION = "The function value %s is not assigned";
+	private static final String NOT_ASSIGNED = "The signal %s is not assigned";
+	private static final String REG_CONNECT_OUTPUT = "The register %s cannot be connected to output port";
+	private static final String ASSIGN_WIDTH_MISMATCH = "Assignment bit width mismatch: %s";
+	private static final String BIT_RANGE_MISMATCH = "Identifier %s bit range does not fit into %s defined in %s";
+	private static final String PORT_WIDTH_MISMATCH = "Port bit width mismatch: %s";
+	private static final String BAD_BIT_RANGE = "Bad bit \"%s\" for identifier %s";
+	private static final String BOTH_ASSIGNMENT = "Both blocking and non-blocking assignments in a initial or always block";
+	private static final String BLOCKING_ALWAYS = "Blocking assignments in always block";
+	private static final String CANNOT_RESOLVED_MODULE = "The module %s is not found in the project";
+	private static final String MODULE_HAS_NO_PORT = "The module %s does not have port %s.";
+	private static final String MODULE_HAS_NO_PARAMETER = "The module %s does not have parameter %s.";
+	private static final String BAD_PORT_CONNECTION = "The signal cannot connect to output or inout port %s";
+	private static final String UNCONNECTED_PORT = "The port %s in module %s is not connected.";
+	private static final String CIRCULAR_PARS = "Parameter values can not be determined (circular dependence likely for %s).";
+	private static final String UNSUPPORTED_FEATURE = "Feature not supported: %s).";
+	
+	private static final String UNKNOWN_DEPENDENCY = "unknown#unknown";
+
+	private static final int NO_ASSIGN = 0;
+	private static final int NON_BLOCKING = 1;
+	private static final int BLOCKING = 2;
+	
+	private IFile m_File;
+	private ParserReader m_Reader;
+	private IProject m_Project;
+	private static OutlineElementFactory m_OutlineElementFactory = new VerilogOutlineElementFactory();
+	private OutlineContainer m_OutlineContainer;
+	private int m_Context;
+//	private String m_Module=null; //Andrey: current (last) module name
+	private int blockContext;
+	private int blockStatus;
+	private Pattern[] taskTokenPattern;
+	private boolean isPortConnect;
+	private VariableStore variableStore;
+	private InstanceStore instanceStore = new InstanceStore();
+	private List<String> generateBlock = new ArrayList<String>();
+//	private List<VariableStore> variableStoreList = new ArrayList<VariableStore>();
+	private Map<String,VariableStore> variableStoreMap = new ConcurrentHashMap<String,VariableStore>();
+	private Map<String,VariableStore> lastVariableStoreMap = null;
+	private VariableStore lastVariableStore=null; // same module from previous parser pass(es) 
+	private int pass=1;
+	private boolean allDepsResolved=true;
+	private boolean allParsResolved=true;
+	private boolean allExpressionsValid=true;
+	private boolean allPortsValid=true;
+	private boolean noProblems=false; // do not create problem markers
+	public boolean getDepsResolved(){return allDepsResolved;}
+	public boolean getParsResolved(){return allParsResolved;}
+	public boolean getExpressionsValid(){return allExpressionsValid;}
+	public boolean getPortsValid(){return allPortsValid;}
+	
+	// support for partial parsing w/o modifying database, just to propagate  parameters to
+	// I/O ports
+	private String targetModule=null;
+	private boolean portsOnly = false;
+	private boolean skip=       false; // do not process outside of the target module
+	private List<String>passedPars=null; // list of parameters passed - should not be overwritten
+//	public void invalidateExpressions(){allExpressionsValid=false;}
+	
+	public void setNoProblems(boolean noProblems){
+		this.noProblems=noProblems;
+	}
+	private Preferences preferences = new Preferences();
+	
+	// Save/restore variable store map between parser passes (for parameters assignments after use)
+	public Map<String,VariableStore> getVariableStoreMap(){
+		return variableStoreMap;
+	}
+	public void setLastVariableStoreMap( Map<String,VariableStore> storeMap){
+		lastVariableStoreMap=storeMap;
+	}
+	
+	public VerilogParser(ParserReader reader, IProject project, IFile file) {
+		super(reader);
+		m_Context = IParser.OUT_OF_MODULE;
+//		m_Module=null;
+		m_Reader = reader;
+		m_Project = project;
+		m_File = file;
+				
+				
+		m_OutlineContainer = null;
+		blockContext = STATEMENT; // no check of block or assign statement
+		// Correct wrong calculation of start/end columns of tokens and so text tags for problems. JavaCC default assumes 8 characters
+		jj_input_stream.setTabSize(1);
+
+		// if project == null, the context scanning is running
+		// no update outline and error markers 
+
+		if (project != null) {
+			// in outline scanning
+			OutlineDatabase database;
+			database = OutlineDatabase.getProjectsDatabase(project);
+			if (database != null) {
+				m_OutlineContainer = database.getOutlineContainer(file);
+				if (m_OutlineContainer == null) {
+					MessageUI.error("Turn on breakpoints");
+					System.out.println("Failed to get database.getOutlineContainer("+file+")");
+				}
+			}
+			// Just temporary - not processing includes in Content Assist
+			if (reader instanceof VerilogParserReader){
+				HashSet<File> includes=((VerilogParserReader)reader).getIncludeFiles();
+				if (includes!=null) {
+					for (File includedFile : includes){
+						m_OutlineContainer.addIncludedFile(includedFile);
+					}
+				}
+			}
+		} else { // used for ContentAssist - just create a new database for just this file
+			// Not clear - where to add included files
+			
+		}
+//		HashSet<File> includes=reader.
+		taskTokenPattern=new Pattern[taskCommentTokens.length];
+        for(int i=0; i< taskCommentTokens.length;i++){
+            String regex=".*\\b("+taskCommentTokens[i]+")(\\b.*)";
+            taskTokenPattern[i]= Pattern.compile(regex);
+        }
+	}
+	// Not yet used
+	public void setOutlineElement(Symbol sym){
+		if (m_OutlineContainer==null) return ; //in portsOnly mode
+		if (sym!=null){
+			try {
+				sym.setOutlineElement(m_OutlineContainer.GetCurrentElement());
+			} catch (Exception e) {
+				System.out.println("failed setOutlineElement("+sym.getFullName()+")");
+			}
+		}
+	}
+	
+	// called by VerilogParserCore
+	protected void beginOutlineElement(Token begin, String name, String type) {
+		if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR)) {
+			System.out.println("--> beginOutlineElement(,"+name+", "+type+"), mFile="+m_File);
+//		System.out.println("--> m_Reader.getIncludeFile()="+((VerilogParserReader) m_Reader).getIncludeFile());
+//		System.out.println("--> m_Reader.getReaderFile()="+((VerilogParserReader) m_Reader).getReaderFile());
+		}		
+/*		
+		public File getIncludeFile(){
+			return currentIncludeFile;
+		}
+		public File getReaderFile(){
+			if (reader==null) return null;
+			return reader.currentFile;
+		}
+*/
+		
+		if (type.startsWith("module#")) {
+			m_Context = IParser.IN_MODULE;
+//			m_Module=name;
+///	private Map<String,VariableStore> lastVariableStoreMap = null;
+//private VariableStore lastVariableStore=null; // same module from previous parser pass(es)
+			if (portsOnly) {
+				if (name.equals(targetModule)){
+					skip=false;
+				} else {
+					skip = true;
+				}
+			} else {
+				variableStore = new VariableStore();
+				if (lastVariableStoreMap!=null){
+					lastVariableStore=lastVariableStoreMap.get(name);
+				}
+// Check duplicate module				
+				if (preferences.unresolvedModule && pass>1) { // to be sure current definition is already counted
+					OutlineDatabase database = OutlineDatabase.getProjectsDatabase(m_Project);
+					OutlineElement [] elements= database.findTopLevelElements(name,true); // "exactly", not just "starting with"
+					if (elements.length>1){
+						for (OutlineElement other:elements){
+							if (!other.getFile().equals(m_File) || (other.getStartingLine() != begin.beginLine)) {
+								warning(begin.beginLine,
+										begin.beginColumn,
+										begin.endLine,
+										begin.endColumn,
+										DUPLICATE_MODULE,
+										name,
+										other.getFile().getLocation()+" line " + other.getStartingLine());
+							}
+						}
+					}
+					
+				}				
+			}
+		}
+		if (skip) return;
+		String depends=null;
+		if (begin instanceof Identifier){
+			depends=((Identifier) begin).getEncodedDepends();
+		}
+		String[] types = type.split("#");
+		int line = begin.beginLine;
+		if (portsOnly)  {
+			if (!(types[0].equals("parameter") || types[0].equals("localparam") || types[0].equals("port"))){
+				return;
+			}
+			if (types[0].equals("parameter") || types[0].equals("localparam")) {
+				if (passedPars.contains(name)){ // do not overwrite passed parameters
+					return; // do not overwrite preset parameters
+				}
+				String bitRange = (types.length > 2) ? types[2] : "";
+				if (bitRange.equals(""))
+					bitRange="?";// Andrey: setting undefine bit width for parameters
+				VariableStore.Symbol ref;
+				ref = variableStore.addSymbol(name, line,
+						begin.beginColumn,begin.endLine,begin.endColumn,
+						types, bitRange,depends);
+				if (ref != null) {
+					ref.addDepends(depends);
+				}
+			} else if (types[0].equals("port")) {
+				addVariable(name, line, begin.beginColumn,begin.endLine,begin.endColumn, types,depends);
+				if ((depends!=null) && depends.contains(UNKNOWN_DEPENDENCY)){
+					if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR))
+						System.out.println("Invalidating port "+name+", dependency="+depends+", pass="+pass);
+					allPortsValid=false;
+				}
+			}			
+			return;
+		}
+		
+		if (m_OutlineContainer != null) {
+			
+			if (types[0].equals("functionreference")) { // add width if available
+				String functionName=name.split(":")[0];
+				VariableStore.Symbol sym = variableStore.findSymbol(functionName);
+				if (sym == null) {
+					if (lastVariableStore!=null) {
+						sym=lastVariableStore.findSymbol(functionName);
+					}
+				}
+				if (sym!=null) {
+					int [] widthBit=sym.getWidthBit();
+					if (widthBit[0]>1){
+						type+=String.format("#[%d:%d]", widthBit[1]+widthBit[0]-1, widthBit[1]);
+					}
+				}
+			}
+			
+//			String depends=null;
+//			if (begin instanceof Identifier){
+//				depends=((Identifier) begin).getEncodedDepends();
+//			}
+//			int line = begin.beginLine;
+			m_OutlineContainer.beginElement(name, type, line,
+					begin.beginColumn, m_File, m_OutlineElementFactory);
+//			String[] types = type.split("#");
+//			if (portsOnly && !(types[0].equals("parameter") || types[0].equals("localparam") || types[0].equals("port"))){
+//				return;
+//			}
+			if (types[0].equals("parameter") || types[0].equals("localparam") || types[0].equals("defparam")) {
+				String bitRange = (types.length > 2) ? types[2] : "";
+				if (bitRange.equals(""))
+//					bitRange = "[31:0]"; // Andrey: always sets parameter of fixed width?
+					bitRange="?";// Andrey: setting undefine bit width for parameters
+				if (portsOnly && passedPars.contains(name)){ // do not overwrite passed parameters
+					return; // do not overwrite preset parameters
+				}
+				VariableStore.Symbol ref;
+				// only single-level defparams are supported: instance.parameter
+				// defparam - just add to variableStore
+				ref = variableStore.addSymbol(name, line,
+						begin.beginColumn,begin.endLine,begin.endColumn,
+						types, bitRange,depends);
+				if (ref == null) {
+					warning(line, begin.beginColumn, begin.endLine, begin.endColumn, DUPLICATE_PARAM, name);
+				} else {
+					ref.addDepends(depends);
+					// Not yet used
+					setOutlineElement(ref);
+				}
+			} else if (types[0].equals("task")) {
+				addTask(name, line, begin.beginColumn,begin.endLine,begin.endColumn, types);
+			} else if (types[0].equals("function")) {
+				addFunciton(name, line, begin.beginColumn,begin.endLine,begin.endColumn, types);
+			} else if (types[0].equals("instance") || types[0].equals("taskenable") || types[0].equals("functionreference")) {
+				isPortConnect = true;
+				// get module name (should be parent)
+				String moduleName=null;
+				int moduleLine = -1; //invalid
+				OutlineElement element = m_OutlineContainer.GetCurrentElement();
+				while (element!=null){
+					element=element.getParent();
+					if ((element!=null) && (element.getType().split("#")[0].equals("module"))){
+						moduleName=element.getName();
+						moduleLine=element.getStartingLine();
+						break;
+					}
+				}
+				if (moduleName==null){
+					System.out.println("beginOutlineElement(): "+types[0]+" "+name+" parent is not a module");
+				}
+				instanceStore.addInstance(types[1], types[0], line, begin.beginColumn, begin.endLine, begin.endColumn,
+						name, moduleName,moduleLine);
+				if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR))
+					System.out.println("beginOutlineElement(,"+name+",), mFile="+m_File);
+			} else {
+				addVariable(name, line, begin.beginColumn,begin.endLine,begin.endColumn, types,depends);
+				if (types[0].equals("port") && (depends!=null) && depends.contains(UNKNOWN_DEPENDENCY)){
+					allPortsValid=false;
+					if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR))
+						System.out.println("Invalid data for port "+name+", dependency="+depends+", pass="+pass);
+				}
+			}
+		}
+	}
+
+	private void addTask(String name, int line, int beginColumn, int endLine, int endColumn,
+			String[] types) {
+		VariableStore.Symbol ref = variableStore.findSymbol(name);
+		if (ref == null) {
+			ref = variableStore.addSymbol(name, line, beginColumn, endLine, endColumn, types, "", null); // no dependencies on parameters for tasks
+		} else {
+			if (ref.isTask() == false || ref.isDefined()) {
+				warning(line, beginColumn, endLine, endColumn, DUPLICATE_TASK, name);
+				return;
+			}
+		}
+		ref.setDefined();
+		// Not yet used
+		setOutlineElement(ref);
+	}
+
+	private void addFunciton(String name, int line, int beginColumn, int endLine, int endColumn,
+			String[] types) {
+		String bitRange = (types.length > 1) ? types[1] : "";
+		VariableStore.Symbol ref = variableStore.findSymbol(name);
+		if (ref == null) {
+			ref = variableStore.addSymbol(name, line, beginColumn, endLine, endColumn, types, bitRange, null); // no dependencies on parameters for functions
+		} else {
+			if (ref.isFunction() == false || ref.isDefined()) {
+				warning(line, beginColumn, endLine, endColumn, DUPLICATE_FUNCTION, name);
+				return;
+			}
+			ref.setWidth(bitRange);
+		}
+		ref.setDefined();
+		// Not yet used
+		setOutlineElement(ref);
+	}
+//	private void addVariable(String name, int line, String[] types) {
+//		addVariable(name, line, -1,-1,-1, types);
+//	}
+	private void addVariable(String name, int line, int beginColumn, int endLine, int endColumn,
+			String[] types, String depends) {
+		String bitRange = null;
+		int dim = 0;
+		if (types[0].equals("variable")) {
+			if (types[1].contains("genvar")) {
+				bitRange = "[-1:0]"; // unfixed Andrey: What is it?
+			}else if (types[1].contains("integer")) {
+				if (preferences.forceInt32Bit)	bitRange = "[31:0]";
+				else bitRange = "?"; //undefined size for integer
+			}else if (types[1].contains("real") || types[1].contains("time")) {
+				bitRange = "?"; //undefined size for integer
+			}
+			else
+				bitRange = (types.length > 2) ? types[2] : "";
+			dim = (types.length > 3) ? Integer.parseInt(types[3]) : 0;
+		} else if (types[0].equals("port")) {
+			bitRange = (types.length > 3) ? types[3] : "";
+		}
+		if (bitRange != null) { //TODO:  Andrey: change separator for generate block - not to confuse with hierarchical name?
+			String head = "";
+			for(int i = 0; i < generateBlock.size(); i++) {
+				head += generateBlock.get(i) + VariableStore.GENERATE_BLOCK_SEPARATOR;
+			}
+			name = head + name;
+			if (m_OutlineContainer!=null){ // skipping for portsOnly?
+				name=addModuleTaskFunctionSuffix(name);
+			}
+			Symbol sym=variableStore.addSymbol(name, line, beginColumn, endLine, endColumn, types, bitRange, dim, depends);
+			if (sym == null) {
+				// c-style port declaration can add reg or wire modifiers.
+				if (types[0].equals("variable")) {
+					VariableStore.Symbol ref = variableStore.findSymbol(name);
+					if (ref.containsType("cstyle")) {
+						ref.addModifier(types[1]);
+//						ref.					ref.setEncodedDepends(((Identifier) begin).getEncodedDepends());
+
+						return;
+					}
+				}
+				warning(line, beginColumn, endLine, endColumn, DUPLICATE_SIGNAL, name);
+			} else{
+				if (types[1].contains("genvar") && !preferences.unsupported) {
+					sym.setValue(0); // valid value 0
+					sym.setAssignd(line);
+				}
+				// Not yet used
+				setOutlineElement(sym); // m_OutlineContainer==null in portsOnly mode is OK
+			}
+		}
+	}
+
+	protected void endOutlineElement(Token end, String name, String type) {
+		if (type.startsWith("module#")) {
+			m_Context = IParser.OUT_OF_MODULE;
+//			m_Module=null;
+//			variableStoreList.add(variableStore);
+			if (!portsOnly) {
+				variableStoreMap.put(name,variableStore);
+			} else {
+				skip = true;
+			}
+			if (portsOnly) {
+				skip = true;
+			}
+//			if (variableStore !=null) {
+				variableStoreMap.put(name,variableStore);
+//			}
+			
+
+		}
+		if (type.startsWith("instance#") || type.startsWith("taskenable#") || type.startsWith("functionreference#")) {
+			isPortConnect = false;
+		}
+		if (m_OutlineContainer != null) {
+//			if (type.startsWith("instance#")) {
+//				isPortConnect = false;
+//			}
+			m_OutlineContainer.endElement(name, type, end.endLine,
+					end.endColumn, m_File);
+		}
+	}
+	
+	protected void parameterAssignment(String name, Expression value, int line) {
+		if (portsOnly && (skip || passedPars.contains(name))){
+			return;
+		}
+		VariableStore.Symbol sym;
+		sym = variableStore.getVariableSymbol(name, generateBlock);
+		if (sym != null) {
+			if (value.isValidInt())
+				sym.setValue(value.intValue());
+			else
+				sym.setValue(value.toString());
+			sym.setAssignd(line);
+			sym.clearDepends();
+			String depends=value.encodeDepends();
+			if (depends!=null){
+				if (depends.contains(UNKNOWN_DEPENDENCY)) {
+					allParsResolved=false;
+				}
+				sym.addDepends(depends);
+			}
+			// Not yet used
+			setOutlineElement(sym);
+		}
+		
+	}
+	
+	private void updateConnection(OutlineDatabase database, VariableStore.Symbol sym,String topModuleName) {
+		if (portsOnly) return;
+		String conns[] = sym.getConnections();
+		if (conns == null)
+			return;
+		for (String conn : conns) {
+			String[] csplit = conn.split("#");
+			String moduleName = csplit[0];
+			String portName = csplit[1];
+			OutlineElement module; // or task/function
+			boolean isTaskOrFunction=csplit[3].equals(PORT_TYPE.TASK.toString()) || csplit[3].equals(PORT_TYPE.FUNCTION.toString());
+			if (isTaskOrFunction){
+				module=database.findTopLevelElement(topModuleName);
+				module = module.findChild(moduleName);
+			} else {
+				module=database.findTopLevelElement(moduleName);
+			}
+			if (module != null) {
+				OutlineElement port = findPortInModule(module, portName);
+				if (port != null) {
+					String type = port.getType();
+					if (type.startsWith("port#input")) {
+						sym.setUsed();
+					} else if (type.startsWith("port#output") ) {
+						if (sym.isReg() && !isTaskOrFunction) {  // task output may be register
+							int line = Integer.parseInt(csplit[2]);
+							warning(line, REG_CONNECT_OUTPUT, sym.getJustName());
+						}
+						sym.setAssignd( Integer.parseInt(csplit[2]));
+					} else if (type.startsWith("port#inout")) {
+						sym.setUsed();
+						sym.setAssignd( Integer.parseInt(csplit[2]));
+					}
+				}
+			}
+		}
+	}
+	
+	private OutlineElement findPortInModule(OutlineElement module, String name) {
+		OutlineElement port=null;
+		if (Character.isDigit(name.charAt(0))) {
+			int index = Integer.parseInt(name);
+			
+//			port = module.getChild(index); // Andrey: This is probably wrong, as there can be parameters before ports
+			// counting only port elements, skipping all others
+			OutlineElement [] oe=module.getChildren();
+			for (OutlineElement e:oe) {
+				if (e.getType().split("#")[0].equals("port")){
+					if (index==0) {
+						port=e;
+						break;
+					} else {
+//						index++;
+						index--;
+					}
+				}
+			}
+		} else {
+			port = module.findChild(name);
+		}
+		if (port == null)
+			return null;
+		if (port.getType().startsWith("port#")) {
+			return port;
+		} else {
+			return null;
+		}
+	}
+
+	private OutlineElement findParameterInModule(OutlineElement module, String name) {
+		OutlineElement parameter=null;
+		if (Character.isDigit(name.charAt(0))) {
+			int index = Integer.parseInt(name);
+			
+//			port = module.getChild(index); // Andrey: This is probably wrong, as there can be parameters before ports
+			// counting only parameter elements, skipping all others
+			OutlineElement [] oe=module.getChildren();
+			for (OutlineElement e:oe) {
+				if (e.getType().split("#")[0].equals("parameter")){
+					if (index==0) {
+						parameter=e;
+						break;
+					} else {
+//						index++;
+						index--;
+					}
+				}
+			}
+		} else {
+			parameter = module.findChild(name);
+		}
+		if (parameter == null)
+			return null;
+		if (parameter.getType().startsWith("parameter#")) {
+			return parameter;
+		} else {
+			return null;
+		}
+	}
+	
+	
+	public void setParametricPorts(){
+		for(String module : variableStoreMap.keySet()) {
+			VariableStore store=variableStoreMap.get(module);
+			boolean parametric=false;
+			boolean hasParameters = false; // ports may depend on localparam, which depend on parameters, but if there are no parameters at all...
+			for (String symKey : store.getKeys()) {
+				VariableStore.Symbol sym=store.getValue(symKey);
+				if (sym.isPort()){
+					String deps=sym.getEncodedDepends();
+					if ((deps!=null) && (deps.contains("#parameter") || deps.contains("#localparam"))) {
+						parametric = true;
+						if (hasParameters) break;
+					}
+				} else if (sym.isParameter() && !sym.isLocalparam()){
+					hasParameters=true;
+					if (parametric) break; 
+				}
+			}
+			if (!hasParameters){
+				if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR) && parametric) {
+					System.out.println("Module "+module+" has parametric ports, but no parameters (just localparam)");				
+				}
+				parametric=false;
+			}
+			if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR)) {
+				if (parametric){
+					System.out.println("Module "+module+" has parametric ports");				
+				} else {
+					System.out.println("Module "+module+" does not have parametric ports");				
+				}
+			}
+			if (m_OutlineContainer!=null){
+				OutlineElement oe=m_OutlineContainer.findTopLevelElement(module);
+				if ((oe!=null) && (oe instanceof VerilogModuleElement)){
+					((VerilogModuleElement) oe).setParametricPorts(parametric);
+				}
+			}
+		}		
+	}
+	
+	public int getParametersRank(){
+		int maxRank=0;
+		for(String module : variableStoreMap.keySet()) {
+			int rank=getParametersRank(variableStoreMap.get(module));
+			if (rank<0) return rank;
+			else if (rank>maxRank) maxRank=rank; 
+		}
+		return maxRank;
+	}
+	
+	/**
+	 * Find maximal number of time to run parser so all parameters will be defined
+	 * @param store VariableStore for selected module
+	 * @return maximal parameter rank or -1 if some parameters are not resolved (circular dependence)
+	 */
+	private int getParametersRank(VariableStore store){
+		Map<String,List<String>> parMap= new ConcurrentHashMap<String,List<String>>();
+		Map<String,Integer> parRank= new ConcurrentHashMap<String,Integer>();
+		for (String symKey : store.getKeys()) {
+			VariableStore.Symbol sym=store.getValue(symKey);
+			if (sym.isParameter()){
+				String deps=sym.getEncodedDepends();
+				if ((deps!=null) && (deps.length()>0)) {
+					List<String> depList=new ArrayList<String>();
+					String [] adeps=deps.split(":");
+					for (String dep:adeps){
+						String [] nameType=dep.split("#");
+						if (nameType[1].equals("parameter") || nameType[1].equals("localparam")){
+							depList.add(nameType[0]);
+						}
+					}
+					parMap.put(symKey, depList);
+					parRank.put(symKey, new Integer(-1)); // undefined rank
+				} else {
+					parRank.put(symKey, new Integer(0));
+				}
+			}
+		}
+		boolean resolvedNew;
+		do {
+			resolvedNew=false;
+			for (String key:parRank.keySet()) if (parRank.get(key)<0){ // only for undefined parameters
+				int maxRankOther=0;
+				for (String dep:parMap.get(key)) {
+					Integer rank=parRank.get(dep);
+					if (rank!=null){
+						if (rank<0){
+							maxRankOther=-1;
+							break;
+						}
+						if (rank>maxRankOther) maxRankOther=rank;
+					}
+				}
+				if (maxRankOther<0){ // still depends on undefined 
+					continue;
+				}
+//				parRank.replace(key, new Integer(maxRankOther+1));
+				parRank.put(key,new Integer(maxRankOther+1)); // replace
+				resolvedNew=true;
+			}
+			
+		} while (resolvedNew);
+		boolean resolved=true;
+		int maxRank=0;
+		for (Integer rank:parRank.values()){
+			if (rank <0){
+				resolved=false;
+				break;
+			} else if (rank>maxRank) maxRank=rank;
+		}
+		if (resolved) return maxRank;
+		String parList="";
+		for (String name:parRank.keySet()) if (parRank.get(name)<0){
+			if (parList.length()>0) parList+=", ";
+			parList+=name;
+		}
+		for (String name:parRank.keySet()) if (parRank.get(name)<0){
+			VariableStore.Symbol sym=store.getValue(name);
+			warning(sym.getLine(), sym.getBeginColumn(), sym.getEndLine(), sym.getEndColumn(),CIRCULAR_PARS, parList);
+		}
+		return -1;
+	}
+	private void checkModulePortsDefined(VariableStore store, String module) { // run only on pass1, if there will be more passes may change
+//		OutlineDatabase database = OutlineDatabase.getProjectsDatabase(m_Project);
+		boolean portsDefined=true;
+		for (String symKey : store.getKeys()) {
+			VariableStore.Symbol sym=store.getValue(symKey);
+			if (sym.isPort()){
+				String depends= sym.getEncodedDepends();
+				if ((depends!=null) && (depends.contains("#parameter") || depends.contains("#localparam") || depends.contains("#unknown"))){
+					portsDefined=false;
+					break;
+				}
+			}
+		}
+		if (m_OutlineContainer!=null){
+			OutlineElement oe=m_OutlineContainer.findTopLevelElement(module);
+			if ((oe!=null) && (oe instanceof VerilogModuleElement)){
+				((VerilogModuleElement) oe).setParametricPorts(!portsDefined);
+				if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR)) 
+					System.out.println("checkModulePortsDefined(): module "+module+" setParametricPorts"+(!portsDefined)+") - preliminary, pass1");
+			}
+		}
+	}
+
+	private void checkVariables(VariableStore store, String module) {
+		VariableStore lastStore=null;
+		if (lastVariableStoreMap!=null){
+			lastStore=lastVariableStoreMap.get(module);
+		}
+		OutlineDatabase database = OutlineDatabase.getProjectsDatabase(m_Project);
+		if (database==null) {
+			System.out.println("database==null in checkVariables(store,"+module+")");
+			return;
+		}
+		OutlineElement topModule=database.findTopLevelElement(module);
+		boolean moduleIsPrimitive=(topModule!=null) && (topModule.getType().contains("#primitive"));
+
+//		for (VariableStore.Symbol sym : store.collection()) {
+		for (String symKey : store.getKeys()) {
+			VariableStore.Symbol sym=store.getValue(symKey);
+			updateConnection(database, sym, module);
+
+			boolean notUsed =     false;
+			boolean notAssigned = false;
+			boolean notDefined =  false;
+			if (!sym.isUsed() && (lastStore!=null)){
+				// Andrey: See if the last pass's symbol is marked as used (in variableReference())
+///			checkVariables(variableStoreMap.get(module),module);
+				VariableStore.Symbol oldSym=lastStore.getValue(symKey);
+				if ((oldSym!=null) && oldSym.isUsed()) {
+					sym.setUsed();
+				}
+			}
+			// process defParam - convert to parameters of instance
+			if (sym.getTypes0().equals("defparam")){
+				String name = sym.getJustName();
+				String [] segments=name.split("\\.");
+				if (segments.length!=2){
+					if (preferences.unsupported) {
+						warning(sym.getLine(), sym.getBeginColumn(), sym.getEndLine(), sym.getEndColumn(),
+								UNSUPPORTED_FEATURE, "defparam with other than 2 segments - <instance_name.parameter_name>");
+					}
+				} else {
+					if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR)) {
+						System.out.println("Processing defparam "+name);
+					}
+					Expression exp=new Expression(sym.getWidthBit()[0]);
+					if (sym.toString()==null) exp.setValue(sym.getValue()); // int value
+					else exp.setValue(sym.toString()); // string value
+					instanceStore.addDefparam(
+							module,
+							segments[0],
+							segments[1], //String parName,
+							sym.getLine(), //int line,
+							sym.getBeginColumn(), //int startCol,
+							sym.getEndColumn(), //int endCol,
+							exp); //Expression signal);
+				}
+				continue;
+			}
+			if (!(moduleIsPrimitive && preferences.skipPrimitives)) {
+				if (sym.isUsed() == false && sym.containsType("output") == false) {
+					notUsed = true;
+				}
+				if (sym.isAssignd() == false && sym.containsType("input") == false) {
+					notAssigned = true;
+				}
+			}
+			if (sym.isDefined() == false) {
+				notDefined=true; // so far only functions can be defined
+			}
+			if (sym.isFunction() && (notUsed || notAssigned  || notDefined)) {
+				int line = sym.getLine();
+				String name = sym.getJustName();
+				if (notDefined) {
+					warning(line, sym.getBeginColumn(), sym.getEndLine(), sym.getEndColumn(),
+							CANNOT_RESOLVED_FUNCTION, name);
+					//NOT_ASSIGNED_FUNCTION
+				} else {
+					if (notUsed) {
+						if (preferences.noUsed)
+							warning(line, sym.getBeginColumn(), sym.getEndLine(), sym.getEndColumn(),
+									NOT_USED_FUNCTION, name);
+					}
+					if (notAssigned) {
+						warning(line, sym.getBeginColumn(), sym.getEndLine(), sym.getEndColumn(),
+								NOT_ASSIGNED_FUNCTION, name);
+						//NOT_ASSIGNED_FUNCTION
+					}
+				}
+				continue;
+			}
+			if (sym.isTask()) {
+				if (notUsed || notDefined) {
+					int line = sym.getLine();
+					String name = sym.getJustName();
+					if (notUsed) {
+						if (preferences.noUsed)
+							warning(line, sym.getBeginColumn(), sym.getEndLine(), sym.getEndColumn(),
+									NOT_USED_TASK, name);
+					} else {
+						warning(line, sym.getBeginColumn(), sym.getEndLine(), sym.getEndColumn(),
+								CANNOT_RESOLVED_TASK, name);
+					}
+				}
+				continue;
+			}
+			if (notUsed || notAssigned) {
+				int line = sym.getLine();
+				String name = sym.getJustName();
+				 if (preferences.noUsed) {
+					if (notUsed && notAssigned)
+						warning(line, sym.getBeginColumn(), sym.getEndLine(), sym.getEndColumn(),
+								NOT_ASSIGNED_AND_USED, name);
+					else if (notUsed) 
+						warning(line, sym.getBeginColumn(), sym.getEndLine(), sym.getEndColumn(),
+								NOT_USED, name);
+					else
+						warning(line, sym.getBeginColumn(), sym.getEndLine(), sym.getEndColumn(),
+								NOT_ASSIGNED, name);
+				}
+			}
+		}
+	}
+	OutlineElement getModuleElement(InstanceStore.Instance inst){
+		OutlineDatabase database = OutlineDatabase.getProjectsDatabase(m_Project);
+		String moduleName = inst.getModuleName();
+		OutlineElement [] elements= database.findTopLevelElements(moduleName, true); // "exactly", not just "starting with"
+		if ((elements == null) || (elements.length==0)) {
+			System.out.println("checkInstance(): Failed to findTopLevelElement("+moduleName+")");
+			return null;
+		}
+		OutlineElement element = elements[0]; //database.findTopLevelElement(parentModuleName);
+		if (elements.length>1){
+			for (OutlineElement oe:elements){
+				if (oe.getFile().equals(m_File) && (oe.getStartingLine() == inst.getModuleLine())){
+					element=oe;
+					break;
+				}
+			}
+			if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR)) 
+				System.out.println("checkInstance(): Multiple definitions for "+moduleName);
+		}
+		return element;
+	}
+	
+	
+    // Andrey: now checkInstance() also adds instance ports as outline elements to module instance
+	private void checkInstance()  {
+		OutlineDatabase database = OutlineDatabase.getProjectsDatabase(m_Project);
+
+		InstanceStore store = instanceStore;
+		
+		for(InstanceStore.Instance inst : store.collection()) {
+			String moduleName = inst.getName();
+			String instType = inst.getType();
+			String parentModuleName=inst.getModuleName();
+			if (parentModuleName==null){
+				System.out.println("checkInstance(): Failed to get parentModuleName() for "+inst.getInstanceName());
+				continue;
+			}
+			if (instType.equals("taskenable") || instType.equals("functionreference")){
+/*				
+				VariableStore vStore=variableStoreMap.get(parentModuleName); 
+				if (vStore == null) {
+					System.out.println("BUG: can not find VaribleStore for module "+parentModuleName);
+					continue;
+				}
+				Symbol taskSym=vStore.getValue(moduleName); // taskName:line:col
+				if (taskSym==null) {
+					if (preferences.unresolvedModule) {
+						int line = inst.getLine();
+						warning(line, inst.getBeginColumn(), inst.getEndLine(), inst.getEndColumn(),
+								instType.equals("taskenable")?CANNOT_RESOLVED_TASK:CANNOT_RESOLVED_FUNCTION, moduleName);
+					}
+					continue;
+				}
+*/				
+				OutlineElement element=getModuleElement(inst);
+				if (element == null) {
+					System.out.println("BUG: can not find enclosing module definition for module "+moduleName);
+					continue;
+				}
+				OutlineElement definition=element.findChild(moduleName);
+				if (instType.equals("taskenable")) {
+					if ((definition==null) || !(definition instanceof VerilogOutlineElementFactory.VerilogTaskElement)) {
+						if (preferences.unresolvedModule) {
+							int line = inst.getLine();
+							warning(line, inst.getBeginColumn(), inst.getEndLine(), inst.getEndColumn(),CANNOT_RESOLVED_TASK, moduleName);
+						}
+						continue;
+					}
+				} else {
+					if ((definition==null) || !(definition instanceof VerilogOutlineElementFactory.VerilogFunctionElement)) {
+						if (preferences.unresolvedModule) {
+							int line = inst.getLine();
+							warning(line, inst.getBeginColumn(), inst.getEndLine(), inst.getEndColumn(),CANNOT_RESOLVED_FUNCTION, moduleName);
+						}
+						continue;
+					}
+				}
+				if (preferences.moduleConnection) {
+					checkInstancePort(inst, definition,null); // non-parametric instance
+				}
+				
+				// Get DB outline element for this task/function
+				
+				continue;
+			}
+			OutlineElement module = database.findTopLevelElement(moduleName);
+			if (module == null) {
+				if (preferences.unresolvedModule) {
+					int line = inst.getLine();
+					warning(line, inst.getBeginColumn(), inst.getEndLine(), inst.getEndColumn(),
+							CANNOT_RESOLVED_MODULE, moduleName);
+				}
+			} else {
+				boolean parametricInstance = ((VerilogModuleElement) module).getParametricPorts();
+				if (preferences.moduleConnection) {
+					checkInstanceParameter(inst, module); // just checking parameter exists (TODO: add parameter type matching?)
+					if (!parametricInstance) checkInstancePort(inst, module,null); // non-parametric instance
+				}
+				// Andrey - add children to instance elements - ports 
+				OutlineElement element=getModuleElement(inst);
+/*				
+				OutlineElement [] elements= database.findTopLevelElements(parentModuleName, true); // "exactly", not just "starting with"
+				if ((elements == null) || (elements.length==0)) {
+					System.out.println("checkInstance(): Failed to findTopLevelElement("+parentModuleName+")");
+					continue;
+				}
+				OutlineElement element = elements[0]; //database.findTopLevelElement(parentModuleName);
+				if (elements.length>1){
+					for (OutlineElement oe:elements){
+						if (oe.getFile().equals(m_File) && (oe.getStartingLine() == inst.getModuleLine())){
+							element=oe;
+							break;
+						}
+					}
+					if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR)) 
+						System.out.println("checkInstance(): Multiple definitions for "+parentModuleName);
+					
+				}
+				// if there are multiple definitions of the same module - this is a problem
+*/
+				
+				element=element.findChild(inst.getInstanceName());
+				if (element==null){
+					System.out.println("checkInstance(): Failed to findChild("+inst.getInstanceName()+")");
+					continue;
+				}
+				// try to add as instance children (there are none yet?)
+				// Assuming there were no children of instances used for something else
+				// Wrong: need outline element for the instance!!	
+				if (element.HasChildren()){
+					if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR)) {
+						System.out.println("checkInstance(): Instance "+element.getName()+" had children - removing them");
+					}
+				}
+				OutlineElement [] ports= createInstancePortList(inst, module);
+				OutlineElement [] parameters= createInstanceParametersList(inst, module);
+				element.clearChildren();
+				for (int i=0;i<ports.length;i++) element.AddChild(ports[i]);
+				for (int i=0;i<parameters.length;i++) element.AddChild(parameters[i]);
+				if (preferences.moduleConnection && parametricInstance) {
+					if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR)) {
+						System.out.println("Need to check parametric ports for instance "+inst.getName());
+					}
+					if ((parameters!=null) && (parameters.length>0)){
+						VariableStore passedParametersStore=new VariableStore();
+						for (OutlineElement oe:parameters){
+//							VerilogParameterElement vpe=(VerilogParameterElement) oe;
+							String [] types=oe.getType().split("#");
+							String bitRange = (types.length > 2) ? types[2] : "";
+							if (bitRange.equals(""))
+								bitRange="?";// Andrey: setting undefine bit width for parameters
+							Symbol ref = passedParametersStore.addSymbol(
+									oe.getShortName(),
+									oe.getStartingLine(),
+									oe.getStartingCol(),
+									oe.getEndingLine(),
+									oe.getEndingCol(),
+									types,
+									bitRange,
+									null); //depends);
+							
+							if (ref==null){
+								System.out.println ("BUG: checkInstance(): failed to add parameter to the VariableStore");
+							} else if (types.length>3){
+								ref.setAssignd(oe.getStartingLine()); // ****************** TODO: What is it here ??  
+								ref.setValue(null);
+								try {
+									ref.setValue(Integer.parseInt(types[3]));
+								} catch (NumberFormatException e){
+									ref.setValue(types[3]);
+								}
+							}
+						}
+						VariableStore parametricPorts= getInstanceParametricPorts(
+								module.getFile(), //IFile file,
+								moduleName,
+								passedParametersStore);
+						checkInstancePort(inst, module,parametricPorts);
+					} else {
+						if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR)) {
+							System.out.println ("instance "+inst.getName()+" does not have any parameters passed");
+						}
+						checkInstancePort(inst, module,null); // still check without parameters?
+					}
+
+				}				
+				
+				
+			}
+		}
+	}
+// Andrey
+	String replacePortWidth(String moduleType, String bitRange){
+		String [] types = moduleType.split("#");
+		if (types.length<4){
+			String [] types1=new String[4];
+			for (int i=0;i<4;i++){
+				if (i<types.length) types1[i]=types[i];
+				else types1[i]="";
+			}
+			types=types1;
+		}
+		types[3]=bitRange;
+		return String.format("%s#%s#%s#%s", types[0], types[1], types[2], types[3]);
+	}
+	
+	/**
+	 * Generate array of outline elements for instance ports, matching the positional arguments
+	 * in the module definition. Missing ports are refer to instance line. Used to reference from the tools output
+	 * @param inst recently parsed instance element that contains line (but no columns)
+	 * @param module definition of the instance module
+	 * @return array of the outline elements to be used as children of the instance (if that works,
+	 *  or separate array in the database)
+	 */
+	private OutlineElement [] createInstancePortList(InstanceStore.Instance inst, OutlineElement module){
+		OutlineElement[] children = module.getChildren();
+//		int numPorts=0;
+//		for (numPorts=0;(numPorts<children.length) && (children[numPorts].getType().startsWith("port#")); numPorts++);
+		List<OutlineElement> portList= new ArrayList<OutlineElement>();
+		for (int i=0;i<children.length; i++){
+			 if (children[i].getType().startsWith("port#")) portList.add(children[i]); 
+		}
+		OutlineElement[] ports= new OutlineElement[portList.size()];
+		for (int i=0; i<ports.length;i++) ports[i]=null;
+		for (InstanceStore.Port iPort : inst.getPorts()) {
+			String name = iPort.getName();
+			int line = iPort.getLine();
+			Expression exp= iPort.getSignal();
+			String bitRange="";
+			if ((exp !=null) && exp.isFixedWidth() && (exp.getWidth()>1)){
+				bitRange=String.format("[%d:0]", exp.getWidth()-1);
+			}
+
+// Find index
+			int index;
+			if (Character.isDigit(name.charAt(0))) {
+				index = Integer.parseInt(name);
+			} else {
+				for (index=0; index < ports.length;index ++){
+					if (portList.get(index).getName().equals(name)) break;
+				}
+				if (index >= ports.length) {
+					continue; // no matching port
+				}
+			}
+//			ports[index]= new OutlineElement(
+			String type=replacePortWidth(portList.get(index).getType(), bitRange);
+			ports[index]=m_OutlineElementFactory.CreateElement(
+					name, // String name,
+					type, //String type,
+					line, //int startLine,
+					iPort.getStartCol(),    //int startCol,
+					line, //int endLine,
+					iPort.getEndCol(),    // int endCol,
+					m_File);  //IFile file,
+//					true) ; // false) ; //boolean bVisible)
+//			ports[index].AddChild(portList.get(index)); // in the module definition - may be used?
+			ports[index].makeAChild(portList.get(index)); // Do not change parent of the module def port
+		}
+		for (int i=0; i<ports.length;i++) if (ports[i]==null){
+///new OutlineElement(
+//			VerilogOutlineElementFactory.VerilogPortElement
+			ports[i]=m_OutlineElementFactory.CreateElement(
+					portList.get(i).getName(), // String name,
+					portList.get(i).getType(), //String type,
+					module.getStartingLine(), //int startLine,
+					0,    //int startCol,
+					module.getStartingLine(), //int endLine,
+					0,    // int endCol,
+					m_File); //, //IFile file,
+//					false) ; //boolean bVisible)
+			ports[i].setVisible(false);
+		}
+		return ports;
+	}
+	
+	String replaceParameterType(String moduleType, String value){
+		String [] types = moduleType.split("#");
+		if (types.length<4){
+			String [] types1=new String[4];
+			for (int i=0;i<4;i++){
+				if (i<types.length) types1[i]=types[i];
+				else types1[i]="";
+			}
+			types=types1;
+		}
+		types[3]=value;
+		return String.format("%s#%s#%s#%s", types[0], types[1], types[2], types[3]);
+	}
+
+	private OutlineElement [] createInstanceParametersList(InstanceStore.Instance inst, OutlineElement module){
+		OutlineElement[] children = module.getChildren();
+		List<OutlineElement> parameterList= new ArrayList<OutlineElement>();
+		for (int i=0;i<children.length; i++){
+			 if (children[i].getType().startsWith("parameter#")) parameterList.add(children[i]); // no localparam here 
+		}
+		OutlineElement[] parameters= new OutlineElement[parameterList.size()]; // parameters copied from module definition
+		for (int i=0; i<parameters.length;i++) parameters[i]=null;
+		for (InstanceStore.Parameter iParam : inst.getParameters()) { // iParam - instance parameters with values to pass
+			String name = iParam.getName();
+			int line = iParam.getLine();
+			Expression exp= iParam.getSignal();
+			String value=(exp != null)?exp.stringValue():"";
+			if (value==null) value=""+exp.intValue();
+// Find index
+			int index;
+			if (Character.isDigit(name.charAt(0))) {
+				index = Integer.parseInt(name);
+			} else {
+				for (index=0; index < parameters.length;index ++){
+					if (parameterList.get(index).getName().equals(name)) break;
+				}
+				if (index >= parameters.length) {
+					continue; // no matching port
+				}
+			}
+			String type=replaceParameterType(parameterList.get(index).getType(), value);
+			parameters[index]=m_OutlineElementFactory.CreateElement(
+					parameterList.get(index).getName(), //name, // String name,
+					type, //String type,
+					line, //int startLine,
+					iParam.getStartCol(),    //int startCol,
+					line, //int endLine,
+					iParam.getEndCol(),    // int endCol,
+					m_File);  //IFile file,
+//					true) ; // false) ; //boolean bVisible)
+//			ports[index].AddChild(portList.get(index)); // in the module definition - may be used?
+			parameters[index].makeAChild(parameterList.get(index)); // Do not change parent of the module def port
+		}
+		// Is that needed? copied values from the module definition (probably just for positional ones)
+		for (int i=0; i<parameters.length;i++) if (parameters[i]==null){
+///new OutlineElement(
+//			VerilogOutlineElementFactory.VerilogPortElement
+			parameters[i]=m_OutlineElementFactory.CreateElement(
+					parameterList.get(i).getName(), // String name,
+					parameterList.get(i).getType(), //String type,
+					module.getStartingLine(), //int startLine,
+					0,    //int startCol,
+					module.getStartingLine(), //int endLine,
+					0,    // int endCol,
+					m_File); //, //IFile file,
+//					false) ; //boolean bVisible)
+			parameters[i].setVisible(false);
+		}
+		return parameters;
+	}
+	private String getGenvarName(String depend){
+		if ((depend==null) || !depend.contains("#genvar")) return null;
+		String genvarName=depend.split("#genvar")[0];
+		if (genvarName.contains(":")) genvarName=genvarName.substring(genvarName.indexOf(":")+1);
+		return genvarName;
+
+	}
+	
+	
+	private void checkInstancePort(InstanceStore.Instance inst, OutlineElement module, VariableStore store) {
+		String moduleName = inst.getName();
+		// scan all ports in instance.
+		for (InstanceStore.Port port : inst.getPorts()) {
+			String name = port.getName();
+			int line = port.getLine();
+			OutlineElement eport = findPortInModule(module, name);
+			if (eport == null) {
+				warning(line, port.getStartCol(), line, port.getEndCol(), MODULE_HAS_NO_PORT, moduleName, name);
+			} else {
+				String type = eport.getType();
+				int [] widthBit=((VerilogOutlineElement) eport).getWidthBit();
+				if (store !=null){ // use port widths from the provided store - it has widths dependent on passed parameters
+					
+					Symbol sym=store.findPort(name);
+					if (sym!=null){
+						widthBit=sym.getWidthBit();
+					} else {
+						System.out.println ("BUG: checkInstancePort() can not find the individual port "+
+								name+" of module "+module.getName()+" instance "+inst.getName()+
+								" pass="+pass+" portsOnly="+portsOnly);
+					}
+				}
+				int portWidth=widthBit[0];
+				if (portWidth==0) portWidth=1; // TODO: What if integer port?
+				Expression signal = port.getSignal();
+				if (signal!=null) {
+					int sigWidth=signal.getWidth();
+					String genvarName=getGenvarName(signal.encodeDepends());
+					if (!signal.isFixedWidth() && (genvarName!=null)){
+						if (preferences.unsupported) {
+							String message = "signal width for port \""+eport.getShortName()+"\" may depend on genvar "+genvarName; 
+							warning(signal.beginLine, signal.beginColumn, signal.endLine, signal.endColumn, UNSUPPORTED_FEATURE, message);
+						}
+					} else {
+						if ((sigWidth!=portWidth) && (signal.isFixedWidth() || preferences.intConst)){
+							if (preferences.contextWidth || !signal.isContextDetermined()|| (portWidth<sigWidth)) {
+								String message = "port \""+eport.getShortName()+"\" expects width=" + portWidth + ", connected signal width=" + sigWidth;
+								warning(signal.beginLine, signal.beginColumn, signal.endLine, signal.endColumn, PORT_WIDTH_MISMATCH, message);
+							}
+						}
+					}
+				}
+				if (type.startsWith("port#input") == false) {
+					if (signal != null && signal.isAssignable() == false) {
+						warning(line, port.getStartCol(), line, port.getEndCol(), BAD_PORT_CONNECTION, name);
+					}
+					if (module instanceof VerilogOutlineElementFactory.VerilogFunctionElement){
+						warning(eport.getStartingLine(),
+								eport.getStartingCol(),
+								eport.getEndingLine(),
+								eport.getEndingCol(),
+								FUNCTION_NOT_INPUT, name,module.getName());
+					}
+				}
+			}
+		}
+
+		if (inst.isNamedMap() == false)
+			return;
+
+		// scan all port in module definition.
+		for (OutlineElement child : module.getChildren()) {
+			String type = child.getType();
+			if (type.startsWith("port#")) {
+				String portName = child.getName();
+				if (inst.findPort(portName) == null) {
+					int line = inst.getLine();
+					warning(line, inst.getBeginColumn(), inst.getEndLine(), inst.getEndColumn(), UNCONNECTED_PORT, portName, moduleName);
+				}
+			}
+		}
+	}
+	
+	private void checkInstanceParameter(InstanceStore.Instance inst, OutlineElement module) {
+		String moduleName = inst.getName();
+
+		// scan all ports in instance.
+		for (InstanceStore.Parameter parameter : inst.getParameters()) {
+			String name = parameter.getName();
+			int line = parameter.getLine();
+			OutlineElement eparameter = findParameterInModule(module, name);
+			if (eparameter == null) {
+				warning(line, parameter.getStartCol(), line, parameter.getEndCol(), MODULE_HAS_NO_PARAMETER, moduleName, name);
+			} else {
+				//TODO: Check parameter type here?
+			}
+		}
+	}
+
+	
+	
+	
+	protected void addCollapsible(int startLine, int endLine) {
+		if (m_OutlineContainer != null) {
+			Collapsible c = m_OutlineContainer.new Collapsible(startLine,
+					endLine);
+			m_OutlineContainer.addCollapsibleRegion(c);
+		}
+	}
+
+	protected void begin(int mode) {
+		m_Context = IParser.IN_STATEMENT;
+		blockContext = mode;
+		blockStatus = NO_ASSIGN;
+		instanceStore.newStatement(); // to accumulate instance parameters
+	}
+
+	protected void end(int mode) {
+		m_Context = IParser.IN_MODULE;
+		blockContext = STATEMENT; // no check of block or assign statement
+	}
+	
+	protected Expression operator(Expression arg, Token op) {
+		Operator ope = new Operator(op.image);
+		Expression ret = ope.operate(arg, preferences);
+		if (ope.isWarning())
+			warning(op.beginLine,op.beginColumn,op.endLine,op.endColumn, ope.getWarning());
+		ret.addReference(arg);
+		ret.addAllDepends(arg);
+		return ret;
+	}
+
+	protected Expression operator(Expression arg1, Token op, Expression arg2) {
+		Operator ope = new Operator(op.image);
+		Expression ret = ope.operate(arg1, arg2, preferences);
+		if (ope.isWarning())
+			warning(op.beginLine, op.beginColumn,op.endLine,op.endColumn, ope.getWarning());
+		ret.addReference(arg1);
+		ret.addReference(arg2);
+		ret.addAllDepends(arg1);
+		ret.addAllDepends(arg2);
+		return ret;
+	}
+
+	protected Expression operator(Expression arg1, Token op, Expression arg2,
+			Expression arg3) {
+		Operator ope = new Operator(op.image);
+		Expression ret = ope.operate(arg1, arg2, arg3, preferences);
+		if (ope.isWarning())
+			warning(op.beginLine, op.beginColumn,op.endLine,op.endColumn, ope.getWarning());
+//		ret.addReference(arg1); // these lines cause concurrent exception during initial scanning
+//		ret.addReference(arg2);
+//		ret.addReference(arg3);
+		ret.addAllDepends(arg1);
+		ret.addAllDepends(arg2);
+		ret.addAllDepends(arg3);
+		return ret;
+	}
+	protected void badBitRange(Identifier ident,String badRange) {
+//		System.out.println ("Bad bit range "+badRange+" for "+ident.image+" pass="+pass);
+//		if ((badRange!=null) && (pass>1) && preferences.bitRange) {
+		if ((badRange!=null)  && preferences.bitRange) {
+			warning(ident.beginLine,ident.beginColumn,ident.endLine,ident.endColumn, BAD_BIT_RANGE,badRange, ident.image);
+		}
+	}
+	protected Expression variableReference(Identifier ident) {
+		String name = ident.image;
+		if (m_OutlineContainer != null) {
+			// If processing task - add task name to the variable, so it will look first for local variables
+			name=addModuleTaskFunctionSuffix(name);
+		}
+		if (name.contains(".")) {
+			if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR)) {
+//				System.out.println("VEditor can not process hierarchical names in expressions yet, name="+name);
+			}
+			//				return new Expression();
+		}
+
+		int line = ident.beginLine;
+		VariableStore.Symbol sym;
+		if (isPortConnect) {
+			// I cannot decide whether the variable is referred or assigned.
+			// But we should be able to at least mark used parameters encoded in ident.paramDepends
+			sym = variableStore.getVariableSymbol(name, generateBlock);
+			if ((sym==null) && (lastVariableStore!=null)) {
+				sym = lastVariableStore.getVariableSymbol(name, generateBlock);
+			}
+			if ((sym!=null) && sym.isParameter()){ 
+				variableStore.addUsedVariable(name, generateBlock);
+			}
+		} else {
+			// TODO: if the variableStore.addUsedVariable(name, generateBlock) has the symbol, but with undefined value
+			// We need to copy defined value from the old (previous pasrser pass) store 				
+			sym = variableStore.addUsedVariable(name, generateBlock);
+			if (lastVariableStore!=null) {
+				if (sym!=null){
+					if (!sym.isAssignd()){
+						VariableStore.Symbol oldSym=lastVariableStore.addUsedVariable(name, generateBlock);
+						if ((oldSym!=null) && oldSym.isAssignd()){
+							// Copy relevant data from the old symbol to the new one. Or just use the old one?
+							// First try to just use old one (will need to combine both in the end). Or just copy back?
+							// No - combine, new may have assign (later) valid value, while the old did not have it.
+							// Just need to copy "Used" from the old one in the end
+							sym=oldSym;
+						}
+					}
+
+				} else {
+					sym = lastVariableStore.addUsedVariable(name, generateBlock); // will mark as "used" in the old store only
+				}
+			}
+		}
+		boolean databaseValid=true;
+		if ((sym == null) && !portsOnly) {
+			OutlineElement element=null;
+			if (name.contains(".")){
+				databaseValid=false;
+				OutlineDatabase database = OutlineDatabase.getProjectsDatabase(m_Project);
+				if ((m_OutlineContainer!=null) && (database!=null) && (database.getScanState()==OutlineDatabase.ScanState.DONE)) {
+					databaseValid=true;
+					if (m_OutlineContainer.GetCurrentElement()!=null) {
+						element=m_OutlineContainer.GetCurrentElement().findHierarchicalChild(name, database);
+					}
+					if (element!=null){
+						String type=element.getType().split("#")[0];
+						if (!type.equals("variable") && !type.equals("port")){
+							System.out.println("Destination is not variable or port: "+element.getType());
+							element=null;
+						}
+					}
+					if (element!=null){
+						if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR))
+							System.out.println("Resolved hierarchical symbol in expression: "+name);
+
+						if (element instanceof VerilogOutlineElementFactory.VerilogOutlineElement){
+							VerilogOutlineElementFactory.VerilogOutlineElement ve=
+									(VerilogOutlineElementFactory.VerilogOutlineElement) element;
+
+							//								int width = ident.getWidth();
+							int [] wb=ident.getWidthBit();
+							if (wb[0] == 0) {
+								wb = ve.getWidthBit(); // doesn't have bit range
+								ident.setWidth(wb[0],wb[1]);
+							} else if (wb[0] == 1) {
+								if (ident.getDimension() <= ve.getDimension()){
+									//										width = ve.getWidth();
+									wb = ve.getWidthBit();
+									ident.setWidth(wb[0],wb[1]);
+								}
+							}
+							if (preferences.bitRange){
+								checkBitRangeFit(ident,ve);
+							}
+							if (ve.isParameter()) {
+								if (ve.isValidInt())
+									return new Expression(wb[0], Integer.parseInt(ve.GetValue()), ident);
+								else
+									return new Expression(wb[0], ve.GetValue(), ident);
+							} else {
+								Expression exp = new Expression(wb[0], ident);
+								return exp;
+							}
+						} else {
+							System.out.println("Element is not an instance of VerilogOutlineElement - "+element.getName());
+						}
+					}
+				}
+			}
+			if (((element == null) && databaseValid) && preferences.unresolved && (pass>1))
+				warning(line,ident.beginColumn,ident.endLine,ident.endColumn, CANNOT_RESOLVED_SIGNAL, name);//   got here from $dumpwars referencing top module name
+		} else if (sym!=null) {
+			
+			//				int width = ident.getWidth();
+			int [] wb=ident.getWidthBit();
+			//				if (width == 0) {
+			if (wb[0] == 0) {
+				//					width = sym.getWidth(); // doesn't have bit range
+				wb=sym.getWidthBit();
+				//				} else if (width == 1) {
+			} else if (wb[0] == 1) {
+				if (ident.getDimension() <= sym.getDimemsion())
+					//						width = sym.getWidth();
+					wb=sym.getWidthBit();
+			}
+			if (preferences.bitRange){
+				checkBitRangeFit(ident,sym);
+			}
+			if (sym.isParameter()) {
+				Expression exp;
+				if (sym.isValidInt())
+					exp= new Expression(wb[0], sym.getValue(), ident);
+				else
+					exp=new Expression(wb[0], sym.toString(), ident);
+				exp.addDepend(sym.getJustName()+"#"+sym.getTypes0());
+				String depends=sym.getEncodedDepends();
+				if ((depends!=null) && depends.contains(UNKNOWN_DEPENDENCY)){
+					exp.addDepend(UNKNOWN_DEPENDENCY);
+					allExpressionsValid=false;
+				}
+				return exp;
+			} else if (sym.isGenvar()) {
+				Expression exp = new Expression(wb[0], ident);
+				exp.addDepend(sym.getJustName()+"#genvar"); // sym.getTypes1()==genvar
+				exp.setValue(0); // for bit select calculation
+				return exp;
+			} else {
+				Expression exp = new Expression(wb[0], ident);
+				exp.addDepend(ident.getEncodedDepends()); // Not sym.getEncodedDepends(), ident includes bit select depend
+				return exp;
+			}
+		}
+		Expression exp=new Expression();
+		exp.extendPosition(ident);
+		allDepsResolved=false;
+		exp.addDepend(UNKNOWN_DEPENDENCY); // depends on something unknown
+
+		// need to add dependence on non-existent in db symbol
+		// only in second pass we'll know what that symbol was
+		return exp;
+	}
+
+	protected void taskReference(Identifier ident) {
+		if (m_OutlineContainer != null) {
+			String name = ident.image;
+			if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR)) {
+				System.out.println("taskReference("+name+")");
+				if (name.startsWith("test_axi")){
+					System.out.println("**** taskReference("+name+")");				
+				}
+			}
+			if (name.contains(".")) {
+				if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR)) {
+					System.out.println("Hierarchical task references are not supported by VEditor yet");
+				}
+				return;
+			}
+			int line = ident.beginLine;
+			VariableStore.Symbol sym = variableStore.findSymbol(name);
+			if (sym == null) {
+				String[] types = {"task"};
+				sym = variableStore.addSymbol(name, line, ident.beginColumn,ident.endLine,ident.endColumn, types, "", ident.getEncodedDepends());
+			}
+			sym.setUsed();
+		}
+	}
+	
+	protected void setIdentifierUsed(Identifier ident){ // Andrey - parameters used in delays
+		if (m_OutlineContainer != null) {
+			VariableStore.Symbol sym = variableStore.findSymbol(ident.image);
+			if (sym != null) {
+				sym.setUsed();
+			}
+		}
+	}
+
+	protected Expression functionReference(Identifier ident) {
+		if (m_OutlineContainer != null) {
+			String name = ident.image;
+			if (name.contains(".")) {
+				if (preferences.unsupported) {
+					warning(ident.beginLine, ident.beginColumn, ident.endLine, ident.endColumn,
+							UNSUPPORTED_FEATURE, "hierarchical function names :"+name);
+				}
+				Expression exp=new Expression();
+				exp.extendPosition(ident);
+				return exp;
+			}
+			int line = ident.beginLine;
+			VariableStore.Symbol sym = variableStore.findSymbol(name);
+			if (sym == null) {
+				if (lastVariableStore!=null) {
+					sym=lastVariableStore.findSymbol(name);
+				}
+			}
+			if (sym == null) {
+				String[] types = {"function", ""};
+				sym = variableStore.addSymbol(name, line, ident.beginColumn,ident.endLine,ident.endColumn, types, "", ident.getEncodedDepends());
+				if (sym!=null){
+					sym.setUsed();
+				}
+			} else {
+				int [] wb = ident.getWidthBit();
+				if (wb[0] == 0)
+					wb = sym.getWidthBit(); // doesn't have bit range
+				Expression exp = new Expression(wb[0]);
+				exp.addReference(ident);
+				exp.extendPosition(ident);
+				return exp;
+			}
+		}
+		//		return new Expression();
+		Expression exp=new Expression();
+		exp.extendPosition(ident);
+		return exp;
+
+	}
+
+	protected void variableAssignment(Identifier ident) {
+		String name = ident.image;
+/*
+ // Not (yet) used		
+		boolean genvarDependentWidth=false;
+		boolean genvarDependent=false;
+		String depends=ident.getEncodedDepends();
+		if ((depends!=null) && depends.contains("#genvar")){
+			if (ident.getWidth()==0) genvarDependentWidth=true;
+			genvarDependent=true;
+		}
+*/		
+		if (m_OutlineContainer != null) {
+			// When processing tasks, use local first
+//			OutlineElement el = m_OutlineContainer.GetCurrentElement();
+			name=addModuleTaskFunctionSuffix(name);
+		}
+		int line = ident.beginLine;
+		VariableStore.Symbol sym = variableStore.addAssignedVariable(name, generateBlock, line);
+		if (sym == null) {
+			VariableStore.Symbol symAny= variableStore.getVariableSymbol(name, generateBlock);
+			if (symAny!=null) {
+				warning(line, ident.beginColumn,ident.endLine,ident.endColumn, ASSIGN_ILLEGAL,
+						symAny.getJustName(),symAny.getTypes()[0]);
+			}
+		}
+		boolean databaseValid=true;
+		if ((sym == null) || ((sym.isVariable() == false) && (sym.isParameter() == false)  && (sym.isFunction() == false))) {
+			OutlineElement element=null;
+			if ((m_OutlineContainer!=null) && (sym==null) && (name.contains("."))){
+				databaseValid=false;
+				OutlineDatabase database = OutlineDatabase.getProjectsDatabase(m_Project);
+				if ((database!=null) && (database.getScanState()==OutlineDatabase.ScanState.DONE)) {
+					databaseValid=true;
+					if (m_OutlineContainer.GetCurrentElement()!=null) {
+						element=m_OutlineContainer.GetCurrentElement().findHierarchicalChild(name, database);
+					}
+					if (element!=null){
+						String type=element.getType().split("#")[0];
+						if (!type.equals("variable") && !type.equals("port")){
+							System.out.println("Destination is not variable or port: "+element.getType());
+							element=null;
+						}
+					}
+					if (element!=null){
+						if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR))
+							System.out.println("Resolved hierarchical symbol "+name);
+						if (element instanceof VerilogOutlineElementFactory.VerilogOutlineElement){
+							VerilogOutlineElementFactory.VerilogOutlineElement ve=
+									(VerilogOutlineElementFactory.VerilogOutlineElement) element;
+							// add symbols (so it will be checked for range later) and mark as used
+							//								int [] wb=ve.getWidthBit();
+							int [] wb=ident.getWidthBit();
+							int dimension=ident.getDimension();
+							if (wb[0] == 0) {
+								wb = ve.getWidthBit(); // doesn't have bit range
+								dimension=ve.getDimension();
+								ident.setWidth(wb[0],wb[1]);
+								ident.setDimension(dimension);
+							} else if (wb[0] == 1) {
+								if (ident.getDimension() <= ve.getDimension()) {
+									//										width = ve.getWidth();
+									wb = ve.getWidthBit();
+									ident.setWidth(wb[0],wb[1]);
+								}
+							}
+
+							String bitRange="[31:0]";
+							if (wb[0]==1) bitRange=String.format("[%d]", wb[1]);
+							else if (wb[0]>1) bitRange=String.format("[%d:%d]", wb[1]+wb[0]-1,wb[1]);
+							// TODO:  Here is the problem: different bit fields for the same hierarchical name may be assigned - 
+							// make it not to cause problems
+							sym=variableStore.addSymbol(name, line, ident.beginColumn,ident.endLine,ident.endColumn,
+									ve.getType().split("#"), bitRange, dimension, null); // no dependencies for hierarchical names
+							if (preferences.bitRange){
+								checkBitRangeFit(ident,ve);
+							}
+							if (sym == null) {
+								if (preferences.unsupported){
+									String message="multiple references/assignments of the same hierarchical name "+ident.image+
+											" are not supported in the editor. It is possible to use a local variable and connect it to "+
+											"the hierarchical in one place.";
+									warning(line, ident.beginColumn,ident.endLine,ident.endColumn, UNSUPPORTED_FEATURE, message);
+								}
+							} else {
+								sym.setUsed(); // Mark as used to avoid "unused" warning - it is not local
+								// Not yet used
+								setOutlineElement(sym); // TODO: Should it be marked for hierarchical names?
+								sym=variableStore.addAssignedVariable(name, generateBlock, line);
+								if (sym==null) {
+									System.out.println("BUG in variableAssignment("+name+") failed to addAssignedVariable()");
+								}
+							}
+							//								if (blockContext == ASSIGN_STMT && ve.isRegister()) {
+							if (blockContext == ASSIGN_STMT && ve.isSequential()) {
+								warning(line, ident.beginColumn,ident.endLine,ident.endColumn, ASSIGN_REG, ident.image);
+							} else if ((blockContext == INITIAL_BLOCK || blockContext == ALWAYS_BLOCK)
+									//										&& ve.isRegister() == false) {
+									&& ve.isSequential() == false) {
+								warning(line, ident.beginColumn,ident.endLine,ident.endColumn, ASSIGN_WIRE, ident.image);
+							}
+						} else {
+							System.out.println("Element is not an instance of VerilogOutlineElement - "+element.getName());
+						}
+					}
+				}
+			}
+			// Currently no additional processing of hierarch. names. TODO: Add them to variableStore and check?
+			if (((element == null) && databaseValid) && preferences.unresolved && (pass>1)) 
+				warning(line, ident.beginColumn,ident.endLine,ident.endColumn, CANNOT_RESOLVED_SIGNAL, name);
+		} else {
+			if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR))
+				System.out.println("assigned symbol "+name+ " ("+sym.getTypes0()+")");
+			//				int width = ident.getWidth();
+			int [] wb = ident.getWidthBit();
+			//				if (width <= 1 && sym.getDimemsion() >= ident.getDimension())
+			if (wb[0] <= 1 && sym.getDimemsion() >= ident.getDimension()) {
+				//					ident.setWidth(sym.getWidth());
+				wb = sym.getWidthBit();
+				//					ident.setWidth(sym.getWidth());
+				ident.setWidth(wb[0],wb[1]);
+			} // sym.getWidth(
+			if (preferences.bitRange){
+				checkBitRangeFit(ident,sym);
+			}
+			if (blockContext == ASSIGN_STMT && sym.isReg()) {
+				warning(line, ident.beginColumn, ident.endLine, ident.endColumn, ASSIGN_REG, name);
+			} else if ((blockContext == INITIAL_BLOCK || blockContext == ALWAYS_BLOCK)
+					&& sym.isReg() == false) {
+				warning(line, ident.beginColumn, ident.endLine, ident.endColumn, ASSIGN_WIRE, name);
+			}
+			//				if (sym.isPort()){
+			//					System.out.println("Assigning port variable");
+			//				}
+		}
+	}
+
+	/**
+	 * Evaluate positional port connection.
+	 */
+//	protected void variableConnection(Expression arg, String module, int portIndex) {
+	protected void positionalPortConnection(Expression arg, String module, int portIndex, PORT_TYPE port_type) {
+		if (m_OutlineContainer == null) return; //in portsOnly pass m_OutlineContainer is null, no need to process instances
+
+		if (port_type==PORT_TYPE.TASK){
+			if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR))
+				System.out.println("Adding task enable port, module="+module+" index="+portIndex);
+		}
+		if (arg == null)
+			return;
+		String name = Integer.toString(portIndex);
+		Identifier[] idents = arg.getReferences();
+//		instanceStore.addPort(name, arg.beginLine, arg.beginColumn, arg.endColumn, arg);
+		instanceStore.addPort(name, arg.beginLine, arg.beginColumn, arg.endColumn, arg, m_File);
+		if ((idents != null) && (arg.beginLine<0)) {
+			arg.extendPosition(idents[0]); // is it needed
+		}
+		portConnection(arg, module, name, arg.beginLine,port_type);
+	}
+
+	/**
+	 * Evaluate named port connection.
+	 */
+//	protected void variableConnection(Expression arg, String module, Identifier port) {
+	protected void namedPortConnection(Expression arg, String module, Identifier port, PORT_TYPE port_type) {
+		if (m_OutlineContainer == null)
+			return;
+
+		int line = port.beginLine;
+		String portName = port.image;
+//		instanceStore.addPort(portName, line, port.beginColumn, port.endColumn, arg);
+		instanceStore.addPort(portName, line, port.beginColumn, port.endColumn, arg, m_File);
+		if (arg != null) {
+			if (arg.beginLine<0) arg.extendPosition(port);
+			portConnection(arg, module, portName, line, port_type);
+		}
+	}
+/*	
+	private OutlineElement getModuleTaskFunction(){
+		OutlineElement el = m_OutlineContainer.GetCurrentElement(); // taskenable/instance
+		while (el!=null){
+			String type = el.getType().split("#")[0];
+			if (type.equals("module") || type.equals("task") || type.equals("function")) {
+				return el;
+			} else {
+				el=el.getParent();
+			}
+		}
+		return null;
+	}
+*/
+	private String addModuleTaskFunctionSuffix(String name){
+		OutlineElement el = m_OutlineContainer.GetCurrentElement(); // taskenable/instance
+		while (el!=null){
+			String type = el.getType().split("#")[0];
+				if (type.equals("module")) {
+					return name;
+				} else if (type.equals("task") || type.equals("function")){
+					return name+"##"+el.getName();
+				} else {
+					el=el.getParent();
+				}
+		}
+		return name;
+	}
+
+	
+	private void portConnection(Expression arg, String module, String portName, int line, PORT_TYPE port_type) {
+		if (portsOnly) return;
+		Identifier[] idents = arg.getReferences();
+		if (idents == null)
+			return;
+//String  debugMsg="";
+		for (Identifier ident : idents) {
+			String fullName=addModuleTaskFunctionSuffix(ident.image);
+//debugMsg+=fullName+", ";			
+			if (preferences.moduleConnection) {
+// Compare widths - not now, for positional ports width is not yet known
+/*				
+				if (arg.isAssignable()) {
+					// The decision of input or output is delayed, just recorded now.
+					variableStore.addConnection(ident.image, generateBlock,
+							module + "#" + portName + "#" + line);
+				} else {
+					// Expression must be used as input only.
+					variableStore.addUsedVariable(ident.image, generateBlock);
+				}
+*/
+				// Andrey - should be done for non-assignable variables too, otherwise does not notice if parameter
+				// was used as an input port
+				// The decision of input or output is delayed, just recorded now.
+				variableStore.addConnection(fullName, generateBlock,
+						module + "#" + portName + "#" + line + "#" + port_type);
+				
+				
+			} else {
+				// no checking module port connection, assume inout port.
+				variableStore.addAssignedVariable(fullName, generateBlock, line); // will not assign if not possible
+				variableStore.addUsedVariable(fullName, generateBlock);
+			}
+		}
+//warning(line,"idents: %s",debugMsg);
+	}
+
+// parameterConnection
+	/**
+	 * Evaluate positional parameter connection.
+	 */
+	protected void positionalParameterConnection(Expression arg, String module, int parameterIndex) {
+		if (arg == null)
+			return;
+		// Don't add parameter to instanceStore.
+		// The connection check is available in named port connection only. Why - maybe fix that for positional too?
+		Identifier[] idents = arg.getReferences();
+		if ((idents != null) && (arg.beginLine<0)) {
+			arg.extendPosition(idents[0]); // is it needed
+		}
+		String name = Integer.toString(parameterIndex);
+		instanceStore.addParameter(name, arg.beginLine, arg.beginColumn, arg.endColumn, arg);
+		parameterConnection(arg, module, name, arg.beginLine);
+	}
+
+	/**
+	 * Evaluate named parameter connection.
+	 */
+	protected void namedParameterConnection(Expression arg, String module, Identifier parameter) {
+		if (m_OutlineContainer == null)
+			return;
+
+		int line = parameter.beginLine;
+		String parameterName = parameter.image;
+		instanceStore.addParameter(parameterName, line, parameter.beginColumn, parameter.endColumn, arg);
+		if (arg != null) {
+			if (arg.beginLine<0) arg.extendPosition(parameter);
+			parameterConnection(arg, module, parameterName, line);
+		}
+	}
+	
+	private void parameterConnection(Expression arg, String module, String parameterName, int line) {
+		if (portsOnly) return;
+		Identifier[] idents = arg.getReferences();
+		if (idents == null)
+			return;
+
+		for (Identifier ident : idents) {
+			if (preferences.moduleConnection) {
+				// Andrey - should be done for non-assignable variables too, otherwise does not notice if parameter
+//				variableStore.addConnection(ident.image, generateBlock,
+//						module + "#" + parameterName + "#" + line);
+				
+				
+			}
+			variableStore.addUsedVariable(ident.image, generateBlock);
+		}
+	}
+	
+// end of parameterConnection	
+	
+//	protected void variableConnection(Expression arg, boolean inp, boolean out) {
+	protected void primitivePortConnection(Expression arg, boolean inp, boolean out, PORT_TYPE port_type, int line) {
+		if (portsOnly) return;
+		Identifier[] idents = arg.getReferences();
+		if (idents == null)
+			return;
+
+		for (Identifier ident : idents) {
+			if (preferences.moduleConnection) {
+				if (out && arg.isAssignable()) variableStore.addAssignedVariable(ident.image, generateBlock, line);
+				if (inp)					   variableStore.addUsedVariable(ident.image, generateBlock);
+			} else {
+				// no checking module port connection, assume inout port.
+				variableStore.addAssignedVariable(ident.image, generateBlock, line);
+				variableStore.addUsedVariable(ident.image, generateBlock);
+			}
+		}
+	}
+
+	
+	
+	protected void evaluateAssignment(Token asn, int lvalue, Expression exp) {
+		if (m_OutlineContainer == null)
+			return;
+
+		if (blockContext == INITIAL_BLOCK || blockContext == ALWAYS_BLOCK) {
+			if (preferences.blocking) {
+				if (asn.image.equals("=")) {
+					if (blockStatus == NON_BLOCKING) {
+						warning(asn.beginLine, asn.beginColumn, asn.endLine, asn.endColumn, BOTH_ASSIGNMENT);
+					} else {
+						blockStatus = BLOCKING;
+					}
+				} else {
+					if (blockStatus == BLOCKING) {
+						warning(asn.beginLine, asn.beginColumn, asn.endLine, asn.endColumn, BOTH_ASSIGNMENT);
+					} else {
+						blockStatus = NON_BLOCKING;
+					}
+				}
+			}
+		}
+
+		if (blockContext == ALWAYS_BLOCK) {
+			if (preferences.blockingAlways && asn.image.equals("=")) {
+				warning(asn.beginLine, asn.beginColumn, asn.endLine, asn.endColumn, BLOCKING_ALWAYS);
+			}
+		}
+
+		if (exp.isFixedWidth() == false || lvalue == 0)
+			return;
+
+		int width = exp.getWidth();
+		if (preferences.intConst == false) {
+			if (width == 32 && exp.isValid())
+				return;
+		}
+		if (preferences.bitWidth && exp.isValidWidth() && lvalue != width) {
+			if (preferences.contextWidth || !exp.isContextDetermined()|| (lvalue<width)) {
+				String message = "from " + width + " to " + lvalue;
+				warning(asn.beginLine, asn.beginColumn, asn.endLine, asn.endColumn, ASSIGN_WIDTH_MISMATCH, message);
+			}
+		}
+//String  debugMsg="";
+//for (Identifier ident : exp.getReferences()) {
+//	debugMsg+=addModuleTaskFunctionSuffix(ident.image)+", ";			
+//}
+//warning(asn.beginLine,"evaluateAssignment idents: %s",debugMsg);
+		
+	}
+
+	protected void beginGenerateBlock(Identifier block) {
+		generateBlock.add(block.image);
+	}
+	
+	protected void endGenerateBlock(Identifier block) {
+		generateBlock.remove(generateBlock.size() - 1);
+	}
+
+	private String readResourceString(int lineNo){
+		if (lineNo<1) return null;
+		BufferedReader br;
+		String line;
+		try{
+			br = new BufferedReader(new InputStreamReader (m_File.getContents()));
+		} catch (CoreException e) {
+			return null;
+		}
+		for (int i=1;i<lineNo;i++){
+			try {
+				br.readLine();
+			} catch (IOException e){
+				return null;  // no need to close(), EOF is not an error
+			}
+		}
+		try {
+			line=br.readLine();
+			br.close();
+			return line;
+		} catch (IOException e){
+			return null;
+		}
+	}
+	
+// Here may be parsing either file or current editor window
+	private boolean isWarningSupressed(int lineNo){
+//		System.out.println("isWarningSupressed("+lineNo+")");
+		if (noProblems) return true;
+		if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.IGNORE_SUPPRESS_WARNINGS)) {
+			return false;
+		}
+		try {
+			HdlDocument document=  HdlEditor.current().getHdlDocument();
+			String previousLine;
+			if ((document==null) || (document.getFile()==null) || !document.getFile().equals(m_File)){
+				previousLine=readResourceString(lineNo-1);
+			} else {
+				previousLine=document.get(document.getLineOffset(lineNo-2),document.getLineLength(lineNo-2));
+			}
+			if (previousLine.contains(VDTErrorParser.SUPPRESS_WARNINGS) && (previousLine.toLowerCase().contains("veditor") || previousLine.contains("all"))){
+				return true;
+			} else {
+				String thisLine;
+				if ((document==null) || (document.getFile()==null) || !document.getFile().equals(m_File)){
+					thisLine=readResourceString(lineNo);
+				} else {
+					thisLine=document.get(document.getLineOffset(lineNo-1),document.getLineLength(lineNo-1));
+				}
+				if (thisLine.contains(VDTErrorParser.SUPPRESS_THIS_WARNING) && (thisLine.toLowerCase().contains("veditor") || thisLine.contains("all"))){
+					return true;
+				} else {
+					return false;
+				}
+			}
+		} catch (Exception e) {
+			return false;
+		}
+	}
+//	private void warning(int line, String format, String arg1, String arg2) {
+//		if(isWarningSupressed(line)) return; 
+//		String message = String.format(format, arg1, arg2);
+//		VerilogPlugin.setWarningMarker(m_File, line, message);
+//	}
+
+	private void warning(int line, String format, String arg) {
+		if(isWarningSupressed(line)) return; 
+		String message = String.format(format, arg);
+		if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR))
+			System.out.println("warning1 ,m_File="+m_File+", line="+line+", message="+message);
+
+		VerilogPlugin.setWarningMarker(m_File, line, message);
+	}
+
+	//	private void warning(int line, String message) {
+	//		if(isWarningSupressed(line)) return; 
+	//		VerilogPlugin.setWarningMarker(m_File, line, message);
+	//	}
+
+	private void warning(int line, int beginColumn, int endLine, int endColumn, String format, String arg1, String arg2) {
+		if(isWarningSupressed(line)) return; 
+		String message = String.format(format, arg1, arg2);
+		if ((endLine<0) || (endColumn<0) || (beginColumn<0)){
+			if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR))
+				System.out.println("warning2 ,m_File="+m_File+", line="+line+", message="+message);
+			VerilogPlugin.setWarningMarker(m_File, line, message);
+			return;
+		}
+		try {
+			HdlDocument document=  HdlEditor.current().getHdlDocument();
+			if (!document.getFile().equals(m_File)){ // parsing file, no need for char position - will be set when opening file
+				VerilogPlugin.setWarningMarker(m_File, line, message);
+				return;
+			}
+			int lineOffset=   document.getLineOffset(line-1);
+			int endLineOffset=document.getLineOffset(endLine-1);
+			int lineLength=document.getLineOffset(line)-lineOffset;
+			if (endColumn>(lineLength+1)) { // problem is in include file
+				VerilogPlugin.setWarningMarker(m_File, line, "(included file): "+message);
+				return;
+			}
+			if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR)) {
+				System.out.println("warning3 ,m_File="+m_File+", line="+line+","+
+						" lineOffset="+lineOffset+
+						" beginColumn="+beginColumn+
+						" start="+(lineOffset+beginColumn-1)+
+						" endLineOffset="+endLineOffset+
+						" endColumn="+endColumn+
+						" start="+(endLineOffset+endColumn-1)+
+						", message="+message);
+			}
+			VerilogPlugin.setWarningMarker(m_File, line, lineOffset+beginColumn-1, endLineOffset+endColumn, message);
+		} catch (Exception e) {
+			if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR))
+				System.out.println("warning4 ,m_File="+m_File+", line="+line+", message="+message);
+			VerilogPlugin.setWarningMarker(m_File, line, message);
+		}
+	}
+
+	private void warning(int line, int beginColumn, int endLine, int endColumn, String format, String arg) {
+		if(isWarningSupressed(line)) return; 
+		String message = String.format(format, arg);
+		if ((endLine<0) || (endColumn<0) || (beginColumn<0)){
+			if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR))
+				System.out.println("warning5 ,m_File="+m_File+", line="+line+", message="+message);
+			VerilogPlugin.setWarningMarker(m_File, line, message);
+			return;
+		}
+		try {
+			HdlDocument document=  HdlEditor.current().getHdlDocument();
+			if (!document.getFile().equals(m_File)){ // parsing file, no need for char position - will be set when opening file
+				VerilogPlugin.setWarningMarker(m_File, line, message);
+				return;
+			}
+			int lineOffset=   document.getLineOffset(line-1);
+			int lineLength=document.getLineOffset(line)-lineOffset;
+			if (endColumn>(lineLength+1)) { // problem is in include file
+				VerilogPlugin.setWarningMarker(m_File, line, "(included file): "+message);
+				return;
+			}
+			int endLineOffset=document.getLineOffset(endLine-1);
+			if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR)) {
+				System.out.println("warning6 ,m_File="+m_File+", line="+line+", endLine="+endLine+
+						" lineOffset="+lineOffset+
+						" beginColumn="+beginColumn+
+						" start="+(lineOffset+beginColumn-1)+
+						" endLineOffset="+endLineOffset+
+						" endColumn="+endColumn+
+						" start="+(endLineOffset+endColumn-1)+
+						", message="+message);
+			}
+			VerilogPlugin.setWarningMarker(m_File, line, lineOffset+beginColumn-1, endLineOffset+endColumn, message);
+		} catch (Exception e) {
+			VerilogPlugin.setWarningMarker(m_File, line, message);
+		}
+	}
+
+	private void warning(int line, int beginColumn, int endLine, int endColumn, String message) {
+		if(isWarningSupressed(line)) return; 
+		if ((endLine<0) || (endColumn<0) || (beginColumn<0)){
+			VerilogPlugin.setWarningMarker(m_File, line, message);
+			return;
+		}
+		try {
+			HdlDocument document=  HdlEditor.current().getHdlDocument();
+			int lineOffset=   document.getLineOffset(line-1);
+			int endLineOffset=document.getLineOffset(endLine-1);
+			VerilogPlugin.setWarningMarker(m_File, line, lineOffset+beginColumn-1, endLineOffset+endColumn, message);
+		} catch (Exception e) {
+			VerilogPlugin.setWarningMarker(m_File, line, message);
+		}
+	}
+
+	private void error(int line, int beginColumn, int endLine, int endColumn, String message) {
+		if ((endLine<0) || (endColumn<0) || (beginColumn<0)){
+			VerilogPlugin.setErrorMarker(m_File, line, message);
+			return;
+		}
+		try {
+			HdlDocument document=  HdlEditor.current().getHdlDocument();
+			int lineOffset=   document.getLineOffset(line-1);
+			int lineLength=   document.getLineOffset(line)-lineOffset;
+			if (beginColumn>=lineLength) beginColumn = lineLength-1;
+			if (endColumn>=  lineLength) endColumn = lineLength-1;
+			int endLineOffset=document.getLineOffset(endLine-1);
+			VerilogPlugin.setErrorMarker(m_File, line, lineOffset+beginColumn-1, endLineOffset+endColumn, message);
+		} catch (Exception e) {
+			VerilogPlugin.setErrorMarker(m_File, line, message);
+		}
+	}
+	
+	// TODO: - add separate for VerilogOutlineElement instead of Symbol
+	private void checkBitRangeFit(Identifier ident, VariableStore.Symbol sym){
+		int [] wb_ident=ident.getWidthBit();
+		int [] wb_sym=  sym.getWidthBit();
+		int w_ident=(wb_ident[0]==0)?0:(wb_ident[0]-1);
+		int w_sym=  (wb_sym[0]==0)?0:(wb_sym[0]-1);
+		String genvarName=getGenvarName(ident.getEncodedDepends());
+		if (genvarName!=null){
+			if (preferences.unsupported){
+				warning(ident.beginLine, ident.beginColumn, ident.endLine, ident.endColumn,
+						UNSUPPORTED_FEATURE,"can not check bit range that may depend on genvar "+genvarName);
+			} 
+		}
+		if ((wb_ident[1]>=wb_sym[1]) && ((wb_ident[1]+w_ident)<=(wb_sym[1]+w_sym))) return;
+		if ((preferences.intConst == false) && (wb_sym[0]==0)) return;
+
+		String sident=ident.image;
+		if (wb_ident[0]==1)     sident=String.format("%s[%d]", sident,wb_ident[1]);
+		else if (wb_ident[0]>1)sident=String.format("%s[%d:%d]", sident,wb_ident[1]+w_ident,wb_ident[1]);
+		String ssym=sym.getFullName();
+		if (wb_sym[0]==1)     ssym=String.format("%s[%d]", ssym,wb_sym[1]);
+		else if (wb_sym[0]>1) ssym=String.format("%s[%d:%d]", ssym,wb_sym[1]+w_sym,wb_sym[1]);
+		String defined=String.format("line %d", sym.getLine());
+		warning(ident.beginLine, ident.beginColumn, ident.endLine, ident.endColumn,
+				String.format(BIT_RANGE_MISMATCH,sident,ssym,defined));		
+	}
+
+	private void checkBitRangeFit(Identifier ident,OutlineElement oe){
+		if (oe instanceof VerilogOutlineElementFactory.VerilogOutlineElement){
+			VerilogOutlineElementFactory.VerilogOutlineElement ve=
+					(VerilogOutlineElementFactory.VerilogOutlineElement) oe;
+			String genvarName=getGenvarName(ident.getEncodedDepends());
+			if (genvarName!=null){
+				if (preferences.unsupported){
+					warning(ident.beginLine, ident.beginColumn, ident.endLine, ident.endColumn,
+							UNSUPPORTED_FEATURE,"can not check bit range that may depend on genvar "+genvarName);
+				} 
+				return;
+			}
+			int [] wb_ident=ident.getWidthBit();
+			int [] wb_sym=  ve.getWidthBit();
+			int w_ident=(wb_ident[0]==0)?0:(wb_ident[0]-1);
+			int w_sym=  (wb_sym[0]==0)?0:(wb_sym[0]-1);
+			if ((wb_ident[1]>=wb_sym[1]) && ((wb_ident[1]+w_ident)<=(wb_sym[1]+w_sym))) return;
+			if ((preferences.intConst == false) && (wb_sym[0]==0)) return;
+			String sident=ident.image;
+			if (wb_ident[0]==1)     sident=String.format("%s[%d]", sident,wb_ident[1]);
+			else if (wb_ident[0]>1)sident=String.format("%s[%d:%d]", sident,wb_ident[1]+w_ident,wb_ident[1]);
+			String ssym=ve.getName();
+			if (wb_sym[0]==1)     ssym=String.format("%s[%d]", ssym,wb_sym[1]);
+			else if (wb_sym[0]>1) ssym=String.format("%s[%d:%d]", ssym,wb_sym[1]+w_sym,wb_sym[1]);
+			String defined=String.format("%s:%d", ve.getFile().getFullPath(), ve.getStartingLine());
+			warning(ident.beginLine, ident.beginColumn, ident.endLine, ident.endColumn,
+					String.format(BIT_RANGE_MISMATCH,sident,ssym,defined));
+		} // So far only for Verilog - add for VHDL
+	}
+	
+	
+	public int getContext() {
+		return m_Context;
+	}
+	
+	private void close() {
+		try {
+			m_Reader.close();
+		} catch (IOException e) {
+		}
+	}
+	public void parse() throws HdlParserException
+	{
+		parse(1);
+	}
+
+	public synchronized void parse(int pass) throws HdlParserException
+	{
+		this.pass=pass;
+		try {
+			m_Reader.reset();
+		} catch (IOException e) {			
+		}
+		
+		if (m_OutlineContainer != null) {
+			VerilogPlugin.deleteMarkers(m_File);
+			preferences.updatePreferences();
+			Expression.setPreferences(preferences);
+			m_OutlineContainer.resetDisabledCode();
+		}
+		try
+		{
+			//start by looking for modules
+			verilogText();
+		}
+		catch(ParseException e){
+			if (m_OutlineContainer != null) {
+				// add error marker in outline scanning
+//				HdlParserException pe=new HdlParserException(e);
+				error(
+						e.currentToken.beginLine,
+						e.currentToken.beginColumn+1,
+						e.currentToken.beginLine,
+						e.currentToken.endColumn+1,
+						e.getMessage());
+			}
+			close();
+			//convert the exception to a generic one
+			throw new HdlParserException(e);
+		} catch (TokenMgrError e1){
+			HdlParserException pe=new HdlParserException(e1);
+			if (m_OutlineContainer != null) {
+				// add error marker in outline scanning
+				error(
+						pe.getStartLine(),
+						pe.getColumn()+1,
+						pe.getStartLine(),
+						pe.getColumn()+1,
+						pe.getMessage());
+			}
+			close();
+			//convert the exception to a generic one
+			throw pe;
+		}
+		
+		if (pass == 0) {
+			close();
+			return; // this will be a pass that needs just to find module names of the instances for closure TODO: speed up 
+		}
+		
+		if (m_OutlineContainer != null) {
+			parseLineComment();
+		}
+		close();
+		for(String module : variableStoreMap.keySet()) {
+			checkVariables(variableStoreMap.get(module),module);
+			// On the first pass set parametric ports if any ports are not resolved. When the database is scanned, only only single-pass parser runs.
+			if (pass==1) {
+				checkModulePortsDefined(variableStoreMap.get(module),module); // run only on pass1
+			}
+			for (Symbol sym: variableStoreMap.get(module).collection()){
+				sym.updateOEDrivers(true); // replace, not append
+			}
+		}
+		checkInstance();
+		if (m_OutlineContainer != null) {
+//			List<VerilogParserReader.FileDisabledRegion> fdr = ((VerilogParserReader) m_Reader).getDisabledRegions(null);
+			IPath location = m_File.getLocation();
+			if (location != null) {
+				List<VerilogParserReader.FileDisabledRegion> fdr_f = ((VerilogParserReader) m_Reader).getDisabledRegions(m_File.getLocation().toFile());
+				for (VerilogParserReader.FileDisabledRegion r : fdr_f){
+					m_OutlineContainer.addDisabledCode(r.startLine, r.endLine);
+				}
+//				System.out.println(m_File+" -> "+fdr_f.size());
+			}
+		}
+		
+	}
+
+	/**
+	 * Set partial parsing mode to determine parametric ports widths for instances
+	 * @param targetModule name of the module to process in the file
+	 * @param store store of passed parameters and parameters determined on previos passes 
+	 * @param passedPars list of passed parameter names (not to overwrite)
+	 * @throws HdlParserException 
+	 */
+	public void parse(int pass, String targetModule, VariableStore store, List<String>passedPars) throws HdlParserException{
+		this.pass=pass;
+		this.targetModule=targetModule;
+		portsOnly=true;
+		lastVariableStore=store;
+		noProblems=true;
+		skip=true;
+		this.passedPars=passedPars;
+		variableStore = new VariableStore();
+		for (String parname:passedPars){
+			VariableStore.Symbol sym=lastVariableStore.getValue(parname);
+			if (sym != null) {
+				sym.setAssignd();
+				sym.clearDepends();
+				variableStore.putValue(parname, sym);
+			}
+		}
+		m_OutlineContainer=null; // try without it?
+		try {
+			m_Reader.reset();
+		} catch (IOException e) {			
+		}
+		try
+		{
+			//start by looking for modules
+			verilogText();
+		}
+		catch(ParseException e){
+			close();
+			//convert the exception to a generic one
+			throw new HdlParserException(e);
+		} catch (TokenMgrError e1){
+			close();
+			//convert the exception to a generic one
+			throw new HdlParserException(e1.getMessage());
+		}
+// DO something else here		
+		
+//		for(String module : variableStoreMap.keySet()) {
+//			checkVariables(variableStoreMap.get(module),module);
+//		}
+//		checkInstance();
+		
+	}
+
+	VariableStore getInstanceParametricPorts (IFile file, String targetModule, VariableStore store){
+		List<String> passedPars=new ArrayList<String>();
+		for (String key:store.getKeys()){
+			passedPars.add(key);
+		}
+		/*
+		String text=null;
+		try{
+			HdlDocument document=  HdlEditor.current().getHdlDocument();
+			if (document.getFile().equals(file)) text=document.get();
+		} catch (Exception e){
+			text=null; // Other file, not the editor window
+		}
+		*/
+		String text= VerilogUtils.getEditorText(file);
+		VerilogParser parser=null;
+		try {
+			parser=null;
+			ParserReader reader;
+			if (text== null) reader= new VerilogParserReader(file.getContents(), file);
+			else             reader= new VerilogParserReader(text, file);
+			parser = (VerilogParser) ParserFactory.createVerilogParser(reader, m_Project, file); // Creates file on outline database
+			//do we have parser
+			if(parser!= null){
+				parser.parse(1, targetModule, store, passedPars);				
+			} else {
+				return null;
+			}
+		} catch (CoreException e) {
+			return null;
+		} catch (HdlParserException e){
+			return null;
+		}
+		OutlineDatabase database = OutlineDatabase.getProjectsDatabase(m_Project);
+		if (database==null){
+			return null; // BUG?
+		}
+//		OutlineContainer container=database.getOutlineContainer(file);
+		database.scanTree(file); // not needed, probably? Or should it be done before that?
+		// Second pass so module instances are known before processing assignments (current
+		// order is opposite. First pass creates warning markers and later defines instances.
+		// Second pass erases markers and uses hierarchical access to instances
+		// Andrey
+		int maxPass=2;
+		for (int numPass=2;numPass<=maxPass;numPass++){
+			// for Verilog only - save/restore variable store between parser passes (for parameters assigned after use)
+			Map<String,VariableStore> variableStoreMap=parser.getVariableStoreMap();
+			ParserReader reader;
+			try {
+				if (text== null) reader= new VerilogParserReader(file.getContents(), file);
+				else             reader= new VerilogParserReader(text, file);
+			} catch (CoreException e) {
+				System.out.println("BUG: getInstanceParametricPorts() could not create VerilogParserReader() e="+e);
+				return null;
+			}
+			parser = (VerilogParser) ParserFactory.createVerilogParser(reader, m_Project, file);
+//			parser.setLastVariableStoreMap(variableStoreMap);
+			if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR))
+				System.out.println("++++++++ Sub-Parser for module "+targetModule+", pass = "+numPass+" ++++++++++++ ");
+			try{
+//				parser.parse(numPass, targetModule, store, passedPars);				
+				parser.parse(numPass, targetModule, variableStoreMap.get(targetModule), passedPars);				
+			}
+			catch (HdlParserException e){
+				System.out.println("BUG: getInstanceParametricPorts() parser("+numPass+","+targetModule+",...) failed,  e="+e);
+				return null;
+			}
+			if (numPass==2){
+				int rank=parser.getParametersRank();
+				if (rank>=0) maxPass= rank+2;
+			}
+			if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR)) {
+				System.out.println("getInstanceParametricPorts pass=" +numPass+" getDepsResolved()=    "+parser.getDepsResolved()+" file:"+file);
+				System.out.println("getInstanceParametricPorts pass=" +numPass+" getParsResolved()=    "+parser.getParsResolved()+" file:"+file);
+				System.out.println("getInstanceParametricPorts pass=" +numPass+" getExpressionsValid()="+parser.getExpressionsValid()+" file:"+file);
+				System.out.println("getInstanceParametricPorts pass=" +numPass+" getPortsValid()=      "+parser.getPortsValid()+" file:"+file);
+			}
+			if (parser.getPortsValid() || (numPass == maxPass)) {
+				break; // all done
+			}
+
+		}
+		try {
+			return parser.getVariableStoreMap().get(targetModule);
+		} catch (Exception e) {
+			System.out.println("BUG: getInstanceParametricPorts() parser.getVariableStoreMap().get("+targetModule+") failed,  e="+e);
+		}
+		return null;
+	}
+
+	
+	/**
+     * Checks to see if a comment contains a task token
+     * @param comment The comment to check
+     * @param msg String array to receive the message type associated with the string
+     * @return The string of the Token. null if the comment does not have a task token
+     */
+    protected String getTaskToken(String comment,String []msg ){
+                
+        for(Pattern pattern:taskTokenPattern){          
+            Matcher matcher= pattern.matcher(comment);
+            if(matcher.find()){             
+                msg[0]=matcher.group(1)+matcher.group(2);
+                return matcher.group(1);
+            }
+        }
+        //if we get here, no task was found
+        return null;
+    }
+    /**
+     * Adds a task to the given line based on the comment token
+     * @param type
+     * @param line
+     */
+    protected void addTaskToLine(String type,String msg, int line){
+        //The first marker is considered high priority
+        if(type.startsWith(taskCommentTokens[0])){
+            VerilogPlugin.setTaskMarker(m_File, line, msg,IMarker.PRIORITY_HIGH);
+        }
+        else{
+            VerilogPlugin.setTaskMarker(m_File, line, msg,IMarker.PRIORITY_NORMAL);
+        }
+    }
+    
+    /**
+     * Removes a task from the given line
+     * @param line Line number to remove the task from
+     */
+    protected void removeTaskFromLine(int line){
+        VerilogPlugin.clearAutoTaskMarker(m_File, line);
+    }
+    
+    /**
+     * Removes all the auto generated tasks from the file
+     */
+    protected void clearAutoTasks(){
+        VerilogPlugin.clearAllAutoTaskMarkers(m_File);
+    }
+    
+    
+	/**
+	 * parse line comment for collapse
+	 */
+	private void parseLineComment() {
+		try {
+			m_Reader.reset();
+			clearAutoTasks();
+
+			boolean continued = false;
+			int startLine = -1;
+			int line = 1;
+			boolean validLine = false;
+			int c = m_Reader.read();
+			while (c != -1) {
+				switch (c) {
+				case '\n':
+					if (continued == true) {
+						continued = false;
+						if (line - startLine >= 2)
+							addCollapsible(startLine, line - 1);
+					}
+					line++;
+					validLine = false;
+					c = m_Reader.read();
+					break;
+				case '/':
+					c = m_Reader.read();
+					if (!validLine && c == '/') {
+						if (continued == false) {
+							startLine = line;
+							continued = true;
+						}
+
+						String comment = getLineComment(m_Reader);
+						if (comment != null){
+						    String []msg=new String[1];								
+                        
+                            addComment(line, comment);
+                            //check to see if we need to add a task
+                            String taskToken=getTaskToken(comment,msg);
+                            if(taskToken != null){                                  
+                                addTaskToLine(taskToken, msg[0], line);
+                            }                               
+                        }
+						line++;
+					}
+					break;
+				default:
+					if (!Character.isWhitespace((char)c)){
+						validLine = true;
+					}
+					c = m_Reader.read();
+					break;
+				}
+			}
+		} catch (IOException e) {
+		}
+	}
+
+	private String getLineComment(Reader reader) throws IOException
+	{
+		StringBuffer str = new StringBuffer();
+		boolean enable = false;
+
+		//  copy to StringBuffer
+		int c = reader.read();
+		while (c != '\n' && c != -1)
+		{
+			if (Character.isLetterOrDigit((char)c) || enable)
+			{
+				str.append((char)c);
+				enable = true;
+			}
+			c = reader.read();
+		}
+
+		// delete tail
+		for (int i = str.length() - 1; i >= 0; i--)
+		{
+			char ch = str.charAt(i);
+			if (!Character.isSpaceChar(ch))
+				break;
+			else
+				str.deleteCharAt(i);
+		}
+
+		if (str.length() != 0)
+			return str.toString();
+		else
+			return null;
+	}
+
+	private void addComment(int line, String comment)
+	{
+		// ignore continuous comments
+		if (prevCommentLine + 1 == line)
+		{
+			prevCommentLine = line;
+			return;
+		}
+
+		prevCommentLine = line;
+
+		//TODO need to add the comment functionality back in
+	}
+	private int prevCommentLine;
+
+	// preferences
+	public static class Preferences {
+		public boolean unresolved;
+		public boolean noUsed;
+		public boolean bitWidth;
+		public boolean bitwiseWidth;
+		public boolean contextWidth;
+		public boolean conditionWidth;
+		public boolean bitRange;
+		public boolean intConst;
+		public boolean blocking;
+		public boolean blockingAlways;
+		public boolean unresolvedModule;
+		public boolean duplicateModule;
+		public boolean moduleConnection;
+		public boolean forceInt32Bit;
+		public boolean skipPrimitives;
+		public boolean unsupported;
+
+		public void updatePreferences() {
+			unresolved = get(WARNING_UNRESOLVED);
+			noUsed = get(WARNING_NO_USED_ASIGNED);
+			bitWidth = get(WARNING_BIT_WIDTH);
+			bitwiseWidth=get(WARNING_BITWISE_WIDTH);
+			contextWidth=get(WARNING_CONTEXT_DETERMINED_WIDTH);
+			conditionWidth=get(WARNING_CONDITION_WIDTH);
+			bitRange = get(WARNING_BIT_RANGE);
+			intConst = get(WARNING_INT_CONSTANT);
+			blocking = get(WARNING_BLOCKING_ASSIGNMENT);
+			blockingAlways = get(WARNING_BLOCKING_ASSIGNMENT_IN_ALWAYS);
+			unresolvedModule = get(WARNING_UNRESOLVED_MODULE);
+			duplicateModule = get(WARNING_DUPLICATE_MODULE);
+			moduleConnection = get(WARNING_MODULE_CONNECTION);
+			forceInt32Bit = get(WARNING_FORCEINT32BIT);
+			skipPrimitives= get(WARNING_SKIP_PRIMITIVES);
+			unsupported=get(WARNING_UNSUPPORTED);
+			
+		}
+
+		private boolean get(String key) {
+			return VerilogPlugin.getPreferenceBoolean(key);
+		}
+	}
+}
+
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/verilog/VerilogParserReader.java vdt/src/com/elphel/vdt/veditor/parser/verilog/VerilogParserReader.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/verilog/VerilogParserReader.java	2016-06-24 10:29:40.856495517 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/verilog/VerilogParserReader.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,14 +1,25 @@
-/*******************************************************************************
- * Copyright (c) 2012 VEditor Team
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2012 VEditor Team
  *
  * Contributors:
  *    KOBAYASHI Tadashi - initial API and implementation
  *******************************************************************************/
-package net.sourceforge.veditor.parser.verilog;
+package com.elphel.vdt.veditor.parser.verilog;
 
 import java.io.File;
 import java.io.FileInputStream;
@@ -16,13 +27,19 @@
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.Reader;
-import java.io.StringReader;
+import java.io.StringReader;
+import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
 import java.util.Map;
-
+
 import org.eclipse.core.resources.IFile;
-
-import net.sourceforge.veditor.parser.ParserReader;
+import org.eclipse.core.resources.IProject;
+
+import com.elphel.vdt.veditor.VerilogPlugin;
+import com.elphel.vdt.veditor.parser.ParserReader;
+import com.elphel.vdt.veditor.preference.PreferenceStrings;
 
 public class VerilogParserReader extends ParserReader {
 	private final static int CONTINUED = 0;
@@ -31,39 +48,161 @@
 	private final static int ENDIF = 3;
 
 	private CharReader reader;
-	private File directory;
+	private File directory;
+	private File projectDirectory;
 	private StringBuilder buffer;
 	private Map<String, String> defines;
 	private boolean isInclude;
-
+	private File currentIncludeFile=null; // Andrey
+	private HashSet<File> includes=null;
+	private List<FileDisabledRegion> disabledRegions = new ArrayList<FileDisabledRegion>();
+	private int disableCount=0; // counts level of if/else to calculate greyed-out code segments
+	
+	public class FileDisabledRegion{
+		public File file;
+		public int startLine;
+		public int endLine;
+		public FileDisabledRegion(File file, int startLine, int endLine){
+			this.file = file;
+			this.startLine = startLine;
+			this.endLine = endLine;
+		}
+	}
+	
+	public HashSet<File> getIncludeFiles(){
+		return includes;
+	}
+	/**
+	 * Return IFile for current include file, or null if it is not include now
+	 * @return
+	 */
+	public File getIncludeFile(){
+		return currentIncludeFile;
+	}
+	public File getReaderFile(){
+		if (reader==null) return null;
+		return reader.currentFile;
+	}
+	
+	public int getBufferCount(){
+		return buffer.length();
+	}
+	
+	public void setDefines(Map<String, String> defines){
+		this.defines = new HashMap<String, String>();
+		this.defines.putAll(defines);
+	}
+
+	public Map<String, String> getDefines(){
+		return defines;
+	}
+
+	public List<FileDisabledRegion> getDisabledRegions(File file){
+		if (file == null) return this.disabledRegions;
+		else {
+			List<FileDisabledRegion> fileDisabledRegions = new ArrayList<FileDisabledRegion>();
+			for (FileDisabledRegion fdr:disabledRegions){
+				if (file.equals(fdr.file)) fileDisabledRegions.add(fdr);
+			}
+			return fileDisabledRegions;
+			
+		}
+	}
+	
+	private boolean isPreDefines(IFile file){
+		if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.EDITOR_AUTO_INCLUDE)) {
+			InputStream includeStream=null;
+			IFile autoInclude=null;
+			try {
+				autoInclude=file.getProject().getFile(VerilogPlugin.getPreferenceString(PreferenceStrings.EDITOR_AUTO_INCLUDE_NAME));
+				if (file.equals(autoInclude)){
+					System.out.println("isPreDefines(\""+file.getName()+"\"): tried to autoinclude itself");
+					return false; // ?
+				}
+				includeStream=autoInclude.getContents();
+			} catch (Exception e){
+				return false;
+			}
+			reader = new CharReader(new InputStreamReader(includeStream), autoInclude.getLocation().toFile());
+			process(autoInclude,true);
+			reader.close();
+			return true;
+		}
+		return false;
+	}
 	public VerilogParserReader(InputStream in, IFile file) {
-		reader = new CharReader(new InputStreamReader(in));
-		process(file);
+		boolean resetDefines=!isPreDefines(file);
+		reader = new CharReader(new InputStreamReader(in), file.getLocation().toFile());
+		process(file, resetDefines);
 		reader.close();
 		// System.out.println(buffer);
 		initialize(buffer.toString());
 	}
 
 	public VerilogParserReader(String text, IFile file) {
-		reader = new CharReader(new StringReader(text));
-		process(file);
+		boolean resetDefines=!isPreDefines(file);
+		reader = new CharReader(new StringReader(text), file.getLocation().toFile());
+		process(file, resetDefines);
 		reader.close();
-		// System.out.println(buffer);
-		initialize(buffer.toString());
+// 		 System.out.println(buffer);
+		initialize(buffer.toString()); // makes reader StringReader from string
 	}
-
-	private void process(IFile file) {
-		directory = file.getLocation().removeLastSegments(1).toFile();
+
+	public VerilogParserReader(InputStream in, IFile file, Map <String,String> defines) {
+		/*
+		 * If defines is null (old way) try editor predefines, if not null (used for tools)
+		 * always skip predefines but start with provided defines
+		 */
+		boolean resetDefines = false;
+		if (defines !=null) setDefines(defines); // initial defines (from the top file and/or from the tool) and skip predefines
+		else resetDefines = !isPreDefines(file);
+		reader = new CharReader(new InputStreamReader(in), file.getLocation().toFile());
+		process(file, resetDefines);
+		reader.close();
+		// System.out.println(buffer);
+		initialize(buffer.toString());
+	}
+
+	public VerilogParserReader(String text, IFile file, Map <String,String> defines) {
+		/*
+		 * If defines is null (old way) try editor predefines, if not null (used for tools)
+		 * always skip predefines but start with provided defines
+		 */
+		boolean resetDefines = false;
+		if (defines !=null) setDefines(defines); // initial defines (from the top file and/or from the tool) and skip predefines
+		else resetDefines = !isPreDefines(file);
+		reader = new CharReader(new StringReader(text), file.getLocation().toFile());
+		process(file, resetDefines);
+		reader.close();
+// 		 System.out.println(buffer);
+		initialize(buffer.toString()); // makes reader StringReader from string
+	}
+	
+	
+	
+//	private void process(IFile file) {
+//		process(file,true);
+//	}
+	private void process(IFile file,boolean resetDefines) {
+//		System.out.println("VerilogParserReader.process(\""+file.getName()+"\", "+resetDefines+")");
+
+		directory = file.getLocation().removeLastSegments(1).toFile();
+		IProject proj=file.getProject();
+		if (proj==null) projectDirectory = null;
+		else projectDirectory = proj.getLocation().toFile();
 		buffer = new StringBuilder();
-		defines = new HashMap<String, String>();
+		if (resetDefines) {
+			defines = new HashMap<String, String>();
+		}
 		isInclude = false;
-
+		currentIncludeFile=null;
 		for (;;) {
 			if (reader.isEof())
 				break;
 			// Normally it runs just once. It allows accidental `else or `endif
 			parseRegion(true);
-		}
+		}
+//		System.out.print("");
 	}
 	
 	private static final int CODE = 0;
@@ -72,10 +211,39 @@
 	private static final int STRING = 3;
 
 	private int parseRegion(boolean enable) {
-		int context = CODE;
-
+		int context = CODE;
+		int dbg_start_line = reader.getLine();
+		if (!enable) {
+			if (disableCount == 0){
+	       		if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_PREPROC)) {
+					System.out.println("File: "+getReaderFile()+" parse disabled region: start disabled code, line # "+reader.getLine()+" ("+dbg_start_line+")");
+				}
+				disabledRegions.add(new FileDisabledRegion(getReaderFile(), reader.getLine(), -1));
+			} else {
+	       		if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_PREPROC)) {
+					System.out.println("File: "+getReaderFile()+" parse disabled region: already disabled code, line # "+
+	       		    reader.getLine()+" ("+dbg_start_line+"), disableCount="+disableCount);
+				}
+			}
+			disableCount++;
+			//FileDisabledRegion
+		}
 		for (;;) {
-			if (reader.isEof()) {
+			if (reader.isEof()) {
+				/*
+				 * keep disabled after end of file (end will be -1)
+				if (!enable) {
+		       		if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_PREPROC)) {
+						System.out.println("File: "+getReaderFile()+" end disabled code, line # "+reader.getLine()+" ("+dbg_start_line+")");
+					}
+					for (int i = disabledRegions.size() - 1; i>=0; i--){ // last added for the same file
+						if (disabledRegions.get(i).file.equals(getReaderFile())){
+							disabledRegions.get(i).endLine = reader.getLine() - 1; // -1?
+							break;
+						}
+					}
+				}
+				*/
 				return CONTINUED;
 			}
 
@@ -113,12 +281,46 @@
 				}
 				break;
 			}
-			if (c == '`' && context == CODE) {
+			if (c == '`' && context == CODE) {
+				if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_PREPROC)) {
+					System.out.println("File: "+getReaderFile()+" got some directive, line # "+reader.getLine()+" ("+dbg_start_line+"), enable = "+enable);
+				}
 				int status = directive(enable);
+				if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_PREPROC)) {
+					System.out.println("File: "+getReaderFile()+" after 'some directive', line # "+reader.getLine()+" ("+dbg_start_line+"), enable = "+enable);
+				}
 				if (status != CONTINUED) {
-					// if get `else `endif, return
+					// if get `else `endif, return
+					if (!enable) {
+						if (disableCount > 0){
+							disableCount --;
+						} else {
+							System.out.println("Extra `endif or `else");
+						}
+						if (disableCount == 0){
+				       		if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_PREPROC)) {
+								System.out.println("File: "+getReaderFile()+" end disabled code, line # "+
+				       		    reader.getLine()+" ("+dbg_start_line+"), disableCount="+disableCount);
+							}
+							for (int i = disabledRegions.size() - 1; i>=0; i--){ // last added for the same file
+								if (disabledRegions.get(i).file.equals(getReaderFile())){
+									disabledRegions.get(i).endLine = reader.getLine();
+									break;
+								}
+							}
+						} else {
+				       		if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_PREPROC)) {
+								System.out.println("File: "+getReaderFile()+" end disabled code, line # "+
+				       		    reader.getLine()+" ("+dbg_start_line+"), but still is disabled, new disableCount="+disableCount);
+							}
+						}
+					}
 					return status;
-				}
+				}
+			} else if (c == '`'){
+	       		if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_PREPROC)) {
+					System.out.println("File: "+getReaderFile()+" got ` outside of CODE context, line # "+reader.getLine()+" ("+dbg_start_line+")"+", context="+context);
+				}
 			} else {
 				if (c == '\n') {
 					if (isInclude)
@@ -136,7 +338,8 @@
 	private int directive(boolean enable) {
 		String cmd = getIdent();
 
-		if (cmd.equals("timescale") || cmd.equals("default_nettype")) {
+		if (cmd.equals("timescale") || cmd.equals("default_nettype") ||
+				cmd.equals("celldefine") || cmd.equals("endcelldefine")	) {
 			getToEndOfLine();
 		} else if (cmd.equals("define")) {
 			String def = getNextIdent();
@@ -150,9 +353,12 @@
 					value = value.substring(0, idx);
 			} else {
 				value = "";
-			}
+			}
+			
 			if (enable)
-				defines.put(def, value);
+				defines.put(def, value);
+//			System.out.println(line+":directive: define: "+def+" -> "+value+ " (" +enable+ "), size()="+defines.size());
+			
 		} else if (cmd.equals("undef")) {
 			String def = getNextIdent();
 			if (enable)
@@ -170,8 +376,12 @@
 			return ENDIF;
 		} else if (cmd.equals("include")) {
 			String filename = getNextString();
-			// System.out.println("include:" + filename);
+			// System.out.println("include:" + filename);
+//			System.out.println("directive: include: "+filename+", size()="+defines.size());
 			directiveInclude(enable, filename);
+//			System.out.println("directive: include finished: "+filename+", size()="+defines.size());
+			// TODO: if came out with disabled - start disabled in this file
+			
 		} else {
 			// macro replace
 			if (enable) {
@@ -209,21 +419,31 @@
 		}
 	}
 
-	private void directiveInclude(boolean enable, String filename) {
+	private void directiveInclude(boolean enable, String filename) {
+//TODO: add warning for missing files? info/hover for full path?		
 		if (enable == false)
 			return;
 		boolean storeIsInclude = isInclude;
+		File storeCurrentIncludeFile=currentIncludeFile;
 		CharReader storeReader = reader;
 		isInclude = true;
-		File file = new File(directory, filename);
+		File file = new File(directory, filename); // original code - include is relative to the file directory
+		if (!file.exists() || !file.isFile()){
+			file = new File(projectDirectory, filename); // modified - try project root too
+		}
+		currentIncludeFile=file;
+		if (includes==null)	includes= new HashSet<File>();
+		includes.add(file);
+//System.out.println("directiveInclude(): "+filename+" ("+file.toString()+")");
 		try {
 			FileInputStream in = new FileInputStream(file);
-			reader = new CharReader(new InputStreamReader(in));
+			reader = new CharReader(new InputStreamReader(in),file);
 			parseRegion(true);
 			reader.close();
 		} catch (IOException e) {
 		}
 		isInclude = storeIsInclude;
+		currentIncludeFile=	storeCurrentIncludeFile;
 		reader = storeReader;
 	}
 
@@ -293,13 +513,19 @@
 		private boolean isCR;
 		private char next;
 		private int line;
+		private File currentFile=null;
 
-		public CharReader(Reader reader) {
+		public CharReader(Reader reader, File file) {
 			this.reader = reader;
 			eof = false;
 			hasNext = false;
 			isCR = false;
 			line = 1;
+			currentFile=file;
+		}
+		
+		public File getCurrentFile(){
+			return currentFile;
 		}
 
 		public char read() {
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASCII_CharStream.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASCII_CharStream.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASCII_CharStream.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASCII_CharStream.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,346 +1,346 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JavaCC: Do not edit this line. ASCII_CharStream.java Version 0.7pre3 */
-/**
- * An implementation of interface CharStream, where the stream is assumed to
- * contain only ASCII characters (without unicode processing).
- */
-
-public final class ASCII_CharStream
-{
-public static final boolean staticFlag = true;
-  static int bufsize;
-  static int available;
-  static int tokenBegin;
-  static public int bufpos = -1;
-  static private int bufline[];
-  static private int bufcolumn[];
-
-  static private int column = 0;
-  static private int line = 1;
-
-  static private boolean prevCharIsCR = false;
-  static private boolean prevCharIsLF = false;
-
-  static private java.io.InputStream inputStream;
-
-  static private byte[] buffer;
-  static private int maxNextCharInd = 0;
-  static private int inBuf = 0;
-
-  static private final void ExpandBuff(boolean wrapAround)
-  {
-     byte[] newbuffer = new byte[bufsize + 2048];
-     int newbufline[] = new int[bufsize + 2048];
-     int newbufcolumn[] = new int[bufsize + 2048];
-
-     try
-     {
-        if (wrapAround)
-        {
-           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
-           System.arraycopy(buffer, 0, newbuffer,
-                                             bufsize - tokenBegin, bufpos);
-           buffer = newbuffer;
-
-           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
-           System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
-           bufline = newbufline;
-
-           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
-           System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
-           bufcolumn = newbufcolumn;
-
-           maxNextCharInd = (bufpos += (bufsize - tokenBegin));
-        }
-        else
-        {
-           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
-           buffer = newbuffer;
-
-           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
-           bufline = newbufline;
-
-           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
-           bufcolumn = newbufcolumn;
-
-           maxNextCharInd = (bufpos -= tokenBegin);
-        }
-     }
-     catch (Throwable t)
-     {
-        throw new Error(t.getMessage());
-     }
-
-
-     bufsize += 2048;
-     available = bufsize;
-     tokenBegin = 0;
-  }
-
-  static private final void FillBuff() throws java.io.IOException
-  {
-     if (maxNextCharInd == available)
-     {
-        if (available == bufsize)
-        {
-           if (tokenBegin > 2048)
-           {
-              bufpos = maxNextCharInd = 0;
-              available = tokenBegin;
-           }
-           else if (tokenBegin < 0)
-              bufpos = maxNextCharInd = 0;
-           else
-              ExpandBuff(false);
-        }
-        else if (available > tokenBegin)
-           available = bufsize;
-        else if ((tokenBegin - available) < 2048)
-           ExpandBuff(true);
-        else
-           available = tokenBegin;
-     }
-
-     int i;
-     try {
-        if ((i = inputStream.read(buffer, maxNextCharInd,
-                                    available - maxNextCharInd)) == -1)
-        {
-           inputStream.close();
-           throw new java.io.IOException();
-        }
-        else
-           maxNextCharInd += i;
-        return;
-     }
-     catch(java.io.IOException e) {
-        --bufpos;
-        backup(0);
-        if (tokenBegin == -1)
-           tokenBegin = bufpos;
-        throw e;
-     }
-  }
-
-  static public final char BeginToken() throws java.io.IOException
-  {
-     tokenBegin = -1;
-     char c = readChar();
-     tokenBegin = bufpos;
-
-     return c;
-  }
-
-  static private final void UpdateLineColumn(char c)
-  {
-     column++;
-
-     if (prevCharIsLF)
-     {
-        prevCharIsLF = false;
-        line += (column = 1);
-     }
-     else if (prevCharIsCR)
-     {
-        prevCharIsCR = false;
-        if (c == '\n')
-        {
-           prevCharIsLF = true;
-        }
-        else
-           line += (column = 1);
-     }
-
-     switch (c)
-     {
-        case '\r' :
-           prevCharIsCR = true;
-           break;
-        case '\n' :
-           prevCharIsLF = true;
-           break;
-        case '\t' :
-           column += (9 - (column & 07));
-           break;
-        default :
-           break;
-     }
-
-     bufline[bufpos] = line;
-     bufcolumn[bufpos] = column;
-  }
-
-  static public final char readChar() throws java.io.IOException
-  {
-     if (inBuf > 0)
-     {
-        --inBuf;
-        return (char)((char)0xff & buffer[(bufpos == bufsize - 1) ? (bufpos = 0) : ++bufpos]);
-     }
-
-     if (++bufpos >= maxNextCharInd)
-        FillBuff();
-
-     char c = (char)((char)0xff & buffer[bufpos]);
-
-     UpdateLineColumn(c);
-     return (c);
-  }
-
-  /**
-   * @deprecated 
-   * @see #getEndColumn
-   */
-
-  static public final int getColumn() {
-     return bufcolumn[bufpos];
-  }
-
-  /**
-   * @deprecated 
-   * @see #getEndLine
-   */
-
-  static public final int getLine() {
-     return bufline[bufpos];
-  }
-
-  static public final int getEndColumn() {
-     return bufcolumn[bufpos];
-  }
-
-  static public final int getEndLine() {
-     return bufline[bufpos];
-  }
-
-  static public final int getBeginColumn() {
-     return bufcolumn[tokenBegin];
-  }
-
-  static public final int getBeginLine() {
-     return bufline[tokenBegin];
-  }
-
-  static public final void backup(int amount) {
-
-    inBuf += amount;
-    if ((bufpos -= amount) < 0)
-       bufpos += bufsize;
-  }
-
-  public ASCII_CharStream(java.io.InputStream dstream, int startline,
-  int startcolumn, int buffersize)
-  {
-    if (inputStream != null)
-       throw new Error("\n   ERROR: Second call to constructor of static ASCII_CharStream.  You must\n" +
-       "       either use ReInit() or set the JavaCC option STATIC to false\n" +
-       "       during the generation of this class.");
-    inputStream = dstream;
-    line = startline;
-    column = startcolumn - 1;
-
-    available = bufsize = buffersize;
-    buffer = new byte[buffersize];
-    bufline = new int[buffersize];
-    bufcolumn = new int[buffersize];
-  }
-
-  public ASCII_CharStream(java.io.InputStream dstream, int startline,
-                                                           int startcolumn)
-  {
-    if (inputStream != null)
-       throw new Error("\n   ERROR: Second call to constructor of static ASCII_CharStream.  You must\n" +
-       "       either use ReInit() or set the JavaCC option STATIC to false\n" +
-       "       during the generation of this class.");
-    inputStream = dstream;
-    line = startline;
-    column = startcolumn - 1;
-
-    available = bufsize = 4096;
-    buffer = new byte[4096];
-    bufline = new int[4096];
-    bufcolumn = new int[4096];
-  }
-  static public void ReInit(java.io.InputStream dstream, int startline,
-  int startcolumn, int buffersize)
-  {
-    inputStream = dstream;
-    line = startline;
-    column = startcolumn - 1;
-
-    if (buffer == null || buffersize != buffer.length)
-    {
-      available = bufsize = buffersize;
-      buffer = new byte[buffersize];
-      bufline = new int[buffersize];
-      bufcolumn = new int[buffersize];
-    }
-    prevCharIsLF = prevCharIsCR = false;
-    tokenBegin = inBuf = maxNextCharInd = 0;
-    bufpos = -1;
-  }
-
-  static public void ReInit(java.io.InputStream dstream, int startline,
-                                                           int startcolumn)
-  {
-    inputStream = dstream;
-    line = startline;
-    column = startcolumn - 1;
-
-    if (buffer == null || 4096 != buffer.length)
-    {
-      available = bufsize = 4096;
-      buffer = new byte[4096];
-      bufline = new int[4096];
-      bufcolumn = new int[4096];
-      available = bufsize = 4096;
-    }
-    prevCharIsLF = prevCharIsCR = false;
-    tokenBegin = inBuf = maxNextCharInd = 0;
-    bufpos = -1;
-  }
-
-  static public final String GetImage()
-  {
-     if (bufpos >= tokenBegin)
-        return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
-     else
-        return new String(buffer, tokenBegin, bufsize - tokenBegin) +
-                              new String(buffer, 0, bufpos + 1);
-  }
-
-  static public final byte[] GetSuffix(int len)
-  {
-     byte[] ret = new byte[len];
-
-     if ((bufpos + 1) >= len)
-        System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
-     else
-     {
-        System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,
-                                                          len - bufpos - 1);
-        System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
-     }
-
-     return ret;
-  }
-
-  static public void Done()
-  {
-     buffer = null;
-     bufline = null;
-     bufcolumn = null;
-  }
-
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JavaCC: Do not edit this line. ASCII_CharStream.java Version 0.7pre3 */
+/**
+ * An implementation of interface CharStream, where the stream is assumed to
+ * contain only ASCII characters (without unicode processing).
+ */
+
+public final class ASCII_CharStream
+{
+public static final boolean staticFlag = true;
+  static int bufsize;
+  static int available;
+  static int tokenBegin;
+  static public int bufpos = -1;
+  static private int bufline[];
+  static private int bufcolumn[];
+
+  static private int column = 0;
+  static private int line = 1;
+
+  static private boolean prevCharIsCR = false;
+  static private boolean prevCharIsLF = false;
+
+  static private java.io.InputStream inputStream;
+
+  static private byte[] buffer;
+  static private int maxNextCharInd = 0;
+  static private int inBuf = 0;
+
+  static private final void ExpandBuff(boolean wrapAround)
+  {
+     byte[] newbuffer = new byte[bufsize + 2048];
+     int newbufline[] = new int[bufsize + 2048];
+     int newbufcolumn[] = new int[bufsize + 2048];
+
+     try
+     {
+        if (wrapAround)
+        {
+           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
+           System.arraycopy(buffer, 0, newbuffer,
+                                             bufsize - tokenBegin, bufpos);
+           buffer = newbuffer;
+
+           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
+           System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
+           bufline = newbufline;
+
+           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
+           System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
+           bufcolumn = newbufcolumn;
+
+           maxNextCharInd = (bufpos += (bufsize - tokenBegin));
+        }
+        else
+        {
+           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
+           buffer = newbuffer;
+
+           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
+           bufline = newbufline;
+
+           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
+           bufcolumn = newbufcolumn;
+
+           maxNextCharInd = (bufpos -= tokenBegin);
+        }
+     }
+     catch (Throwable t)
+     {
+        throw new Error(t.getMessage());
+     }
+
+
+     bufsize += 2048;
+     available = bufsize;
+     tokenBegin = 0;
+  }
+
+  static private final void FillBuff() throws java.io.IOException
+  {
+     if (maxNextCharInd == available)
+     {
+        if (available == bufsize)
+        {
+           if (tokenBegin > 2048)
+           {
+              bufpos = maxNextCharInd = 0;
+              available = tokenBegin;
+           }
+           else if (tokenBegin < 0)
+              bufpos = maxNextCharInd = 0;
+           else
+              ExpandBuff(false);
+        }
+        else if (available > tokenBegin)
+           available = bufsize;
+        else if ((tokenBegin - available) < 2048)
+           ExpandBuff(true);
+        else
+           available = tokenBegin;
+     }
+
+     int i;
+     try {
+        if ((i = inputStream.read(buffer, maxNextCharInd,
+                                    available - maxNextCharInd)) == -1)
+        {
+           inputStream.close();
+           throw new java.io.IOException();
+        }
+        else
+           maxNextCharInd += i;
+        return;
+     }
+     catch(java.io.IOException e) {
+        --bufpos;
+        backup(0);
+        if (tokenBegin == -1)
+           tokenBegin = bufpos;
+        throw e;
+     }
+  }
+
+  static public final char BeginToken() throws java.io.IOException
+  {
+     tokenBegin = -1;
+     char c = readChar();
+     tokenBegin = bufpos;
+
+     return c;
+  }
+
+  static private final void UpdateLineColumn(char c)
+  {
+     column++;
+
+     if (prevCharIsLF)
+     {
+        prevCharIsLF = false;
+        line += (column = 1);
+     }
+     else if (prevCharIsCR)
+     {
+        prevCharIsCR = false;
+        if (c == '\n')
+        {
+           prevCharIsLF = true;
+        }
+        else
+           line += (column = 1);
+     }
+
+     switch (c)
+     {
+        case '\r' :
+           prevCharIsCR = true;
+           break;
+        case '\n' :
+           prevCharIsLF = true;
+           break;
+        case '\t' :
+           column += (9 - (column & 07));
+           break;
+        default :
+           break;
+     }
+
+     bufline[bufpos] = line;
+     bufcolumn[bufpos] = column;
+  }
+
+  static public final char readChar() throws java.io.IOException
+  {
+     if (inBuf > 0)
+     {
+        --inBuf;
+        return (char)((char)0xff & buffer[(bufpos == bufsize - 1) ? (bufpos = 0) : ++bufpos]);
+     }
+
+     if (++bufpos >= maxNextCharInd)
+        FillBuff();
+
+     char c = (char)((char)0xff & buffer[bufpos]);
+
+     UpdateLineColumn(c);
+     return (c);
+  }
+
+  /**
+   * @deprecated 
+   * @see #getEndColumn
+   */
+
+  static public final int getColumn() {
+     return bufcolumn[bufpos];
+  }
+
+  /**
+   * @deprecated 
+   * @see #getEndLine
+   */
+
+  static public final int getLine() {
+     return bufline[bufpos];
+  }
+
+  static public final int getEndColumn() {
+     return bufcolumn[bufpos];
+  }
+
+  static public final int getEndLine() {
+     return bufline[bufpos];
+  }
+
+  static public final int getBeginColumn() {
+     return bufcolumn[tokenBegin];
+  }
+
+  static public final int getBeginLine() {
+     return bufline[tokenBegin];
+  }
+
+  static public final void backup(int amount) {
+
+    inBuf += amount;
+    if ((bufpos -= amount) < 0)
+       bufpos += bufsize;
+  }
+
+  public ASCII_CharStream(java.io.InputStream dstream, int startline,
+  int startcolumn, int buffersize)
+  {
+    if (inputStream != null)
+       throw new Error("\n   ERROR: Second call to constructor of static ASCII_CharStream.  You must\n" +
+       "       either use ReInit() or set the JavaCC option STATIC to false\n" +
+       "       during the generation of this class.");
+    inputStream = dstream;
+    line = startline;
+    column = startcolumn - 1;
+
+    available = bufsize = buffersize;
+    buffer = new byte[buffersize];
+    bufline = new int[buffersize];
+    bufcolumn = new int[buffersize];
+  }
+
+  public ASCII_CharStream(java.io.InputStream dstream, int startline,
+                                                           int startcolumn)
+  {
+    if (inputStream != null)
+       throw new Error("\n   ERROR: Second call to constructor of static ASCII_CharStream.  You must\n" +
+       "       either use ReInit() or set the JavaCC option STATIC to false\n" +
+       "       during the generation of this class.");
+    inputStream = dstream;
+    line = startline;
+    column = startcolumn - 1;
+
+    available = bufsize = 4096;
+    buffer = new byte[4096];
+    bufline = new int[4096];
+    bufcolumn = new int[4096];
+  }
+  static public void ReInit(java.io.InputStream dstream, int startline,
+  int startcolumn, int buffersize)
+  {
+    inputStream = dstream;
+    line = startline;
+    column = startcolumn - 1;
+
+    if (buffer == null || buffersize != buffer.length)
+    {
+      available = bufsize = buffersize;
+      buffer = new byte[buffersize];
+      bufline = new int[buffersize];
+      bufcolumn = new int[buffersize];
+    }
+    prevCharIsLF = prevCharIsCR = false;
+    tokenBegin = inBuf = maxNextCharInd = 0;
+    bufpos = -1;
+  }
+
+  static public void ReInit(java.io.InputStream dstream, int startline,
+                                                           int startcolumn)
+  {
+    inputStream = dstream;
+    line = startline;
+    column = startcolumn - 1;
+
+    if (buffer == null || 4096 != buffer.length)
+    {
+      available = bufsize = 4096;
+      buffer = new byte[4096];
+      bufline = new int[4096];
+      bufcolumn = new int[4096];
+      available = bufsize = 4096;
+    }
+    prevCharIsLF = prevCharIsCR = false;
+    tokenBegin = inBuf = maxNextCharInd = 0;
+    bufpos = -1;
+  }
+
+  static public final String GetImage()
+  {
+     if (bufpos >= tokenBegin)
+        return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
+     else
+        return new String(buffer, tokenBegin, bufsize - tokenBegin) +
+                              new String(buffer, 0, bufpos + 1);
+  }
+
+  static public final byte[] GetSuffix(int len)
+  {
+     byte[] ret = new byte[len];
+
+     if ((bufpos + 1) >= len)
+        System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
+     else
+     {
+        System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,
+                                                          len - bufpos - 1);
+        System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
+     }
+
+     return ret;
+  }
+
+  static public void Done()
+  {
+     buffer = null;
+     bufline = null;
+     bufcolumn = null;
+  }
+
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTacross_aspect.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTacross_aspect.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTacross_aspect.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTacross_aspect.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTacross_aspect.java */
-/* JJT: 0.3pre1 */
-
-public class ASTacross_aspect extends SimpleNode {
-  ASTacross_aspect(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTacross_aspect.java */
+/* JJT: 0.3pre1 */
+
+public class ASTacross_aspect extends SimpleNode {
+  ASTacross_aspect(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTactual_part.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTactual_part.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTactual_part.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTactual_part.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTactual_part.java */
-/* JJT: 0.3pre1 */
-
-public class ASTactual_part extends SimpleNode {
-  ASTactual_part(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTactual_part.java */
+/* JJT: 0.3pre1 */
+
+public class ASTactual_part extends SimpleNode {
+  ASTactual_part(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTaggregate.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTaggregate.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTaggregate.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTaggregate.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTaggregate.java */
-/* JJT: 0.3pre1 */
-
-public class ASTaggregate extends SimpleNode {
-  ASTaggregate(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTaggregate.java */
+/* JJT: 0.3pre1 */
+
+public class ASTaggregate extends SimpleNode {
+  ASTaggregate(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTalias_declaration.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTalias_declaration.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTalias_declaration.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTalias_declaration.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,35 +1,35 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTalias_declaration.java */
-/* JJT: 0.3pre1 */
-
-public class ASTalias_declaration extends SimpleNode {
-  ASTalias_declaration(int id) {
-    super(id);
-  }
-  
-  public String getIdentifier(){
-	  ASTalias_designator designator=(ASTalias_designator)jjtGetChild(0);
-	  return designator.getIdentifier();
-  }
-  
-  public String getName() {
-		for (Node child : children) {
-			if (child instanceof ASTname) {
-				ASTname astName = (ASTname)child;
-				return ((ASTidentifier) (astName.jjtGetChild(0))).name;
-			}
-		}
-		return null;
-	}
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTalias_declaration.java */
+/* JJT: 0.3pre1 */
+
+public class ASTalias_declaration extends SimpleNode {
+  ASTalias_declaration(int id) {
+    super(id);
+  }
+  
+  public String getIdentifier(){
+	  ASTalias_designator designator=(ASTalias_designator)jjtGetChild(0);
+	  return designator.getIdentifier();
+  }
+  
+  public String getName() {
+		for (Node child : children) {
+			if (child instanceof ASTname) {
+				ASTname astName = (ASTname)child;
+				return ((ASTidentifier) (astName.jjtGetChild(0))).name;
+			}
+		}
+		return null;
+	}
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTalias_designator.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTalias_designator.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTalias_designator.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTalias_designator.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,29 +1,29 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTalias_designator.java */
-/* JJT: 0.3pre1 */
-
-public class ASTalias_designator extends SimpleNode {
-  ASTalias_designator(int id) {
-    super(id);
-  }
-  
-  public String getIdentifier(){
-	  for (Node child : children) {
-			if (child instanceof ASTidentifier) {
-				return ((ASTidentifier)(child)).name;
-			}
-		}
-		return null;
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTalias_designator.java */
+/* JJT: 0.3pre1 */
+
+public class ASTalias_designator extends SimpleNode {
+  ASTalias_designator(int id) {
+    super(id);
+  }
+  
+  public String getIdentifier(){
+	  for (Node child : children) {
+			if (child instanceof ASTidentifier) {
+				return ((ASTidentifier)(child)).name;
+			}
+		}
+		return null;
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTallocator.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTallocator.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTallocator.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTallocator.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTallocator.java */
-/* JJT: 0.3pre1 */
-
-public class ASTallocator extends SimpleNode {
-  ASTallocator(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTallocator.java */
+/* JJT: 0.3pre1 */
+
+public class ASTallocator extends SimpleNode {
+  ASTallocator(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTarchitecture_body.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTarchitecture_body.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTarchitecture_body.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTarchitecture_body.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,58 +1,58 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTarchitecture_body.java */
-/* JJT: 0.3pre1 */
-
-public class ASTarchitecture_body extends SimpleNode {
-  ASTarchitecture_body(int id) {
-    super(id);
-  }
-
-
-  public String getIdentifier(){
-	  return ((ASTidentifier)jjtGetChild(0)).name;
-  }
-  
-  public String getEntityName(){
-	  ASTname astName=(ASTname)getChild(1);
-	  return ((ASTidentifier)(astName.jjtGetChild(0))).name;
-  }
-
-  /**
-   * semantic-checks for architecture_body:
-   * - identifiers at beginning and end must match.
-   * - entity_name denotes an entity.
-   */
-  public void Check()
-  {
-    // identifiers at beginning and end must match
-    String s1 = ((ASTidentifier)jjtGetChild(0)).name;
-
-    int i = jjtGetNumChildren()-1;
-    if (jjtGetChild(i).toString() == "identifier")
-    {
-      if ( s1.compareTo( ((ASTidentifier)jjtGetChild(i)).name) != 0)
-        getErrorHandler().Error("identifiers don't match: "
-          +s1+"/="+((ASTidentifier)jjtGetChild(i)).name,null);
-    }
-
-
-    // the entity_name denotes an entity
-    // to be done (name must be done before...)
-
-    CheckSIWGLevel1();
-  }
-
-
-
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTarchitecture_body.java */
+/* JJT: 0.3pre1 */
+
+public class ASTarchitecture_body extends SimpleNode {
+  ASTarchitecture_body(int id) {
+    super(id);
+  }
+
+
+  public String getIdentifier(){
+	  return ((ASTidentifier)jjtGetChild(0)).name;
+  }
+  
+  public String getEntityName(){
+	  ASTname astName=(ASTname)getChild(1);
+	  return ((ASTidentifier)(astName.jjtGetChild(0))).name;
+  }
+
+  /**
+   * semantic-checks for architecture_body:
+   * - identifiers at beginning and end must match.
+   * - entity_name denotes an entity.
+   */
+  public void Check()
+  {
+    // identifiers at beginning and end must match
+    String s1 = ((ASTidentifier)jjtGetChild(0)).name;
+
+    int i = jjtGetNumChildren()-1;
+    if (jjtGetChild(i).toString() == "identifier")
+    {
+      if ( s1.compareTo( ((ASTidentifier)jjtGetChild(i)).name) != 0)
+        getErrorHandler().Error("identifiers don't match: "
+          +s1+"/="+((ASTidentifier)jjtGetChild(i)).name,null);
+    }
+
+
+    // the entity_name denotes an entity
+    // to be done (name must be done before...)
+
+    CheckSIWGLevel1();
+  }
+
+
+
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTarchitecture_declarative_part.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTarchitecture_declarative_part.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTarchitecture_declarative_part.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTarchitecture_declarative_part.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,19 +1,19 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-/* Generated By:JJTree: Do not edit this line. ASTarchitecture_declarative_part.java */
-/* JJT: 0.3pre1 */
-
-public class ASTarchitecture_declarative_part extends SimpleNode {
-  ASTarchitecture_declarative_part(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+/* Generated By:JJTree: Do not edit this line. ASTarchitecture_declarative_part.java */
+/* JJT: 0.3pre1 */
+
+public class ASTarchitecture_declarative_part extends SimpleNode {
+  ASTarchitecture_declarative_part(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTarchitecture_statement_part.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTarchitecture_statement_part.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTarchitecture_statement_part.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTarchitecture_statement_part.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTarchitecture_statement_part.java */
-/* JJT: 0.3pre1 */
-
-public class ASTarchitecture_statement_part extends SimpleNode {
-  ASTarchitecture_statement_part(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTarchitecture_statement_part.java */
+/* JJT: 0.3pre1 */
+
+public class ASTarchitecture_statement_part extends SimpleNode {
+  ASTarchitecture_statement_part(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTassertion.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTassertion.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTassertion.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTassertion.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTassertion.java */
-/* JJT: 0.3pre1 */
-
-public class ASTassertion extends SimpleNode {
-  ASTassertion(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTassertion.java */
+/* JJT: 0.3pre1 */
+
+public class ASTassertion extends SimpleNode {
+  ASTassertion(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTassertion_statement.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTassertion_statement.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTassertion_statement.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTassertion_statement.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTassertion_statement.java */
-/* JJT: 0.3pre1 */
-
-public class ASTassertion_statement extends SimpleNode {
-  ASTassertion_statement(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTassertion_statement.java */
+/* JJT: 0.3pre1 */
+
+public class ASTassertion_statement extends SimpleNode {
+  ASTassertion_statement(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTassociation_element.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTassociation_element.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTassociation_element.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTassociation_element.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTassociation_element.java */
-/* JJT: 0.3pre1 */
-
-public class ASTassociation_element extends SimpleNode {
-  ASTassociation_element(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTassociation_element.java */
+/* JJT: 0.3pre1 */
+
+public class ASTassociation_element extends SimpleNode {
+  ASTassociation_element(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTassociation_list.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTassociation_list.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTassociation_list.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTassociation_list.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTassociation_list.java */
-/* JJT: 0.3pre1 */
-
-public class ASTassociation_list extends SimpleNode {
-  ASTassociation_list(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTassociation_list.java */
+/* JJT: 0.3pre1 */
+
+public class ASTassociation_list extends SimpleNode {
+  ASTassociation_list(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTattribute_declaration.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTattribute_declaration.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTattribute_declaration.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTattribute_declaration.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTattribute_declaration.java */
-/* JJT: 0.3pre1 */
-
-public class ASTattribute_declaration extends SimpleNode {
-  ASTattribute_declaration(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTattribute_declaration.java */
+/* JJT: 0.3pre1 */
+
+public class ASTattribute_declaration extends SimpleNode {
+  ASTattribute_declaration(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTattribute_name.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTattribute_name.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTattribute_name.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTattribute_name.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTattribute_name.java */
-/* JJT: 0.3pre1 */
-
-public class ASTattribute_name extends SimpleNode {
-  ASTattribute_name(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTattribute_name.java */
+/* JJT: 0.3pre1 */
+
+public class ASTattribute_name extends SimpleNode {
+  ASTattribute_name(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTattribute_specification.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTattribute_specification.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTattribute_specification.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTattribute_specification.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTattribute_specification.java */
-/* JJT: 0.3pre1 */
-
-public class ASTattribute_specification extends SimpleNode {
-  ASTattribute_specification(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTattribute_specification.java */
+/* JJT: 0.3pre1 */
+
+public class ASTattribute_specification extends SimpleNode {
+  ASTattribute_specification(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTbinding_indication.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTbinding_indication.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTbinding_indication.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTbinding_indication.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTbinding_indication.java */
-/* JJT: 0.3pre1 */
-
-public class ASTbinding_indication extends SimpleNode {
-  ASTbinding_indication(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTbinding_indication.java */
+/* JJT: 0.3pre1 */
+
+public class ASTbinding_indication extends SimpleNode {
+  ASTbinding_indication(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTblock_configuration.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTblock_configuration.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTblock_configuration.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTblock_configuration.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTblock_configuration.java */
-/* JJT: 0.3pre1 */
-
-public class ASTblock_configuration extends SimpleNode {
-  ASTblock_configuration(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTblock_configuration.java */
+/* JJT: 0.3pre1 */
+
+public class ASTblock_configuration extends SimpleNode {
+  ASTblock_configuration(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTblock_declarative_part.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTblock_declarative_part.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTblock_declarative_part.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTblock_declarative_part.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTblock_declarative_part.java */
-/* JJT: 0.3pre1 */
-
-public class ASTblock_declarative_part extends SimpleNode {
-  ASTblock_declarative_part(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTblock_declarative_part.java */
+/* JJT: 0.3pre1 */
+
+public class ASTblock_declarative_part extends SimpleNode {
+  ASTblock_declarative_part(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTblock_header.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTblock_header.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTblock_header.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTblock_header.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTblock_header.java */
-/* JJT: 0.3pre1 */
-
-public class ASTblock_header extends SimpleNode {
-  ASTblock_header(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTblock_header.java */
+/* JJT: 0.3pre1 */
+
+public class ASTblock_header extends SimpleNode {
+  ASTblock_header(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTblock_specification.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTblock_specification.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTblock_specification.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTblock_specification.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTblock_specification.java */
-/* JJT: 0.3pre1 */
-
-public class ASTblock_specification extends SimpleNode {
-  ASTblock_specification(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTblock_specification.java */
+/* JJT: 0.3pre1 */
+
+public class ASTblock_specification extends SimpleNode {
+  ASTblock_specification(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTblock_statement.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTblock_statement.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTblock_statement.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTblock_statement.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTblock_statement.java */
-/* JJT: 0.3pre1 */
-
-public class ASTblock_statement extends SimpleNode {
-  ASTblock_statement(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTblock_statement.java */
+/* JJT: 0.3pre1 */
+
+public class ASTblock_statement extends SimpleNode {
+  ASTblock_statement(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTblock_statement_part.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTblock_statement_part.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTblock_statement_part.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTblock_statement_part.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTblock_statement_part.java */
-/* JJT: 0.3pre1 */
-
-public class ASTblock_statement_part extends SimpleNode {
-  ASTblock_statement_part(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTblock_statement_part.java */
+/* JJT: 0.3pre1 */
+
+public class ASTblock_statement_part extends SimpleNode {
+  ASTblock_statement_part(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTbranch_quantity_declaration.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTbranch_quantity_declaration.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTbranch_quantity_declaration.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTbranch_quantity_declaration.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTbranch_quantity_declaration.java */
-/* JJT: 0.3pre1 */
-
-public class ASTbranch_quantity_declaration extends SimpleNode {
-  ASTbranch_quantity_declaration(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTbranch_quantity_declaration.java */
+/* JJT: 0.3pre1 */
+
+public class ASTbranch_quantity_declaration extends SimpleNode {
+  ASTbranch_quantity_declaration(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTbreak_element.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTbreak_element.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTbreak_element.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTbreak_element.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTbreak_element.java */
-/* JJT: 0.3pre1 */
-
-public class ASTbreak_element extends SimpleNode {
-  ASTbreak_element(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTbreak_element.java */
+/* JJT: 0.3pre1 */
+
+public class ASTbreak_element extends SimpleNode {
+  ASTbreak_element(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTbreak_list.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTbreak_list.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTbreak_list.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTbreak_list.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTbreak_list.java */
-/* JJT: 0.3pre1 */
-
-public class ASTbreak_list extends SimpleNode {
-  ASTbreak_list(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTbreak_list.java */
+/* JJT: 0.3pre1 */
+
+public class ASTbreak_list extends SimpleNode {
+  ASTbreak_list(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTbreak_statement.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTbreak_statement.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTbreak_statement.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTbreak_statement.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTbreak_statement.java */
-/* JJT: 0.3pre1 */
-
-public class ASTbreak_statement extends SimpleNode {
-  ASTbreak_statement(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTbreak_statement.java */
+/* JJT: 0.3pre1 */
+
+public class ASTbreak_statement extends SimpleNode {
+  ASTbreak_statement(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTcase_statement_alternative.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTcase_statement_alternative.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTcase_statement_alternative.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTcase_statement_alternative.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,28 +1,28 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-/* Generated By:JJTree: Do not edit this line. ASTcase_statement_alternative.java */
-/* JJT: 0.3pre1 */
-
-public class ASTcase_statement_alternative extends SimpleNode {
-	ASTcase_statement_alternative(int id) {
-		super(id);
-	}
-
-	@Override
-	public void jjtOpen() {	
-		super.jjtOpen();
-	}
-
-	@Override
-	public void jjtClose() {	
-		super.jjtClose();
-	}
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+/* Generated By:JJTree: Do not edit this line. ASTcase_statement_alternative.java */
+/* JJT: 0.3pre1 */
+
+public class ASTcase_statement_alternative extends SimpleNode {
+	ASTcase_statement_alternative(int id) {
+		super(id);
+	}
+
+	@Override
+	public void jjtOpen() {	
+		super.jjtOpen();
+	}
+
+	@Override
+	public void jjtClose() {	
+		super.jjtClose();
+	}
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTcase_statement.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTcase_statement.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTcase_statement.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTcase_statement.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTcase_statement.java */
-/* JJT: 0.3pre1 */
-
-public class ASTcase_statement extends SimpleNode {
-  ASTcase_statement(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTcase_statement.java */
+/* JJT: 0.3pre1 */
+
+public class ASTcase_statement extends SimpleNode {
+  ASTcase_statement(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTchoice.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTchoice.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTchoice.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTchoice.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTchoice.java */
-/* JJT: 0.3pre1 */
-
-public class ASTchoice extends SimpleNode {
-  ASTchoice(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTchoice.java */
+/* JJT: 0.3pre1 */
+
+public class ASTchoice extends SimpleNode {
+  ASTchoice(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTchoices.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTchoices.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTchoices.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTchoices.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTchoices.java */
-/* JJT: 0.3pre1 */
-
-public class ASTchoices extends SimpleNode {
-  ASTchoices(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTchoices.java */
+/* JJT: 0.3pre1 */
+
+public class ASTchoices extends SimpleNode {
+  ASTchoices(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTcomponent_configuration.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTcomponent_configuration.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTcomponent_configuration.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTcomponent_configuration.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTcomponent_configuration.java */
-/* JJT: 0.3pre1 */
-
-public class ASTcomponent_configuration extends SimpleNode {
-  ASTcomponent_configuration(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTcomponent_configuration.java */
+/* JJT: 0.3pre1 */
+
+public class ASTcomponent_configuration extends SimpleNode {
+  ASTcomponent_configuration(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTcomponent_declaration.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTcomponent_declaration.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTcomponent_declaration.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTcomponent_declaration.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,24 +1,24 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTcomponent_declaration.java */
-/* JJT: 0.3pre1 */
-
-public class ASTcomponent_declaration extends SimpleNode {
-  ASTcomponent_declaration(int id) {
-    super(id);
-  }
-  
-  public String getIdentifier(){
-	  return ((ASTidentifier)jjtGetChild(0)).name;
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTcomponent_declaration.java */
+/* JJT: 0.3pre1 */
+
+public class ASTcomponent_declaration extends SimpleNode {
+  ASTcomponent_declaration(int id) {
+    super(id);
+  }
+  
+  public String getIdentifier(){
+	  return ((ASTidentifier)jjtGetChild(0)).name;
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTcomponent_instantiation_statement.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTcomponent_instantiation_statement.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTcomponent_instantiation_statement.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTcomponent_instantiation_statement.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,28 +1,28 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTcomponent_instantiation_statement.java */
-/* JJT: 0.3pre1 */
-
-public class ASTcomponent_instantiation_statement extends SimpleNode {
-  ASTcomponent_instantiation_statement(int id) {
-    super(id);
-  }
-  
-  public String getIdentifier(){
-	  return ((ASTidentifier)jjtGetChild(0)).name;
-  }
-  
-  public ASTinstantiated_unit getInstatiatedUnit(){
-	  return ((ASTinstantiated_unit)jjtGetChild(1));
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTcomponent_instantiation_statement.java */
+/* JJT: 0.3pre1 */
+
+public class ASTcomponent_instantiation_statement extends SimpleNode {
+  ASTcomponent_instantiation_statement(int id) {
+    super(id);
+  }
+  
+  public String getIdentifier(){
+	  return ((ASTidentifier)jjtGetChild(0)).name;
+  }
+  
+  public ASTinstantiated_unit getInstatiatedUnit(){
+	  return ((ASTinstantiated_unit)jjtGetChild(1));
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTcomponent_specification.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTcomponent_specification.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTcomponent_specification.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTcomponent_specification.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTcomponent_specification.java */
-/* JJT: 0.3pre1 */
-
-public class ASTcomponent_specification extends SimpleNode {
-  ASTcomponent_specification(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTcomponent_specification.java */
+/* JJT: 0.3pre1 */
+
+public class ASTcomponent_specification extends SimpleNode {
+  ASTcomponent_specification(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTcomposite_type_definition.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTcomposite_type_definition.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTcomposite_type_definition.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTcomposite_type_definition.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTcomposite_type_definition.java */
-/* JJT: 0.3pre1 */
-
-public class ASTcomposite_type_definition extends SimpleNode {
-  ASTcomposite_type_definition(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTcomposite_type_definition.java */
+/* JJT: 0.3pre1 */
+
+public class ASTcomposite_type_definition extends SimpleNode {
+  ASTcomposite_type_definition(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTconcurrent_assertion_statement.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTconcurrent_assertion_statement.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTconcurrent_assertion_statement.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTconcurrent_assertion_statement.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTconcurrent_assertion_statement.java */
-/* JJT: 0.3pre1 */
-
-public class ASTconcurrent_assertion_statement extends SimpleNode {
-  ASTconcurrent_assertion_statement(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTconcurrent_assertion_statement.java */
+/* JJT: 0.3pre1 */
+
+public class ASTconcurrent_assertion_statement extends SimpleNode {
+  ASTconcurrent_assertion_statement(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTconcurrent_break_statement.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTconcurrent_break_statement.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTconcurrent_break_statement.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTconcurrent_break_statement.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTconcurrent_break_statement.java */
-/* JJT: 0.3pre1 */
-
-public class ASTconcurrent_break_statement extends SimpleNode {
-  ASTconcurrent_break_statement(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTconcurrent_break_statement.java */
+/* JJT: 0.3pre1 */
+
+public class ASTconcurrent_break_statement extends SimpleNode {
+  ASTconcurrent_break_statement(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTconcurrent_procedure_call_statement.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTconcurrent_procedure_call_statement.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTconcurrent_procedure_call_statement.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTconcurrent_procedure_call_statement.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTconcurrent_procedure_call_statement.java */
-/* JJT: 0.3pre1 */
-
-public class ASTconcurrent_procedure_call_statement extends SimpleNode {
-  ASTconcurrent_procedure_call_statement(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTconcurrent_procedure_call_statement.java */
+/* JJT: 0.3pre1 */
+
+public class ASTconcurrent_procedure_call_statement extends SimpleNode {
+  ASTconcurrent_procedure_call_statement(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTconcurrent_signal_assignment_statement.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTconcurrent_signal_assignment_statement.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTconcurrent_signal_assignment_statement.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTconcurrent_signal_assignment_statement.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTconcurrent_signal_assignment_statement.java */
-/* JJT: 0.3pre1 */
-
-public class ASTconcurrent_signal_assignment_statement extends SimpleNode {
-  ASTconcurrent_signal_assignment_statement(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTconcurrent_signal_assignment_statement.java */
+/* JJT: 0.3pre1 */
+
+public class ASTconcurrent_signal_assignment_statement extends SimpleNode {
+  ASTconcurrent_signal_assignment_statement(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTconditional_signal_assignment.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTconditional_signal_assignment.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTconditional_signal_assignment.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTconditional_signal_assignment.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTconditional_signal_assignment.java */
-/* JJT: 0.3pre1 */
-
-public class ASTconditional_signal_assignment extends SimpleNode {
-  ASTconditional_signal_assignment(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTconditional_signal_assignment.java */
+/* JJT: 0.3pre1 */
+
+public class ASTconditional_signal_assignment extends SimpleNode {
+  ASTconditional_signal_assignment(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTconditional_waveforms.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTconditional_waveforms.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTconditional_waveforms.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTconditional_waveforms.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTconditional_waveforms.java */
-/* JJT: 0.3pre1 */
-
-public class ASTconditional_waveforms extends SimpleNode {
-  ASTconditional_waveforms(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTconditional_waveforms.java */
+/* JJT: 0.3pre1 */
+
+public class ASTconditional_waveforms extends SimpleNode {
+  ASTconditional_waveforms(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTconfiguration_declaration.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTconfiguration_declaration.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTconfiguration_declaration.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTconfiguration_declaration.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTconfiguration_declaration.java */
-/* JJT: 0.3pre1 */
-
-public class ASTconfiguration_declaration extends SimpleNode {
-  ASTconfiguration_declaration(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTconfiguration_declaration.java */
+/* JJT: 0.3pre1 */
+
+public class ASTconfiguration_declaration extends SimpleNode {
+  ASTconfiguration_declaration(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTconfiguration_declarative_part.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTconfiguration_declarative_part.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTconfiguration_declarative_part.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTconfiguration_declarative_part.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTconfiguration_declarative_part.java */
-/* JJT: 0.3pre1 */
-
-public class ASTconfiguration_declarative_part extends SimpleNode {
-  ASTconfiguration_declarative_part(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTconfiguration_declarative_part.java */
+/* JJT: 0.3pre1 */
+
+public class ASTconfiguration_declarative_part extends SimpleNode {
+  ASTconfiguration_declarative_part(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTconfiguration_specification.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTconfiguration_specification.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTconfiguration_specification.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTconfiguration_specification.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTconfiguration_specification.java */
-/* JJT: 0.3pre1 */
-
-public class ASTconfiguration_specification extends SimpleNode {
-  ASTconfiguration_specification(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTconfiguration_specification.java */
+/* JJT: 0.3pre1 */
+
+public class ASTconfiguration_specification extends SimpleNode {
+  ASTconfiguration_specification(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTconstant_declaration.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTconstant_declaration.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTconstant_declaration.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTconstant_declaration.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,45 +1,45 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTconstant_declaration.java */
-/* JJT: 0.3pre1 */
-
-public class ASTconstant_declaration extends SimpleNode {
-  ASTconstant_declaration(int id) {
-    super(id);
-  }
-  public String[] getIdentifierList(){
-	  return ((ASTidentifier_list)jjtGetChild(0)).getIdentifierNames();
-  }
-  
-  public String getSubType(){
-	  ASTsubtype_indication subtype= (ASTsubtype_indication)jjtGetChild(1);
-	  String result = subtype.getIdentifier();
-	  if(jjtGetNumChildren()>2) {
-		  if(jjtGetChild(2) instanceof SimpleNode) {
-			  SimpleNode initvalue = (SimpleNode)jjtGetChild(2);
-			 
-			  String completevalue = "";
-			  Token curtoken = initvalue.getFirstToken();
-			  if(curtoken!=null) {
-				  completevalue = curtoken.toString();
-				  while(curtoken!=initvalue.getLastToken() && curtoken.next!=null) {
-					  curtoken = curtoken.next;
-					  completevalue = completevalue + " " +curtoken.toString();
-				  }
-			  }
-			  result += "#"+completevalue;
-		  }
-	  }
-	  return result;
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTconstant_declaration.java */
+/* JJT: 0.3pre1 */
+
+public class ASTconstant_declaration extends SimpleNode {
+  ASTconstant_declaration(int id) {
+    super(id);
+  }
+  public String[] getIdentifierList(){
+	  return ((ASTidentifier_list)jjtGetChild(0)).getIdentifierNames();
+  }
+  
+  public String getSubType(){
+	  ASTsubtype_indication subtype= (ASTsubtype_indication)jjtGetChild(1);
+	  String result = subtype.getIdentifier();
+	  if(jjtGetNumChildren()>2) {
+		  if(jjtGetChild(2) instanceof SimpleNode) {
+			  SimpleNode initvalue = (SimpleNode)jjtGetChild(2);
+			 
+			  String completevalue = "";
+			  Token curtoken = initvalue.getFirstToken();
+			  if(curtoken!=null) {
+				  completevalue = curtoken.toString();
+				  while(curtoken!=initvalue.getLastToken() && curtoken.next!=null) {
+					  curtoken = curtoken.next;
+					  completevalue = completevalue + " " +curtoken.toString();
+				  }
+			  }
+			  result += "#"+completevalue;
+		  }
+	  }
+	  return result;
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTconstrained_array_definition.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTconstrained_array_definition.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTconstrained_array_definition.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTconstrained_array_definition.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTconstrained_array_definition.java */
-/* JJT: 0.3pre1 */
-
-public class ASTconstrained_array_definition extends SimpleNode {
-  ASTconstrained_array_definition(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTconstrained_array_definition.java */
+/* JJT: 0.3pre1 */
+
+public class ASTconstrained_array_definition extends SimpleNode {
+  ASTconstrained_array_definition(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTconstrained_nature_definition.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTconstrained_nature_definition.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTconstrained_nature_definition.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTconstrained_nature_definition.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTconstrained_nature_definition.java */
-/* JJT: 0.3pre1 */
-
-public class ASTconstrained_nature_definition extends SimpleNode {
-  ASTconstrained_nature_definition(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTconstrained_nature_definition.java */
+/* JJT: 0.3pre1 */
+
+public class ASTconstrained_nature_definition extends SimpleNode {
+  ASTconstrained_nature_definition(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTcontext_clause.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTcontext_clause.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTcontext_clause.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTcontext_clause.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTcontext_clause.java */
-/* JJT: 0.3pre1 */
-
-public class ASTcontext_clause extends SimpleNode {
-  ASTcontext_clause(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTcontext_clause.java */
+/* JJT: 0.3pre1 */
+
+public class ASTcontext_clause extends SimpleNode {
+  ASTcontext_clause(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTdelay_mechanism.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTdelay_mechanism.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTdelay_mechanism.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTdelay_mechanism.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTdelay_mechanism.java */
-/* JJT: 0.3pre1 */
-
-public class ASTdelay_mechanism extends SimpleNode {
-  ASTdelay_mechanism(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTdelay_mechanism.java */
+/* JJT: 0.3pre1 */
+
+public class ASTdelay_mechanism extends SimpleNode {
+  ASTdelay_mechanism(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTdesign_file.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTdesign_file.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTdesign_file.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTdesign_file.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTdesign_file.java */
-/* JJT: 0.3pre1 */
-
-public class ASTdesign_file extends SimpleNode {
-  ASTdesign_file(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTdesign_file.java */
+/* JJT: 0.3pre1 */
+
+public class ASTdesign_file extends SimpleNode {
+  ASTdesign_file(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTdesign_unit.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTdesign_unit.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTdesign_unit.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTdesign_unit.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTdesign_unit.java */
-/* JJT: 0.3pre1 */
-
-public class ASTdesign_unit extends SimpleNode {
-  ASTdesign_unit(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTdesign_unit.java */
+/* JJT: 0.3pre1 */
+
+public class ASTdesign_unit extends SimpleNode {
+  ASTdesign_unit(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTdirection.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTdirection.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTdirection.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTdirection.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTdirection.java */
-/* JJT: 0.3pre1 */
-
-public class ASTdirection extends SimpleNode {
-  ASTdirection(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTdirection.java */
+/* JJT: 0.3pre1 */
+
+public class ASTdirection extends SimpleNode {
+  ASTdirection(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTdisconnection_specification.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTdisconnection_specification.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTdisconnection_specification.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTdisconnection_specification.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTdisconnection_specification.java */
-/* JJT: 0.3pre1 */
-
-public class ASTdisconnection_specification extends SimpleNode {
-  ASTdisconnection_specification(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTdisconnection_specification.java */
+/* JJT: 0.3pre1 */
+
+public class ASTdisconnection_specification extends SimpleNode {
+  ASTdisconnection_specification(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTelement_declaration.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTelement_declaration.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTelement_declaration.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTelement_declaration.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,32 +1,32 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTelement_declaration.java */
-/* JJT: 0.3pre1 */
-
-public class ASTelement_declaration extends SimpleNode {
-  ASTelement_declaration(int id) {
-    super(id);
-  }
-
-  public String[] getIdentifierList(){
-	  if(getChildCount()==0) return new String[0];
-	  if(!(jjtGetChild(0) instanceof ASTidentifier_list)) return new String[0];
-	  return ((ASTidentifier_list)jjtGetChild(0)).getIdentifierNames();
-  }
-  
-  public String getSubType() {
-	  if(getChildCount()<2) return "";
-	  if(!(jjtGetChild(1) instanceof ASTsubtype_indication)) return "";
-	  return ((ASTsubtype_indication)jjtGetChild(1)).getIdentifier();
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTelement_declaration.java */
+/* JJT: 0.3pre1 */
+
+public class ASTelement_declaration extends SimpleNode {
+  ASTelement_declaration(int id) {
+    super(id);
+  }
+
+  public String[] getIdentifierList(){
+	  if(getChildCount()==0) return new String[0];
+	  if(!(jjtGetChild(0) instanceof ASTidentifier_list)) return new String[0];
+	  return ((ASTidentifier_list)jjtGetChild(0)).getIdentifierNames();
+  }
+  
+  public String getSubType() {
+	  if(getChildCount()<2) return "";
+	  if(!(jjtGetChild(1) instanceof ASTsubtype_indication)) return "";
+	  return ((ASTsubtype_indication)jjtGetChild(1)).getIdentifier();
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTentity_aspect.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTentity_aspect.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTentity_aspect.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTentity_aspect.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTentity_aspect.java */
-/* JJT: 0.3pre1 */
-
-public class ASTentity_aspect extends SimpleNode {
-  ASTentity_aspect(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTentity_aspect.java */
+/* JJT: 0.3pre1 */
+
+public class ASTentity_aspect extends SimpleNode {
+  ASTentity_aspect(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTentity_class_entry.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTentity_class_entry.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTentity_class_entry.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTentity_class_entry.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTentity_class_entry.java */
-/* JJT: 0.3pre1 */
-
-public class ASTentity_class_entry extends SimpleNode {
-  ASTentity_class_entry(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTentity_class_entry.java */
+/* JJT: 0.3pre1 */
+
+public class ASTentity_class_entry extends SimpleNode {
+  ASTentity_class_entry(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTentity_class_entry_list.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTentity_class_entry_list.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTentity_class_entry_list.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTentity_class_entry_list.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTentity_class_entry_list.java */
-/* JJT: 0.3pre1 */
-
-public class ASTentity_class_entry_list extends SimpleNode {
-  ASTentity_class_entry_list(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTentity_class_entry_list.java */
+/* JJT: 0.3pre1 */
+
+public class ASTentity_class_entry_list extends SimpleNode {
+  ASTentity_class_entry_list(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTentity_declaration.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTentity_declaration.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTentity_declaration.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTentity_declaration.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,66 +1,66 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTentity_declaration.java */
-/* JJT: 0.3pre1 */
-
-public class ASTentity_declaration extends SimpleNode {
-  ASTentity_declaration(int id) {
-    super(id);
-  }
-
-  public String getIdentifier(){
-	  return ((ASTidentifier)jjtGetChild(0)).name;
-  }
-
-  /**
-   * semantic-checks for entity_declaration
-   * - identifiers at beginning and end must match
-   * - the identifier is now an entity_simple_name.
-   */
-  public void Check()
-  {
-    //  identifiers at beginning and end must match
-    String s1 = ((ASTidentifier)jjtGetChild(0)).name;
-
-    int i = jjtGetNumChildren()-1;
-    if (jjtGetChild(i).toString() == "identifier")
-    {
-      if ( s1.compareTo( ((ASTidentifier)jjtGetChild(i)).name) != 0)
-    	  getErrorHandler().Error("identifiers don't match",null);
-    }
-
-    // the identifier is now an entity_simple_name.
-    m_Parser.getSymbolTable().addSymbol(new Symbol(s1, ENTITY));
-    CheckSIWGLevel1();
-  }
-
-
-  /**
-   * VI SIWG Level1 not supported:
-   * - entity_statement_part
-   * - entity_declarative_part
-   */
-  public void CheckSIWGLevel1()
-  {
-    for (int i = 0; i < jjtGetNumChildren(); i++)
-    {
-/*      if ((jjtGetChild(i).getId() == JJTENTITY_DECLARATIVE_PART)
-          && (jjtGetChild(i).jjtGetNumChildren() > 0))
-    	  getErrorHandler().WarnLevel1("entity_declarative_part not supported");*/
-
-/*      if ((jjtGetChild(i).toString() == "entity_statement_part")
-          && (jjtGetChild(i).jjtGetNumChildren() > 0))
-    	  getErrorHandler().WarnLevel1("entity_statement_part not supported");*/
-    }
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTentity_declaration.java */
+/* JJT: 0.3pre1 */
+
+public class ASTentity_declaration extends SimpleNode {
+  ASTentity_declaration(int id) {
+    super(id);
+  }
+
+  public String getIdentifier(){
+	  return ((ASTidentifier)jjtGetChild(0)).name;
+  }
+
+  /**
+   * semantic-checks for entity_declaration
+   * - identifiers at beginning and end must match
+   * - the identifier is now an entity_simple_name.
+   */
+  public void Check()
+  {
+    //  identifiers at beginning and end must match
+    String s1 = ((ASTidentifier)jjtGetChild(0)).name;
+
+    int i = jjtGetNumChildren()-1;
+    if (jjtGetChild(i).toString() == "identifier")
+    {
+      if ( s1.compareTo( ((ASTidentifier)jjtGetChild(i)).name) != 0)
+    	  getErrorHandler().Error("identifiers don't match",null);
+    }
+
+    // the identifier is now an entity_simple_name.
+    m_Parser.getSymbolTable().addSymbol(new Symbol(s1, ENTITY));
+    CheckSIWGLevel1();
+  }
+
+
+  /**
+   * VI SIWG Level1 not supported:
+   * - entity_statement_part
+   * - entity_declarative_part
+   */
+  public void CheckSIWGLevel1()
+  {
+    for (int i = 0; i < jjtGetNumChildren(); i++)
+    {
+/*      if ((jjtGetChild(i).getId() == JJTENTITY_DECLARATIVE_PART)
+          && (jjtGetChild(i).jjtGetNumChildren() > 0))
+    	  getErrorHandler().WarnLevel1("entity_declarative_part not supported");*/
+
+/*      if ((jjtGetChild(i).toString() == "entity_statement_part")
+          && (jjtGetChild(i).jjtGetNumChildren() > 0))
+    	  getErrorHandler().WarnLevel1("entity_statement_part not supported");*/
+    }
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTentity_declarative_part.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTentity_declarative_part.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTentity_declarative_part.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTentity_declarative_part.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTentity_declarative_part.java */
-/* JJT: 0.3pre1 */
-
-public class ASTentity_declarative_part extends SimpleNode {
-  ASTentity_declarative_part(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTentity_declarative_part.java */
+/* JJT: 0.3pre1 */
+
+public class ASTentity_declarative_part extends SimpleNode {
+  ASTentity_declarative_part(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTentity_designator.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTentity_designator.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTentity_designator.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTentity_designator.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTentity_designator.java */
-/* JJT: 0.3pre1 */
-
-public class ASTentity_designator extends SimpleNode {
-  ASTentity_designator(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTentity_designator.java */
+/* JJT: 0.3pre1 */
+
+public class ASTentity_designator extends SimpleNode {
+  ASTentity_designator(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTentity_header.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTentity_header.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTentity_header.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTentity_header.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTentity_header.java */
-/* JJT: 0.3pre1 */
-
-public class ASTentity_header extends SimpleNode {
-  ASTentity_header(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTentity_header.java */
+/* JJT: 0.3pre1 */
+
+public class ASTentity_header extends SimpleNode {
+  ASTentity_header(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTentity_name_list.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTentity_name_list.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTentity_name_list.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTentity_name_list.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTentity_name_list.java */
-/* JJT: 0.3pre1 */
-
-public class ASTentity_name_list extends SimpleNode {
-  ASTentity_name_list(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTentity_name_list.java */
+/* JJT: 0.3pre1 */
+
+public class ASTentity_name_list extends SimpleNode {
+  ASTentity_name_list(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTentity_specification.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTentity_specification.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTentity_specification.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTentity_specification.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTentity_specification.java */
-/* JJT: 0.3pre1 */
-
-public class ASTentity_specification extends SimpleNode {
-  ASTentity_specification(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTentity_specification.java */
+/* JJT: 0.3pre1 */
+
+public class ASTentity_specification extends SimpleNode {
+  ASTentity_specification(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTentity_statement_part.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTentity_statement_part.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTentity_statement_part.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTentity_statement_part.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTentity_statement_part.java */
-/* JJT: 0.3pre1 */
-
-public class ASTentity_statement_part extends SimpleNode {
-  ASTentity_statement_part(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTentity_statement_part.java */
+/* JJT: 0.3pre1 */
+
+public class ASTentity_statement_part extends SimpleNode {
+  ASTentity_statement_part(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTentity_tag.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTentity_tag.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTentity_tag.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTentity_tag.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTentity_tag.java */
-/* JJT: 0.3pre1 */
-
-public class ASTentity_tag extends SimpleNode {
-  ASTentity_tag(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTentity_tag.java */
+/* JJT: 0.3pre1 */
+
+public class ASTentity_tag extends SimpleNode {
+  ASTentity_tag(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTenumeration_literal.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTenumeration_literal.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTenumeration_literal.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTenumeration_literal.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTenumeration_literal.java */
-/* JJT: 0.3pre1 */
-
-public class ASTenumeration_literal extends SimpleNode {
-  ASTenumeration_literal(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTenumeration_literal.java */
+/* JJT: 0.3pre1 */
+
+public class ASTenumeration_literal extends SimpleNode {
+  ASTenumeration_literal(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTenumeration_type_definition.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTenumeration_type_definition.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTenumeration_type_definition.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTenumeration_type_definition.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTenumeration_type_definition.java */
-/* JJT: 0.3pre1 */
-
-public class ASTenumeration_type_definition extends SimpleNode {
-  ASTenumeration_type_definition(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTenumeration_type_definition.java */
+/* JJT: 0.3pre1 */
+
+public class ASTenumeration_type_definition extends SimpleNode {
+  ASTenumeration_type_definition(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTerror_skipto.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTerror_skipto.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTerror_skipto.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTerror_skipto.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTerror_skipto.java */
-/* JJT: 0.3pre1 */
-
-public class ASTerror_skipto extends SimpleNode {
-  ASTerror_skipto(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTerror_skipto.java */
+/* JJT: 0.3pre1 */
+
+public class ASTerror_skipto extends SimpleNode {
+  ASTerror_skipto(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTexit_statement.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTexit_statement.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTexit_statement.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTexit_statement.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTexit_statement.java */
-/* JJT: 0.3pre1 */
-
-public class ASTexit_statement extends SimpleNode {
-  ASTexit_statement(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTexit_statement.java */
+/* JJT: 0.3pre1 */
+
+public class ASTexit_statement extends SimpleNode {
+  ASTexit_statement(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTfactor.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTfactor.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTfactor.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTfactor.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTfactor.java */
-/* JJT: 0.3pre1 */
-
-public class ASTfactor extends SimpleNode {
-  ASTfactor(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTfactor.java */
+/* JJT: 0.3pre1 */
+
+public class ASTfactor extends SimpleNode {
+  ASTfactor(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTfile_declaration.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTfile_declaration.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTfile_declaration.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTfile_declaration.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,29 +1,29 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTfile_declaration.java */
-/* JJT: 0.3pre1 */
-
-public class ASTfile_declaration extends SimpleNode {
-  ASTfile_declaration(int id) {
-    super(id);
-  }
-  
-  public String[] getIdentifierList(){
-	  return ((ASTidentifier_list)jjtGetChild(0)).getIdentifierNames();
-  }
-  
-  public String getSubType(){
-	  ASTsubtype_indication subtype= (ASTsubtype_indication)jjtGetChild(1);
-	  return subtype.getIdentifier();
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTfile_declaration.java */
+/* JJT: 0.3pre1 */
+
+public class ASTfile_declaration extends SimpleNode {
+  ASTfile_declaration(int id) {
+    super(id);
+  }
+  
+  public String[] getIdentifierList(){
+	  return ((ASTidentifier_list)jjtGetChild(0)).getIdentifierNames();
+  }
+  
+  public String getSubType(){
+	  ASTsubtype_indication subtype= (ASTsubtype_indication)jjtGetChild(1);
+	  return subtype.getIdentifier();
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTfile_open_information.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTfile_open_information.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTfile_open_information.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTfile_open_information.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTfile_open_information.java */
-/* JJT: 0.3pre1 */
-
-public class ASTfile_open_information extends SimpleNode {
-  ASTfile_open_information(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTfile_open_information.java */
+/* JJT: 0.3pre1 */
+
+public class ASTfile_open_information extends SimpleNode {
+  ASTfile_open_information(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTformal_parameter_list.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTformal_parameter_list.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTformal_parameter_list.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTformal_parameter_list.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,28 +1,28 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTformal_parameter_list.java */
-/* JJT: 0.3pre1 */
-
-public class ASTformal_parameter_list extends SimpleNode {
-  ASTformal_parameter_list(int id) {
-    super(id);
-  }
-  
-  public ASTinterface_list getInterfaceList(){
-	  for(Node child:children){
-		  if(child instanceof ASTinterface_list)
-			  return (ASTinterface_list)child; 
-	  }
-	  return null;
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTformal_parameter_list.java */
+/* JJT: 0.3pre1 */
+
+public class ASTformal_parameter_list extends SimpleNode {
+  ASTformal_parameter_list(int id) {
+    super(id);
+  }
+  
+  public ASTinterface_list getInterfaceList(){
+	  for(Node child:children){
+		  if(child instanceof ASTinterface_list)
+			  return (ASTinterface_list)child; 
+	  }
+	  return null;
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTfree_quantity_declaration.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTfree_quantity_declaration.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTfree_quantity_declaration.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTfree_quantity_declaration.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTfree_quantity_declaration.java */
-/* JJT: 0.3pre1 */
-
-public class ASTfree_quantity_declaration extends SimpleNode {
-  ASTfree_quantity_declaration(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTfree_quantity_declaration.java */
+/* JJT: 0.3pre1 */
+
+public class ASTfree_quantity_declaration extends SimpleNode {
+  ASTfree_quantity_declaration(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTfull_type_declaration.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTfull_type_declaration.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTfull_type_declaration.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTfull_type_declaration.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTfull_type_declaration.java */
-/* JJT: 0.3pre1 */
-
-public class ASTfull_type_declaration extends SimpleNode {
-  ASTfull_type_declaration(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTfull_type_declaration.java */
+/* JJT: 0.3pre1 */
+
+public class ASTfull_type_declaration extends SimpleNode {
+  ASTfull_type_declaration(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTfunction_call.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTfunction_call.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTfunction_call.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTfunction_call.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,29 +1,29 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-/* Generated By:JJTree: Do not edit this line. ASTfunction_call.java */
-/* JJT: 0.3pre1 */
-
-public class ASTfunction_call extends SimpleNode {
-	ASTfunction_call(int id) {
-		super(id);
-	}
-
-	@Override
-	public void jjtOpen() {
-		super.jjtOpen();
-	}
-
-	@Override
-	public void jjtClose() {
-		super.jjtClose();
-	}
-
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+/* Generated By:JJTree: Do not edit this line. ASTfunction_call.java */
+/* JJT: 0.3pre1 */
+
+public class ASTfunction_call extends SimpleNode {
+	ASTfunction_call(int id) {
+		super(id);
+	}
+
+	@Override
+	public void jjtOpen() {
+		super.jjtOpen();
+	}
+
+	@Override
+	public void jjtClose() {
+		super.jjtClose();
+	}
+
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTgenerate_statement.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTgenerate_statement.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTgenerate_statement.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTgenerate_statement.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTgenerate_statement.java */
-/* JJT: 0.3pre1 */
-
-public class ASTgenerate_statement extends SimpleNode {
-  ASTgenerate_statement(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTgenerate_statement.java */
+/* JJT: 0.3pre1 */
+
+public class ASTgenerate_statement extends SimpleNode {
+  ASTgenerate_statement(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTgeneration_scheme.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTgeneration_scheme.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTgeneration_scheme.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTgeneration_scheme.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTgeneration_scheme.java */
-/* JJT: 0.3pre1 */
-
-public class ASTgeneration_scheme extends SimpleNode {
-  ASTgeneration_scheme(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTgeneration_scheme.java */
+/* JJT: 0.3pre1 */
+
+public class ASTgeneration_scheme extends SimpleNode {
+  ASTgeneration_scheme(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTgeneric_clause.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTgeneric_clause.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTgeneric_clause.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTgeneric_clause.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,27 +1,27 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTgeneric_clause.java */
-/* JJT: 0.3pre1 */
-
-public class ASTgeneric_clause extends SimpleNode {
-  ASTgeneric_clause(int id) {
-    super(id);
-  }
-  public ASTinterface_list getInterfaceList(){
-	  for(Node child:children){
-		  if(child instanceof ASTinterface_list)
-			  return (ASTinterface_list)child; 
-	  }
-	  return null;
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTgeneric_clause.java */
+/* JJT: 0.3pre1 */
+
+public class ASTgeneric_clause extends SimpleNode {
+  ASTgeneric_clause(int id) {
+    super(id);
+  }
+  public ASTinterface_list getInterfaceList(){
+	  for(Node child:children){
+		  if(child instanceof ASTinterface_list)
+			  return (ASTinterface_list)child; 
+	  }
+	  return null;
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTgroup_constituent.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTgroup_constituent.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTgroup_constituent.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTgroup_constituent.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTgroup_constituent.java */
-/* JJT: 0.3pre1 */
-
-public class ASTgroup_constituent extends SimpleNode {
-  ASTgroup_constituent(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTgroup_constituent.java */
+/* JJT: 0.3pre1 */
+
+public class ASTgroup_constituent extends SimpleNode {
+  ASTgroup_constituent(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTgroup_constituent_list.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTgroup_constituent_list.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTgroup_constituent_list.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTgroup_constituent_list.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTgroup_constituent_list.java */
-/* JJT: 0.3pre1 */
-
-public class ASTgroup_constituent_list extends SimpleNode {
-  ASTgroup_constituent_list(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTgroup_constituent_list.java */
+/* JJT: 0.3pre1 */
+
+public class ASTgroup_constituent_list extends SimpleNode {
+  ASTgroup_constituent_list(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTgroup_declaration.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTgroup_declaration.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTgroup_declaration.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTgroup_declaration.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTgroup_declaration.java */
-/* JJT: 0.3pre1 */
-
-public class ASTgroup_declaration extends SimpleNode {
-  ASTgroup_declaration(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTgroup_declaration.java */
+/* JJT: 0.3pre1 */
+
+public class ASTgroup_declaration extends SimpleNode {
+  ASTgroup_declaration(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTgroup_template_declaration.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTgroup_template_declaration.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTgroup_template_declaration.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTgroup_template_declaration.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTgroup_template_declaration.java */
-/* JJT: 0.3pre1 */
-
-public class ASTgroup_template_declaration extends SimpleNode {
-  ASTgroup_template_declaration(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTgroup_template_declaration.java */
+/* JJT: 0.3pre1 */
+
+public class ASTgroup_template_declaration extends SimpleNode {
+  ASTgroup_template_declaration(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTguarded_signal_specification.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTguarded_signal_specification.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTguarded_signal_specification.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTguarded_signal_specification.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTguarded_signal_specification.java */
-/* JJT: 0.3pre1 */
-
-public class ASTguarded_signal_specification extends SimpleNode {
-  ASTguarded_signal_specification(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTguarded_signal_specification.java */
+/* JJT: 0.3pre1 */
+
+public class ASTguarded_signal_specification extends SimpleNode {
+  ASTguarded_signal_specification(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTidentifier.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTidentifier.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTidentifier.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTidentifier.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,21 +1,21 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTidentifier.java */
-/* JJT: 0.3pre1 */
-
-public class ASTidentifier extends SimpleNode {
-  ASTidentifier(int id) {
-    super(id);
-  }
-  String name;
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTidentifier.java */
+/* JJT: 0.3pre1 */
+
+public class ASTidentifier extends SimpleNode {
+  ASTidentifier(int id) {
+    super(id);
+  }
+  String name;
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTidentifier_list.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTidentifier_list.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTidentifier_list.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTidentifier_list.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,34 +1,34 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-import java.util.ArrayList;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTidentifier_list.java */
-/* JJT: 0.3pre1 */
-
-public class ASTidentifier_list extends SimpleNode {
-  ASTidentifier_list(int id) {
-    super(id);
-  }
-  
-  public String[] getIdentifierNames(){
-	  ArrayList<String> results=new ArrayList<String>();
-	  
-	  for(Node node:children){
-		  if (node instanceof ASTidentifier) {
-			ASTidentifier identifier = (ASTidentifier) node;
-			results.add(identifier.name);
-		}
-	  }
-	  return results.toArray(new String[0]);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+import java.util.ArrayList;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTidentifier_list.java */
+/* JJT: 0.3pre1 */
+
+public class ASTidentifier_list extends SimpleNode {
+  ASTidentifier_list(int id) {
+    super(id);
+  }
+  
+  public String[] getIdentifierNames(){
+	  ArrayList<String> results=new ArrayList<String>();
+	  
+	  for(Node node:children){
+		  if (node instanceof ASTidentifier) {
+			ASTidentifier identifier = (ASTidentifier) node;
+			results.add(identifier.name);
+		}
+	  }
+	  return results.toArray(new String[0]);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTif_statement.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTif_statement.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTif_statement.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTif_statement.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTif_statement.java */
-/* JJT: 0.3pre1 */
-
-public class ASTif_statement extends SimpleNode {
-  ASTif_statement(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTif_statement.java */
+/* JJT: 0.3pre1 */
+
+public class ASTif_statement extends SimpleNode {
+  ASTif_statement(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTincomplete_type_declaration.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTincomplete_type_declaration.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTincomplete_type_declaration.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTincomplete_type_declaration.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTincomplete_type_declaration.java */
-/* JJT: 0.3pre1 */
-
-public class ASTincomplete_type_declaration extends SimpleNode {
-  ASTincomplete_type_declaration(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTincomplete_type_declaration.java */
+/* JJT: 0.3pre1 */
+
+public class ASTincomplete_type_declaration extends SimpleNode {
+  ASTincomplete_type_declaration(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTindex_constraint.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTindex_constraint.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTindex_constraint.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTindex_constraint.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTindex_constraint.java */
-/* JJT: 0.3pre1 */
-
-public class ASTindex_constraint extends SimpleNode {
-  ASTindex_constraint(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTindex_constraint.java */
+/* JJT: 0.3pre1 */
+
+public class ASTindex_constraint extends SimpleNode {
+  ASTindex_constraint(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTindexed_name.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTindexed_name.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTindexed_name.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTindexed_name.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTindexed_name.java */
-/* JJT: 0.3pre1 */
-
-public class ASTindexed_name extends SimpleNode {
-  ASTindexed_name(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTindexed_name.java */
+/* JJT: 0.3pre1 */
+
+public class ASTindexed_name extends SimpleNode {
+  ASTindexed_name(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTindex_specification.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTindex_specification.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTindex_specification.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTindex_specification.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTindex_specification.java */
-/* JJT: 0.3pre1 */
-
-public class ASTindex_specification extends SimpleNode {
-  ASTindex_specification(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTindex_specification.java */
+/* JJT: 0.3pre1 */
+
+public class ASTindex_specification extends SimpleNode {
+  ASTindex_specification(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTindex_subtype_definition.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTindex_subtype_definition.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTindex_subtype_definition.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTindex_subtype_definition.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTindex_subtype_definition.java */
-/* JJT: 0.3pre1 */
-
-public class ASTindex_subtype_definition extends SimpleNode {
-  ASTindex_subtype_definition(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTindex_subtype_definition.java */
+/* JJT: 0.3pre1 */
+
+public class ASTindex_subtype_definition extends SimpleNode {
+  ASTindex_subtype_definition(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTinstantiated_unit.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTinstantiated_unit.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTinstantiated_unit.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTinstantiated_unit.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,46 +1,46 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTinstantiated_unit.java */
-/* JJT: 0.3pre1 */
-
-public class ASTinstantiated_unit extends SimpleNode {
-  ASTinstantiated_unit(int id) {
-    super(id);
-  }
-  
-  public String getName(){
-	  for (Node child:children){
-		  if(child instanceof ASTname){
-			  ASTname name=(ASTname)child;
-			  return name.getIdentifier();
-		  }		 
-	  }
-	  return "";
-  }
-  
-  public String getidentifier(){
-	  for (Node child:children){
-		  if(child instanceof ASTidentifier){
-			  return ((ASTidentifier)child).name;
-		  }		 
-	  }
-	  return "";
-  }
-  
-  public String getType(){
-	  if(getFirstToken()!=null){
-		  return getFirstToken().image;
-	  }
-	  return "";
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTinstantiated_unit.java */
+/* JJT: 0.3pre1 */
+
+public class ASTinstantiated_unit extends SimpleNode {
+  ASTinstantiated_unit(int id) {
+    super(id);
+  }
+  
+  public String getName(){
+	  for (Node child:children){
+		  if(child instanceof ASTname){
+			  ASTname name=(ASTname)child;
+			  return name.getIdentifier();
+		  }		 
+	  }
+	  return "";
+  }
+  
+  public String getidentifier(){
+	  for (Node child:children){
+		  if(child instanceof ASTidentifier){
+			  return ((ASTidentifier)child).name;
+		  }		 
+	  }
+	  return "";
+  }
+  
+  public String getType(){
+	  if(getFirstToken()!=null){
+		  return getFirstToken().image;
+	  }
+	  return "";
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTinstantiation_list.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTinstantiation_list.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTinstantiation_list.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTinstantiation_list.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTinstantiation_list.java */
-/* JJT: 0.3pre1 */
-
-public class ASTinstantiation_list extends SimpleNode {
-  ASTinstantiation_list(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTinstantiation_list.java */
+/* JJT: 0.3pre1 */
+
+public class ASTinstantiation_list extends SimpleNode {
+  ASTinstantiation_list(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTinterface_constant_declaration.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTinterface_constant_declaration.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTinterface_constant_declaration.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTinterface_constant_declaration.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,29 +1,29 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTinterface_constant_declaration.java */
-/* JJT: 0.3pre1 */
-
-public class ASTinterface_constant_declaration extends SimpleNode {
-  ASTinterface_constant_declaration(int id) {
-    super(id);
-  }
-  
-  public String[] getIdentifierList(){
-	  return ((ASTidentifier_list)jjtGetChild(0)).getIdentifierNames();
-  }
-  
-  public String getSubType(){
-	  ASTsubtype_indication subtype= (ASTsubtype_indication)jjtGetChild(1);
-	  return subtype.getIdentifier();
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTinterface_constant_declaration.java */
+/* JJT: 0.3pre1 */
+
+public class ASTinterface_constant_declaration extends SimpleNode {
+  ASTinterface_constant_declaration(int id) {
+    super(id);
+  }
+  
+  public String[] getIdentifierList(){
+	  return ((ASTidentifier_list)jjtGetChild(0)).getIdentifierNames();
+  }
+  
+  public String getSubType(){
+	  ASTsubtype_indication subtype= (ASTsubtype_indication)jjtGetChild(1);
+	  return subtype.getIdentifier();
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTinterface_file_declaration.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTinterface_file_declaration.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTinterface_file_declaration.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTinterface_file_declaration.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,30 +1,30 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTinterface_file_declaration.java */
-/* JJT: 0.3pre1 */
-
-public class ASTinterface_file_declaration extends SimpleNode {
-  ASTinterface_file_declaration(int id) {
-    super(id);
-  }
-  
-  public String[] getIdentifierList(){
-	  return ((ASTidentifier_list)jjtGetChild(0)).getIdentifierNames();
-  }
-  
-  public String getSubType(){
-	  ASTsubtype_indication subtype= (ASTsubtype_indication)getChild(1); 
-	  return subtype.getIdentifier();
-	
-  } 
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTinterface_file_declaration.java */
+/* JJT: 0.3pre1 */
+
+public class ASTinterface_file_declaration extends SimpleNode {
+  ASTinterface_file_declaration(int id) {
+    super(id);
+  }
+  
+  public String[] getIdentifierList(){
+	  return ((ASTidentifier_list)jjtGetChild(0)).getIdentifierNames();
+  }
+  
+  public String getSubType(){
+	  ASTsubtype_indication subtype= (ASTsubtype_indication)getChild(1); 
+	  return subtype.getIdentifier();
+	
+  } 
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTinterface_list.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTinterface_list.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTinterface_list.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTinterface_list.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,21 +1,21 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTinterface_list.java */
-/* JJT: 0.3pre1 */
-
-public class ASTinterface_list extends SimpleNode {
-  ASTinterface_list(int id) {
-    super(id);
-  }
-    
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTinterface_list.java */
+/* JJT: 0.3pre1 */
+
+public class ASTinterface_list extends SimpleNode {
+  ASTinterface_list(int id) {
+    super(id);
+  }
+    
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTinterface_quantity_declaration.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTinterface_quantity_declaration.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTinterface_quantity_declaration.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTinterface_quantity_declaration.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTinterface_quantity_declaration.java */
-/* JJT: 0.3pre1 */
-
-public class ASTinterface_quantity_declaration extends SimpleNode {
-  ASTinterface_quantity_declaration(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTinterface_quantity_declaration.java */
+/* JJT: 0.3pre1 */
+
+public class ASTinterface_quantity_declaration extends SimpleNode {
+  ASTinterface_quantity_declaration(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTinterface_signal_declaration.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTinterface_signal_declaration.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTinterface_signal_declaration.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTinterface_signal_declaration.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,44 +1,44 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTinterface_signal_declaration.java */
-/* JJT: 0.3pre1 */
-
-public class ASTinterface_signal_declaration extends SimpleNode {
-  ASTinterface_signal_declaration(int id) {
-    super(id);
-  }
-  
-  public String[] getIdentifierList(){
-	  return ((ASTidentifier_list)jjtGetChild(0)).getIdentifierNames();
-  }
-  
-  public String getSubType(){
-	  for(Node child:children){
-		  if(child instanceof ASTsubtype_indication){
-			  ASTsubtype_indication subtype= (ASTsubtype_indication)child; 
-			  return subtype.getIdentifier();
-		  }
-	  }
-	  return null;
-  }
-  
-  public String getMode(){
-	  for(Node child:children){
-		  if(child instanceof ASTmode){
-			  ASTmode mode=(ASTmode)child;
-			  return mode.getMode();
-		  }
-	  }
-	  return null;
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTinterface_signal_declaration.java */
+/* JJT: 0.3pre1 */
+
+public class ASTinterface_signal_declaration extends SimpleNode {
+  ASTinterface_signal_declaration(int id) {
+    super(id);
+  }
+  
+  public String[] getIdentifierList(){
+	  return ((ASTidentifier_list)jjtGetChild(0)).getIdentifierNames();
+  }
+  
+  public String getSubType(){
+	  for(Node child:children){
+		  if(child instanceof ASTsubtype_indication){
+			  ASTsubtype_indication subtype= (ASTsubtype_indication)child; 
+			  return subtype.getIdentifier();
+		  }
+	  }
+	  return null;
+  }
+  
+  public String getMode(){
+	  for(Node child:children){
+		  if(child instanceof ASTmode){
+			  ASTmode mode=(ASTmode)child;
+			  return mode.getMode();
+		  }
+	  }
+	  return null;
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTinterface_terminal_declaration.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTinterface_terminal_declaration.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTinterface_terminal_declaration.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTinterface_terminal_declaration.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTinterface_terminal_declaration.java */
-/* JJT: 0.3pre1 */
-
-public class ASTinterface_terminal_declaration extends SimpleNode {
-  ASTinterface_terminal_declaration(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTinterface_terminal_declaration.java */
+/* JJT: 0.3pre1 */
+
+public class ASTinterface_terminal_declaration extends SimpleNode {
+  ASTinterface_terminal_declaration(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTinterface_variable_declaration.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTinterface_variable_declaration.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTinterface_variable_declaration.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTinterface_variable_declaration.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,44 +1,44 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTinterface_variable_declaration.java */
-/* JJT: 0.3pre1 */
-
-public class ASTinterface_variable_declaration extends SimpleNode {
-  ASTinterface_variable_declaration(int id) {
-    super(id);
-  }
-  
-  public String[] getIdentifierList(){
-	  return ((ASTidentifier_list)jjtGetChild(0)).getIdentifierNames();
-  }
-  
-  public String getSubType(){
-	  for(Node child:children){
-		  if(child instanceof ASTsubtype_indication){
-			  ASTsubtype_indication subtype= (ASTsubtype_indication)child; 
-			  return subtype.getIdentifier();
-		  }
-	  }
-	  return null;
-  }
-  
-  public String getMode(){
-	  for(Node child:children){
-		  if(child instanceof ASTmode){
-			  ASTmode mode=(ASTmode)child;
-			  return mode.getMode();
-		  }
-	  }
-	  return null;
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTinterface_variable_declaration.java */
+/* JJT: 0.3pre1 */
+
+public class ASTinterface_variable_declaration extends SimpleNode {
+  ASTinterface_variable_declaration(int id) {
+    super(id);
+  }
+  
+  public String[] getIdentifierList(){
+	  return ((ASTidentifier_list)jjtGetChild(0)).getIdentifierNames();
+  }
+  
+  public String getSubType(){
+	  for(Node child:children){
+		  if(child instanceof ASTsubtype_indication){
+			  ASTsubtype_indication subtype= (ASTsubtype_indication)child; 
+			  return subtype.getIdentifier();
+		  }
+	  }
+	  return null;
+  }
+  
+  public String getMode(){
+	  for(Node child:children){
+		  if(child instanceof ASTmode){
+			  ASTmode mode=(ASTmode)child;
+			  return mode.getMode();
+		  }
+	  }
+	  return null;
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTiteration_scheme.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTiteration_scheme.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTiteration_scheme.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTiteration_scheme.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTiteration_scheme.java */
-/* JJT: 0.3pre1 */
-
-public class ASTiteration_scheme extends SimpleNode {
-  ASTiteration_scheme(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTiteration_scheme.java */
+/* JJT: 0.3pre1 */
+
+public class ASTiteration_scheme extends SimpleNode {
+  ASTiteration_scheme(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTliteral.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTliteral.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTliteral.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTliteral.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTliteral.java */
-/* JJT: 0.3pre1 */
-
-public class ASTliteral extends SimpleNode {
-  ASTliteral(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTliteral.java */
+/* JJT: 0.3pre1 */
+
+public class ASTliteral extends SimpleNode {
+  ASTliteral(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTlogical_name_list.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTlogical_name_list.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTlogical_name_list.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTlogical_name_list.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTlogical_name_list.java */
-/* JJT: 0.3pre1 */
-
-public class ASTlogical_name_list extends SimpleNode {
-  ASTlogical_name_list(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTlogical_name_list.java */
+/* JJT: 0.3pre1 */
+
+public class ASTlogical_name_list extends SimpleNode {
+  ASTlogical_name_list(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTloop_statement.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTloop_statement.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTloop_statement.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTloop_statement.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTloop_statement.java */
-/* JJT: 0.3pre1 */
-
-public class ASTloop_statement extends SimpleNode {
-  ASTloop_statement(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTloop_statement.java */
+/* JJT: 0.3pre1 */
+
+public class ASTloop_statement extends SimpleNode {
+  ASTloop_statement(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTmode.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTmode.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTmode.java	2016-06-24 10:29:40.860495408 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTmode.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,24 +1,24 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTmode.java */
-/* JJT: 0.3pre1 */
-
-public class ASTmode extends SimpleNode {
-  ASTmode(int id) {
-    super(id);
-  }
-  
-  public String getMode(){
-	  return first_token.image;
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTmode.java */
+/* JJT: 0.3pre1 */
+
+public class ASTmode extends SimpleNode {
+  ASTmode(int id) {
+    super(id);
+  }
+  
+  public String getMode(){
+	  return first_token.image;
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTname.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTname.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTname.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTname.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,24 +1,24 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTname.java */
-/* JJT: 0.3pre1 */
-
-public class ASTname extends SimpleNode {
-  ASTname(int id) {
-    super(id);
-  }
-  
-  public String getIdentifier(){
-	  return ((ASTidentifier)jjtGetChild(0)).name;
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTname.java */
+/* JJT: 0.3pre1 */
+
+public class ASTname extends SimpleNode {
+  ASTname(int id) {
+    super(id);
+  }
+  
+  public String getIdentifier(){
+	  return ((ASTidentifier)jjtGetChild(0)).name;
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTnature_declaration.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTnature_declaration.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTnature_declaration.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTnature_declaration.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTnature_declaration.java */
-/* JJT: 0.3pre1 */
-
-public class ASTnature_declaration extends SimpleNode {
-  ASTnature_declaration(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTnature_declaration.java */
+/* JJT: 0.3pre1 */
+
+public class ASTnature_declaration extends SimpleNode {
+  ASTnature_declaration(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTnature_element_declaration.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTnature_element_declaration.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTnature_element_declaration.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTnature_element_declaration.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTnature_element_declaration.java */
-/* JJT: 0.3pre1 */
-
-public class ASTnature_element_declaration extends SimpleNode {
-  ASTnature_element_declaration(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTnature_element_declaration.java */
+/* JJT: 0.3pre1 */
+
+public class ASTnature_element_declaration extends SimpleNode {
+  ASTnature_element_declaration(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTnext_statement.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTnext_statement.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTnext_statement.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTnext_statement.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTnext_statement.java */
-/* JJT: 0.3pre1 */
-
-public class ASTnext_statement extends SimpleNode {
-  ASTnext_statement(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTnext_statement.java */
+/* JJT: 0.3pre1 */
+
+public class ASTnext_statement extends SimpleNode {
+  ASTnext_statement(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTnull_statement.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTnull_statement.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTnull_statement.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTnull_statement.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTnull_statement.java */
-/* JJT: 0.3pre1 */
-
-public class ASTnull_statement extends SimpleNode {
-  ASTnull_statement(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTnull_statement.java */
+/* JJT: 0.3pre1 */
+
+public class ASTnull_statement extends SimpleNode {
+  ASTnull_statement(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASToperator_symbol.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASToperator_symbol.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASToperator_symbol.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASToperator_symbol.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASToperator_symbol.java */
-/* JJT: 0.3pre1 */
-
-public class ASToperator_symbol extends SimpleNode {
-  ASToperator_symbol(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASToperator_symbol.java */
+/* JJT: 0.3pre1 */
+
+public class ASToperator_symbol extends SimpleNode {
+  ASToperator_symbol(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASToptions_.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASToptions_.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASToptions_.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASToptions_.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASToptions_.java */
-/* JJT: 0.3pre1 */
-
-public class ASToptions_ extends SimpleNode {
-  ASToptions_(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASToptions_.java */
+/* JJT: 0.3pre1 */
+
+public class ASToptions_ extends SimpleNode {
+  ASToptions_(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTpackage_body_declarative_part.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTpackage_body_declarative_part.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTpackage_body_declarative_part.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTpackage_body_declarative_part.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTpackage_body_declarative_part.java */
-/* JJT: 0.3pre1 */
-
-public class ASTpackage_body_declarative_part extends SimpleNode {
-  ASTpackage_body_declarative_part(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTpackage_body_declarative_part.java */
+/* JJT: 0.3pre1 */
+
+public class ASTpackage_body_declarative_part extends SimpleNode {
+  ASTpackage_body_declarative_part(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTpackage_body.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTpackage_body.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTpackage_body.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTpackage_body.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,24 +1,24 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTpackage_body.java */
-/* JJT: 0.3pre1 */
-
-public class ASTpackage_body extends SimpleNode {
-  ASTpackage_body(int id) {
-    super(id);
-  }
-  public String getIdentifier(){
-	  return ((ASTidentifier)jjtGetChild(0)).name;
-  }
-  
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTpackage_body.java */
+/* JJT: 0.3pre1 */
+
+public class ASTpackage_body extends SimpleNode {
+  ASTpackage_body(int id) {
+    super(id);
+  }
+  public String getIdentifier(){
+	  return ((ASTidentifier)jjtGetChild(0)).name;
+  }
+  
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTpackage_declaration.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTpackage_declaration.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTpackage_declaration.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTpackage_declaration.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,25 +1,25 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTpackage_declaration.java */
-/* JJT: 0.3pre1 */
-
-public class ASTpackage_declaration extends SimpleNode {
-  ASTpackage_declaration(int id) {
-    super(id);
-  }
-  
-  public String getIdentifier(){
-	  return ((ASTidentifier)jjtGetChild(0)).name;
-  }
-  
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTpackage_declaration.java */
+/* JJT: 0.3pre1 */
+
+public class ASTpackage_declaration extends SimpleNode {
+  ASTpackage_declaration(int id) {
+    super(id);
+  }
+  
+  public String getIdentifier(){
+	  return ((ASTidentifier)jjtGetChild(0)).name;
+  }
+  
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTpackage_declarative_part.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTpackage_declarative_part.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTpackage_declarative_part.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTpackage_declarative_part.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,21 +1,21 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTpackage_declarative_part.java */
-/* JJT: 0.3pre1 */
-
-public class ASTpackage_declarative_part extends SimpleNode {
-  ASTpackage_declarative_part(int id) {
-    super(id);
-  }
-
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTpackage_declarative_part.java */
+/* JJT: 0.3pre1 */
+
+public class ASTpackage_declarative_part extends SimpleNode {
+  ASTpackage_declarative_part(int id) {
+    super(id);
+  }
+
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTparameter_specification.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTparameter_specification.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTparameter_specification.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTparameter_specification.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTparameter_specification.java */
-/* JJT: 0.3pre1 */
-
-public class ASTparameter_specification extends SimpleNode {
-  ASTparameter_specification(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTparameter_specification.java */
+/* JJT: 0.3pre1 */
+
+public class ASTparameter_specification extends SimpleNode {
+  ASTparameter_specification(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTphysical_literal.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTphysical_literal.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTphysical_literal.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTphysical_literal.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTphysical_literal.java */
-/* JJT: 0.3pre1 */
-
-public class ASTphysical_literal extends SimpleNode {
-  ASTphysical_literal(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTphysical_literal.java */
+/* JJT: 0.3pre1 */
+
+public class ASTphysical_literal extends SimpleNode {
+  ASTphysical_literal(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTphysical_type_definition.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTphysical_type_definition.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTphysical_type_definition.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTphysical_type_definition.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTphysical_type_definition.java */
-/* JJT: 0.3pre1 */
-
-public class ASTphysical_type_definition extends SimpleNode {
-  ASTphysical_type_definition(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTphysical_type_definition.java */
+/* JJT: 0.3pre1 */
+
+public class ASTphysical_type_definition extends SimpleNode {
+  ASTphysical_type_definition(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTport_clause.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTport_clause.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTport_clause.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTport_clause.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,33 +1,33 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/**
- * File modified from autogen version 
- * @author gho18481
- *
- */
-/* Generated By:JJTree: Do not edit this line. ASTport_clause.java */
-/* JJT: 0.3pre1 */
-
-public class ASTport_clause extends SimpleNode {
-  ASTport_clause(int id) {
-    super(id);
-  }
-    
-  public ASTinterface_list getInterfaceList(){
-	  for(Node child:children){
-		  if(child instanceof ASTinterface_list)
-			  return (ASTinterface_list)child; 
-	  }
-	  return null;
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/**
+ * File modified from autogen version 
+ * @author gho18481
+ *
+ */
+/* Generated By:JJTree: Do not edit this line. ASTport_clause.java */
+/* JJT: 0.3pre1 */
+
+public class ASTport_clause extends SimpleNode {
+  ASTport_clause(int id) {
+    super(id);
+  }
+    
+  public ASTinterface_list getInterfaceList(){
+	  for(Node child:children){
+		  if(child instanceof ASTinterface_list)
+			  return (ASTinterface_list)child; 
+	  }
+	  return null;
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTport_map_aspect.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTport_map_aspect.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTport_map_aspect.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTport_map_aspect.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTport_map_aspect.java */
-/* JJT: 0.3pre1 */
-
-public class ASTport_map_aspect extends SimpleNode {
-  ASTport_map_aspect(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTport_map_aspect.java */
+/* JJT: 0.3pre1 */
+
+public class ASTport_map_aspect extends SimpleNode {
+  ASTport_map_aspect(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTprefix.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTprefix.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTprefix.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTprefix.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTprefix.java */
-/* JJT: 0.3pre1 */
-
-public class ASTprefix extends SimpleNode {
-  ASTprefix(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTprefix.java */
+/* JJT: 0.3pre1 */
+
+public class ASTprefix extends SimpleNode {
+  ASTprefix(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTprocedural_declarative_part.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTprocedural_declarative_part.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTprocedural_declarative_part.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTprocedural_declarative_part.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTprocedural_declarative_part.java */
-/* JJT: 0.3pre1 */
-
-public class ASTprocedural_declarative_part extends SimpleNode {
-  ASTprocedural_declarative_part(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTprocedural_declarative_part.java */
+/* JJT: 0.3pre1 */
+
+public class ASTprocedural_declarative_part extends SimpleNode {
+  ASTprocedural_declarative_part(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTprocedural_statement_part.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTprocedural_statement_part.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTprocedural_statement_part.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTprocedural_statement_part.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTprocedural_statement_part.java */
-/* JJT: 0.3pre1 */
-
-public class ASTprocedural_statement_part extends SimpleNode {
-  ASTprocedural_statement_part(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTprocedural_statement_part.java */
+/* JJT: 0.3pre1 */
+
+public class ASTprocedural_statement_part extends SimpleNode {
+  ASTprocedural_statement_part(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTprocedure_call.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTprocedure_call.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTprocedure_call.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTprocedure_call.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTprocedure_call.java */
-/* JJT: 0.3pre1 */
-
-public class ASTprocedure_call extends SimpleNode {
-  ASTprocedure_call(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTprocedure_call.java */
+/* JJT: 0.3pre1 */
+
+public class ASTprocedure_call extends SimpleNode {
+  ASTprocedure_call(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTprocedure_call_statement.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTprocedure_call_statement.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTprocedure_call_statement.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTprocedure_call_statement.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTprocedure_call_statement.java */
-/* JJT: 0.3pre1 */
-
-public class ASTprocedure_call_statement extends SimpleNode {
-  ASTprocedure_call_statement(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTprocedure_call_statement.java */
+/* JJT: 0.3pre1 */
+
+public class ASTprocedure_call_statement extends SimpleNode {
+  ASTprocedure_call_statement(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTprocess_declarative_part.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTprocess_declarative_part.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTprocess_declarative_part.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTprocess_declarative_part.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTprocess_declarative_part.java */
-/* JJT: 0.3pre1 */
-
-public class ASTprocess_declarative_part extends SimpleNode {
-  ASTprocess_declarative_part(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTprocess_declarative_part.java */
+/* JJT: 0.3pre1 */
+
+public class ASTprocess_declarative_part extends SimpleNode {
+  ASTprocess_declarative_part(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTprocess_statement.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTprocess_statement.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTprocess_statement.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTprocess_statement.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,47 +1,47 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTprocess_statement.java */
-/* JJT: 0.3pre1 */
-
-public class ASTprocess_statement extends SimpleNode {
-  ASTprocess_statement(int id) {
-    super(id);
-  }
-
-  public String getIdentifier(){
-	  if(jjtGetChild(0) instanceof ASTidentifier){
-		  return ((ASTidentifier)jjtGetChild(0)).name;
-	  }
-	  return null;
-  }  
-
-  /**
-   * semantic-checks for process_statement
-   * - identifiers at beginning and end must match
-   * - ...
-   */
-  public void Check()
-  {
-	if(jjtGetChild(0) instanceof ASTidentifier){
-		String s1 = ((ASTidentifier)jjtGetChild(0)).name;
-	    int i = jjtGetNumChildren()-1;
-	    if (jjtGetChild(i).toString() == "identifier")
-	    {
-	      if ( s1.compareTo(((ASTidentifier)jjtGetChild(i)).name) != 0)
-	    	  getErrorHandler().Error("identifiers don't match: "+s1+"/="+
-	             ((ASTidentifier)jjtGetChild(i)).name,null);
-	    }
-	    CheckSIWGLevel1();
-	}
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTprocess_statement.java */
+/* JJT: 0.3pre1 */
+
+public class ASTprocess_statement extends SimpleNode {
+  ASTprocess_statement(int id) {
+    super(id);
+  }
+
+  public String getIdentifier(){
+	  if(jjtGetChild(0) instanceof ASTidentifier){
+		  return ((ASTidentifier)jjtGetChild(0)).name;
+	  }
+	  return null;
+  }  
+
+  /**
+   * semantic-checks for process_statement
+   * - identifiers at beginning and end must match
+   * - ...
+   */
+  public void Check()
+  {
+	if(jjtGetChild(0) instanceof ASTidentifier){
+		String s1 = ((ASTidentifier)jjtGetChild(0)).name;
+	    int i = jjtGetNumChildren()-1;
+	    if (jjtGetChild(i).toString() == "identifier")
+	    {
+	      if ( s1.compareTo(((ASTidentifier)jjtGetChild(i)).name) != 0)
+	    	  getErrorHandler().Error("identifiers don't match: "+s1+"/="+
+	             ((ASTidentifier)jjtGetChild(i)).name,null);
+	    }
+	    CheckSIWGLevel1();
+	}
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTprocess_statement_part.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTprocess_statement_part.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTprocess_statement_part.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTprocess_statement_part.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,21 +1,21 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTprocess_statement_part.java */
-/* JJT: 0.3pre1 */
-
-public class ASTprocess_statement_part extends SimpleNode {
-  ASTprocess_statement_part(int id) {
-    super(id);
-  }
-    
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTprocess_statement_part.java */
+/* JJT: 0.3pre1 */
+
+public class ASTprocess_statement_part extends SimpleNode {
+  ASTprocess_statement_part(int id) {
+    super(id);
+  }
+    
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTqualified_expression.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTqualified_expression.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTqualified_expression.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTqualified_expression.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTqualified_expression.java */
-/* JJT: 0.3pre1 */
-
-public class ASTqualified_expression extends SimpleNode {
-  ASTqualified_expression(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTqualified_expression.java */
+/* JJT: 0.3pre1 */
+
+public class ASTqualified_expression extends SimpleNode {
+  ASTqualified_expression(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTrange.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTrange.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTrange.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTrange.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTrange.java */
-/* JJT: 0.3pre1 */
-
-public class ASTrange extends SimpleNode {
-  ASTrange(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTrange.java */
+/* JJT: 0.3pre1 */
+
+public class ASTrange extends SimpleNode {
+  ASTrange(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTrecord_nature_definition.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTrecord_nature_definition.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTrecord_nature_definition.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTrecord_nature_definition.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTrecord_nature_definition.java */
-/* JJT: 0.3pre1 */
-
-public class ASTrecord_nature_definition extends SimpleNode {
-  ASTrecord_nature_definition(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTrecord_nature_definition.java */
+/* JJT: 0.3pre1 */
+
+public class ASTrecord_nature_definition extends SimpleNode {
+  ASTrecord_nature_definition(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTrecord_type_definition.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTrecord_type_definition.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTrecord_type_definition.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTrecord_type_definition.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,28 +1,28 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTrecord_type_definition.java */
-/* JJT: 0.3pre1 */
-
-public class ASTrecord_type_definition extends SimpleNode {
-  ASTrecord_type_definition(int id) {
-    super(id);
-  }
-
- public ASTinterface_list getInterfaceList(){
-	  for(Node child:children){
-		  if(child instanceof ASTinterface_list)
-			  return (ASTinterface_list)child; 
-	  }
-	  return null;
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTrecord_type_definition.java */
+/* JJT: 0.3pre1 */
+
+public class ASTrecord_type_definition extends SimpleNode {
+  ASTrecord_type_definition(int id) {
+    super(id);
+  }
+
+ public ASTinterface_list getInterfaceList(){
+	  for(Node child:children){
+		  if(child instanceof ASTinterface_list)
+			  return (ASTinterface_list)child; 
+	  }
+	  return null;
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTrelation.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTrelation.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTrelation.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTrelation.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTrelation.java */
-/* JJT: 0.3pre1 */
-
-public class ASTrelation extends SimpleNode {
-  ASTrelation(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTrelation.java */
+/* JJT: 0.3pre1 */
+
+public class ASTrelation extends SimpleNode {
+  ASTrelation(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTreport_statement.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTreport_statement.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTreport_statement.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTreport_statement.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTreport_statement.java */
-/* JJT: 0.3pre1 */
-
-public class ASTreport_statement extends SimpleNode {
-  ASTreport_statement(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTreport_statement.java */
+/* JJT: 0.3pre1 */
+
+public class ASTreport_statement extends SimpleNode {
+  ASTreport_statement(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTreturn_statement.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTreturn_statement.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTreturn_statement.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTreturn_statement.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTreturn_statement.java */
-/* JJT: 0.3pre1 */
-
-public class ASTreturn_statement extends SimpleNode {
-  ASTreturn_statement(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTreturn_statement.java */
+/* JJT: 0.3pre1 */
+
+public class ASTreturn_statement extends SimpleNode {
+  ASTreturn_statement(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTscalar_nature_definition.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTscalar_nature_definition.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTscalar_nature_definition.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTscalar_nature_definition.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTscalar_nature_definition.java */
-/* JJT: 0.3pre1 */
-
-public class ASTscalar_nature_definition extends SimpleNode {
-  ASTscalar_nature_definition(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTscalar_nature_definition.java */
+/* JJT: 0.3pre1 */
+
+public class ASTscalar_nature_definition extends SimpleNode {
+  ASTscalar_nature_definition(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsecondary_unit_declaration.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsecondary_unit_declaration.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsecondary_unit_declaration.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsecondary_unit_declaration.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTsecondary_unit_declaration.java */
-/* JJT: 0.3pre1 */
-
-public class ASTsecondary_unit_declaration extends SimpleNode {
-  ASTsecondary_unit_declaration(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTsecondary_unit_declaration.java */
+/* JJT: 0.3pre1 */
+
+public class ASTsecondary_unit_declaration extends SimpleNode {
+  ASTsecondary_unit_declaration(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTselected_name.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTselected_name.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTselected_name.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTselected_name.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTselected_name.java */
-/* JJT: 0.3pre1 */
-
-public class ASTselected_name extends SimpleNode {
-  ASTselected_name(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTselected_name.java */
+/* JJT: 0.3pre1 */
+
+public class ASTselected_name extends SimpleNode {
+  ASTselected_name(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTselected_signal_assignment.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTselected_signal_assignment.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTselected_signal_assignment.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTselected_signal_assignment.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTselected_signal_assignment.java */
-/* JJT: 0.3pre1 */
-
-public class ASTselected_signal_assignment extends SimpleNode {
-  ASTselected_signal_assignment(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTselected_signal_assignment.java */
+/* JJT: 0.3pre1 */
+
+public class ASTselected_signal_assignment extends SimpleNode {
+  ASTselected_signal_assignment(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTselected_waveforms.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTselected_waveforms.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTselected_waveforms.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTselected_waveforms.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTselected_waveforms.java */
-/* JJT: 0.3pre1 */
-
-public class ASTselected_waveforms extends SimpleNode {
-  ASTselected_waveforms(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTselected_waveforms.java */
+/* JJT: 0.3pre1 */
+
+public class ASTselected_waveforms extends SimpleNode {
+  ASTselected_waveforms(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsensitivity_list.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsensitivity_list.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsensitivity_list.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsensitivity_list.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTsensitivity_list.java */
-/* JJT: 0.3pre1 */
-
-public class ASTsensitivity_list extends SimpleNode {
-  ASTsensitivity_list(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTsensitivity_list.java */
+/* JJT: 0.3pre1 */
+
+public class ASTsensitivity_list extends SimpleNode {
+  ASTsensitivity_list(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsequence_of_statements.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsequence_of_statements.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsequence_of_statements.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsequence_of_statements.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTsequence_of_statements.java */
-/* JJT: 0.3pre1 */
-
-public class ASTsequence_of_statements extends SimpleNode {
-  ASTsequence_of_statements(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTsequence_of_statements.java */
+/* JJT: 0.3pre1 */
+
+public class ASTsequence_of_statements extends SimpleNode {
+  ASTsequence_of_statements(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTshared_variable_declaration.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTshared_variable_declaration.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTshared_variable_declaration.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTshared_variable_declaration.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTshared_variable_declaration.java */
-/* JJT: 0.3pre1 */
-
-public class ASTshared_variable_declaration extends SimpleNode {
-  ASTshared_variable_declaration(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTshared_variable_declaration.java */
+/* JJT: 0.3pre1 */
+
+public class ASTshared_variable_declaration extends SimpleNode {
+  ASTshared_variable_declaration(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTshift_expression.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTshift_expression.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTshift_expression.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTshift_expression.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTshift_expression.java */
-/* JJT: 0.3pre1 */
-
-public class ASTshift_expression extends SimpleNode {
-  ASTshift_expression(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTshift_expression.java */
+/* JJT: 0.3pre1 */
+
+public class ASTshift_expression extends SimpleNode {
+  ASTshift_expression(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsignal_assignment_statement.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsignal_assignment_statement.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsignal_assignment_statement.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsignal_assignment_statement.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTsignal_assignment_statement.java */
-/* JJT: 0.3pre1 */
-
-public class ASTsignal_assignment_statement extends SimpleNode {
-  ASTsignal_assignment_statement(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTsignal_assignment_statement.java */
+/* JJT: 0.3pre1 */
+
+public class ASTsignal_assignment_statement extends SimpleNode {
+  ASTsignal_assignment_statement(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsignal_declaration.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsignal_declaration.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsignal_declaration.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsignal_declaration.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,29 +1,29 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTsignal_declaration.java */
-/* JJT: 0.3pre1 */
-
-public class ASTsignal_declaration extends SimpleNode {
-  ASTsignal_declaration(int id) {
-    super(id);
-  }
-  
-  public String[] getIdentifierList(){
-	  return ((ASTidentifier_list)jjtGetChild(0)).getIdentifierNames();
-  }
-  
-  public String getSubType(){
-	  ASTsubtype_indication subtype= (ASTsubtype_indication)jjtGetChild(1);
-	  return subtype.getIdentifier();
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTsignal_declaration.java */
+/* JJT: 0.3pre1 */
+
+public class ASTsignal_declaration extends SimpleNode {
+  ASTsignal_declaration(int id) {
+    super(id);
+  }
+  
+  public String[] getIdentifierList(){
+	  return ((ASTidentifier_list)jjtGetChild(0)).getIdentifierNames();
+  }
+  
+  public String getSubType(){
+	  ASTsubtype_indication subtype= (ASTsubtype_indication)jjtGetChild(1);
+	  return subtype.getIdentifier();
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsignal_kind.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsignal_kind.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsignal_kind.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsignal_kind.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTsignal_kind.java */
-/* JJT: 0.3pre1 */
-
-public class ASTsignal_kind extends SimpleNode {
-  ASTsignal_kind(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTsignal_kind.java */
+/* JJT: 0.3pre1 */
+
+public class ASTsignal_kind extends SimpleNode {
+  ASTsignal_kind(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsignal_list.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsignal_list.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsignal_list.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsignal_list.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTsignal_list.java */
-/* JJT: 0.3pre1 */
-
-public class ASTsignal_list extends SimpleNode {
-  ASTsignal_list(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTsignal_list.java */
+/* JJT: 0.3pre1 */
+
+public class ASTsignal_list extends SimpleNode {
+  ASTsignal_list(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsignature.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsignature.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsignature.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsignature.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTsignature.java */
-/* JJT: 0.3pre1 */
-
-public class ASTsignature extends SimpleNode {
-  ASTsignature(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTsignature.java */
+/* JJT: 0.3pre1 */
+
+public class ASTsignature extends SimpleNode {
+  ASTsignature(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsign.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsign.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsign.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsign.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTsign.java */
-/* JJT: 0.3pre1 */
-
-public class ASTsign extends SimpleNode {
-  ASTsign(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTsign.java */
+/* JJT: 0.3pre1 */
+
+public class ASTsign extends SimpleNode {
+  ASTsign(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsimple_expression.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsimple_expression.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsimple_expression.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsimple_expression.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTsimple_expression.java */
-/* JJT: 0.3pre1 */
-
-public class ASTsimple_expression extends SimpleNode {
-  ASTsimple_expression(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTsimple_expression.java */
+/* JJT: 0.3pre1 */
+
+public class ASTsimple_expression extends SimpleNode {
+  ASTsimple_expression(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsimple_simultaneous_statement.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsimple_simultaneous_statement.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsimple_simultaneous_statement.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsimple_simultaneous_statement.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTsimple_simultaneous_statement.java */
-/* JJT: 0.3pre1 */
-
-public class ASTsimple_simultaneous_statement extends SimpleNode {
-  ASTsimple_simultaneous_statement(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTsimple_simultaneous_statement.java */
+/* JJT: 0.3pre1 */
+
+public class ASTsimple_simultaneous_statement extends SimpleNode {
+  ASTsimple_simultaneous_statement(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsimultaneous_alternative.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsimultaneous_alternative.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsimultaneous_alternative.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsimultaneous_alternative.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTsimultaneous_alternative.java */
-/* JJT: 0.3pre1 */
-
-public class ASTsimultaneous_alternative extends SimpleNode {
-  ASTsimultaneous_alternative(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTsimultaneous_alternative.java */
+/* JJT: 0.3pre1 */
+
+public class ASTsimultaneous_alternative extends SimpleNode {
+  ASTsimultaneous_alternative(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsimultaneous_case_statement.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsimultaneous_case_statement.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsimultaneous_case_statement.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsimultaneous_case_statement.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTsimultaneous_case_statement.java */
-/* JJT: 0.3pre1 */
-
-public class ASTsimultaneous_case_statement extends SimpleNode {
-  ASTsimultaneous_case_statement(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTsimultaneous_case_statement.java */
+/* JJT: 0.3pre1 */
+
+public class ASTsimultaneous_case_statement extends SimpleNode {
+  ASTsimultaneous_case_statement(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsimultaneous_if_statement.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsimultaneous_if_statement.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsimultaneous_if_statement.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsimultaneous_if_statement.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTsimultaneous_if_statement.java */
-/* JJT: 0.3pre1 */
-
-public class ASTsimultaneous_if_statement extends SimpleNode {
-  ASTsimultaneous_if_statement(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTsimultaneous_if_statement.java */
+/* JJT: 0.3pre1 */
+
+public class ASTsimultaneous_if_statement extends SimpleNode {
+  ASTsimultaneous_if_statement(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsimultaneous_null_statement.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsimultaneous_null_statement.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsimultaneous_null_statement.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsimultaneous_null_statement.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTsimultaneous_null_statement.java */
-/* JJT: 0.3pre1 */
-
-public class ASTsimultaneous_null_statement extends SimpleNode {
-  ASTsimultaneous_null_statement(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTsimultaneous_null_statement.java */
+/* JJT: 0.3pre1 */
+
+public class ASTsimultaneous_null_statement extends SimpleNode {
+  ASTsimultaneous_null_statement(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsimultaneous_procedural_statement.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsimultaneous_procedural_statement.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsimultaneous_procedural_statement.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsimultaneous_procedural_statement.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTsimultaneous_procedural_statement.java */
-/* JJT: 0.3pre1 */
-
-public class ASTsimultaneous_procedural_statement extends SimpleNode {
-  ASTsimultaneous_procedural_statement(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTsimultaneous_procedural_statement.java */
+/* JJT: 0.3pre1 */
+
+public class ASTsimultaneous_procedural_statement extends SimpleNode {
+  ASTsimultaneous_procedural_statement(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsimultaneous_statement_part.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsimultaneous_statement_part.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsimultaneous_statement_part.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsimultaneous_statement_part.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTsimultaneous_statement_part.java */
-/* JJT: 0.3pre1 */
-
-public class ASTsimultaneous_statement_part extends SimpleNode {
-  ASTsimultaneous_statement_part(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTsimultaneous_statement_part.java */
+/* JJT: 0.3pre1 */
+
+public class ASTsimultaneous_statement_part extends SimpleNode {
+  ASTsimultaneous_statement_part(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTslice_name.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTslice_name.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTslice_name.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTslice_name.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTslice_name.java */
-/* JJT: 0.3pre1 */
-
-public class ASTslice_name extends SimpleNode {
-  ASTslice_name(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTslice_name.java */
+/* JJT: 0.3pre1 */
+
+public class ASTslice_name extends SimpleNode {
+  ASTslice_name(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsource_aspect.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsource_aspect.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsource_aspect.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsource_aspect.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTsource_aspect.java */
-/* JJT: 0.3pre1 */
-
-public class ASTsource_aspect extends SimpleNode {
-  ASTsource_aspect(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTsource_aspect.java */
+/* JJT: 0.3pre1 */
+
+public class ASTsource_aspect extends SimpleNode {
+  ASTsource_aspect(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsource_quantity_declaration.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsource_quantity_declaration.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsource_quantity_declaration.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsource_quantity_declaration.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTsource_quantity_declaration.java */
-/* JJT: 0.3pre1 */
-
-public class ASTsource_quantity_declaration extends SimpleNode {
-  ASTsource_quantity_declaration(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTsource_quantity_declaration.java */
+/* JJT: 0.3pre1 */
+
+public class ASTsource_quantity_declaration extends SimpleNode {
+  ASTsource_quantity_declaration(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsubnature_declaration.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsubnature_declaration.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsubnature_declaration.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsubnature_declaration.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTsubnature_declaration.java */
-/* JJT: 0.3pre1 */
-
-public class ASTsubnature_declaration extends SimpleNode {
-  ASTsubnature_declaration(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTsubnature_declaration.java */
+/* JJT: 0.3pre1 */
+
+public class ASTsubnature_declaration extends SimpleNode {
+  ASTsubnature_declaration(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsubnature_indication.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsubnature_indication.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsubnature_indication.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsubnature_indication.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTsubnature_indication.java */
-/* JJT: 0.3pre1 */
-
-public class ASTsubnature_indication extends SimpleNode {
-  ASTsubnature_indication(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTsubnature_indication.java */
+/* JJT: 0.3pre1 */
+
+public class ASTsubnature_indication extends SimpleNode {
+  ASTsubnature_indication(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsubprogram_body.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsubprogram_body.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsubprogram_body.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsubprogram_body.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,24 +1,24 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTsubprogram_body.java */
-/* JJT: 0.3pre1 */
-
-public class ASTsubprogram_body extends SimpleNode {
-  ASTsubprogram_body(int id) {
-    super(id);
-  }
-  
-  ASTsubprogram_specification getSpecification(){
-	  return (ASTsubprogram_specification)getChild(0);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTsubprogram_body.java */
+/* JJT: 0.3pre1 */
+
+public class ASTsubprogram_body extends SimpleNode {
+  ASTsubprogram_body(int id) {
+    super(id);
+  }
+  
+  ASTsubprogram_specification getSpecification(){
+	  return (ASTsubprogram_specification)getChild(0);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsubprogram_declarative_part.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsubprogram_declarative_part.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsubprogram_declarative_part.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsubprogram_declarative_part.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTsubprogram_declarative_part.java */
-/* JJT: 0.3pre1 */
-
-public class ASTsubprogram_declarative_part extends SimpleNode {
-  ASTsubprogram_declarative_part(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTsubprogram_declarative_part.java */
+/* JJT: 0.3pre1 */
+
+public class ASTsubprogram_declarative_part extends SimpleNode {
+  ASTsubprogram_declarative_part(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsubprogram_specification.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsubprogram_specification.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsubprogram_specification.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsubprogram_specification.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,67 +1,67 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTsubprogram_specification.java */
-/* JJT: 0.3pre1 */
-
-public class ASTsubprogram_specification extends SimpleNode {
-  ASTsubprogram_specification(int id) {
-    super(id);
-  }
-  
-  public String getIdentifier(){
-	  Node child=getChild(0);
-	  if(child instanceof ASTidentifier){
-		  return ((ASTidentifier)child).name;
-	  }
-	  else if (child instanceof ASToperator_symbol){
-		  ASToperator_symbol symbol=(ASToperator_symbol)child;
-		  return symbol.first_token.image;
-	  }
-	  return "";
-  }
-  
-  public String getType(){
-	  String designator=getIdentifier();
-	  StringBuffer results=new StringBuffer();
-	  //scan until we find the designator, the token immediately before 
-	  //the designator is the type
-	  for(Token token=first_token; token!=null && token!=last_token; token=token.next){
-		  if(token.image.equals(designator)){
-			  break;
-		  }
-		  results.append(token.image);
-	  }
-	  
-	  return results.toString();
-  }
-  
-  public String getReturnType(){
-	  //the return type is a name
-	  for(Node child:children){
-		if(child instanceof ASTname){
-			return ((ASTname)child).getIdentifier();
-		}
-	  }
-	  return "";
-  }
-  
-  public ASTformal_parameter_list getParameters(){
-	//the return type is a name
-	  for(Node child:children){
-		if(child instanceof ASTformal_parameter_list){
-			return ((ASTformal_parameter_list)child);
-		}
-	  }
-	  return null;
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTsubprogram_specification.java */
+/* JJT: 0.3pre1 */
+
+public class ASTsubprogram_specification extends SimpleNode {
+  ASTsubprogram_specification(int id) {
+    super(id);
+  }
+  
+  public String getIdentifier(){
+	  Node child=getChild(0);
+	  if(child instanceof ASTidentifier){
+		  return ((ASTidentifier)child).name;
+	  }
+	  else if (child instanceof ASToperator_symbol){
+		  ASToperator_symbol symbol=(ASToperator_symbol)child;
+		  return symbol.first_token.image;
+	  }
+	  return "";
+  }
+  
+  public String getType(){
+	  String designator=getIdentifier();
+	  StringBuffer results=new StringBuffer();
+	  //scan until we find the designator, the token immediately before 
+	  //the designator is the type
+	  for(Token token=first_token; token!=null && token!=last_token; token=token.next){
+		  if(token.image.equals(designator)){
+			  break;
+		  }
+		  results.append(token.image);
+	  }
+	  
+	  return results.toString();
+  }
+  
+  public String getReturnType(){
+	  //the return type is a name
+	  for(Node child:children){
+		if(child instanceof ASTname){
+			return ((ASTname)child).getIdentifier();
+		}
+	  }
+	  return "";
+  }
+  
+  public ASTformal_parameter_list getParameters(){
+	//the return type is a name
+	  for(Node child:children){
+		if(child instanceof ASTformal_parameter_list){
+			return ((ASTformal_parameter_list)child);
+		}
+	  }
+	  return null;
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsubprogram_statement_part.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsubprogram_statement_part.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsubprogram_statement_part.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsubprogram_statement_part.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTsubprogram_statement_part.java */
-/* JJT: 0.3pre1 */
-
-public class ASTsubprogram_statement_part extends SimpleNode {
-  ASTsubprogram_statement_part(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTsubprogram_statement_part.java */
+/* JJT: 0.3pre1 */
+
+public class ASTsubprogram_statement_part extends SimpleNode {
+  ASTsubprogram_statement_part(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsubtype_declaration.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsubtype_declaration.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsubtype_declaration.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsubtype_declaration.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,48 +1,48 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-import net.sourceforge.veditor.parser.vhdl.Token;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTsubtype_declaration.java */
-/* JJT: 0.3pre1 */
-
-public class ASTsubtype_declaration extends SimpleNode {
-  ASTsubtype_declaration(int id) {
-    super(id);
-  }
-  
-  public String getIdentifier(){
-	  //ASTname astName=(ASTname)getChild(0);
-	  //return ((ASTidentifier)(astName.getChild(0))).name;
-	  
-	  String completetype = "";
-	  Token curtoken = getFirstToken();
-	  if(curtoken!=null) {
-		  curtoken = curtoken.next;
-		  if(curtoken != null) completetype = curtoken.toString();
-	  }
-	  return completetype;
-	  
-	  
-	  /*
-	  String completetype = "";
-	  Token curtoken = getFirstToken();
-	  if(curtoken!=null) {
-		  completetype = curtoken.toString();
-		  while(curtoken!=getLastToken() && curtoken.next!=null) {
-			  curtoken = curtoken.next;
-			  completetype = completetype + " " +curtoken.toString();
-		  }
-	  }
-	  return completetype;*/
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+import com.elphel.vdt.veditor.parser.vhdl.Token;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTsubtype_declaration.java */
+/* JJT: 0.3pre1 */
+
+public class ASTsubtype_declaration extends SimpleNode {
+  ASTsubtype_declaration(int id) {
+    super(id);
+  }
+  
+  public String getIdentifier(){
+	  //ASTname astName=(ASTname)getChild(0);
+	  //return ((ASTidentifier)(astName.getChild(0))).name;
+	  
+	  String completetype = "";
+	  Token curtoken = getFirstToken();
+	  if(curtoken!=null) {
+		  curtoken = curtoken.next;
+		  if(curtoken != null) completetype = curtoken.toString();
+	  }
+	  return completetype;
+	  
+	  
+	  /*
+	  String completetype = "";
+	  Token curtoken = getFirstToken();
+	  if(curtoken!=null) {
+		  completetype = curtoken.toString();
+		  while(curtoken!=getLastToken() && curtoken.next!=null) {
+			  curtoken = curtoken.next;
+			  completetype = completetype + " " +curtoken.toString();
+		  }
+	  }
+	  return completetype;*/
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsubtype_indication.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsubtype_indication.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTsubtype_indication.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTsubtype_indication.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,36 +1,36 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTsubtype_indication.java */
-/* JJT: 0.3pre1 */
-
-public class ASTsubtype_indication extends SimpleNode {
-  ASTsubtype_indication(int id) {
-    super(id);
-  }
-  
-  public String getIdentifier(){
-	  //ASTname astName=(ASTname)getChild(0);
-	  //return ((ASTidentifier)(astName.getChild(0))).name;
-	  
-	  String completetype = "";
-	  Token curtoken = getFirstToken();
-	  if(curtoken!=null) {
-		  completetype = curtoken.toString();
-		  while(curtoken!=getLastToken() && curtoken.next!=null) {
-			  curtoken = curtoken.next;
-			  completetype = completetype + " " +curtoken.toString();
-		  }
-	  }
-	  return completetype;
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTsubtype_indication.java */
+/* JJT: 0.3pre1 */
+
+public class ASTsubtype_indication extends SimpleNode {
+  ASTsubtype_indication(int id) {
+    super(id);
+  }
+  
+  public String getIdentifier(){
+	  //ASTname astName=(ASTname)getChild(0);
+	  //return ((ASTidentifier)(astName.getChild(0))).name;
+	  
+	  String completetype = "";
+	  Token curtoken = getFirstToken();
+	  if(curtoken!=null) {
+		  completetype = curtoken.toString();
+		  while(curtoken!=getLastToken() && curtoken.next!=null) {
+			  curtoken = curtoken.next;
+			  completetype = completetype + " " +curtoken.toString();
+		  }
+	  }
+	  return completetype;
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTterminal_aspect.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTterminal_aspect.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTterminal_aspect.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTterminal_aspect.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTterminal_aspect.java */
-/* JJT: 0.3pre1 */
-
-public class ASTterminal_aspect extends SimpleNode {
-  ASTterminal_aspect(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTterminal_aspect.java */
+/* JJT: 0.3pre1 */
+
+public class ASTterminal_aspect extends SimpleNode {
+  ASTterminal_aspect(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTterminal_declaration.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTterminal_declaration.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTterminal_declaration.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTterminal_declaration.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTterminal_declaration.java */
-/* JJT: 0.3pre1 */
-
-public class ASTterminal_declaration extends SimpleNode {
-  ASTterminal_declaration(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTterminal_declaration.java */
+/* JJT: 0.3pre1 */
+
+public class ASTterminal_declaration extends SimpleNode {
+  ASTterminal_declaration(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTterm.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTterm.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTterm.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTterm.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTterm.java */
-/* JJT: 0.3pre1 */
-
-public class ASTterm extends SimpleNode {
-  ASTterm(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTterm.java */
+/* JJT: 0.3pre1 */
+
+public class ASTterm extends SimpleNode {
+  ASTterm(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTthrough_aspect.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTthrough_aspect.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTthrough_aspect.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTthrough_aspect.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTthrough_aspect.java */
-/* JJT: 0.3pre1 */
-
-public class ASTthrough_aspect extends SimpleNode {
-  ASTthrough_aspect(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTthrough_aspect.java */
+/* JJT: 0.3pre1 */
+
+public class ASTthrough_aspect extends SimpleNode {
+  ASTthrough_aspect(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTtype_conversion.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTtype_conversion.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTtype_conversion.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTtype_conversion.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTtype_conversion.java */
-/* JJT: 0.3pre1 */
-
-public class ASTtype_conversion extends SimpleNode {
-  ASTtype_conversion(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTtype_conversion.java */
+/* JJT: 0.3pre1 */
+
+public class ASTtype_conversion extends SimpleNode {
+  ASTtype_conversion(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTunconstrained_array_definition.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTunconstrained_array_definition.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTunconstrained_array_definition.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTunconstrained_array_definition.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTunconstrained_array_definition.java */
-/* JJT: 0.3pre1 */
-
-public class ASTunconstrained_array_definition extends SimpleNode {
-  ASTunconstrained_array_definition(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTunconstrained_array_definition.java */
+/* JJT: 0.3pre1 */
+
+public class ASTunconstrained_array_definition extends SimpleNode {
+  ASTunconstrained_array_definition(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTunconstrained_nature_definition.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTunconstrained_nature_definition.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTunconstrained_nature_definition.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTunconstrained_nature_definition.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTunconstrained_nature_definition.java */
-/* JJT: 0.3pre1 */
-
-public class ASTunconstrained_nature_definition extends SimpleNode {
-  ASTunconstrained_nature_definition(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTunconstrained_nature_definition.java */
+/* JJT: 0.3pre1 */
+
+public class ASTunconstrained_nature_definition extends SimpleNode {
+  ASTunconstrained_nature_definition(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTuse_clause.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTuse_clause.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTuse_clause.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTuse_clause.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTuse_clause.java */
-/* JJT: 0.3pre1 */
-
-public class ASTuse_clause extends SimpleNode {
-  ASTuse_clause(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTuse_clause.java */
+/* JJT: 0.3pre1 */
+
+public class ASTuse_clause extends SimpleNode {
+  ASTuse_clause(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTvariable_assignment_statement.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTvariable_assignment_statement.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTvariable_assignment_statement.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTvariable_assignment_statement.java	2016-06-24 10:29:40.820496516 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTvariable_assignment_statement.java */
-/* JJT: 0.3pre1 */
-
-public class ASTvariable_assignment_statement extends SimpleNode {
-  ASTvariable_assignment_statement(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTvariable_assignment_statement.java */
+/* JJT: 0.3pre1 */
+
+public class ASTvariable_assignment_statement extends SimpleNode {
+  ASTvariable_assignment_statement(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTvariable_declaration.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTvariable_declaration.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTvariable_declaration.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTvariable_declaration.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,39 +1,39 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-/* Generated By:JJTree: Do not edit this line. ASTvariable_declaration.java */
-/* JJT: 0.3pre1 */
-
-public class ASTvariable_declaration extends SimpleNode {
-	ASTvariable_declaration(int id) {
-		super(id);
-	}
-
-	@Override
-	public void jjtOpen() {
-		// TODO Auto-generated method stub
-		super.jjtOpen();
-	}
-
-	@Override
-	public void jjtClose() {
-		// TODO Auto-generated method stub
-		super.jjtClose();
-	}
-
-	public String[] getIdentifierList() {
-		return ((ASTidentifier_list) jjtGetChild(0)).getIdentifierNames();
-	}
-
-	public String getSubType() {
-		ASTsubtype_indication subtype = (ASTsubtype_indication) jjtGetChild(1);
-		return subtype.getIdentifier();
-	}
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+/* Generated By:JJTree: Do not edit this line. ASTvariable_declaration.java */
+/* JJT: 0.3pre1 */
+
+public class ASTvariable_declaration extends SimpleNode {
+	ASTvariable_declaration(int id) {
+		super(id);
+	}
+
+	@Override
+	public void jjtOpen() {
+		// TODO Auto-generated method stub
+		super.jjtOpen();
+	}
+
+	@Override
+	public void jjtClose() {
+		// TODO Auto-generated method stub
+		super.jjtClose();
+	}
+
+	public String[] getIdentifierList() {
+		return ((ASTidentifier_list) jjtGetChild(0)).getIdentifierNames();
+	}
+
+	public String getSubType() {
+		ASTsubtype_indication subtype = (ASTsubtype_indication) jjtGetChild(1);
+		return subtype.getIdentifier();
+	}
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTwait_statement.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTwait_statement.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTwait_statement.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTwait_statement.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTwait_statement.java */
-/* JJT: 0.3pre1 */
-
-public class ASTwait_statement extends SimpleNode {
-  ASTwait_statement(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTwait_statement.java */
+/* JJT: 0.3pre1 */
+
+public class ASTwait_statement extends SimpleNode {
+  ASTwait_statement(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTwaveform_element.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTwaveform_element.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTwaveform_element.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTwaveform_element.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTwaveform_element.java */
-/* JJT: 0.3pre1 */
-
-public class ASTwaveform_element extends SimpleNode {
-  ASTwaveform_element(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTwaveform_element.java */
+/* JJT: 0.3pre1 */
+
+public class ASTwaveform_element extends SimpleNode {
+  ASTwaveform_element(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTwaveform.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTwaveform.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ASTwaveform.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ASTwaveform.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,20 +1,20 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. ASTwaveform.java */
-/* JJT: 0.3pre1 */
-
-public class ASTwaveform extends SimpleNode {
-  ASTwaveform(int id) {
-    super(id);
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. ASTwaveform.java */
+/* JJT: 0.3pre1 */
+
+public class ASTwaveform extends SimpleNode {
+  ASTwaveform(int id) {
+    super(id);
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ErrorHandler.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/ErrorHandler.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/ErrorHandler.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/ErrorHandler.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,111 +1,111 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-import java.util.ArrayList;
-
-/**
- * (c) 1997 Christoph Grimm, J. W. Goethe-University.
- * Beginning of an error handler, should organize different
- * error messages, depending on a chosen level of error reporting. 
- * Still very simple.
- */
-
-class ErrorHandler {
-	private VhdlParserCore m_Parser;
-	private ArrayList<Error> m_Warnings = new ArrayList<Error>();
-	private ArrayList<Error> m_Errors = new ArrayList<Error>();
-
-	public ErrorHandler(VhdlParserCore parser) {
-		m_Parser = parser;
-	}
-
-	/**
-	 * Print a warning, that a construct is not supported in SIWG Level 1,
-	 * if this is switched on by command line.
-	 */
-	void WarnLevel1(String w) {
-		Token t = m_Parser.getToken(0);
-		Error error = new Error(
-				"line (" + t.beginLine + "): " + w,
-				t.beginLine,
-				null);		
-		m_Warnings.add(error);
-	}
-
-	/**
-	 * Print a warning, that a semantic/syntactic error has occurred.
-	 */
-	void Error(String w,Exception e) {
-		Token t = m_Parser.getToken(0);
-		Error error = new Error(
-						"line (" + t.beginLine + "): " + w,
-						t.beginLine,
-						e);
-		m_Errors.add(error);
-	}
-
-	/**
-	 * Print a summary, consisting of all numbers of errors and warnings
-	 * detected.
-	 */
-	void Summary() {
-		if(getErrors().length > 0){
-			System.err.println("Errors:");
-		}
-		for (Error error : getErrors()) {
-			System.err.println(error.m_Message);
-		}
-		if(getWarnings().length > 0){
-			System.err.println("Warnings:");
-		}
-		for (Error error : getWarnings()) {
-			System.err.println(error.m_Message);
-		}
-	}
-
-	public Error[] getErrors() {
-		return m_Errors.toArray(new Error[0]);
-	}
-
-	public Error[] getWarnings() {
-		return m_Warnings.toArray(new Error[0]);
-	}
-
-	/**
-	 * Class used to hold information about the message
-	 * @author gho18481
-	 *
-	 */
-	public class Error {
-		private String m_Message;
-		private int m_Line;
-		private Exception m_Exception;
-		
-		public Error(String msg,int line,Exception e){
-			m_Message=msg;
-			m_Line=line;
-			m_Exception=e;
-		}
-		public String getMessage(){
-			StringBuffer results=new StringBuffer(m_Message);
-			
-			if(m_Exception!=null){
-				results.append("\nPossible Cause:\n");
-				String exceptionMesg=m_Exception.toString();
-				//clean up the message
-				results.append(exceptionMesg.substring(exceptionMesg.indexOf(':')+1));				
-			}
-			
-			return results.toString();
-		}
-		public int getLine(){return m_Line;}
-		public Exception getException(){return m_Exception;}
-	}
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+import java.util.ArrayList;
+
+/**
+ * (c) 1997 Christoph Grimm, J. W. Goethe-University.
+ * Beginning of an error handler, should organize different
+ * error messages, depending on a chosen level of error reporting. 
+ * Still very simple.
+ */
+
+class ErrorHandler {
+	private VhdlParserCore m_Parser;
+	private ArrayList<Error> m_Warnings = new ArrayList<Error>();
+	private ArrayList<Error> m_Errors = new ArrayList<Error>();
+
+	public ErrorHandler(VhdlParserCore parser) {
+		m_Parser = parser;
+	}
+
+	/**
+	 * Print a warning, that a construct is not supported in SIWG Level 1,
+	 * if this is switched on by command line.
+	 */
+	void WarnLevel1(String w) {
+		Token t = m_Parser.getToken(0);
+		Error error = new Error(
+				"line (" + t.beginLine + "): " + w,
+				t.beginLine,
+				null);		
+		m_Warnings.add(error);
+	}
+
+	/**
+	 * Print a warning, that a semantic/syntactic error has occurred.
+	 */
+	void Error(String w,Exception e) {
+		Token t = m_Parser.getToken(0);
+		Error error = new Error(
+						"line (" + t.beginLine + "): " + w,
+						t.beginLine,
+						e);
+		m_Errors.add(error);
+	}
+
+	/**
+	 * Print a summary, consisting of all numbers of errors and warnings
+	 * detected.
+	 */
+	void Summary() {
+		if(getErrors().length > 0){
+			System.err.println("Errors:");
+		}
+		for (Error error : getErrors()) {
+			System.err.println(error.m_Message);
+		}
+		if(getWarnings().length > 0){
+			System.err.println("Warnings:");
+		}
+		for (Error error : getWarnings()) {
+			System.err.println(error.m_Message);
+		}
+	}
+
+	public Error[] getErrors() {
+		return m_Errors.toArray(new Error[0]);
+	}
+
+	public Error[] getWarnings() {
+		return m_Warnings.toArray(new Error[0]);
+	}
+
+	/**
+	 * Class used to hold information about the message
+	 * @author gho18481
+	 *
+	 */
+	public class Error {
+		private String m_Message;
+		private int m_Line;
+		private Exception m_Exception;
+		
+		public Error(String msg,int line,Exception e){
+			m_Message=msg;
+			m_Line=line;
+			m_Exception=e;
+		}
+		public String getMessage(){
+			StringBuffer results=new StringBuffer(m_Message);
+			
+			if(m_Exception!=null){
+				results.append("\nPossible Cause:\n");
+				String exceptionMesg=m_Exception.toString();
+				//clean up the message
+				results.append(exceptionMesg.substring(exceptionMesg.indexOf(':')+1));				
+			}
+			
+			return results.toString();
+		}
+		public int getLine(){return m_Line;}
+		public Exception getException(){return m_Exception;}
+	}
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/Helper.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/Helper.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/Helper.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/Helper.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,5 +1,5 @@
-package net.sourceforge.veditor.parser.vhdl;
-
-public class Helper {
-
-}
+package com.elphel.vdt.veditor.parser.vhdl;
+
+public class Helper {
+
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/JJTVhdlParserCoreState.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/JJTVhdlParserCoreState.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/JJTVhdlParserCoreState.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/JJTVhdlParserCoreState.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,123 +1,123 @@
-/* Generated By:JavaCC: Do not edit this line. JJTVhdlParserCoreState.java Version 5.0 */
-package net.sourceforge.veditor.parser.vhdl;
-
-public class JJTVhdlParserCoreState {
-  private java.util.List<Node> nodes;
-  private java.util.List<Integer> marks;
-
-  private int sp;        // number of nodes on stack
-  private int mk;        // current mark
-  private boolean node_created;
-
-  public JJTVhdlParserCoreState() {
-    nodes = new java.util.ArrayList<Node>();
-    marks = new java.util.ArrayList<Integer>();
-    sp = 0;
-    mk = 0;
-  }
-
-  /* Determines whether the current node was actually closed and
-     pushed.  This should only be called in the final user action of a
-     node scope.  */
-  public boolean nodeCreated() {
-    return node_created;
-  }
-
-  /* Call this to reinitialize the node stack.  It is called
-     automatically by the parser's ReInit() method. */
-  public void reset() {
-    nodes.clear();
-    marks.clear();
-    sp = 0;
-    mk = 0;
-  }
-
-  /* Returns the root node of the AST.  It only makes sense to call
-     this after a successful parse. */
-  public Node rootNode() {
-    return nodes.get(0);
-  }
-
-  /* Pushes a node on to the stack. */
-  public void pushNode(Node n) {
-    nodes.add(n);
-    ++sp;
-  }
-
-  /* Returns the node on the top of the stack, and remove it from the
-     stack.  */
-  public Node popNode() {
-    if (--sp < mk) {
-      mk = marks.remove(marks.size()-1);
-    }
-    return nodes.remove(nodes.size()-1);
-  }
-
-  /* Returns the node currently on the top of the stack. */
-  public Node peekNode() {
-    return nodes.get(nodes.size()-1);
-  }
-
-  /* Returns the number of children on the stack in the current node
-     scope. */
-  public int nodeArity() {
-    return sp - mk;
-  }
-
-
-  public void clearNodeScope(Node n) {
-    while (sp > mk) {
-      popNode();
-    }
-    mk = marks.remove(marks.size()-1);
-  }
-
-
-  public void openNodeScope(Node n) {
-    marks.add(mk);
-    mk = sp;
-    n.jjtOpen();
-  }
-
-
-  /* A definite node is constructed from a specified number of
-     children.  That number of nodes are popped from the stack and
-     made the children of the definite node.  Then the definite node
-     is pushed on to the stack. */
-  public void closeNodeScope(Node n, int num) {
-    mk = marks.remove(marks.size()-1);
-    while (num-- > 0) {
-      Node c = popNode();
-      c.jjtSetParent(n);
-      n.jjtAddChild(c, num);
-    }
-    n.jjtClose();
-    pushNode(n);
-    node_created = true;
-  }
-
-
-  /* A conditional node is constructed if its condition is true.  All
-     the nodes that have been pushed since the node was opened are
-     made children of the conditional node, which is then pushed
-     on to the stack.  If the condition is false the node is not
-     constructed and they are left on the stack. */
-  public void closeNodeScope(Node n, boolean condition) {
-    if (condition) {
-      int a = nodeArity();
-      mk = marks.remove(marks.size()-1);
-      while (a-- > 0) {
-        Node c = popNode();
-        c.jjtSetParent(n);
-        n.jjtAddChild(c, a);
-      }
-      n.jjtClose();
-      pushNode(n);
-      node_created = true;
-    } else {
-      mk = marks.remove(marks.size()-1);
-      node_created = false;
-    }
-  }
-}
-/* JavaCC - OriginalChecksum=91c13c82b6a8075d98c3d1486b5e3c43 (do not edit this line) */
+/* Generated By:JavaCC: Do not edit this line. JJTVhdlParserCoreState.java Version 6.0_1 */
+package com.elphel.vdt.veditor.parser.vhdl;
+
+public class JJTVhdlParserCoreState {
+  private java.util.List<Node> nodes;
+  private java.util.List<Integer> marks;
+
+  private int sp;        // number of nodes on stack
+  private int mk;        // current mark
+  private boolean node_created;
+
+  public JJTVhdlParserCoreState() {
+    nodes = new java.util.ArrayList<Node>();
+    marks = new java.util.ArrayList<Integer>();
+    sp = 0;
+    mk = 0;
+  }
+
+  /* Determines whether the current node was actually closed and
+     pushed.  This should only be called in the final user action of a
+     node scope.  */
+  public boolean nodeCreated() {
+    return node_created;
+  }
+
+  /* Call this to reinitialize the node stack.  It is called
+     automatically by the parser's ReInit() method. */
+  public void reset() {
+    nodes.clear();
+    marks.clear();
+    sp = 0;
+    mk = 0;
+  }
+
+  /* Returns the root node of the AST.  It only makes sense to call
+     this after a successful parse. */
+  public Node rootNode() {
+    return nodes.get(0);
+  }
+
+  /* Pushes a node on to the stack. */
+  public void pushNode(Node n) {
+    nodes.add(n);
+    ++sp;
+  }
+
+  /* Returns the node on the top of the stack, and remove it from the
+     stack.  */
+  public Node popNode() {
+    if (--sp < mk) {
+      mk = marks.remove(marks.size()-1);
+    }
+    return nodes.remove(nodes.size()-1);
+  }
+
+  /* Returns the node currently on the top of the stack. */
+  public Node peekNode() {
+    return nodes.get(nodes.size()-1);
+  }
+
+  /* Returns the number of children on the stack in the current node
+     scope. */
+  public int nodeArity() {
+    return sp - mk;
+  }
+
+
+  public void clearNodeScope(Node n) {
+    while (sp > mk) {
+      popNode();
+    }
+    mk = marks.remove(marks.size()-1);
+  }
+
+
+  public void openNodeScope(Node n) {
+    marks.add(mk);
+    mk = sp;
+    n.jjtOpen();
+  }
+
+
+  /* A definite node is constructed from a specified number of
+     children.  That number of nodes are popped from the stack and
+     made the children of the definite node.  Then the definite node
+     is pushed on to the stack. */
+  public void closeNodeScope(Node n, int num) {
+    mk = marks.remove(marks.size()-1);
+    while (num-- > 0) {
+      Node c = popNode();
+      c.jjtSetParent(n);
+      n.jjtAddChild(c, num);
+    }
+    n.jjtClose();
+    pushNode(n);
+    node_created = true;
+  }
+
+
+  /* A conditional node is constructed if its condition is true.  All
+     the nodes that have been pushed since the node was opened are
+     made children of the conditional node, which is then pushed
+     on to the stack.  If the condition is false the node is not
+     constructed and they are left on the stack. */
+  public void closeNodeScope(Node n, boolean condition) {
+    if (condition) {
+      int a = nodeArity();
+      mk = marks.remove(marks.size()-1);
+      while (a-- > 0) {
+        Node c = popNode();
+        c.jjtSetParent(n);
+        n.jjtAddChild(c, a);
+      }
+      n.jjtClose();
+      pushNode(n);
+      node_created = true;
+    } else {
+      mk = marks.remove(marks.size()-1);
+      node_created = false;
+    }
+  }
+}
+/* JavaCC - OriginalChecksum=b3950229267254ee44e83e43f937f326 (do not edit this line) */
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/Node.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/Node.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/Node.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/Node.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,61 +1,61 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. Node.java */
-/* JJT: 0.3pre1 */
-
-/* All AST nodes must implement this interface.  It provides basic
-   machinery for constructing the parent and child relationships
-   between nodes. */
-
-public interface Node {
-
-  /** This method is called after the node has been made the current
-    node.  It indicates that child nodes can now be added to it. */
-  public void jjtOpen();
-
-  /** This method is called after all the child nodes have been
-    added. */
-  public void jjtClose();
-
-  /** This pair of methods are used to inform the node of its
-    parent. */
-  public void jjtSetParent(Node n);
-  public Node jjtGetParent();
-
-  /** This method tells the node to add its argument to the node's
-    list of children.  */
-  public void jjtAddChild(Node n, int i);
-
-  /** This method returns a child node.  The children are numbered
-     from zero, left to right. */
-  public Node jjtGetChild(int i);
-
-  /** Return the number of children the node has. */
-  int jjtGetNumChildren();
-
-
-
-  /**
-   * The following has been added by Christoph Grimm
-   */
-  public int getId();
-
-
-  /**
-   * Procedures that perform semantic checks...
-   */
-  public void Check();
-  public void CheckSIWGLevel1();
-
-
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. Node.java */
+/* JJT: 0.3pre1 */
+
+/* All AST nodes must implement this interface.  It provides basic
+   machinery for constructing the parent and child relationships
+   between nodes. */
+
+public interface Node {
+
+  /** This method is called after the node has been made the current
+    node.  It indicates that child nodes can now be added to it. */
+  public void jjtOpen();
+
+  /** This method is called after all the child nodes have been
+    added. */
+  public void jjtClose();
+
+  /** This pair of methods are used to inform the node of its
+    parent. */
+  public void jjtSetParent(Node n);
+  public Node jjtGetParent();
+
+  /** This method tells the node to add its argument to the node's
+    list of children.  */
+  public void jjtAddChild(Node n, int i);
+
+  /** This method returns a child node.  The children are numbered
+     from zero, left to right. */
+  public Node jjtGetChild(int i);
+
+  /** Return the number of children the node has. */
+  int jjtGetNumChildren();
+
+
+
+  /**
+   * The following has been added by Christoph Grimm
+   */
+  public int getId();
+
+
+  /**
+   * Procedures that perform semantic checks...
+   */
+  public void Check();
+  public void CheckSIWGLevel1();
+
+
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/SimpleNode.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/SimpleNode.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/SimpleNode.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/SimpleNode.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,169 +1,169 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-/* Generated By:JJTree: Do not edit this line. SimpleNode.java */
-/* JJT: 0.3pre1 */
-
-public class SimpleNode implements Node, VhdlParserCoreConstants{
-  protected Node parent;
-  protected Node[] children;
-  protected int id;
-  protected Token first_token, last_token;
-  protected VhdlParserCore m_Parser;
-
-  public SimpleNode(int i) {
-    id = i;
-    children=null;
-  }
-
-  public void jjtOpen() {
-  }
-
-  public void jjtClose() {
-  }
-  
-  public void jjtSetParent(Node n) { parent = n; }
-  public Node jjtGetParent() { return parent; }
-
-  public void jjtAddChild(Node n, int i) {
-    if (children == null) {
-      children = new Node[i + 1];
-    } else if (i >= children.length) {
-      Node c[] = new Node[i + 1];
-      System.arraycopy(children, 0, c, 0, children.length);
-      children = c;
-    }
-    children[i] = n;    
-  }
-
-  public void setFirstToken(Token token){
-	  first_token=token;
-  }
-  
-  public void setLastToken(Token token){
-	last_token=token;  
-  }
-  
-  public Token getFirstToken(){ return first_token;}
-  public Token getLastToken(){ return last_token;}
-  
-  public Node jjtGetChild(int i) {
-    return children[i];
-  }
-
-  public int jjtGetNumChildren() {
-    return (children == null) ? 0 : children.length;
-  }
-  
-  /* You can override these two methods in subclasses of SimpleNode to
-     customize the way the node appears when the tree is dumped.  If
-     your output uses more than one line you should override
-     toString(String), otherwise overriding toString() is probably all
-     you need to do. */
-
-  public String toString() { return VhdlParserCoreTreeConstants.jjtNodeName[id]; }
-  public String toString(String prefix) { return prefix + toString(); }
-
-  /* Override this method if you want to customize how the node dumps
-     out its children. */
-
-  public void dump(String prefix) {
-    System.out.println(toString(prefix));
-    if (children != null) {
-      for (int i = 0; i < children.length; ++i) {
-	SimpleNode n = (SimpleNode)children[i];
-	if (n != null) {
-	  n.dump(prefix + " ");
-	}
-      }
-    }
-  }
-
-  //
-  // Added by Ali Ghorashi
-  //===============================
-  
-  public ErrorHandler getErrorHandler(){	  
-	  return m_Parser.getErrorHandler();
-  }
-  
-  public void setParser(VhdlParserCore parser){
-	  m_Parser=parser;
-  }
-  
-  public SimpleNode getChild(int n){
-	  if(children!=null && n < children.length && children[n] instanceof SimpleNode){
-		  return (SimpleNode)children[n];
-	  }
-	  else {
-		  return null;
-	  }
-  }  
-  
-  public int getChildCount(){
-	  return jjtGetNumChildren();
-  }
-  /**
-   * Start a new block with a new symbol table. The current table
-   * is saved in the variable upper_symtab. 
-   */
-  public void newBlock()
-  {
-    SymbolTable new_symtab = new SymbolTable();
-    new_symtab.upper_symtab = m_Parser.getSymbolTable();
-    m_Parser.setSymbolTable(new_symtab);
-  }
-
-  /**
-   * Start a new block wit a new symbol table. The current table
-   * is saved in the variable upper_symtab. Furthermore, a first
-   * symbol of type type and id id is added.
-   */
-  public void newBlock(String type, String id)
-  {
-    SymbolTable new_symtab = new SymbolTable();
-    new_symtab.upper_symtab = m_Parser.getSymbolTable();
-    m_Parser.setSymbolTable(new_symtab);
-    m_Parser.getSymbolTable().addSymbol(new Symbol(id, DEFAULT));
-  }
-
-  /**
-   * End a block: the current symbol table becomes the upper symbol
-   * table.
-   */
-  public void endBlock()
-  {
-	  m_Parser.setSymbolTable(m_Parser.getSymbolTable().upper_symtab);
-  }
-
- 
-  /**
-   * Perform all semantic actions and checks, which are necessary
-   */
-  public void Check()
-  {
-  }
-
-  /**
-   * Report warnings, when SIWG Level 1 is violated
-   */
-  public void CheckSIWGLevel1()
-  {
-  }
-
-  public int getId()
-  {
-    return id;
-  }
-  
-}
-
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+/* Generated By:JJTree: Do not edit this line. SimpleNode.java */
+/* JJT: 0.3pre1 */
+
+public class SimpleNode implements Node, VhdlParserCoreConstants{
+  protected Node parent;
+  protected Node[] children;
+  protected int id;
+  protected Token first_token, last_token;
+  protected VhdlParserCore m_Parser;
+
+  public SimpleNode(int i) {
+    id = i;
+    children=null;
+  }
+
+  public void jjtOpen() {
+  }
+
+  public void jjtClose() {
+  }
+  
+  public void jjtSetParent(Node n) { parent = n; }
+  public Node jjtGetParent() { return parent; }
+
+  public void jjtAddChild(Node n, int i) {
+    if (children == null) {
+      children = new Node[i + 1];
+    } else if (i >= children.length) {
+      Node c[] = new Node[i + 1];
+      System.arraycopy(children, 0, c, 0, children.length);
+      children = c;
+    }
+    children[i] = n;    
+  }
+
+  public void setFirstToken(Token token){
+	  first_token=token;
+  }
+  
+  public void setLastToken(Token token){
+	last_token=token;  
+  }
+  
+  public Token getFirstToken(){ return first_token;}
+  public Token getLastToken(){ return last_token;}
+  
+  public Node jjtGetChild(int i) {
+    return children[i];
+  }
+
+  public int jjtGetNumChildren() {
+    return (children == null) ? 0 : children.length;
+  }
+  
+  /* You can override these two methods in subclasses of SimpleNode to
+     customize the way the node appears when the tree is dumped.  If
+     your output uses more than one line you should override
+     toString(String), otherwise overriding toString() is probably all
+     you need to do. */
+
+  public String toString() { return VhdlParserCoreTreeConstants.jjtNodeName[id]; }
+  public String toString(String prefix) { return prefix + toString(); }
+
+  /* Override this method if you want to customize how the node dumps
+     out its children. */
+
+  public void dump(String prefix) {
+    System.out.println(toString(prefix));
+    if (children != null) {
+      for (int i = 0; i < children.length; ++i) {
+	SimpleNode n = (SimpleNode)children[i];
+	if (n != null) {
+	  n.dump(prefix + " ");
+	}
+      }
+    }
+  }
+
+  //
+  // Added by Ali Ghorashi
+  //===============================
+  
+  public ErrorHandler getErrorHandler(){	  
+	  return m_Parser.getErrorHandler();
+  }
+  
+  public void setParser(VhdlParserCore parser){
+	  m_Parser=parser;
+  }
+  
+  public SimpleNode getChild(int n){
+	  if(children!=null && n < children.length && children[n] instanceof SimpleNode){
+		  return (SimpleNode)children[n];
+	  }
+	  else {
+		  return null;
+	  }
+  }  
+  
+  public int getChildCount(){
+	  return jjtGetNumChildren();
+  }
+  /**
+   * Start a new block with a new symbol table. The current table
+   * is saved in the variable upper_symtab. 
+   */
+  public void newBlock()
+  {
+    SymbolTable new_symtab = new SymbolTable();
+    new_symtab.upper_symtab = m_Parser.getSymbolTable();
+    m_Parser.setSymbolTable(new_symtab);
+  }
+
+  /**
+   * Start a new block wit a new symbol table. The current table
+   * is saved in the variable upper_symtab. Furthermore, a first
+   * symbol of type type and id id is added.
+   */
+  public void newBlock(String type, String id)
+  {
+    SymbolTable new_symtab = new SymbolTable();
+    new_symtab.upper_symtab = m_Parser.getSymbolTable();
+    m_Parser.setSymbolTable(new_symtab);
+    m_Parser.getSymbolTable().addSymbol(new Symbol(id, DEFAULT));
+  }
+
+  /**
+   * End a block: the current symbol table becomes the upper symbol
+   * table.
+   */
+  public void endBlock()
+  {
+	  m_Parser.setSymbolTable(m_Parser.getSymbolTable().upper_symtab);
+  }
+
+ 
+  /**
+   * Perform all semantic actions and checks, which are necessary
+   */
+  public void Check()
+  {
+  }
+
+  /**
+   * Report warnings, when SIWG Level 1 is violated
+   */
+  public void CheckSIWGLevel1()
+  {
+  }
+
+  public int getId()
+  {
+    return id;
+  }
+  
+}
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/Symbol.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/Symbol.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/Symbol.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/Symbol.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,103 +1,103 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-
-
-/**
- * A symbol - entry in symbol-table
- */
-class Symbol implements VhdlParserCoreConstants
-{
-
-  public Symbol(String id, int k)
-  {
-    identifier = id;
-    kind       = k;
-  }
-
-  /**
-   * The identifier-string from the source-code
-   */
-  public String identifier;
-
-  /**
-   * The last alias used in the KIR-Graph
-   */
-  public String last_alias;
-
-  /**
-   * What type is it: procedure, type, signal, ...
-   */
-  public int kind;
-
-
-  /**
-   * print the symbol on screen for debugging purposes.
-   */
-  public void dump()
-  {
-    System.out.println("identifier: "+identifier);
-    System.out.println("kind:       "+tokenImage[kind]);
-  }
-
-}
-
-
-/**
- * Entry in the symbol tables for a signal or a variable.
- * if a signal kind is given, a signal is generated, if a
- * signal kind is not given, a variable is generated by the
- * constructor.
- */
-class SignalSymbol extends Symbol
-{
-  /**
-   * Create a new signal symbol for the identifier id with the type t
-   * of a signal-kind (bus, register,...) sk and an initial value i
-   */
-  public SignalSymbol(String id, Symbol t, int sk, ASTrelation i)
-  {
-    super(id, SIGNAL);
-    type = t;
-    signal_kind = sk;
-    init = i;
-  }
-
-  /**
-   * Create a new variable symbol for the identifier id with the type t
-   * and the inition value i.
-   */
-  public SignalSymbol(String id, Symbol t, ASTrelation i)
-  {
-    super(id, VARIABLE);
-    type = t;
-    signal_kind = DEFAULT;
-    init = i;
-  }
-
-  /**
-   * Type of this signal
-   */
-  public Symbol type;
-
-  /**
-   * Kind of this signal
-   */
-  public int signal_kind;
-
-  /**
-   * Expression for initial value
-   */
-  public ASTrelation init;
-}
-
-
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+
+
+/**
+ * A symbol - entry in symbol-table
+ */
+class Symbol implements VhdlParserCoreConstants
+{
+
+  public Symbol(String id, int k)
+  {
+    identifier = id;
+    kind       = k;
+  }
+
+  /**
+   * The identifier-string from the source-code
+   */
+  public String identifier;
+
+  /**
+   * The last alias used in the KIR-Graph
+   */
+  public String last_alias;
+
+  /**
+   * What type is it: procedure, type, signal, ...
+   */
+  public int kind;
+
+
+  /**
+   * print the symbol on screen for debugging purposes.
+   */
+  public void dump()
+  {
+    System.out.println("identifier: "+identifier);
+    System.out.println("kind:       "+tokenImage[kind]);
+  }
+
+}
+
+
+/**
+ * Entry in the symbol tables for a signal or a variable.
+ * if a signal kind is given, a signal is generated, if a
+ * signal kind is not given, a variable is generated by the
+ * constructor.
+ */
+class SignalSymbol extends Symbol
+{
+  /**
+   * Create a new signal symbol for the identifier id with the type t
+   * of a signal-kind (bus, register,...) sk and an initial value i
+   */
+  public SignalSymbol(String id, Symbol t, int sk, ASTrelation i)
+  {
+    super(id, SIGNAL);
+    type = t;
+    signal_kind = sk;
+    init = i;
+  }
+
+  /**
+   * Create a new variable symbol for the identifier id with the type t
+   * and the inition value i.
+   */
+  public SignalSymbol(String id, Symbol t, ASTrelation i)
+  {
+    super(id, VARIABLE);
+    type = t;
+    signal_kind = DEFAULT;
+    init = i;
+  }
+
+  /**
+   * Type of this signal
+   */
+  public Symbol type;
+
+  /**
+   * Kind of this signal
+   */
+  public int signal_kind;
+
+  /**
+   * Expression for initial value
+   */
+  public ASTrelation init;
+}
+
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/SymbolTable.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/SymbolTable.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/SymbolTable.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/SymbolTable.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,95 +1,95 @@
-/**
- * 
- * This file is based on the VHDL parser originally developed by
- * (c) 1997 Christoph Grimm,
- * J.W. Goethe-University Frankfurt
- * Department for computer engineering
- *
- **/
-package net.sourceforge.veditor.parser.vhdl;
-
-
-
-import java.util.*;
-
-//
-// Classes used for building the symbol tables
-//=========================================================
-
-
-
-public class SymbolTable
-{
-  /**
-   * Vector, where the symbols are stored.
-   */
-  Vector<Symbol> symbols = new Vector<Symbol>();
-
-  /**
-   * Hierarchie of symbol tables is stored using this
-   * variable. The upper symbol table is the enclosing architecture,
-   * entity, ... scope. 
-   */
-  SymbolTable upper_symtab;
-
-  /**
-   * Add an identifier to symbol table
-   */
-  public void addSymbol(Symbol s)
-  {
-    symbols.addElement(s);
-  }
-
-  /**
-   * Get a symbol from the symbol table
-   */
-  public Symbol getSymbol(String identifier)
-  {
-    int i;
-    for ( i = 0; i < symbols.size(); i++ )
-    {
-      if ( identifier.compareTo(((Symbol)symbols.elementAt(i)).identifier) == 0 )
-        return (Symbol) symbols.elementAt(i);
-    }
-    try {
-      return upper_symtab.getSymbol(identifier);
-    }
-    catch (Exception e)
-    {
-      return new Symbol("ERROR", 0);
-    }
-  }
-
-
-  String block_name;
-
-  /**
-   * Start a new Block
-   */
-  public void newBlock(String identifier)
-  {
-    block_name = identifier;
-  }
-
-  /**
-   * End a block with identifier identifier.
-   */
-  public void endBlock(String identifier)
-  {
-    if (block_name != identifier)
-    {
-      System.out.println("ERROR: identifiers at start and end don't match");
-    }
-  }
-
-  /**
-   * dump the symbol table
-   */
-  public void dump()
-  {
-    for ( int i = 0; i < symbols.size(); i++ )
-    {
-      (symbols.elementAt(i)).dump();
-    }
-  }
-}
+/**
+ * 
+ * This file is based on the VHDL parser originally developed by
+ * (c) 1997 Christoph Grimm,
+ * J.W. Goethe-University Frankfurt
+ * Department for computer engineering
+ *
+ **/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+
+
+import java.util.*;
+
+//
+// Classes used for building the symbol tables
+//=========================================================
+
+
+
+public class SymbolTable
+{
+  /**
+   * Vector, where the symbols are stored.
+   */
+  Vector<Symbol> symbols = new Vector<Symbol>();
+
+  /**
+   * Hierarchie of symbol tables is stored using this
+   * variable. The upper symbol table is the enclosing architecture,
+   * entity, ... scope. 
+   */
+  SymbolTable upper_symtab;
+
+  /**
+   * Add an identifier to symbol table
+   */
+  public void addSymbol(Symbol s)
+  {
+    symbols.addElement(s);
+  }
+
+  /**
+   * Get a symbol from the symbol table
+   */
+  public Symbol getSymbol(String identifier)
+  {
+    int i;
+    for ( i = 0; i < symbols.size(); i++ )
+    {
+      if ( identifier.compareTo(((Symbol)symbols.elementAt(i)).identifier) == 0 )
+        return (Symbol) symbols.elementAt(i);
+    }
+    try {
+      return upper_symtab.getSymbol(identifier);
+    }
+    catch (Exception e)
+    {
+      return new Symbol("ERROR", 0);
+    }
+  }
+
+
+  String block_name;
+
+  /**
+   * Start a new Block
+   */
+  public void newBlock(String identifier)
+  {
+    block_name = identifier;
+  }
+
+  /**
+   * End a block with identifier identifier.
+   */
+  public void endBlock(String identifier)
+  {
+    if (block_name != identifier)
+    {
+      System.out.println("ERROR: identifiers at start and end don't match");
+    }
+  }
+
+  /**
+   * dump the symbol table
+   */
+  public void dump()
+  {
+    for ( int i = 0; i < symbols.size(); i++ )
+    {
+      (symbols.elementAt(i)).dump();
+    }
+  }
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/vhdl.jj vdt/src/com/elphel/vdt/veditor/parser/vhdl/vhdl.jj
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/vhdl.jj	1969-12-31 17:00:00.000000000 -0700
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/vhdl.jj	2016-06-24 10:29:40.824496406 -0600
@@ -0,0 +1,8980 @@
+/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. vhdl.jj */
+/*@egen*/
+/**
+ *
+ * VHDL-93, VHDL-AMS grammar for JavaCC 
+ * (c) 1997 Christoph Grimm
+ * 
+ * EMail: grimm@ti.informatik.uni-frankfurt.de
+ * Address:
+ * Christoph Grimm
+ * J. W. Goethe-University Frankfurt
+ * Robert-Mayer-Strasse 11-15
+ * 60054 Frankfurt
+ * Germany
+ *
+ *
+ * By using this file, I agree with the following:
+ * -----------------------------------------------
+ *
+ * 1. This grammar is free for evaluation purposes.
+ *
+ * 2. You may use and modify it, but when distributing is, you must also
+ *    include the original files and copyright notes from me.
+ *
+ * 3. For commercial use of derived works contact me.
+ *   
+ * 4. The grammar is NOT optimized for speed. The aim is to keep the grammar 
+ *    similar to the original productions in the LRM.
+ *
+ * 5. Don't complain about errors - report them, maybe with fixes to me.
+ *
+ */
+
+
+options
+{
+  // DEBUG_PARSER = true;
+  // CHOICE_AMBIGUITY_CHECK=3;
+  IGNORE_CASE=false;
+                       
+             
+}
+
+ 
+
+
+/**
+ * The parser is instanciated in the file vhdl.java
+ */
+PARSER_BEGIN(VhdlParserCore)
+
+package com.elphel.vdt.veditor.parser.vhdl;
+
+@SuppressWarnings("all")
+
+public class VhdlParserCore/*@bgen(jjtree)*/implements VhdlParserCoreTreeConstants/*@egen*/
+{/*@bgen(jjtree)*/
+  protected JJTVhdlParserCoreState jjtree = new JJTVhdlParserCoreState();
+
+/*@egen*/
+  /**
+   * Called, whenever a new node in jjtree is generated.
+   * - store first token of the production.
+   * - check, if production is supported in subsets that are to be
+   *   checked.
+   */
+   void jjtreeOpenNodeScope(Node n)
+  {
+    
+    ((SimpleNode) n).setFirstToken(getToken(1));
+    ((SimpleNode) n).setParser(this);
+  }
+
+  /**
+   * Called, whenever a node in jjtree is closed.
+   */
+   void jjtreeCloseNodeScope(Node n)
+  {
+    ((SimpleNode) n).setLastToken(getToken(0)); 
+  }
+  
+  public ErrorHandler getErrorHandler(){
+  	return errs;
+  }
+    
+  public SymbolTable getSymbolTable(){
+  	return m_SymbolTable;
+  }
+  
+  public void setSymbolTable(SymbolTable symbolTable){
+    m_SymbolTable=symbolTable;
+  }
+  
+  ErrorHandler errs = new ErrorHandler(this);
+  SymbolTable m_SymbolTable=null;
+}
+
+PARSER_END(VhdlParserCore)
+
+
+SKIP :
+{
+    " "
+  | "\n"
+  | "\r"
+  | "\t"
+  | "\f"
+}
+
+
+SPECIAL_TOKEN :
+{
+  <COMMENT: "--" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
+}
+
+
+/** 
+ * Section 13: Lexical elements
+ * with extensions from IEEE 1076.1
+ */
+TOKEN [IGNORE_CASE] :
+{
+    <ABS:          "abs">
+  | <ACCESS:       "access">
+  | <ACROSS:       "across">
+  | <AFTER:        "after">
+  | <ALIAS:        "alias">
+  | <ALL:          "all">
+  | <AND:          "and">
+  | <ARCHITECTURE: "architecture">
+  | <ARRAY:        "array">
+  | <ASSERT:       "assert">
+  | <ATTRIBUTE:    "attribute">
+  | <BEGIN:        "begin">
+  | <BLOCK:        "block">
+  | <BODY:         "body">
+  | <BREAK:        "break">
+  | <BUFFER:       "buffer">
+  | <BUS:          "bus">
+  | <CASE:         "case">
+  | <COMPONENT:    "component">
+  | <CONFIGURATION: "configuration">
+  | <CONSTANT:      "constant">
+  | <DISCONNECT:    "disconnect">
+  | <DOWNTO:        "downto">
+  | <ELSE:          "else">
+  | <ELSIF:         "elsif">
+  | <END:           "end">
+  | <ENTITY:        "entity">
+  | <EXIT:          "exit">
+  | <FILE:          "file">
+  | <FOR:           "for">
+  | <FUNCTION:      "function">
+  | <GENERATE:      "generate">
+  | <GENERIC:       "generic">
+  | <GROUP:         "group">
+  | <GUARDED:       "guarded">
+  | <IF:            "if">
+  | <IMPURE:        "impure">
+  | <IN:            "in">
+  | <INERTIAL:      "inertial">
+  | <INOUT:         "inout">
+  | <IS:            "is">
+  | <LABEL:         "label">
+  | <LIBRARY:       "library">
+  | <LINKAGE:       "linkage">
+  | <LITERAL:       "literal">
+  | <LOOP:          "loop">
+  | <MAP:           "map">
+  | <MOD:           "mod">
+  | <NAND:          "nand">
+  | <NATURE:        "nature">
+  | <NEW:           "new">
+  | <NEXT:          "next">
+  | <NOISE:         "noise">
+  | <NOR:           "nor">
+  | <NOT:           "not">
+  | <NULL:          "null">
+  | <OF:            "of">
+  | <ON:            "on">
+  | <OPEN:          "open">
+  | <OR:            "or">
+  | <OTHERS:        "others">
+  | <OUT:           "out">
+  | <PACKAGE:       "package">
+  | <PORT:          "port">
+  | <POSTPONED:     "postponed">
+  | <PROCEDURAL:    "procedural">
+  | <PROCEDURE:     "procedure">
+  | <PROCESS:       "process">
+  | <PROTECTED:     "protected">
+  | <PURE:          "pure">
+  | <QUANTITY:      "quantity">
+  | <RANGE:         "range">
+  | <RECORD:        "record">
+  | <REGISTER:      "register">
+  | <REJECT:        "reject">
+  | <REM:           "rem">
+  | <REPORT:        "report">
+  | <RETURN:        "return">
+  | <ROL:           "rol">
+  | <ROR:           "ror">
+  | <SELECT:        "select">
+  | <SEVERITY:      "severity">
+  | <SIGNAL:        "signal">
+  | <SHARED:        "shared">
+  | <SLA:           "sla">
+  | <SLL:           "sll">
+  | <SPECTRUM:      "spectrum">
+  | <SRA:           "sra">
+  | <SRL:           "srl">
+  | <SUBNATURE:     "subnature">
+  | <SUBTYPE:       "subtype">
+  | <TERMINAL:      "terminal">
+  | <THEN:          "then">
+  | <THROUGH:       "through">
+  | <TO:            "to">
+  | <TOLERANCE:     "tolerance">
+  | <TRANSPORT:     "transport">
+  | <TYPE:          "type">
+  | <UNAFFECTED:    "unaffected">
+  | <UNITS:         "units">
+  | <UNTIL:         "until">
+  | <USE:           "use">
+  | <VARIABLE:      "variable">
+  | <WAIT:          "wait">
+  | <WHEN:          "when">
+  | <WHILE:         "while">
+  | <WITH:          "with">
+  | <XNOR:          "xnor">
+  | <XOR:           "xor">
+}
+
+
+
+TOKEN :
+{
+    <#upper_case_letter:               ["A"-"Z"]>
+  | <#lower_case_letter:               ["a"-"z"]>
+  | <#digit:                           ["0"-"9"]>
+  | <#extended_digit:                  ["0"-"9","A"-"F","a"-"f"]>
+  | <#special_character:               ["#","&","'","(",")","*","+",",","-",
+                                        ".","/",":",";","<","=",">","[","]",
+                                        "_","|"]>
+  | <#other_special_character:         ["!","$","%","@","?","^","`","{","}","~",
+                                        "\\"]>
+  | <#format_effector:                 ["\n","\t"]>
+  | <#base_specifier:                  ["B","O","X","b","o","x"]>
+  | <#underline:                       "_">
+  | <#letter:                          ["a"-"z","A"-"Z"]>
+  | <#letter_or_digit:                 ["a"-"z","A"-"Z","0"-"9"]>
+  | <#integer: <digit> (("_")? <digit>)*>
+  | <#base: <integer>>
+  | <#based_integer: (("_")? <extended_digit>)*>
+  | <based_literal: <base> "#" <based_integer> ("." <based_integer>)? "#" (<exponent>)?>
+  | <#basic_character: (<basic_graphic_character>|<format_effector>)>
+  | <#basic_graphic_character: (["A"-"Z"]|<digit>|<special_character>|" ")>
+  | <basic_identifier: <letter> ( ("_")? <letter_or_digit> )*>
+  | <bit_string_literal: <base_specifier> "\"" <bit_value> "\"">
+  | <#bit_value: <extended_digit> ( ("_")? <extended_digit>)*>
+  | <character_literal:  "'" (<graphic_character>|"\"") "'">
+  | <decimal_literal: <integer> ( "." <integer>)? ( <exponent> )?>
+  | <#exponent: ("E" ("+")? <integer>) | ("E" "-" <integer>)>
+  | <extended_identifier: "\\" <graphic_character> ( <graphic_character> )* "\\">
+  | <#graphic_character: (<basic_graphic_character>
+                          | <lower_case_letter>
+                          | <other_special_character>)>
+  | <string_literal: "\"" (<graphic_character>|"\"\"")* "\"">
+
+  | <EXP: "**">
+  | <MUL: "*">
+  | <DIV: "/">
+  | <ADD: "+">
+  | <SUB: "-">
+  | <CONCAT: "&">
+  | <EQ:  "=">
+  | <NEQ: "/=">
+  | <GE:  ">=">
+  | <LE:  "<=">
+  | <GT:  ">">
+  | <LO:  "<">
+  | <SEMICOLON: ";">
+  | <COLON: ":">
+  | <ASSIGN: ":=">
+  | <RARROW: "=>">
+}
+
+
+
+
+void abstract_literal()       :
+{}
+{
+    <decimal_literal>
+  | <based_literal>
+}
+
+
+
+void access_type_definition()       :
+{}
+{
+  <ACCESS> subtype_indication()
+}
+
+
+
+void actual_designator()       :
+{}
+{
+    LOOKAHEAD(expression()) 
+    expression()
+  | LOOKAHEAD(signal_name())
+    signal_name()
+  | LOOKAHEAD(variable_name())
+    variable_name()
+  | LOOKAHEAD(file_name())
+    file_name()
+  | <OPEN>
+
+  // 1076.1 extensions:
+  | LOOKAHEAD(terminal_name())
+    terminal_name()
+  | quantity_name()
+}
+
+
+
+void actual_parameter_part()       :
+{}
+{
+  parameter_association_list()
+}
+
+
+void actual_part() :
+{/*@bgen(jjtree) actual_part */
+  ASTactual_part jjtn000 = new ASTactual_part(JJTACTUAL_PART);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) actual_part */
+    try {
+/*@egen*/
+    LOOKAHEAD( function_name() "(" actual_designator() ")")
+    function_name() "(" actual_designator() ")"
+  | LOOKAHEAD( type_mark() "(" actual_designator() ")")
+    type_mark() "(" actual_designator() ")"
+  | actual_designator()/*@bgen(jjtree)*/
+    } catch (Throwable jjte000) {
+      if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        throw (RuntimeException)jjte000;
+      }
+      if (jjte000 instanceof ParseException) {
+        throw (ParseException)jjte000;
+      }
+      throw (Error)jjte000;
+    } finally {
+      if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+/*@egen*/
+}
+
+
+int adding_operator()       :
+{}
+{
+    <ADD>               { return ADD; }
+  | <SUB>               { return SUB; }
+  | <CONCAT>            { return CONCAT; }
+}
+
+
+void aggregate() :
+{/*@bgen(jjtree) aggregate */
+  ASTaggregate jjtn000 = new ASTaggregate(JJTAGGREGATE);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) aggregate */
+  try {
+/*@egen*/
+  "(" element_association()  ("," element_association())*  ")"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}    
+
+void alias_declaration() :
+{/*@bgen(jjtree) alias_declaration */
+  ASTalias_declaration jjtn000 = new ASTalias_declaration(JJTALIAS_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) alias_declaration */
+  try {
+/*@egen*/
+  <ALIAS> alias_designator()
+   [ ":" subtype_indication() ] <IS> name() signature() ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void alias_designator() :
+{/*@bgen(jjtree) alias_designator */
+  ASTalias_designator jjtn000 = new ASTalias_designator(JJTALIAS_DESIGNATOR);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) alias_designator */
+    try {
+/*@egen*/
+    identifier()
+  | <character_literal>
+  | operator_symbol()/*@bgen(jjtree)*/
+    } catch (Throwable jjte000) {
+      if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        throw (RuntimeException)jjte000;
+      }
+      if (jjte000 instanceof ParseException) {
+        throw (ParseException)jjte000;
+      }
+      throw (Error)jjte000;
+    } finally {
+      if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+/*@egen*/
+}
+
+void allocator() :
+{/*@bgen(jjtree) allocator */
+  ASTallocator jjtn000 = new ASTallocator(JJTALLOCATOR);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) allocator */
+  try {
+/*@egen*/
+  <NEW>
+  (
+      LOOKAHEAD( type_mark() "'")
+      qualified_expression()
+    | subtype_indication()
+  )/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+
+void architecture_body() :
+{/*@bgen(jjtree) architecture_body */
+  ASTarchitecture_body jjtn000 = new ASTarchitecture_body(JJTARCHITECTURE_BODY);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) architecture_body */
+  try {
+/*@egen*/
+  <ARCHITECTURE> identifier() <OF> entity_name() <IS> { jjtn000.newBlock(); }
+    architecture_declarative_part()
+  <BEGIN>
+    architecture_statement_part()
+  <END> [ <ARCHITECTURE> ] [ architecture_simple_name() ] ";"/*@bgen(jjtree)*/
+  {
+    jjtree.closeNodeScope(jjtn000, true);
+    jjtc000 = false;
+    if (jjtree.nodeCreated()) {
+     jjtreeCloseNodeScope(jjtn000);
+    }
+  }
+/*@egen*/
+
+  {
+    jjtn000.endBlock();
+    jjtn000.Check();
+  }/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+
+void architecture_declarative_part() :
+{/*@bgen(jjtree) architecture_declarative_part */
+  ASTarchitecture_declarative_part jjtn000 = new ASTarchitecture_declarative_part(JJTARCHITECTURE_DECLARATIVE_PART);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) architecture_declarative_part */
+  try {
+/*@egen*/
+  ( block_declarative_item() )*/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+void architecture_statement_part() :
+{/*@bgen(jjtree) architecture_statement_part */
+  ASTarchitecture_statement_part jjtn000 = new ASTarchitecture_statement_part(JJTARCHITECTURE_STATEMENT_PART);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) architecture_statement_part */
+  try {
+/*@egen*/
+  ( architecture_statement() )*/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+/**
+ *  This rule also contains the concurrent statements.
+ */
+void architecture_statement()       :
+{}
+{
+  // 
+  // lookahead would really be annoying here. Therefore I have
+  // moved the concurrent statement into this rule.
+  // concurrent_statements:
+  //
+
+  try {
+
+    LOOKAHEAD([block_label() ":"] <BLOCK>)
+    block_statement()
+  | LOOKAHEAD([process_label() ":"] [<POSTPONED>] <PROCESS>)
+    process_statement()
+  | LOOKAHEAD([label() ":"] [<POSTPONED>] procedure_call() ";")
+    concurrent_procedure_call_statement()
+  | LOOKAHEAD([label() ":"] [<POSTPONED>] <ASSERT>)
+    concurrent_assertion_statement()
+  | LOOKAHEAD([label() ":"] [<POSTPONED>] conditional_signal_assignment()|
+              [label() ":"] [<POSTPONED>] selected_signal_assignment())
+    concurrent_signal_assignment_statement()
+  | LOOKAHEAD(instantiation_label() ":" instantiated_unit() )
+    component_instantiation_statement()
+  | LOOKAHEAD(generate_statement())
+    generate_statement()
+
+  /** 1076.1 extensions: */
+  | LOOKAHEAD(concurrent_break_statement())
+    concurrent_break_statement()
+  | simultaneous_statement()
+
+  }
+
+  /** Error handling: Skip until next semicolon */
+  catch(ParseException e)
+  {
+    error_skipto(SEMICOLON, "syntax error in statement");
+  }
+}
+
+
+/**
+ * 1076.1 extension:
+ */
+void array_nature_definition()        :
+{}
+{
+    LOOKAHEAD(<ARRAY> "(" index_subtype_definition() )
+    unconstrained_nature_definition()
+  | constrained_nature_definition()
+}
+
+/**
+  * 1076.1 extension:
+  */
+void unconstrained_nature_definition() :
+{/*@bgen(jjtree) unconstrained_nature_definition */
+  ASTunconstrained_nature_definition jjtn000 = new ASTunconstrained_nature_definition(JJTUNCONSTRAINED_NATURE_DEFINITION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) unconstrained_nature_definition */
+  try {
+/*@egen*/
+  <ARRAY> "(" index_subtype_definition() ("," index_subtype_definition())* ")" 
+  <OF> subnature_indication()/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+/**
+  * 1076.1 extension:
+  */
+void constrained_nature_definition() :
+{/*@bgen(jjtree) constrained_nature_definition */
+  ASTconstrained_nature_definition jjtn000 = new ASTconstrained_nature_definition(JJTCONSTRAINED_NATURE_DEFINITION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) constrained_nature_definition */
+  try {
+/*@egen*/
+  <ARRAY> index_constraint() <OF> subnature_indication()/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void array_type_definition()      :
+{}
+{
+    LOOKAHEAD(unconstrained_array_definition())
+    unconstrained_array_definition()
+  | constrained_array_definition()
+}
+
+void assertion() :
+{/*@bgen(jjtree) assertion */
+  ASTassertion jjtn000 = new ASTassertion(JJTASSERTION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) assertion */
+  try {
+/*@egen*/
+  <ASSERT> condition()
+  [ <REPORT> expression() ]
+  [ <SEVERITY> expression() ]/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void assertion_statement() :
+{/*@bgen(jjtree) assertion_statement */
+  ASTassertion_statement jjtn000 = new ASTassertion_statement(JJTASSERTION_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) assertion_statement */
+  try {
+/*@egen*/
+  [ label() ":" ] assertion() ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+
+void association_element() :
+{/*@bgen(jjtree) association_element */
+  ASTassociation_element jjtn000 = new ASTassociation_element(JJTASSOCIATION_ELEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) association_element */
+  try {
+/*@egen*/
+  [ LOOKAHEAD( formal_part() "=>" ) formal_part() "=>" ]
+  actual_part()/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+void association_list() :
+{/*@bgen(jjtree) association_list */
+  ASTassociation_list jjtn000 = new ASTassociation_list(JJTASSOCIATION_LIST);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) association_list */
+  try {
+/*@egen*/
+  association_element() ( "," association_element() )*/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void attribute_declaration() :
+{/*@bgen(jjtree) attribute_declaration */
+  ASTattribute_declaration jjtn000 = new ASTattribute_declaration(JJTATTRIBUTE_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) attribute_declaration */
+  try {
+/*@egen*/
+  <ATTRIBUTE> identifier() ":" type_mark() ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void attribute_designator()       :
+{}
+{
+  attribute_simple_name()
+}
+
+
+void attribute_name() :
+{/*@bgen(jjtree) attribute_name */
+  ASTattribute_name jjtn000 = new ASTattribute_name(JJTATTRIBUTE_NAME);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) attribute_name */
+  try {
+/*@egen*/
+  prefix() signature() "'" attribute_designator() [ "(" expression() ("," expression())* ")" ]/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void attribute_specification() :
+{/*@bgen(jjtree) attribute_specification */
+  ASTattribute_specification jjtn000 = new ASTattribute_specification(JJTATTRIBUTE_SPECIFICATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) attribute_specification */
+  try {
+/*@egen*/
+  <ATTRIBUTE> attribute_designator() <OF>
+  entity_specification() <IS> expression() ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+void base_unit_declaration()       :
+{}
+{
+  identifier() ";"
+}
+
+
+
+void binding_indication() :
+{/*@bgen(jjtree) binding_indication */
+  ASTbinding_indication jjtn000 = new ASTbinding_indication(JJTBINDING_INDICATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) binding_indication */
+  try {
+/*@egen*/
+  [ <USE> entity_aspect() ]
+  [ generic_map_aspect() ]
+  [ port_map_aspect() ]/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+void block_configuration() :
+{/*@bgen(jjtree) block_configuration */
+  ASTblock_configuration jjtn000 = new ASTblock_configuration(JJTBLOCK_CONFIGURATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) block_configuration */
+  try {
+/*@egen*/
+  <FOR> block_specification()
+                ( use_clause() )*
+                ( configuration_item() )*
+  <END> <FOR> ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+void block_declarative_item()       :
+{}
+{
+  try {
+
+    LOOKAHEAD(subprogram_declaration())
+    subprogram_declaration()
+  | subprogram_body()
+  | type_declaration()
+  | subtype_declaration()
+  | constant_declaration()
+  | signal_declaration()
+  | shared_variable_declaration()
+  | file_declaration()
+  | alias_declaration()
+  | component_declaration()
+  | LOOKAHEAD(attribute_declaration())
+    attribute_declaration()
+  | attribute_specification()
+  | configuration_specification()
+  | disconnection_specification()
+  | use_clause()
+  | LOOKAHEAD(<GROUP> identifier() <IS>)
+    group_template_declaration()
+  | group_declaration()
+
+  /** 1076.1 - Extensions: */
+  | nature_declaration()
+  | subnature_declaration()
+  | quantity_declaration()
+  | terminal_declaration()
+
+  }
+
+  // Error handling: skip until next semicolon
+  catch (ParseException e)
+  {
+    error_skipto(SEMICOLON, "syntax error in declarative item");
+  }
+}
+
+
+void block_declarative_part() :
+{/*@bgen(jjtree) block_declarative_part */
+  ASTblock_declarative_part jjtn000 = new ASTblock_declarative_part(JJTBLOCK_DECLARATIVE_PART);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) block_declarative_part */
+  try {
+/*@egen*/
+  ( block_declarative_item() )*/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+void block_header() :
+{/*@bgen(jjtree) block_header */
+  ASTblock_header jjtn000 = new ASTblock_header(JJTBLOCK_HEADER);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) block_header */
+  try {
+/*@egen*/
+  [ generic_clause()  [ generic_map_aspect() ";" ] ]
+  [ port_clause()     [ port_map_aspect() ";"    ] ]/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+void block_specification() :
+{/*@bgen(jjtree) block_specification */
+  ASTblock_specification jjtn000 = new ASTblock_specification(JJTBLOCK_SPECIFICATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) block_specification */
+    try {
+/*@egen*/
+    LOOKAHEAD(architecture_name())
+    architecture_name()
+  | LOOKAHEAD(block_statement_label())
+    block_statement_label()
+  | LOOKAHEAD(generate_statement_label())
+    generate_statement_label() [ "(" index_specification() ")" ]/*@bgen(jjtree)*/
+    } catch (Throwable jjte000) {
+      if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        throw (RuntimeException)jjte000;
+      }
+      if (jjte000 instanceof ParseException) {
+        throw (ParseException)jjte000;
+      }
+      throw (Error)jjte000;
+    } finally {
+      if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+/*@egen*/
+}
+
+
+void block_statement() :
+{/*@bgen(jjtree) block_statement */
+  ASTblock_statement jjtn000 = new ASTblock_statement(JJTBLOCK_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) block_statement */
+  try {
+/*@egen*/
+  block_label() ":"
+                <BLOCK> [ "(" guard_expression() ")" ] [ <IS> ]
+                        block_header()
+                        block_declarative_part()
+                <BEGIN>
+                        block_statement_part()
+                <END> <BLOCK> [ block_label() ] ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void block_statement_part() :
+{/*@bgen(jjtree) block_statement_part */
+  ASTblock_statement_part jjtn000 = new ASTblock_statement_part(JJTBLOCK_STATEMENT_PART);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) block_statement_part */
+  try {
+/*@egen*/
+  (architecture_statement() )*/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+/**
+ * Section 8.14: Break statement
+ * 1076.1 extension:
+ */
+void break_statement() :
+{/*@bgen(jjtree) break_statement */
+  ASTbreak_statement jjtn000 = new ASTbreak_statement(JJTBREAK_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) break_statement */
+  try {
+/*@egen*/
+  [label()  ":"] <BREAK> [break_list()] [<WHEN> condition() ] ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+/**
+ * 1076.1 extension:
+ */
+void break_list() :
+{/*@bgen(jjtree) break_list */
+  ASTbreak_list jjtn000 = new ASTbreak_list(JJTBREAK_LIST);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) break_list */
+  try {
+/*@egen*/
+  break_element() ("," break_element() )*/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+/**
+ * 1076.1 extension:
+ */
+void break_element() :
+{/*@bgen(jjtree) break_element */
+  ASTbreak_element jjtn000 = new ASTbreak_element(JJTBREAK_ELEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) break_element */
+  try {
+/*@egen*/
+  [selector_clause() ] quantity_name() "=>" expression()/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+/**
+ * 1076.1 extension:
+ */
+void selector_clause()       :
+{}
+{
+  <FOR> quantity_name() <USE>
+}
+
+void case_statement() :
+{/*@bgen(jjtree) case_statement */
+  ASTcase_statement jjtn000 = new ASTcase_statement(JJTCASE_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) case_statement */
+  try {
+/*@egen*/
+  [ case_label() ":" ]
+                <CASE> expression() <IS>
+                        case_statement_alternative()
+                        ( case_statement_alternative() )*
+                <END> <CASE> [ case_label() ] ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void case_statement_alternative() :
+{/*@bgen(jjtree) case_statement_alternative */
+  ASTcase_statement_alternative jjtn000 = new ASTcase_statement_alternative(JJTCASE_STATEMENT_ALTERNATIVE);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) case_statement_alternative */
+  try {
+/*@egen*/
+  <WHEN> choices() "=>"
+                sequence_of_statements()/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void choice() :
+{/*@bgen(jjtree) choice */
+  ASTchoice jjtn000 = new ASTchoice(JJTCHOICE);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) choice */
+    try {
+/*@egen*/
+  /** Dirty Solution */
+    LOOKAHEAD( discrete_range()  ("=>" | "|" | ";" | ",") )
+    discrete_range()
+  | LOOKAHEAD( simple_expression()  ("=>" | "|" | ";" | ",") )
+    simple_expression()
+  | element_simple_name()
+  | <OTHERS>/*@bgen(jjtree)*/
+    } catch (Throwable jjte000) {
+      if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        throw (RuntimeException)jjte000;
+      }
+      if (jjte000 instanceof ParseException) {
+        throw (ParseException)jjte000;
+      }
+      throw (Error)jjte000;
+    } finally {
+      if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+/*@egen*/
+}
+
+
+void choices() :
+{/*@bgen(jjtree) choices */
+  ASTchoices jjtn000 = new ASTchoices(JJTCHOICES);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) choices */
+  try {
+/*@egen*/
+  choice() ( "|" choice() )*/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void component_configuration() :
+{/*@bgen(jjtree) component_configuration */
+  ASTcomponent_configuration jjtn000 = new ASTcomponent_configuration(JJTCOMPONENT_CONFIGURATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) component_configuration */
+  try {
+/*@egen*/
+  <FOR> component_specification()
+                [ binding_indication() ";" ]
+                [ block_configuration() ]
+  <END> <FOR> ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+void component_declaration() :
+{/*@bgen(jjtree) component_declaration */
+  ASTcomponent_declaration jjtn000 = new ASTcomponent_declaration(JJTCOMPONENT_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) component_declaration */
+  try {
+/*@egen*/
+  <COMPONENT> identifier() [ <IS> ]
+      [ local_generic_clause() ]
+      [ local_port_clause() ]
+  <END> <COMPONENT> [ component_simple_name() ] ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+void component_instantiation_statement() :
+{/*@bgen(jjtree) component_instantiation_statement */
+  ASTcomponent_instantiation_statement jjtn000 = new ASTcomponent_instantiation_statement(JJTCOMPONENT_INSTANTIATION_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) component_instantiation_statement */
+  try {
+/*@egen*/
+  instantiation_label() ":"
+         instantiated_unit()
+         [ generic_map_aspect() ]
+         [ port_map_aspect() ] ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+// 1076.1 - extension:
+void composite_nature_definition()       :
+{}
+{
+    array_nature_definition()
+  | record_nature_definition()
+}
+
+void component_specification() :
+{/*@bgen(jjtree) component_specification */
+  ASTcomponent_specification jjtn000 = new ASTcomponent_specification(JJTCOMPONENT_SPECIFICATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) component_specification */
+  try {
+/*@egen*/
+  instantiation_list() ":" component_name()/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void composite_type_definition() :
+{/*@bgen(jjtree) composite_type_definition */
+  ASTcomposite_type_definition jjtn000 = new ASTcomposite_type_definition(JJTCOMPOSITE_TYPE_DEFINITION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) composite_type_definition */
+    try {
+/*@egen*/
+    array_type_definition()
+  | record_type_definition()/*@bgen(jjtree)*/
+    } catch (Throwable jjte000) {
+      if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        throw (RuntimeException)jjte000;
+      }
+      if (jjte000 instanceof ParseException) {
+        throw (ParseException)jjte000;
+      }
+      throw (Error)jjte000;
+    } finally {
+      if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+/*@egen*/
+}
+
+
+void concurrent_assertion_statement() :
+{/*@bgen(jjtree) concurrent_assertion_statement */
+  ASTconcurrent_assertion_statement jjtn000 = new ASTconcurrent_assertion_statement(JJTCONCURRENT_ASSERTION_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) concurrent_assertion_statement */
+  try {
+/*@egen*/
+  [ label() ":" ] [ <POSTPONED> ] assertion() ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void concurrent_procedure_call_statement() :
+{/*@bgen(jjtree) concurrent_procedure_call_statement */
+  ASTconcurrent_procedure_call_statement jjtn000 = new ASTconcurrent_procedure_call_statement(JJTCONCURRENT_PROCEDURE_CALL_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) concurrent_procedure_call_statement */
+  try {
+/*@egen*/
+  [ LOOKAHEAD( label() ":") label() ":" ]
+  [ <POSTPONED> ] procedure_call() ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+void concurrent_signal_assignment_statement() :
+{/*@bgen(jjtree) concurrent_signal_assignment_statement */
+  ASTconcurrent_signal_assignment_statement jjtn000 = new ASTconcurrent_signal_assignment_statement(JJTCONCURRENT_SIGNAL_ASSIGNMENT_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) concurrent_signal_assignment_statement */
+    try {
+/*@egen*/
+    [ LOOKAHEAD( label() ":") label() ":" ]
+    [ <POSTPONED> ]
+    ( LOOKAHEAD(  target() "<=" options_() conditional_waveforms() ";") 
+        conditional_signal_assignment() 
+      | selected_signal_assignment() )/*@bgen(jjtree)*/
+    } catch (Throwable jjte000) {
+      if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        throw (RuntimeException)jjte000;
+      }
+      if (jjte000 instanceof ParseException) {
+        throw (ParseException)jjte000;
+      }
+      throw (Error)jjte000;
+    } finally {
+      if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+/*@egen*/
+}
+
+
+void condition()       :
+{}
+{
+  boolean_expression()
+}
+
+
+void condition_clause()       :
+{}
+{
+  <UNTIL> condition()
+}
+
+
+void conditional_signal_assignment() :
+{/*@bgen(jjtree) conditional_signal_assignment */
+  ASTconditional_signal_assignment jjtn000 = new ASTconditional_signal_assignment(JJTCONDITIONAL_SIGNAL_ASSIGNMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) conditional_signal_assignment */
+  try {
+/*@egen*/
+  target() "<=" options_() conditional_waveforms() ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void conditional_waveforms() :
+{/*@bgen(jjtree) conditional_waveforms */
+  ASTconditional_waveforms jjtn000 = new ASTconditional_waveforms(JJTCONDITIONAL_WAVEFORMS);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) conditional_waveforms */
+  try {
+/*@egen*/
+  //( waveform() <WHEN> condition() <ELSE> )*
+  //waveform() [ <WHEN> condition() ]
+  waveform()
+    ( LOOKAHEAD( <WHEN> condition() <ELSE>)
+        <WHEN> condition() <ELSE> waveform() )*
+    [ <WHEN> condition() ]/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void configuration_declaration() :
+{/*@bgen(jjtree) configuration_declaration */
+  ASTconfiguration_declaration jjtn000 = new ASTconfiguration_declaration(JJTCONFIGURATION_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) configuration_declaration */
+  try {
+/*@egen*/
+  <CONFIGURATION> identifier() <OF> entity_name() <IS>
+    configuration_declarative_part()
+    block_configuration()
+  <END> [ <CONFIGURATION> ] [ configuration_simple_name() ] ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void configuration_declarative_item()       :
+{}
+{
+  try {
+    use_clause()
+  | attribute_specification()
+  | group_declaration()
+  }
+
+  catch(ParseException e)
+  {
+    error_skipto(SEMICOLON, "syntax error in declarative item");
+  }
+}
+
+
+void configuration_declarative_part() :
+{/*@bgen(jjtree) configuration_declarative_part */
+  ASTconfiguration_declarative_part jjtn000 = new ASTconfiguration_declarative_part(JJTCONFIGURATION_DECLARATIVE_PART);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) configuration_declarative_part */
+  try {
+/*@egen*/
+  ( configuration_declarative_item() )*/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+
+void configuration_item()       :
+{}
+{
+    LOOKAHEAD(block_configuration())
+    block_configuration()
+  | component_configuration()
+}
+
+void configuration_specification() :
+{/*@bgen(jjtree) configuration_specification */
+  ASTconfiguration_specification jjtn000 = new ASTconfiguration_specification(JJTCONFIGURATION_SPECIFICATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) configuration_specification */
+  try {
+/*@egen*/
+  <FOR> component_specification() binding_indication() ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+void constant_declaration() :
+{/*@bgen(jjtree) constant_declaration */
+  ASTconstant_declaration jjtn000 = new ASTconstant_declaration(JJTCONSTANT_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) constant_declaration */
+  try {
+/*@egen*/
+  <CONSTANT> identifier_list() ":" subtype_indication()
+    [ ":=" expression() ] ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+
+void constrained_array_definition() :
+{/*@bgen(jjtree) constrained_array_definition */
+  ASTconstrained_array_definition jjtn000 = new ASTconstrained_array_definition(JJTCONSTRAINED_ARRAY_DEFINITION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) constrained_array_definition */
+  try {
+/*@egen*/
+  <ARRAY> index_constraint() <OF> element_subtype_indication()/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void constraint()       :
+{}
+{
+    range_constraint()
+  | index_constraint()
+}
+
+void context_clause() :
+{/*@bgen(jjtree) context_clause */
+  ASTcontext_clause jjtn000 = new ASTcontext_clause(JJTCONTEXT_CLAUSE);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) context_clause */
+  try {
+/*@egen*/
+  ( context_item() )*/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+void context_item()       :
+{}
+{
+    library_clause()
+  | use_clause()
+}
+
+
+/** 
+ * Section 4:
+ * Declarations
+ */
+
+
+/**
+ * 1076.1 extension:
+ */
+void terminal_declaration() :
+{/*@bgen(jjtree) terminal_declaration */
+  ASTterminal_declaration jjtn000 = new ASTterminal_declaration(JJTTERMINAL_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) terminal_declaration */
+  try {
+/*@egen*/
+  <TERMINAL> identifier_list() ":" subnature_indication() ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+void terminal_aspect() :
+{/*@bgen(jjtree) terminal_aspect */
+  ASTterminal_aspect jjtn000 = new ASTterminal_aspect(JJTTERMINAL_ASPECT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) terminal_aspect */
+  try {
+/*@egen*/
+  plus_terminal_name() [ <TO> minus_terminal_name() ]/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void delay_mechanism() :
+{/*@bgen(jjtree) delay_mechanism */
+  ASTdelay_mechanism jjtn000 = new ASTdelay_mechanism(JJTDELAY_MECHANISM);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) delay_mechanism */
+    try {
+/*@egen*/
+    <TRANSPORT>
+  | [ <REJECT> time_expression() ] <INERTIAL>/*@bgen(jjtree)*/
+    } catch (Throwable jjte000) {
+      if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        throw (RuntimeException)jjte000;
+      }
+      if (jjte000 instanceof ParseException) {
+        throw (ParseException)jjte000;
+      }
+      throw (Error)jjte000;
+    } finally {
+      if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+/*@egen*/
+}
+
+ASTdesign_file design_file() :
+{/*@bgen(jjtree) design_file */
+  ASTdesign_file jjtn000 = new ASTdesign_file(JJTDESIGN_FILE);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) design_file */
+  try {
+/*@egen*/
+  ( design_unit() )*/*@bgen(jjtree)*/
+  {
+    jjtree.closeNodeScope(jjtn000, true);
+    jjtc000 = false;
+    if (jjtree.nodeCreated()) {
+     jjtreeCloseNodeScope(jjtn000);
+    }
+  }
+/*@egen*/
+  { return jjtn000; }/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void design_unit() :
+{/*@bgen(jjtree) design_unit */
+  ASTdesign_unit jjtn000 = new ASTdesign_unit(JJTDESIGN_UNIT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) design_unit */
+  try {
+/*@egen*/
+  context_clause() library_unit()/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+void designator()       :
+{}
+{
+    identifier()
+  | operator_symbol()
+}
+
+void direction() :
+{/*@bgen(jjtree) direction */
+  ASTdirection jjtn000 = new ASTdirection(JJTDIRECTION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) direction */
+  try {
+/*@egen*/
+  <TO> | <DOWNTO>/*@bgen(jjtree)*/
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void disconnection_specification() :
+{/*@bgen(jjtree) disconnection_specification */
+  ASTdisconnection_specification jjtn000 = new ASTdisconnection_specification(JJTDISCONNECTION_SPECIFICATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) disconnection_specification */
+  try {
+/*@egen*/
+  <DISCONNECT> guarded_signal_specification() <AFTER>
+    time_expression() ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+void discrete_range()        :
+{}
+{
+    LOOKAHEAD(simple_expression() direction() )
+    range()
+  | LOOKAHEAD( discrete_subtype_indication() )
+    discrete_subtype_indication()
+  | range() 
+}
+
+
+void element_association()       :
+{}
+{
+  [ LOOKAHEAD(choices() "=>") choices() "=>" ]
+  expression()
+}
+
+
+void element_declaration() :
+{/*@bgen(jjtree) element_declaration */
+  ASTelement_declaration jjtn000 = new ASTelement_declaration(JJTELEMENT_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) element_declaration */
+  try {
+/*@egen*/
+  identifier_list() ":" element_subtype_definition() ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void element_subtype_definition()       :
+{}
+{
+  subtype_indication()
+}
+
+
+void entity_aspect() :
+{/*@bgen(jjtree) entity_aspect */
+  ASTentity_aspect jjtn000 = new ASTentity_aspect(JJTENTITY_ASPECT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) entity_aspect */
+    try {
+/*@egen*/
+    <ENTITY> entity_name()
+    [ LOOKAHEAD("(" architecture_identifier() ")")
+    "(" architecture_identifier() ")" ]
+  | <CONFIGURATION> configuration_name()
+  | <OPEN>/*@bgen(jjtree)*/
+    } catch (Throwable jjte000) {
+      if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        throw (RuntimeException)jjte000;
+      }
+      if (jjte000 instanceof ParseException) {
+        throw (ParseException)jjte000;
+      }
+      throw (Error)jjte000;
+    } finally {
+      if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+/*@egen*/
+}
+
+/**
+ * Section 5: Specifications
+ */
+int entity_class()       :
+{}
+{
+    <ENTITY>                    { return ENTITY; }
+  | <ARCHITECTURE>              { return ARCHITECTURE; }
+  | <CONFIGURATION>             { return CONFIGURATION; }
+  | <PROCEDURE>                 { return PROCEDURE; }
+  | <FUNCTION>                  { return FUNCTION; }
+  | <PACKAGE>                   { return PACKAGE; }
+  | <TYPE>                      { return TYPE; }
+  | <SUBTYPE>                   { return SUBTYPE; }
+  | <CONSTANT>                  { return CONSTANT; }
+  | <SIGNAL>                    { return SIGNAL; }
+  | <VARIABLE>                  { return VARIABLE; }
+  | <COMPONENT>                 { return COMPONENT; }
+  | <LABEL>                     { return LABEL; }
+  | <LITERAL>                   { return LITERAL; }
+  | <UNITS>                     { return UNITS; }
+  | <GROUP>                     { return GROUP; }
+  | <FILE>                      { return FILE; }
+
+  /** 1076.1 extensions: */
+  | <SUBNATURE>                 { return SUBNATURE; }
+  | <NATURE>                    { return NATURE; }
+  | <TERMINAL>                  { return TERMINAL; }
+}
+
+
+void entity_class_entry()  :
+{/*@bgen(jjtree) entity_class_entry */
+  ASTentity_class_entry jjtn000 = new ASTentity_class_entry(JJTENTITY_CLASS_ENTRY);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) entity_class_entry */
+  try {
+/*@egen*/
+  entity_class() [ "<>" ]/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void entity_class_entry_list() :
+{/*@bgen(jjtree) entity_class_entry_list */
+  ASTentity_class_entry_list jjtn000 = new ASTentity_class_entry_list(JJTENTITY_CLASS_ENTRY_LIST);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) entity_class_entry_list */
+  try {
+/*@egen*/
+  entity_class_entry() ( "," entity_class_entry() )*/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void entity_declaration() :
+{/*@bgen(jjtree) entity_declaration */
+  ASTentity_declaration jjtn000 = new ASTentity_declaration(JJTENTITY_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) entity_declaration */
+  try {
+/*@egen*/
+  <ENTITY> identifier() <IS>                       { jjtn000.newBlock(); }
+          entity_header()
+          entity_declarative_part()
+  [ <BEGIN>
+    entity_statement_part() ]
+  <END> [ <ENTITY> ] [ entity_simple_name() ] ";"/*@bgen(jjtree)*/
+  {
+    jjtree.closeNodeScope(jjtn000, true);
+    jjtc000 = false;
+    if (jjtree.nodeCreated()) {
+     jjtreeCloseNodeScope(jjtn000);
+    }
+  }
+/*@egen*/
+
+  {
+    jjtn000.Check();
+    jjtn000.endBlock();
+  }/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void entity_declarative_item()       :
+{}
+{
+  try {
+    LOOKAHEAD(subprogram_declaration())
+    subprogram_declaration()
+  | subprogram_body()
+  | type_declaration()
+  | subtype_declaration()
+  | constant_declaration()
+  | signal_declaration()
+  | shared_variable_declaration()
+  | file_declaration()
+  | alias_declaration()
+  | LOOKAHEAD(attribute_declaration())
+    attribute_declaration()
+  | attribute_specification()
+  | disconnection_specification()
+  | use_clause()
+  | LOOKAHEAD(<GROUP> identifier() <IS>)
+    group_template_declaration()
+  | group_declaration()
+
+  // 1076.1 - Extensions:
+  | nature_declaration()
+  | subnature_declaration()
+  | terminal_declaration()
+  }
+  catch( ParseException e )
+  {
+    error_skipto(SEMICOLON, "syntax error in declarative item");
+  }
+}
+
+/**
+ * 4.8: Nature Declaration
+ * 1076.1 extension
+ */
+void nature_declaration() :
+{/*@bgen(jjtree) nature_declaration */
+  ASTnature_declaration jjtn000 = new ASTnature_declaration(JJTNATURE_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) nature_declaration */
+  try {
+/*@egen*/
+  <NATURE> identifier() <IS> nature_definition() ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+/**
+ * 1076.1 extension
+ */
+void nature_definition()       :
+{}
+{
+    scalar_nature_definition()
+  | composite_nature_definition()
+}
+
+void subnature_declaration() :
+{/*@bgen(jjtree) subnature_declaration */
+  ASTsubnature_declaration jjtn000 = new ASTsubnature_declaration(JJTSUBNATURE_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) subnature_declaration */
+  try {
+/*@egen*/
+  <SUBNATURE> identifier() <IS> subnature_indication() ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void subnature_indication() :
+{/*@bgen(jjtree) subnature_indication */
+  ASTsubnature_indication jjtn000 = new ASTsubnature_indication(JJTSUBNATURE_INDICATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) subnature_indication */
+  try {
+/*@egen*/
+  nature_mark() [index_constraint() ] 
+  [ <TOLERANCE> string_expression() <ACROSS> string_expression() <THROUGH>]/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+void nature_mark()       :
+{}
+{
+    LOOKAHEAD(nature_name())
+    nature_name() 
+  | LOOKAHEAD(subnature_name())
+    subnature_name()
+}
+
+void entity_declarative_part() :
+{/*@bgen(jjtree) entity_declarative_part */
+  ASTentity_declarative_part jjtn000 = new ASTentity_declarative_part(JJTENTITY_DECLARATIVE_PART);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) entity_declarative_part */
+  try {
+/*@egen*/
+  ( entity_declarative_item() )*/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+void entity_designator() :
+{/*@bgen(jjtree) entity_designator */
+  ASTentity_designator jjtn000 = new ASTentity_designator(JJTENTITY_DESIGNATOR);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) entity_designator */
+  try {
+/*@egen*/
+  entity_tag() signature()/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+
+void entity_header() :
+{/*@bgen(jjtree) entity_header */
+  ASTentity_header jjtn000 = new ASTentity_header(JJTENTITY_HEADER);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) entity_header */
+  try {
+/*@egen*/
+  [ formal_generic_clause() ]
+  [ formal_port_clause() ]/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void entity_name_list() :
+{/*@bgen(jjtree) entity_name_list */
+  ASTentity_name_list jjtn000 = new ASTentity_name_list(JJTENTITY_NAME_LIST);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) entity_name_list */
+  try {
+/*@egen*/
+  entity_designator() ( "," entity_designator() )*
+  | <OTHERS>
+  | <ALL>/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void entity_specification() :
+{/*@bgen(jjtree) entity_specification */
+  ASTentity_specification jjtn000 = new ASTentity_specification(JJTENTITY_SPECIFICATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) entity_specification */
+        try {
+/*@egen*/
+        entity_name_list() ":" entity_class()/*@bgen(jjtree)*/
+        } catch (Throwable jjte000) {
+          if (jjtc000) {
+            jjtree.clearNodeScope(jjtn000);
+            jjtc000 = false;
+          } else {
+            jjtree.popNode();
+          }
+          if (jjte000 instanceof RuntimeException) {
+            throw (RuntimeException)jjte000;
+          }
+          if (jjte000 instanceof ParseException) {
+            throw (ParseException)jjte000;
+          }
+          throw (Error)jjte000;
+        } finally {
+          if (jjtc000) {
+            jjtree.closeNodeScope(jjtn000, true);
+            if (jjtree.nodeCreated()) {
+             jjtreeCloseNodeScope(jjtn000);
+            }
+          }
+        }
+/*@egen*/
+}
+
+
+void entity_statement()       :
+{}
+{   LOOKAHEAD( concurrent_assertion_statement() )
+    concurrent_assertion_statement()
+  | LOOKAHEAD([process_label() ":"] [<POSTPONED>] <PROCESS>)
+    passive_process_statement()
+  | passive_concurrent_procedure_call_statement()
+}
+
+
+void entity_statement_part() :
+{/*@bgen(jjtree) entity_statement_part */
+  ASTentity_statement_part jjtn000 = new ASTentity_statement_part(JJTENTITY_STATEMENT_PART);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) entity_statement_part */
+  try {
+/*@egen*/
+  ( entity_statement() )*/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+void entity_tag() :
+{/*@bgen(jjtree) entity_tag */
+  ASTentity_tag jjtn000 = new ASTentity_tag(JJTENTITY_TAG);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) entity_tag */
+    try {
+/*@egen*/
+    simple_name()
+  | <character_literal>
+  | operator_symbol()/*@bgen(jjtree)*/
+    } catch (Throwable jjte000) {
+      if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        throw (RuntimeException)jjte000;
+      }
+      if (jjte000 instanceof ParseException) {
+        throw (ParseException)jjte000;
+      }
+      throw (Error)jjte000;
+    } finally {
+      if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+/*@egen*/
+}
+
+
+void enumeration_literal() :
+{/*@bgen(jjtree) enumeration_literal */
+  ASTenumeration_literal jjtn000 = new ASTenumeration_literal(JJTENUMERATION_LITERAL);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) enumeration_literal */
+  try {
+/*@egen*/
+  <character_literal>
+  | identifier()/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+
+void enumeration_type_definition() :
+{/*@bgen(jjtree) enumeration_type_definition */
+  ASTenumeration_type_definition jjtn000 = new ASTenumeration_type_definition(JJTENUMERATION_TYPE_DEFINITION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) enumeration_type_definition */
+  try {
+/*@egen*/
+  "(" enumeration_literal() ( "," enumeration_literal())* ")"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void exit_statement() :
+{/*@bgen(jjtree) exit_statement */
+  ASTexit_statement jjtn000 = new ASTexit_statement(JJTEXIT_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) exit_statement */
+  try {
+/*@egen*/
+  [ label() ":" ] <EXIT> [ loop_label() ]
+    [ <WHEN> condition() ] ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+void expression()       :
+{ int op; }
+{
+/**  relation() (
+ *   ( <AND> relation() )* |
+ *    ( <OR> relation() )*  |
+ *    ( <XOR> relation() )* |
+ *    [ <NAND> relation() ] |
+ *    [ <NOR> relation() ]  |
+ *    ( <XNOR> relation() )*
+ *  )
+ */
+  relation() 
+  ( LOOKAHEAD(1) op=logical_operator()/*@bgen(jjtree) #relation( 2) */
+                                       {
+                                         ASTrelation jjtn001 = new ASTrelation(JJTRELATION);
+                                         boolean jjtc001 = true;
+                                         jjtree.openNodeScope(jjtn001);
+                                         jjtreeOpenNodeScope(jjtn001);
+                                       }
+                                       try {
+/*@egen*/ relation()/*@bgen(jjtree)*/
+                                       } catch (Throwable jjte001) {
+                                         if (jjtc001) {
+                                           jjtree.clearNodeScope(jjtn001);
+                                           jjtc001 = false;
+                                         } else {
+                                           jjtree.popNode();
+                                         }
+                                         if (jjte001 instanceof RuntimeException) {
+                                           throw (RuntimeException)jjte001;
+                                         }
+                                         if (jjte001 instanceof ParseException) {
+                                           throw (ParseException)jjte001;
+                                         }
+                                         throw (Error)jjte001;
+                                       } finally {
+                                         if (jjtc001) {
+                                           jjtree.closeNodeScope(jjtn001,  2);
+                                           if (jjtree.nodeCreated()) {
+                                            jjtreeCloseNodeScope(jjtn001);
+                                           }
+                                         }
+                                       }
+/*@egen*/
+               )*
+
+}
+
+
+void factor()       :
+{}
+{
+    <ABS> primary()
+  | <NOT> primary()
+  | primary() [ LOOKAHEAD("**" primary() ) <EXP>/*@bgen(jjtree) #factor( 2) */
+                                                 {
+                                                   ASTfactor jjtn001 = new ASTfactor(JJTFACTOR);
+                                                   boolean jjtc001 = true;
+                                                   jjtree.openNodeScope(jjtn001);
+                                                   jjtreeOpenNodeScope(jjtn001);
+                                                 }
+                                                 try {
+/*@egen*/ primary()/*@bgen(jjtree)*/
+                                                 } catch (Throwable jjte001) {
+                                                   if (jjtc001) {
+                                                     jjtree.clearNodeScope(jjtn001);
+                                                     jjtc001 = false;
+                                                   } else {
+                                                     jjtree.popNode();
+                                                   }
+                                                   if (jjte001 instanceof RuntimeException) {
+                                                     throw (RuntimeException)jjte001;
+                                                   }
+                                                   if (jjte001 instanceof ParseException) {
+                                                     throw (ParseException)jjte001;
+                                                   }
+                                                   throw (Error)jjte001;
+                                                 } finally {
+                                                   if (jjtc001) {
+                                                     jjtree.closeNodeScope(jjtn001,  2);
+                                                     if (jjtree.nodeCreated()) {
+                                                      jjtreeCloseNodeScope(jjtn001);
+                                                     }
+                                                   }
+                                                 }
+/*@egen*/            ]
+}
+
+
+void file_declaration() :
+{/*@bgen(jjtree) file_declaration */
+  ASTfile_declaration jjtn000 = new ASTfile_declaration(JJTFILE_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) file_declaration */
+  try {
+/*@egen*/
+  <FILE> identifier_list() ":" subtype_indication()
+     [ file_open_information() ] ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void file_logical_name()       :
+{}
+{
+  string_expression()
+}
+
+
+void file_open_information() :
+{/*@bgen(jjtree) file_open_information */
+  ASTfile_open_information jjtn000 = new ASTfile_open_information(JJTFILE_OPEN_INFORMATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) file_open_information */
+  try {
+/*@egen*/
+  <OPEN> file_open_kind_expression() <IS> file_logical_name()
+  | <IS> [ <IN> | <OUT> ] file_logical_name()/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+void file_type_definition()       :
+{}
+{
+  <FILE> <OF> type_mark()
+}
+
+void floating_type_definition()       :
+{}
+{
+  range_constraint()
+}
+
+
+void formal_designator()       :
+{}
+{
+    LOOKAHEAD( generic_name() )
+    generic_name()
+  | LOOKAHEAD( port_name() )
+    port_name()
+  | parameter_name()
+}
+
+void formal_parameter_list() :
+{/*@bgen(jjtree) formal_parameter_list */
+  ASTformal_parameter_list jjtn000 = new ASTformal_parameter_list(JJTFORMAL_PARAMETER_LIST);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) formal_parameter_list */
+  try {
+/*@egen*/
+  parameter_interface_list()/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void formal_part()       :
+{}
+{
+    LOOKAHEAD( function_name() "(" formal_designator() ")")
+    function_name() "(" formal_designator() ")"
+  | LOOKAHEAD( type_mark() "(" formal_designator() ")")
+    type_mark() "(" formal_designator() ")"
+  | formal_designator()
+}
+
+void full_type_declaration() :
+{/*@bgen(jjtree) full_type_declaration */
+  ASTfull_type_declaration jjtn000 = new ASTfull_type_declaration(JJTFULL_TYPE_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) full_type_declaration */
+  try {
+/*@egen*/
+  <TYPE> identifier() <IS> type_definition() ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void function_call() :
+{/*@bgen(jjtree) function_call */
+  ASTfunction_call jjtn000 = new ASTfunction_call(JJTFUNCTION_CALL);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) function_call */
+  try {
+/*@egen*/
+  function_name()
+  [ LOOKAHEAD( "(" actual_parameter_part() ")" ) "(" actual_parameter_part() ")" ]/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+/**
+ * Section 9.7
+ */
+void generate_statement() :
+{/*@bgen(jjtree) generate_statement */
+  ASTgenerate_statement jjtn000 = new ASTgenerate_statement(JJTGENERATE_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) generate_statement */
+  try {
+/*@egen*/
+  generate_label() ":"
+  generation_scheme() <GENERATE>
+    [ LOOKAHEAD(2) ( block_declarative_item() )* <BEGIN> ]
+    ( architecture_statement() )*
+  <END> <GENERATE> [ generate_label() ] ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+/** 1076.1 extension: */
+void concurrent_break_statement() :
+{/*@bgen(jjtree) concurrent_break_statement */
+  ASTconcurrent_break_statement jjtn000 = new ASTconcurrent_break_statement(JJTCONCURRENT_BREAK_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) concurrent_break_statement */
+  try {
+/*@egen*/
+  [label() ":"] <BREAK> [break_list()] [sensitivity_clause() ] [ <WHEN> condition()] ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void generation_scheme() :
+{/*@bgen(jjtree) generation_scheme */
+  ASTgeneration_scheme jjtn000 = new ASTgeneration_scheme(JJTGENERATION_SCHEME);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) generation_scheme */
+    try {
+/*@egen*/
+    <FOR> generate_parameter_specification()
+  | <IF> condition()/*@bgen(jjtree)*/
+    } catch (Throwable jjte000) {
+      if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        throw (RuntimeException)jjte000;
+      }
+      if (jjte000 instanceof ParseException) {
+        throw (ParseException)jjte000;
+      }
+      throw (Error)jjte000;
+    } finally {
+      if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+/*@egen*/
+}
+
+
+void generic_clause() :
+{/*@bgen(jjtree) generic_clause */
+  ASTgeneric_clause jjtn000 = new ASTgeneric_clause(JJTGENERIC_CLAUSE);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) generic_clause */
+  try {
+/*@egen*/
+  <GENERIC> "(" generic_list() ")" ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void generic_list()       :
+{}
+{
+  generic_interface_list()
+}
+
+
+void generic_map_aspect()       :
+{}
+{
+  <GENERIC> <MAP> "(" generic_association_list() ")"
+}
+
+
+void group_constituent() :
+{/*@bgen(jjtree) group_constituent */
+  ASTgroup_constituent jjtn000 = new ASTgroup_constituent(JJTGROUP_CONSTITUENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) group_constituent */
+    try {
+/*@egen*/
+    name()
+  | <character_literal>/*@bgen(jjtree)*/
+    } catch (Throwable jjte000) {
+      if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        throw (RuntimeException)jjte000;
+      }
+      if (jjte000 instanceof ParseException) {
+        throw (ParseException)jjte000;
+      }
+      throw (Error)jjte000;
+    } finally {
+      if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+/*@egen*/
+}
+
+
+void group_constituent_list() :
+{/*@bgen(jjtree) group_constituent_list */
+  ASTgroup_constituent_list jjtn000 = new ASTgroup_constituent_list(JJTGROUP_CONSTITUENT_LIST);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) group_constituent_list */
+  try {
+/*@egen*/
+  group_constituent() ( "," group_constituent() )*/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void group_template_declaration() :
+{/*@bgen(jjtree) group_template_declaration */
+  ASTgroup_template_declaration jjtn000 = new ASTgroup_template_declaration(JJTGROUP_TEMPLATE_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) group_template_declaration */
+  try {
+/*@egen*/
+  <GROUP> identifier() <IS> "(" entity_class_entry_list() ")" ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+void group_declaration() :
+{/*@bgen(jjtree) group_declaration */
+  ASTgroup_declaration jjtn000 = new ASTgroup_declaration(JJTGROUP_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) group_declaration */
+  try {
+/*@egen*/
+  <GROUP> identifier() ":" group_template_name()
+  "(" group_constituent_list() ")" ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+
+void guarded_signal_specification() :
+{/*@bgen(jjtree) guarded_signal_specification */
+  ASTguarded_signal_specification jjtn000 = new ASTguarded_signal_specification(JJTGUARDED_SIGNAL_SPECIFICATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) guarded_signal_specification */
+  try {
+/*@egen*/
+  guarded_signal_list() ":" type_mark()/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void identifier() :
+{/*@bgen(jjtree) identifier */
+  ASTidentifier jjtn000 = new ASTidentifier(JJTIDENTIFIER);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/ Token t; }
+{/*@bgen(jjtree) identifier */
+     try {
+/*@egen*/  
+     t=<basic_identifier>/*@bgen(jjtree)*/
+                             {
+                               jjtree.closeNodeScope(jjtn000, true);
+                               jjtc000 = false;
+                               if (jjtree.nodeCreated()) {
+                                jjtreeCloseNodeScope(jjtn000);
+                               }
+                             }
+/*@egen*/    { jjtn000.name = t.image; }
+  |  t=<extended_identifier>/*@bgen(jjtree)*/
+                             {
+                               jjtree.closeNodeScope(jjtn000, true);
+                               jjtc000 = false;
+                               if (jjtree.nodeCreated()) {
+                                jjtreeCloseNodeScope(jjtn000);
+                               }
+                             }
+/*@egen*/ { jjtn000.name = t.image; }/*@bgen(jjtree)*/
+     } finally {
+       if (jjtc000) {
+         jjtree.closeNodeScope(jjtn000, true);
+         if (jjtree.nodeCreated()) {
+          jjtreeCloseNodeScope(jjtn000);
+         }
+       }
+     }
+/*@egen*/
+}
+
+
+void identifier_list() :
+{/*@bgen(jjtree) identifier_list */
+  ASTidentifier_list jjtn000 = new ASTidentifier_list(JJTIDENTIFIER_LIST);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) identifier_list */
+  try {
+/*@egen*/
+  identifier() ( "," identifier() )*/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void if_statement() :
+{/*@bgen(jjtree) if_statement */
+  ASTif_statement jjtn000 = new ASTif_statement(JJTIF_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) if_statement */
+  try {
+/*@egen*/
+  [ if_label() ":" ]
+  <IF> condition() <THEN>
+  sequence_of_statements()
+  ( <ELSIF> condition() <THEN>
+    sequence_of_statements() )*
+  [ <ELSE>
+    sequence_of_statements() ]
+  <END> <IF> [ if_label() ] ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+void incomplete_type_declaration() :
+{/*@bgen(jjtree) incomplete_type_declaration */
+  ASTincomplete_type_declaration jjtn000 = new ASTincomplete_type_declaration(JJTINCOMPLETE_TYPE_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) incomplete_type_declaration */
+  try {
+/*@egen*/
+  <TYPE> identifier() ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void index_constraint() :
+{/*@bgen(jjtree) index_constraint */
+  ASTindex_constraint jjtn000 = new ASTindex_constraint(JJTINDEX_CONSTRAINT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) index_constraint */
+  try {
+/*@egen*/
+  "(" discrete_range() ( "," discrete_range() )* ")"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+
+void index_specification() :
+{/*@bgen(jjtree) index_specification */
+  ASTindex_specification jjtn000 = new ASTindex_specification(JJTINDEX_SPECIFICATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) index_specification */
+    try {
+/*@egen*/
+    LOOKAHEAD( discrete_range() )
+    discrete_range()
+  | static_expression()/*@bgen(jjtree)*/
+    } catch (Throwable jjte000) {
+      if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        throw (RuntimeException)jjte000;
+      }
+      if (jjte000 instanceof ParseException) {
+        throw (ParseException)jjte000;
+      }
+      throw (Error)jjte000;
+    } finally {
+      if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+/*@egen*/
+}
+
+
+void index_subtype_definition() :
+{/*@bgen(jjtree) index_subtype_definition */
+  ASTindex_subtype_definition jjtn000 = new ASTindex_subtype_definition(JJTINDEX_SUBTYPE_DEFINITION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) index_subtype_definition */
+  try {
+/*@egen*/
+  type_mark() <RANGE> "<>"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+void indexed_name() :
+{/*@bgen(jjtree) indexed_name */
+  ASTindexed_name jjtn000 = new ASTindexed_name(JJTINDEXED_NAME);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) indexed_name */
+  try {
+/*@egen*/
+  prefix() "(" expression() ( "," expression() )* ")"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+void instantiated_unit() :
+{/*@bgen(jjtree) instantiated_unit */
+  ASTinstantiated_unit jjtn000 = new ASTinstantiated_unit(JJTINSTANTIATED_UNIT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) instantiated_unit */
+    try {
+/*@egen*/
+    [ <COMPONENT> ] component_name()
+  | <ENTITY> entity_name() [ "(" architecture_identifier() ")" ]
+  | <CONFIGURATION> configuration_name()/*@bgen(jjtree)*/
+    } catch (Throwable jjte000) {
+      if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        throw (RuntimeException)jjte000;
+      }
+      if (jjte000 instanceof ParseException) {
+        throw (ParseException)jjte000;
+      }
+      throw (Error)jjte000;
+    } finally {
+      if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+/*@egen*/
+}
+
+
+void instantiation_list() :
+{/*@bgen(jjtree) instantiation_list */
+  ASTinstantiation_list jjtn000 = new ASTinstantiation_list(JJTINSTANTIATION_LIST);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) instantiation_list */
+    try {
+/*@egen*/
+    instantiation_label() ( "," instantiation_label() )*
+  | <OTHERS>
+  | <ALL>/*@bgen(jjtree)*/
+    } catch (Throwable jjte000) {
+      if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        throw (RuntimeException)jjte000;
+      }
+      if (jjte000 instanceof ParseException) {
+        throw (ParseException)jjte000;
+      }
+      throw (Error)jjte000;
+    } finally {
+      if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+/*@egen*/
+}
+
+void integer_type_definition()       :
+{}
+{
+  range_constraint()
+}
+
+
+
+void interface_constant_declaration() :
+{/*@bgen(jjtree) interface_constant_declaration */
+  ASTinterface_constant_declaration jjtn000 = new ASTinterface_constant_declaration(JJTINTERFACE_CONSTANT_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) interface_constant_declaration */
+  try {
+/*@egen*/
+  [ <CONSTANT> ] identifier_list() ":" [ <IN> ]
+    subtype_indication() [ ":=" static_expression() ]/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+/**
+ * Section 4.3.2:
+ */
+void interface_declaration()       :
+{}
+{
+    LOOKAHEAD(interface_constant_declaration() ) 
+    interface_constant_declaration()
+  | LOOKAHEAD(interface_signal_declaration() )
+    interface_signal_declaration()
+  | LOOKAHEAD(interface_variable_declaration() )
+    interface_variable_declaration()
+  | LOOKAHEAD(interface_file_declaration() )
+    interface_file_declaration()
+
+  /** 1076.1 extensions: */
+  | interface_terminal_declaration() 
+  | interface_quantity_declaration()
+}
+
+
+/**
+ * 1076.1 extension:
+ */
+void interface_terminal_declaration()  :
+{/*@bgen(jjtree) interface_terminal_declaration */
+  ASTinterface_terminal_declaration jjtn000 = new ASTinterface_terminal_declaration(JJTINTERFACE_TERMINAL_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) interface_terminal_declaration */
+  try {
+/*@egen*/
+  <TERMINAL> identifier_list() ":" subnature_indication()/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+/**
+ * 1076.1 extension:
+ */
+void interface_quantity_declaration() :
+{/*@bgen(jjtree) interface_quantity_declaration */
+  ASTinterface_quantity_declaration jjtn000 = new ASTinterface_quantity_declaration(JJTINTERFACE_QUANTITY_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) interface_quantity_declaration */
+  try {
+/*@egen*/
+  <QUANTITY> identifier_list() ":" 
+  [ <IN> | <OUT> ] subtype_indication() [ ":=" static_expression() ]/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void interface_element()       :
+{}
+{
+  interface_declaration()
+}
+
+
+void interface_file_declaration() :
+{/*@bgen(jjtree) interface_file_declaration */
+  ASTinterface_file_declaration jjtn000 = new ASTinterface_file_declaration(JJTINTERFACE_FILE_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) interface_file_declaration */
+  try {
+/*@egen*/
+  <FILE> identifier_list() ":" subtype_indication()/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void interface_list() :
+{/*@bgen(jjtree) interface_list */
+  ASTinterface_list jjtn000 = new ASTinterface_list(JJTINTERFACE_LIST);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) interface_list */
+  try {
+/*@egen*/
+  interface_element() ( ";" interface_element() )*/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+void interface_signal_declaration() :
+{/*@bgen(jjtree) interface_signal_declaration */
+  ASTinterface_signal_declaration jjtn000 = new ASTinterface_signal_declaration(JJTINTERFACE_SIGNAL_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) interface_signal_declaration */
+  try {
+/*@egen*/
+  [<SIGNAL>] identifier_list() ":"
+  [ mode() ] subtype_indication() [ <BUS> ] [ ":=" static_expression() ]/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void interface_variable_declaration() :
+{/*@bgen(jjtree) interface_variable_declaration */
+  ASTinterface_variable_declaration jjtn000 = new ASTinterface_variable_declaration(JJTINTERFACE_VARIABLE_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) interface_variable_declaration */
+  try {
+/*@egen*/
+  [<VARIABLE>] identifier_list() ":"
+  [ mode() ] subtype_indication() [ ":=" static_expression() ]/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+
+void iteration_scheme() :
+{/*@bgen(jjtree) iteration_scheme */
+  ASTiteration_scheme jjtn000 = new ASTiteration_scheme(JJTITERATION_SCHEME);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) iteration_scheme */
+    try {
+/*@egen*/
+    <WHILE> condition()
+  | <FOR> loop_parameter_specification()/*@bgen(jjtree)*/
+    } catch (Throwable jjte000) {
+      if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        throw (RuntimeException)jjte000;
+      }
+      if (jjte000 instanceof ParseException) {
+        throw (ParseException)jjte000;
+      }
+      throw (Error)jjte000;
+    } finally {
+      if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+/*@egen*/
+}
+
+
+void label()       :
+{}
+{
+  identifier()
+}
+
+
+
+void library_clause()       :
+{}
+{
+  <LIBRARY> logical_name_list() ";"
+}
+
+
+void library_unit()       :
+{}
+{   LOOKAHEAD(<ENTITY> | <CONFIGURATION> | <PACKAGE> identifier() )
+    primary_unit()
+  | secondary_unit()
+}
+
+
+
+void literal() :
+{/*@bgen(jjtree) literal */
+  ASTliteral jjtn000 = new ASTliteral(JJTLITERAL);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) literal */
+    try {
+/*@egen*/
+    LOOKAHEAD( numeric_literal() )
+    numeric_literal()
+  | enumeration_literal()
+  | <string_literal>
+  | <bit_string_literal>
+  | <NULL>/*@bgen(jjtree)*/
+    } catch (Throwable jjte000) {
+      if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        throw (RuntimeException)jjte000;
+      }
+      if (jjte000 instanceof ParseException) {
+        throw (ParseException)jjte000;
+      }
+      throw (Error)jjte000;
+    } finally {
+      if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+/*@egen*/
+}
+
+
+void logical_name()       :
+{}
+{
+  identifier()
+}
+
+
+
+void logical_name_list() :
+{/*@bgen(jjtree) logical_name_list */
+  ASTlogical_name_list jjtn000 = new ASTlogical_name_list(JJTLOGICAL_NAME_LIST);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) logical_name_list */
+  try {
+/*@egen*/
+  logical_name() ( "," logical_name() )*/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+int logical_operator()       :
+{}
+{
+    <AND>             { return AND; }
+  | <OR>              { return OR; }
+  | <NAND>            { return NAND; }
+  | <NOR>             { return NOR; }
+  | <XOR>             { return XOR; }
+  | <XNOR>            { return XNOR; }
+}
+
+
+void loop_statement() :
+{/*@bgen(jjtree) loop_statement */
+  ASTloop_statement jjtn000 = new ASTloop_statement(JJTLOOP_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) loop_statement */
+  try {
+/*@egen*/
+  [ loop_label() ":" ]
+  [ iteration_scheme() ] <LOOP>
+                        sequence_of_statements()
+  <END> <LOOP> [ loop_label() ] ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+int miscellaneous_operator()       :
+{}
+{
+    <EXP>               { return EXP; }
+  | <ABS>               { return ABS; }
+  | <NOT>               { return NOT; }
+}
+
+
+void mode() :
+{/*@bgen(jjtree) mode */
+  ASTmode jjtn000 = new ASTmode(JJTMODE);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) mode */
+    try {
+/*@egen*/
+    <IN>
+  | <OUT>
+  | <INOUT>
+  | <BUFFER>
+  | <LINKAGE>/*@bgen(jjtree)*/
+    } finally {
+      if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+/*@egen*/
+}
+
+int multiplying_operator()       :
+{}
+{
+    "*"                 { return MUL; }
+  | "/"                 { return DIV; }
+  | <MOD>               { return MOD; }
+  | <REM>               { return REM; }
+}
+
+
+void name() :
+{/*@bgen(jjtree) name */
+  ASTname jjtn000 = new ASTname(JJTNAME);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) name */
+  try {
+/*@egen*/
+/**  simple_name()
+ * | operator_symbol()
+ *  | selected_name()
+ *  | indexed_name()
+ *  | slice_name()
+ *  | attribute_name()
+ *
+ * Kann ohne Linksrekursion wie folgt geschrieben werden:
+ */
+  ( simple_name() | operator_symbol() )
+  [ LOOKAHEAD(name_extension()) name_extension()   ]/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+void name_extension()       :
+{}
+{
+  (
+        LOOKAHEAD( signature() "'"  )
+        signature() "'" attribute_designator()
+        [ LOOKAHEAD( "(" expression() ")") "(" expression() ")"]
+      | "." suffix()
+      | LOOKAHEAD( "(" discrete_range() ")" ) 
+        "(" discrete_range() ")"  
+      | LOOKAHEAD( "(" expression() ("," expression() )* ")" )
+        "(" expression() ("," expression() )* ")"
+      /**
+       * The following production is already in sign. "'" ... ,
+       * since signature can be empty!
+       * | "'" attribute_designator() [ "(" expression() ")"]
+       */
+  )
+  [  LOOKAHEAD(name_extension() ) name_extension() ]
+}
+
+/**
+ * 1076.1 extension:
+ */
+void nature_element_declaration() :
+{/*@bgen(jjtree) nature_element_declaration */
+  ASTnature_element_declaration jjtn000 = new ASTnature_element_declaration(JJTNATURE_ELEMENT_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) nature_element_declaration */
+  try {
+/*@egen*/
+  identifier_list() ":" element_subnature_definition()/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+/**
+ * 1076.1 extension:
+ */
+void element_subnature_definition()       :
+{}
+{
+  subnature_indication()
+}
+
+
+void next_statement() :
+{/*@bgen(jjtree) next_statement */
+  ASTnext_statement jjtn000 = new ASTnext_statement(JJTNEXT_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) next_statement */
+  try {
+/*@egen*/                                                               
+  [ label() ":" ] <NEXT> [ loop_label() ] [ <WHEN> condition() ] ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+void null_statement() :
+{/*@bgen(jjtree) null_statement */
+  ASTnull_statement jjtn000 = new ASTnull_statement(JJTNULL_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) null_statement */
+  try {
+/*@egen*/
+  [ label() ":" ] <NULL> ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+
+void numeric_literal()       :
+{}
+{
+    LOOKAHEAD(physical_literal())
+    physical_literal()
+  | abstract_literal()
+}
+
+
+void object_declaration()       :
+{}
+{
+  try {
+    constant_declaration()
+  | signal_declaration()
+  | variable_declaration()
+  | file_declaration()
+  /** 1076.1 extensions: */
+  | terminal_declaration()
+  | quantity_declaration()
+
+  }
+  catch( ParseException e )
+  {
+    error_skipto(SEMICOLON, "syntax error in declaration");
+  }
+}
+
+
+void operator_symbol() :
+{/*@bgen(jjtree) operator_symbol */
+  ASToperator_symbol jjtn000 = new ASToperator_symbol(JJTOPERATOR_SYMBOL);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) operator_symbol */
+  try {
+/*@egen*/
+  <string_literal>/*@bgen(jjtree)*/
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void options_() :
+{/*@bgen(jjtree) options_ */
+  ASToptions_ jjtn000 = new ASToptions_(JJTOPTIONS_);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) options_ */
+  try {
+/*@egen*/
+  [ <GUARDED> ] [ delay_mechanism() ]/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void package_body() :
+{/*@bgen(jjtree) package_body */
+  ASTpackage_body jjtn000 = new ASTpackage_body(JJTPACKAGE_BODY);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) package_body */
+  try {
+/*@egen*/
+  <PACKAGE> <BODY> package_simple_name() <IS>
+       package_body_declarative_part()
+  <END> [ <PACKAGE> <BODY> ] [ package_simple_name() ] ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+void package_body_declarative_item()       :
+{}
+{
+  try {
+    LOOKAHEAD(subprogram_declaration())
+    subprogram_declaration()
+  | subprogram_body()
+  | type_declaration()
+  | subtype_declaration()
+  | constant_declaration()
+  | shared_variable_declaration()
+  | file_declaration()
+  | alias_declaration()
+  | use_clause()
+  | LOOKAHEAD(<GROUP> identifier() <IS>)
+    group_template_declaration()
+  | group_declaration()
+  }
+  catch( ParseException e )
+  {
+    error_skipto(SEMICOLON, "syntax error in declarative item");
+  }
+}
+
+
+void package_body_declarative_part() :
+{/*@bgen(jjtree) package_body_declarative_part */
+  ASTpackage_body_declarative_part jjtn000 = new ASTpackage_body_declarative_part(JJTPACKAGE_BODY_DECLARATIVE_PART);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) package_body_declarative_part */
+  try {
+/*@egen*/
+  ( package_body_declarative_item() )*/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+
+void package_declaration() :
+{/*@bgen(jjtree) package_declaration */
+  ASTpackage_declaration jjtn000 = new ASTpackage_declaration(JJTPACKAGE_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) package_declaration */
+  try {
+/*@egen*/
+  <PACKAGE> identifier() <IS>
+     package_declarative_part()
+  <END> [ <PACKAGE> ] [ package_simple_name() ] ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void package_declarative_item()       :
+{}
+{
+  try {
+    subprogram_declaration()
+  | type_declaration()
+  | subtype_declaration()
+  | constant_declaration()
+  | signal_declaration()
+  | shared_variable_declaration()
+  | file_declaration()
+  | alias_declaration()
+  | component_declaration()
+  | LOOKAHEAD( attribute_declaration() )
+    attribute_declaration()
+  | attribute_specification()
+  | disconnection_specification()
+  | use_clause()
+  | LOOKAHEAD(<GROUP> identifier() <IS>)
+    group_template_declaration()
+  | group_declaration()
+
+  // 1076.1 extensions:
+  | nature_declaration()
+  | subnature_declaration()
+  | terminal_declaration()
+  }
+  catch(ParseException e)
+  {
+    error_skipto(SEMICOLON, "syntax error in declaration");
+  }
+}
+
+void package_declarative_part() :
+{/*@bgen(jjtree) package_declarative_part */
+  ASTpackage_declarative_part jjtn000 = new ASTpackage_declarative_part(JJTPACKAGE_DECLARATIVE_PART);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) package_declarative_part */
+  try {
+/*@egen*/
+  ( package_declarative_item() )*/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void parameter_specification() :
+{/*@bgen(jjtree) parameter_specification */
+  ASTparameter_specification jjtn000 = new ASTparameter_specification(JJTPARAMETER_SPECIFICATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) parameter_specification */
+  try {
+/*@egen*/
+  identifier() <IN> discrete_range()/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+void physical_literal() :
+{/*@bgen(jjtree) physical_literal */
+  ASTphysical_literal jjtn000 = new ASTphysical_literal(JJTPHYSICAL_LITERAL);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) physical_literal */
+  try {
+/*@egen*/
+  [ LOOKAHEAD(abstract_literal() unit_name() )
+    abstract_literal() ]
+  unit_name()/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void physical_type_definition() :
+{/*@bgen(jjtree) physical_type_definition */
+  ASTphysical_type_definition jjtn000 = new ASTphysical_type_definition(JJTPHYSICAL_TYPE_DEFINITION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) physical_type_definition */
+  try {
+/*@egen*/
+  range_constraint()
+  <UNITS>
+  base_unit_declaration()
+  ( secondary_unit_declaration() )*
+  <END> <UNITS> [ physical_type_simple_name() ]/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void port_clause() :
+{/*@bgen(jjtree) port_clause */
+  ASTport_clause jjtn000 = new ASTport_clause(JJTPORT_CLAUSE);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) port_clause */
+  try {
+/*@egen*/
+  <PORT> "(" port_list() ")" ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+void port_list()       :
+{}
+{
+  port_interface_list()
+}
+
+
+void port_map_aspect() :
+{/*@bgen(jjtree) port_map_aspect */
+  ASTport_map_aspect jjtn000 = new ASTport_map_aspect(JJTPORT_MAP_ASPECT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) port_map_aspect */
+  try {
+/*@egen*/
+  <PORT> <MAP> "(" port_association_list() ")"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void prefix() :
+{/*@bgen(jjtree) prefix */
+  ASTprefix jjtn000 = new ASTprefix(JJTPREFIX);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) prefix */
+    try {
+/*@egen*/
+    LOOKAHEAD( function_call() )
+    function_call()
+  | name()/*@bgen(jjtree)*/
+    } catch (Throwable jjte000) {
+      if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        throw (RuntimeException)jjte000;
+      }
+      if (jjte000 instanceof ParseException) {
+        throw (ParseException)jjte000;
+      }
+      throw (Error)jjte000;
+    } finally {
+      if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+/*@egen*/
+}
+
+
+void primary()       :
+{}
+{
+    LOOKAHEAD( qualified_expression() )
+    qualified_expression()
+
+  | LOOKAHEAD( function_call() )
+    function_call()
+
+  | LOOKAHEAD(name())
+    name()
+
+  | LOOKAHEAD(literal())
+    literal()
+
+  | LOOKAHEAD( aggregate() )
+    aggregate()
+
+  | LOOKAHEAD( "(" expression() ")")
+    "(" expression() ")"
+
+  | LOOKAHEAD( type_conversion() )
+    type_conversion()
+
+  | allocator()
+
+}
+
+
+void primary_unit()       :
+{}
+{
+    entity_declaration()
+  | configuration_declaration()
+  | LOOKAHEAD(<PACKAGE> identifier())
+    package_declaration()
+}
+
+
+void procedure_call() :
+{/*@bgen(jjtree) procedure_call */
+  ASTprocedure_call jjtn000 = new ASTprocedure_call(JJTPROCEDURE_CALL);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) procedure_call */
+  try {
+/*@egen*/
+  procedure_name() [ "(" actual_parameter_part() ")" ]/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+void procedure_call_statement() :
+{/*@bgen(jjtree) procedure_call_statement */
+  ASTprocedure_call_statement jjtn000 = new ASTprocedure_call_statement(JJTPROCEDURE_CALL_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) procedure_call_statement */
+   try {
+/*@egen*/
+   [ LOOKAHEAD( label() ":") label() ":" ]
+   procedure_call() ";"/*@bgen(jjtree)*/
+   } catch (Throwable jjte000) {
+     if (jjtc000) {
+       jjtree.clearNodeScope(jjtn000);
+       jjtc000 = false;
+     } else {
+       jjtree.popNode();
+     }
+     if (jjte000 instanceof RuntimeException) {
+       throw (RuntimeException)jjte000;
+     }
+     if (jjte000 instanceof ParseException) {
+       throw (ParseException)jjte000;
+     }
+     throw (Error)jjte000;
+   } finally {
+     if (jjtc000) {
+       jjtree.closeNodeScope(jjtn000, true);
+       if (jjtree.nodeCreated()) {
+        jjtreeCloseNodeScope(jjtn000);
+       }
+     }
+   }
+/*@egen*/
+}
+
+
+void process_declarative_item()       :
+{}
+{
+    LOOKAHEAD(subprogram_declaration())
+    subprogram_declaration()
+  | subprogram_body()
+  | type_declaration()
+  | subtype_declaration()
+  | constant_declaration()
+  | variable_declaration()
+  | file_declaration()
+  | alias_declaration()
+  | LOOKAHEAD( attribute_declaration() )
+    attribute_declaration()
+  | attribute_specification()
+  | use_clause()
+  | LOOKAHEAD( <GROUP> identifier() <IS> )
+    group_template_declaration()
+  | group_declaration()
+}
+
+void process_declarative_part() :
+{/*@bgen(jjtree) process_declarative_part */
+  ASTprocess_declarative_part jjtn000 = new ASTprocess_declarative_part(JJTPROCESS_DECLARATIVE_PART);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) process_declarative_part */
+  try {
+/*@egen*/
+  ( process_declarative_item() )*/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void process_statement() :
+{/*@bgen(jjtree) process_statement */
+  ASTprocess_statement jjtn000 = new ASTprocess_statement(JJTPROCESS_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) process_statement */
+   try {
+/*@egen*/
+   [ process_label() ":" ]
+   [ <POSTPONED> ] <PROCESS>                    { jjtn000.newBlock(); }
+   [ "(" sensitivity_list() ")" ] [ <IS> ]
+     process_declarative_part()
+   <BEGIN>
+     process_statement_part()
+   <END> [ <POSTPONED> ] <PROCESS> [ process_label() ] ";"/*@bgen(jjtree)*/
+   {
+     jjtree.closeNodeScope(jjtn000, true);
+     jjtc000 = false;
+     if (jjtree.nodeCreated()) {
+      jjtreeCloseNodeScope(jjtn000);
+     }
+   }
+/*@egen*/
+
+   {
+     jjtn000.Check();
+     jjtn000.endBlock();
+   }/*@bgen(jjtree)*/
+   } catch (Throwable jjte000) {
+     if (jjtc000) {
+       jjtree.clearNodeScope(jjtn000);
+       jjtc000 = false;
+     } else {
+       jjtree.popNode();
+     }
+     if (jjte000 instanceof RuntimeException) {
+       throw (RuntimeException)jjte000;
+     }
+     if (jjte000 instanceof ParseException) {
+       throw (ParseException)jjte000;
+     }
+     throw (Error)jjte000;
+   } finally {
+     if (jjtc000) {
+       jjtree.closeNodeScope(jjtn000, true);
+       if (jjtree.nodeCreated()) {
+        jjtreeCloseNodeScope(jjtn000);
+       }
+     }
+   }
+/*@egen*/
+}
+
+
+void process_statement_part() :
+{/*@bgen(jjtree) process_statement_part */
+  ASTprocess_statement_part jjtn000 = new ASTprocess_statement_part(JJTPROCESS_STATEMENT_PART);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) process_statement_part */
+  try {
+/*@egen*/
+  ( sequential_statement() )*/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+/*
+    VHDL 2002: protected types:
+*/
+
+void protected_type_body()       :
+{}
+{
+  <PROTECTED> <BODY>
+    protected_type_body_declarative_part()
+  <END> <PROTECTED> <BODY> [ simple_name() ]
+}
+
+void protected_type_body_declarative_item()       :
+{}
+{
+    LOOKAHEAD(subprogram_declaration())
+    subprogram_declaration()
+    | subprogram_body()
+    | type_declaration() 
+    | subtype_declaration() 
+    | constant_declaration() 
+    | variable_declaration() 
+    | file_declaration() 
+    | alias_declaration() 
+    | LOOKAHEAD(attribute_declaration())
+    attribute_declaration() 
+    | attribute_specification() 
+    | use_clause() 
+    | LOOKAHEAD(group_template_declaration())
+    group_template_declaration()
+    | group_declaration() 
+}
+
+void protected_type_body_declarative_part()       :
+{}
+{ 
+  (protected_type_body_declarative_item())+
+}
+
+void protected_type_declaration()       :
+{}
+{
+  <PROTECTED>
+    protected_type_declarative_part()
+  <END> <PROTECTED> [ simple_name() ]
+}
+
+void protected_type_declarative_item()       :
+{}
+{
+    subprogram_declaration()
+    | attribute_declaration()
+    | use_clause()
+}
+
+void protected_type_declarative_part()       :
+{}
+{ 
+  (protected_type_declarative_item())+
+}
+
+void protected_type_definition()       :
+{}
+{
+    LOOKAHEAD(protected_type_body()) protected_type_body()
+    | protected_type_declaration()
+}
+
+void qualified_expression() :
+{/*@bgen(jjtree) qualified_expression */
+  ASTqualified_expression jjtn000 = new ASTqualified_expression(JJTQUALIFIED_EXPRESSION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) qualified_expression */
+  try {
+/*@egen*/
+  type_mark() "'"
+  (   LOOKAHEAD( aggregate() )
+      aggregate()
+    | "(" expression() ")"
+  )/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+void range() :
+{/*@bgen(jjtree) range */
+  ASTrange jjtn000 = new ASTrange(JJTRANGE);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) range */
+    try {
+/*@egen*/
+    LOOKAHEAD( simple_expression() direction() )
+    simple_expression() direction() simple_expression()
+  | range_attribute_name()/*@bgen(jjtree)*/
+    } catch (Throwable jjte000) {
+      if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        throw (RuntimeException)jjte000;
+      }
+      if (jjte000 instanceof ParseException) {
+        throw (ParseException)jjte000;
+      }
+      throw (Error)jjte000;
+    } finally {
+      if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+/*@egen*/
+}
+
+
+void range_constraint()       :
+{}
+{
+  <RANGE> range()
+}
+
+void record_nature_definition() :
+{/*@bgen(jjtree) record_nature_definition */
+  ASTrecord_nature_definition jjtn000 = new ASTrecord_nature_definition(JJTRECORD_NATURE_DEFINITION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) record_nature_definition */
+  try {
+/*@egen*/
+  <RECORD>
+  ( nature_element_declaration() )+
+  <END> <RECORD> [ record_nature_simple_name() ]/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+void record_type_definition() :
+{/*@bgen(jjtree) record_type_definition */
+  ASTrecord_type_definition jjtn000 = new ASTrecord_type_definition(JJTRECORD_TYPE_DEFINITION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) record_type_definition */
+  try {
+/*@egen*/
+  <RECORD>
+  ( element_declaration() )+
+  <END> <RECORD> [ record_type_simple_name() ]/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+
+void relation()       :
+{ int op; }
+{
+  shift_expression() 
+  [ LOOKAHEAD(1)
+  op=relational_operator()/*@bgen(jjtree) #shift_expression( 2) */
+  {
+    ASTshift_expression jjtn001 = new ASTshift_expression(JJTSHIFT_EXPRESSION);
+    boolean jjtc001 = true;
+    jjtree.openNodeScope(jjtn001);
+    jjtreeOpenNodeScope(jjtn001);
+  }
+  try {
+/*@egen*/
+  shift_expression()/*@bgen(jjtree)*/
+  } catch (Throwable jjte001) {
+    if (jjtc001) {
+      jjtree.clearNodeScope(jjtn001);
+      jjtc001 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte001 instanceof RuntimeException) {
+      throw (RuntimeException)jjte001;
+    }
+    if (jjte001 instanceof ParseException) {
+      throw (ParseException)jjte001;
+    }
+    throw (Error)jjte001;
+  } finally {
+    if (jjtc001) {
+      jjtree.closeNodeScope(jjtn001,  2);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn001);
+      }
+    }
+  }
+/*@egen*/
+                       ]
+}
+
+
+int relational_operator()       :
+{}
+{
+    <EQ>                { return EQ; }
+  | <NEQ>               { return NEQ; } 
+  | <LO>                { return LO; }
+  | <LE>                { return LE; }
+  | <GT>                { return GT; }
+  | <GE>                { return GE; }
+}
+
+
+void report_statement() :
+{/*@bgen(jjtree) report_statement */
+  ASTreport_statement jjtn000 = new ASTreport_statement(JJTREPORT_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) report_statement */
+  try {
+/*@egen*/
+  [ label() ":" ]  <REPORT> expression()
+  [ <SEVERITY> expression() ] ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void return_statement() :
+{/*@bgen(jjtree) return_statement */
+  ASTreturn_statement jjtn000 = new ASTreturn_statement(JJTRETURN_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) return_statement */
+  try {
+/*@egen*/
+  [ label() ":" ] <RETURN> [ expression() ] ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+// 1076.1 - extension:
+void scalar_nature_definition() :
+{/*@bgen(jjtree) scalar_nature_definition */
+  ASTscalar_nature_definition jjtn000 = new ASTscalar_nature_definition(JJTSCALAR_NATURE_DEFINITION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) scalar_nature_definition */
+  try {
+/*@egen*/
+  type_mark() <ACROSS> type_mark() <THROUGH>/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void scalar_type_definition()       :
+{}
+{
+    LOOKAHEAD(range_constraint() <UNITS> )
+    physical_type_definition()
+  |
+    LOOKAHEAD(enumeration_type_definition())
+    enumeration_type_definition()
+/**  | integer_type_definition()
+ *  | floating_type_definition()
+ * integer- and floating_type_definition are both range_constraint,
+ * thus:
+ */
+  |
+    range_constraint()
+}
+
+void secondary_unit()       :
+{}
+{
+    LOOKAHEAD( <ARCHITECTURE> )
+    architecture_body()
+  | LOOKAHEAD( <PACKAGE> <BODY> )
+    package_body()
+}
+
+
+void secondary_unit_declaration() :
+{/*@bgen(jjtree) secondary_unit_declaration */
+  ASTsecondary_unit_declaration jjtn000 = new ASTsecondary_unit_declaration(JJTSECONDARY_UNIT_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) secondary_unit_declaration */
+  try {
+/*@egen*/
+  identifier() "=" physical_literal() ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void selected_name() :
+{/*@bgen(jjtree) selected_name */
+  ASTselected_name jjtn000 = new ASTselected_name(JJTSELECTED_NAME);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) selected_name */
+  try {
+/*@egen*/
+  /**
+   * prefix() "." suffix()
+   * results in left-recursion...
+   * the follwoing does the same (i hope ...)
+   */
+
+  ( simple_name() | operator_symbol() )
+  [ LOOKAHEAD( name_extension() )  name_extension() ]/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+
+  /**
+   * semantic analysis has to ensure that last production
+   * was "." suffix()
+   */
+}
+
+
+void selected_signal_assignment() :
+{/*@bgen(jjtree) selected_signal_assignment */
+  ASTselected_signal_assignment jjtn000 = new ASTselected_signal_assignment(JJTSELECTED_SIGNAL_ASSIGNMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) selected_signal_assignment */
+  try {
+/*@egen*/
+  <WITH> expression() <SELECT>
+  target()  "<=" options_() selected_waveforms() ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+void selected_waveforms() :
+{/*@bgen(jjtree) selected_waveforms */
+  ASTselected_waveforms jjtn000 = new ASTselected_waveforms(JJTSELECTED_WAVEFORMS);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) selected_waveforms */
+  try {
+/*@egen*/
+  waveform() <WHEN> choices()
+  ("," waveform() <WHEN> choices() )*/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+void sensitivity_clause()       :
+{}
+{
+  <ON> sensitivity_list()
+}
+
+
+void sensitivity_list() :
+{/*@bgen(jjtree) sensitivity_list */
+  ASTsensitivity_list jjtn000 = new ASTsensitivity_list(JJTSENSITIVITY_LIST);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) sensitivity_list */
+  try {
+/*@egen*/
+  signal_name() ( "," signal_name() )*/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void sequence_of_statements() :
+{/*@bgen(jjtree) sequence_of_statements */
+  ASTsequence_of_statements jjtn000 = new ASTsequence_of_statements(JJTSEQUENCE_OF_STATEMENTS);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) sequence_of_statements */
+  try {
+/*@egen*/
+  ( sequential_statement() )*/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+void sequential_statement()       :
+{}
+{
+  try {
+    (
+      LOOKAHEAD(3)
+      wait_statement()
+    | LOOKAHEAD(3)
+      assertion_statement()
+    | LOOKAHEAD(3)
+      report_statement()
+    | LOOKAHEAD(  [ label() ":" ] target() "<=" )
+      signal_assignment_statement()
+    | LOOKAHEAD(  [ label() ":" ] target() ":=" )
+      variable_assignment_statement()
+    | LOOKAHEAD(3)
+      procedure_call_statement()
+    | LOOKAHEAD(3)
+      if_statement()
+    | LOOKAHEAD(3)
+      case_statement()
+    | LOOKAHEAD(3)
+      loop_statement()
+    | LOOKAHEAD(3)
+      next_statement()
+    | LOOKAHEAD(3)
+      exit_statement()
+    | LOOKAHEAD(3)
+      return_statement()
+    | LOOKAHEAD(3)
+      null_statement()
+
+    /** 1076.1 extensions: */
+    | break_statement()
+    )
+  }
+
+  // Error handling: skip till next semicolon.
+  catch (ParseException e)
+  {
+    error_skipto(SEMICOLON, "syntax error in sequential statement");
+  } 
+}
+
+
+void shift_expression()       :
+{ int op; }
+{
+  simple_expression() 
+  [ LOOKAHEAD(2) op=shift_operator()/*@bgen(jjtree) #simple_expression( 2) */
+  {
+    ASTsimple_expression jjtn001 = new ASTsimple_expression(JJTSIMPLE_EXPRESSION);
+    boolean jjtc001 = true;
+    jjtree.openNodeScope(jjtn001);
+    jjtreeOpenNodeScope(jjtn001);
+  }
+  try {
+/*@egen*/
+  simple_expression()/*@bgen(jjtree)*/
+  } catch (Throwable jjte001) {
+    if (jjtc001) {
+      jjtree.clearNodeScope(jjtn001);
+      jjtc001 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte001 instanceof RuntimeException) {
+      throw (RuntimeException)jjte001;
+    }
+    if (jjte001 instanceof ParseException) {
+      throw (ParseException)jjte001;
+    }
+    throw (Error)jjte001;
+  } finally {
+    if (jjtc001) {
+      jjtree.closeNodeScope(jjtn001,  2);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn001);
+      }
+    }
+  }
+/*@egen*/                        ]
+}
+
+int shift_operator()       :
+{}
+{
+    <SLL>               { return SLL; }
+  | <SRL>               { return SRL; }
+  | <SLA>               { return SLA; }
+  | <SRA>               { return SRA; }
+  | <ROL>               { return ROL; }
+  | <ROR>               { return ROR; }
+}
+
+void sign() :
+{/*@bgen(jjtree) sign */
+  ASTsign jjtn000 = new ASTsign(JJTSIGN);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) sign */
+    try {
+/*@egen*/
+    "+"
+  | "-"/*@bgen(jjtree)*/
+    } finally {
+      if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+/*@egen*/
+}
+
+
+void signal_assignment_statement() :
+{/*@bgen(jjtree) signal_assignment_statement */
+  ASTsignal_assignment_statement jjtn000 = new ASTsignal_assignment_statement(JJTSIGNAL_ASSIGNMENT_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) signal_assignment_statement */
+  try {
+/*@egen*/
+  [ LOOKAHEAD( label() ":") label() ":" ]
+  target() "<=" [ delay_mechanism() ] waveform() ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+
+}
+
+
+void signal_declaration() :
+{/*@bgen(jjtree) signal_declaration */
+  ASTsignal_declaration jjtn000 = new ASTsignal_declaration(JJTSIGNAL_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) signal_declaration */
+    try {
+/*@egen*/
+    <SIGNAL> identifier_list() ":"
+    subtype_indication() [ signal_kind() ] [ ":=" expression() ] ";"/*@bgen(jjtree)*/
+    } catch (Throwable jjte000) {
+      if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        throw (RuntimeException)jjte000;
+      }
+      if (jjte000 instanceof ParseException) {
+        throw (ParseException)jjte000;
+      }
+      throw (Error)jjte000;
+    } finally {
+      if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+/*@egen*/
+}
+
+
+void signal_kind() :
+{/*@bgen(jjtree) signal_kind */
+  ASTsignal_kind jjtn000 = new ASTsignal_kind(JJTSIGNAL_KIND);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) signal_kind */
+    try {
+/*@egen*/
+    <REGISTER>
+  | <BUS>/*@bgen(jjtree)*/
+    } finally {
+      if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+/*@egen*/
+}
+
+void signal_list() :
+{/*@bgen(jjtree) signal_list */
+  ASTsignal_list jjtn000 = new ASTsignal_list(JJTSIGNAL_LIST);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) signal_list */
+    try {
+/*@egen*/
+    signal_name() ( "," signal_name() )*
+  | <OTHERS>
+  | <ALL>/*@bgen(jjtree)*/
+    } catch (Throwable jjte000) {
+      if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        throw (RuntimeException)jjte000;
+      }
+      if (jjte000 instanceof ParseException) {
+        throw (ParseException)jjte000;
+      }
+      throw (Error)jjte000;
+    } finally {
+      if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+/*@egen*/
+}
+
+
+void signature() :
+{/*@bgen(jjtree) signature */
+  ASTsignature jjtn000 = new ASTsignature(JJTSIGNATURE);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) signature */
+  try {
+/*@egen*/
+  [ type_mark() ( LOOKAHEAD( "," type_mark() ) "," type_mark() )* ]
+  [ <RETURN> type_mark() ]/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void simple_expression()       :
+{ int op; }
+{
+   [ sign() ] term()
+   ( LOOKAHEAD(2) op=adding_operator()/*@bgen(jjtree) #term( 2) */
+                                       {
+                                         ASTterm jjtn001 = new ASTterm(JJTTERM);
+                                         boolean jjtc001 = true;
+                                         jjtree.openNodeScope(jjtn001);
+                                         jjtreeOpenNodeScope(jjtn001);
+                                       }
+                                       try {
+/*@egen*/ term()/*@bgen(jjtree)*/
+                                       } catch (Throwable jjte001) {
+                                         if (jjtc001) {
+                                           jjtree.clearNodeScope(jjtn001);
+                                           jjtc001 = false;
+                                         } else {
+                                           jjtree.popNode();
+                                         }
+                                         if (jjte001 instanceof RuntimeException) {
+                                           throw (RuntimeException)jjte001;
+                                         }
+                                         if (jjte001 instanceof ParseException) {
+                                           throw (ParseException)jjte001;
+                                         }
+                                         throw (Error)jjte001;
+                                       } finally {
+                                         if (jjtc001) {
+                                           jjtree.closeNodeScope(jjtn001,  2);
+                                           if (jjtree.nodeCreated()) {
+                                            jjtreeCloseNodeScope(jjtn001);
+                                           }
+                                         }
+                                       }
+/*@egen*/
+              )*
+}
+
+
+void simple_name()       :
+{}
+{
+  identifier()
+}
+
+void slice_name() :
+{/*@bgen(jjtree) slice_name */
+  ASTslice_name jjtn000 = new ASTslice_name(JJTSLICE_NAME);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) slice_name */
+  try {
+/*@egen*/
+  prefix() "(" discrete_range() ")"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+
+void subprogram_body() :
+{/*@bgen(jjtree) subprogram_body */
+  ASTsubprogram_body jjtn000 = new ASTsubprogram_body(JJTSUBPROGRAM_BODY);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) subprogram_body */
+  try {
+/*@egen*/
+  subprogram_specification() <IS>
+     subprogram_declarative_part()
+  <BEGIN>
+         subprogram_statement_part()
+  <END> [ subprogram_kind() ] [ designator() ] ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void subprogram_declaration()       :
+{}
+{
+  subprogram_specification() ";"
+}
+
+
+void subprogram_declarative_item()       :
+{}
+{
+    LOOKAHEAD(subprogram_declaration())
+    subprogram_declaration()
+  | subprogram_body()
+  | type_declaration()
+  | subtype_declaration()
+  | constant_declaration()
+  | variable_declaration()
+  | file_declaration()
+  | alias_declaration()
+  | LOOKAHEAD(attribute_declaration())
+    attribute_declaration()
+  | attribute_specification()
+  | use_clause()
+  | LOOKAHEAD( <GROUP> identifier() <IS>)
+    group_template_declaration()
+  | group_declaration()
+}
+
+void subprogram_declarative_part() :
+{/*@bgen(jjtree) subprogram_declarative_part */
+  ASTsubprogram_declarative_part jjtn000 = new ASTsubprogram_declarative_part(JJTSUBPROGRAM_DECLARATIVE_PART);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) subprogram_declarative_part */
+  try {
+/*@egen*/
+  ( subprogram_declarative_item() )*/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+int subprogram_kind()       :
+{}
+{
+    <PROCEDURE>                 { return PROCEDURE; }
+  | <FUNCTION>                  { return FUNCTION; }
+}
+
+void subprogram_specification() :
+{/*@bgen(jjtree) subprogram_specification */
+  ASTsubprogram_specification jjtn000 = new ASTsubprogram_specification(JJTSUBPROGRAM_SPECIFICATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) subprogram_specification */
+  try {
+/*@egen*/
+  <PROCEDURE> designator() [ "(" formal_parameter_list() ")" ]
+  | [ <PURE> | <IMPURE> ]  <FUNCTION> designator()
+     [ "(" formal_parameter_list() ")" ]
+                <RETURN> type_mark()/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+
+void subprogram_statement_part() :
+{/*@bgen(jjtree) subprogram_statement_part */
+  ASTsubprogram_statement_part jjtn000 = new ASTsubprogram_statement_part(JJTSUBPROGRAM_STATEMENT_PART);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) subprogram_statement_part */
+  try {
+/*@egen*/
+  ( sequential_statement() )*/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void subtype_declaration() :
+{/*@bgen(jjtree) subtype_declaration */
+  ASTsubtype_declaration jjtn000 = new ASTsubtype_declaration(JJTSUBTYPE_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) subtype_declaration */
+  try {
+/*@egen*/
+  <SUBTYPE> identifier() <IS> subtype_indication() ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+/**
+ * Section 4.1:
+ */
+void subtype_indication() :
+{/*@bgen(jjtree) subtype_indication */
+  ASTsubtype_indication jjtn000 = new ASTsubtype_indication(JJTSUBTYPE_INDICATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) subtype_indication */
+    try {
+/*@egen*/
+  /*
+   * enumeration resolves conflict ! After implementation of symbol tables
+   * this can be replaced by semantic lookahead.
+   */ 
+    LOOKAHEAD(resolution_function_name() type_mark() constraint())
+    resolution_function_name() type_mark() constraint() 
+      [ LOOKAHEAD(tolerance_aspect())tolerance_aspect() ]
+
+  | LOOKAHEAD( type_mark() constraint() )
+    type_mark() constraint() 
+      [ LOOKAHEAD(tolerance_aspect()) tolerance_aspect() ]
+
+  | LOOKAHEAD( resolution_function_name() type_mark() )
+    resolution_function_name() type_mark() 
+      [ LOOKAHEAD(tolerance_aspect())tolerance_aspect() ]
+
+  | LOOKAHEAD( type_mark() )
+    type_mark()  
+      [ LOOKAHEAD(tolerance_aspect()) tolerance_aspect() ]/*@bgen(jjtree)*/
+    } catch (Throwable jjte000) {
+      if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        throw (RuntimeException)jjte000;
+      }
+      if (jjte000 instanceof ParseException) {
+        throw (ParseException)jjte000;
+      }
+      throw (Error)jjte000;
+    } finally {
+      if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+/*@egen*/
+}
+
+
+/**
+ * 1076.1 extension:
+ */
+void tolerance_aspect()       :
+{}
+{
+  <TOLERANCE> string_expression()
+}
+
+
+/**
+ * Section 4.3.1.6: Quantity declaration
+ * 1076.1 extension:
+ */
+void quantity_declaration()       :
+{}
+{
+    LOOKAHEAD(free_quantity_declaration() )
+    free_quantity_declaration()
+  | LOOKAHEAD(branch_quantity_declaration() )
+    branch_quantity_declaration()
+  | source_quantity_declaration()
+}
+
+/**
+ * 1076.1 extension:
+ */
+void free_quantity_declaration() :
+{/*@bgen(jjtree) free_quantity_declaration */
+  ASTfree_quantity_declaration jjtn000 = new ASTfree_quantity_declaration(JJTFREE_QUANTITY_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) free_quantity_declaration */
+  try {
+/*@egen*/
+  <QUANTITY> identifier_list() ":" subtype_indication() [":=" expression()] ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+/**
+ * 1076.1 extension:
+ */
+void branch_quantity_declaration() :
+{/*@bgen(jjtree) branch_quantity_declaration */
+  ASTbranch_quantity_declaration jjtn000 = new ASTbranch_quantity_declaration(JJTBRANCH_QUANTITY_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) branch_quantity_declaration */
+  try {
+/*@egen*/
+  <QUANTITY> [LOOKAHEAD(across_aspect()) across_aspect()] 
+	     [LOOKAHEAD(through_aspect()) through_aspect()] 
+	     terminal_aspect() ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+/**
+ * 1076.1 extension:
+ */
+void source_quantity_declaration() :
+{/*@bgen(jjtree) source_quantity_declaration */
+  ASTsource_quantity_declaration jjtn000 = new ASTsource_quantity_declaration(JJTSOURCE_QUANTITY_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) source_quantity_declaration */
+  try {
+/*@egen*/ 
+  <QUANTITY> identifier_list() ":" subtype_indication() source_aspect() ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+/**
+ * 1076.1 extension:
+ */
+void across_aspect() :
+{/*@bgen(jjtree) across_aspect */
+  ASTacross_aspect jjtn000 = new ASTacross_aspect(JJTACROSS_ASPECT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) across_aspect */
+  try {
+/*@egen*/
+  identifier_list() [ tolerance_aspect() ] [ ":=" expression() ] <ACROSS>/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+/**
+ * 1076.1 extension:
+ */
+void through_aspect() :
+{/*@bgen(jjtree) through_aspect */
+  ASTthrough_aspect jjtn000 = new ASTthrough_aspect(JJTTHROUGH_ASPECT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) through_aspect */
+  try {
+/*@egen*/
+  identifier_list() [ tolerance_aspect() ] [ ":=" expression() ] <THROUGH>/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+} 
+
+/**
+ * 1076.1 extension:
+ */
+void source_aspect() :
+{/*@bgen(jjtree) source_aspect */
+  ASTsource_aspect jjtn000 = new ASTsource_aspect(JJTSOURCE_ASPECT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) source_aspect */
+    try {
+/*@egen*/
+    <SPECTRUM> magnitude_simple_expression() "," phase_simple_expression() 
+  | <NOISE>    magnitude_simple_expression()/*@bgen(jjtree)*/
+    } catch (Throwable jjte000) {
+      if (jjtc000) {
+        jjtree.clearNodeScope(jjtn000);
+        jjtc000 = false;
+      } else {
+        jjtree.popNode();
+      }
+      if (jjte000 instanceof RuntimeException) {
+        throw (RuntimeException)jjte000;
+      }
+      if (jjte000 instanceof ParseException) {
+        throw (ParseException)jjte000;
+      }
+      throw (Error)jjte000;
+    } finally {
+      if (jjtc000) {
+        jjtree.closeNodeScope(jjtn000, true);
+        if (jjtree.nodeCreated()) {
+         jjtreeCloseNodeScope(jjtn000);
+        }
+      }
+    }
+/*@egen*/ 
+}
+
+void suffix()       :
+{}
+{
+    simple_name()
+  | <character_literal>
+  | operator_symbol()
+  | <ALL>
+}
+
+void target()       :
+{}
+{
+    name()
+  | aggregate()
+}
+
+
+void term()       :
+{ int op; }
+{
+  factor() ( LOOKAHEAD(2) op = multiplying_operator()/*@bgen(jjtree) #factor( 2) */
+                                                      {
+                                                        ASTfactor jjtn001 = new ASTfactor(JJTFACTOR);
+                                                        boolean jjtc001 = true;
+                                                        jjtree.openNodeScope(jjtn001);
+                                                        jjtreeOpenNodeScope(jjtn001);
+                                                      }
+                                                      try {
+/*@egen*/ factor()/*@bgen(jjtree)*/
+                                                      } catch (Throwable jjte001) {
+                                                        if (jjtc001) {
+                                                          jjtree.clearNodeScope(jjtn001);
+                                                          jjtc001 = false;
+                                                        } else {
+                                                          jjtree.popNode();
+                                                        }
+                                                        if (jjte001 instanceof RuntimeException) {
+                                                          throw (RuntimeException)jjte001;
+                                                        }
+                                                        if (jjte001 instanceof ParseException) {
+                                                          throw (ParseException)jjte001;
+                                                        }
+                                                        throw (Error)jjte001;
+                                                      } finally {
+                                                        if (jjtc001) {
+                                                          jjtree.closeNodeScope(jjtn001,  2);
+                                                          if (jjtree.nodeCreated()) {
+                                                           jjtreeCloseNodeScope(jjtn001);
+                                                          }
+                                                        }
+                                                      }
+/*@egen*/           
+  )*
+}
+
+void timeout_clause()       :
+{}
+{
+  <FOR> time_or_real_expression()
+}
+
+
+void type_conversion() :
+{/*@bgen(jjtree) type_conversion */
+  ASTtype_conversion jjtn000 = new ASTtype_conversion(JJTTYPE_CONVERSION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) type_conversion */
+  try {
+/*@egen*/
+  type_mark() "(" expression() ")"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void type_declaration()       :
+{}
+{
+    LOOKAHEAD( <TYPE> identifier() <IS> )
+    full_type_declaration()
+  | incomplete_type_declaration()
+}
+
+
+void type_definition()       :
+{}
+{
+    scalar_type_definition()
+  | composite_type_definition()
+  | access_type_definition()
+  | file_type_definition()
+  | protected_type_definition()
+}
+
+
+void type_mark()       :
+{}
+{
+    LOOKAHEAD(type_name())
+    type_name()
+  | LOOKAHEAD(subtype_name())
+    subtype_name()
+}
+
+
+void unconstrained_array_definition() :
+{/*@bgen(jjtree) unconstrained_array_definition */
+  ASTunconstrained_array_definition jjtn000 = new ASTunconstrained_array_definition(JJTUNCONSTRAINED_ARRAY_DEFINITION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) unconstrained_array_definition */
+  try {
+/*@egen*/
+  <ARRAY> "(" index_subtype_definition()
+    ( "," index_subtype_definition() )* ")"
+      <OF> element_subtype_indication()/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void use_clause() :
+{/*@bgen(jjtree) use_clause */
+  ASTuse_clause jjtn000 = new ASTuse_clause(JJTUSE_CLAUSE);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) use_clause */
+   try {
+/*@egen*/
+   <USE> selected_name() ( "," selected_name() )* ";"/*@bgen(jjtree)*/
+   } catch (Throwable jjte000) {
+     if (jjtc000) {
+       jjtree.clearNodeScope(jjtn000);
+       jjtc000 = false;
+     } else {
+       jjtree.popNode();
+     }
+     if (jjte000 instanceof RuntimeException) {
+       throw (RuntimeException)jjte000;
+     }
+     if (jjte000 instanceof ParseException) {
+       throw (ParseException)jjte000;
+     }
+     throw (Error)jjte000;
+   } finally {
+     if (jjtc000) {
+       jjtree.closeNodeScope(jjtn000, true);
+       if (jjtree.nodeCreated()) {
+        jjtreeCloseNodeScope(jjtn000);
+       }
+     }
+   }
+/*@egen*/
+}
+
+
+void variable_assignment_statement() :
+{/*@bgen(jjtree) variable_assignment_statement */
+  ASTvariable_assignment_statement jjtn000 = new ASTvariable_assignment_statement(JJTVARIABLE_ASSIGNMENT_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) variable_assignment_statement */
+  try {
+/*@egen*/
+  [ LOOKAHEAD( label() ":") label() ":" ]
+  target()  ":=" expression() ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void variable_declaration() :
+{/*@bgen(jjtree) variable_declaration */
+  ASTvariable_declaration jjtn000 = new ASTvariable_declaration(JJTVARIABLE_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) variable_declaration */
+  try {
+/*@egen*/
+  [ <SHARED> ] <VARIABLE> identifier_list() ":"
+  subtype_indication() [ ":=" expression() ] ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+void wait_statement() :
+{/*@bgen(jjtree) wait_statement */
+  ASTwait_statement jjtn000 = new ASTwait_statement(JJTWAIT_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) wait_statement */
+   try {
+/*@egen*/
+   [ LOOKAHEAD( label() ) ":" label() ":"]
+   <WAIT> [ sensitivity_clause() ]
+   [ condition_clause() ] [ timeout_clause() ] ";"/*@bgen(jjtree)*/
+   } catch (Throwable jjte000) {
+     if (jjtc000) {
+       jjtree.clearNodeScope(jjtn000);
+       jjtc000 = false;
+     } else {
+       jjtree.popNode();
+     }
+     if (jjte000 instanceof RuntimeException) {
+       throw (RuntimeException)jjte000;
+     }
+     if (jjte000 instanceof ParseException) {
+       throw (ParseException)jjte000;
+     }
+     throw (Error)jjte000;
+   } finally {
+     if (jjtc000) {
+       jjtree.closeNodeScope(jjtn000, true);
+       if (jjtree.nodeCreated()) {
+        jjtreeCloseNodeScope(jjtn000);
+       }
+     }
+   }
+/*@egen*/
+}
+
+
+void waveform() :
+{/*@bgen(jjtree) waveform */
+  ASTwaveform jjtn000 = new ASTwaveform(JJTWAVEFORM);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) waveform */
+  try {
+/*@egen*/
+  waveform_element() ( "," waveform_element() )*
+  | <UNAFFECTED>/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+void waveform_element() :
+{/*@bgen(jjtree) waveform_element */
+  ASTwaveform_element jjtn000 = new ASTwaveform_element(JJTWAVEFORM_ELEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) waveform_element */
+     try {
+/*@egen*/
+     LOOKAHEAD(<NULL>)
+     <NULL>             [<AFTER> time_expression() ]
+  |  value_expression() [ <AFTER> time_expression() ]/*@bgen(jjtree)*/
+     } catch (Throwable jjte000) {
+       if (jjtc000) {
+         jjtree.clearNodeScope(jjtn000);
+         jjtc000 = false;
+       } else {
+         jjtree.popNode();
+       }
+       if (jjte000 instanceof RuntimeException) {
+         throw (RuntimeException)jjte000;
+       }
+       if (jjte000 instanceof ParseException) {
+         throw (ParseException)jjte000;
+       }
+       throw (Error)jjte000;
+     } finally {
+       if (jjtc000) {
+         jjtree.closeNodeScope(jjtn000, true);
+         if (jjtree.nodeCreated()) {
+          jjtreeCloseNodeScope(jjtn000);
+         }
+       }
+     }
+/*@egen*/
+}
+
+
+/** 
+ *Section 15: Simultaneous statements
+ * 1076.1 extension
+ */
+void simultaneous_statement_part()   :
+{/*@bgen(jjtree) simultaneous_statement_part */
+  ASTsimultaneous_statement_part jjtn000 = new ASTsimultaneous_statement_part(JJTSIMULTANEOUS_STATEMENT_PART);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) simultaneous_statement_part */
+  try {
+/*@egen*/
+  ( simultaneous_statement() )*/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+/**
+ * 1076.1 extension:
+ */
+void simultaneous_statement()       :
+{}
+{
+    LOOKAHEAD(simple_simultaneous_statement())
+    simple_simultaneous_statement()
+  | LOOKAHEAD( [if_label()] ":" <IF> condition() <USE> )
+    simultaneous_if_statement()
+  | LOOKAHEAD(simultaneous_case_statement())
+    simultaneous_case_statement()
+  | LOOKAHEAD(4) // procedural is at least as 4th position...
+    simultaneous_procedural_statement()
+  | simultaneous_null_statement()
+}
+
+/**
+ * 1076.1 extension:
+ */
+void simple_simultaneous_statement() :
+{/*@bgen(jjtree) simple_simultaneous_statement */
+  ASTsimple_simultaneous_statement jjtn000 = new ASTsimple_simultaneous_statement(JJTSIMPLE_SIMULTANEOUS_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) simple_simultaneous_statement */
+  try {
+/*@egen*/
+  [ LOOKAHEAD( label() ":") label() ":"] 
+  [<PURE>|<IMPURE>] simple_expression() 
+  "==" simple_expression() [ tolerance_aspect() ] ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+/**
+ * 1076.1 extension:
+ */
+void simultaneous_if_statement() :
+{/*@bgen(jjtree) simultaneous_if_statement */
+  ASTsimultaneous_if_statement jjtn000 = new ASTsimultaneous_if_statement(JJTSIMULTANEOUS_IF_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) simultaneous_if_statement */
+  try {
+/*@egen*/
+  [ if_label() ":"] <IF> condition() <USE>
+     simultaneous_statement_part()
+  ( <ELSIF> condition() <USE> simultaneous_statement_part() )*
+  [ <ELSE> simultaneous_statement_part() ]
+  <END> <USE> [ if_label()] ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+/**
+ * 1076.1 extension:
+ */
+void simultaneous_case_statement() :
+{/*@bgen(jjtree) simultaneous_case_statement */
+  ASTsimultaneous_case_statement jjtn000 = new ASTsimultaneous_case_statement(JJTSIMULTANEOUS_CASE_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) simultaneous_case_statement */
+  try {
+/*@egen*/
+  [ case_label() ":"] <CASE> expression() <USE>
+    (simultaneous_alternative())*
+  <END> <CASE> [ case_label() ] ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+/**
+ * 1076.1 extension:
+ */
+void simultaneous_alternative() :
+{/*@bgen(jjtree) simultaneous_alternative */
+  ASTsimultaneous_alternative jjtn000 = new ASTsimultaneous_alternative(JJTSIMULTANEOUS_ALTERNATIVE);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) simultaneous_alternative */
+  try {
+/*@egen*/
+  <WHEN> choices() <USE> simultaneous_statement_part()/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+/**
+ * 1076.1 extension:
+ */
+void simultaneous_procedural_statement() :
+{/*@bgen(jjtree) simultaneous_procedural_statement */
+  ASTsimultaneous_procedural_statement jjtn000 = new ASTsimultaneous_procedural_statement(JJTSIMULTANEOUS_PROCEDURAL_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) simultaneous_procedural_statement */
+  try {
+/*@egen*/
+  [procedural_label() ":"] [<PURE>|<IMPURE>] <PROCEDURAL> [<IS>]
+    procedural_declarative_part()
+   <BEGIN>
+     procedural_statement_part()
+   <END> <PROCEDURAL> [ procedural_label()] ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+// 1076.1 extension:
+void procedural_label()       :
+{}
+{
+  label()
+}
+
+// 1076.1 extension:
+void procedural_declarative_part() :
+{/*@bgen(jjtree) procedural_declarative_part */
+  ASTprocedural_declarative_part jjtn000 = new ASTprocedural_declarative_part(JJTPROCEDURAL_DECLARATIVE_PART);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) procedural_declarative_part */
+  try {
+/*@egen*/
+  ( procedural_declarative_item() )*/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+/**
+ * 1076.1 extension:
+ */
+void procedural_declarative_item()       :
+{}
+{
+    LOOKAHEAD(subprogram_declaration())
+    subprogram_declaration()
+  | subprogram_body()
+  | type_declaration()
+  | subtype_declaration()
+  | constant_declaration()
+  | variable_declaration()
+  | alias_declaration()
+  | LOOKAHEAD(attribute_declaration())
+    attribute_declaration()
+  | attribute_specification()
+  | use_clause()
+  | LOOKAHEAD(group_template_declaration())
+    group_template_declaration()
+  | group_declaration()
+}
+
+/**
+ * 1076.1 extension:
+ */
+void procedural_statement_part() :
+{/*@bgen(jjtree) procedural_statement_part */
+  ASTprocedural_statement_part jjtn000 = new ASTprocedural_statement_part(JJTPROCEDURAL_STATEMENT_PART);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) procedural_statement_part */
+  try {
+/*@egen*/
+  ( sequential_statement() )*/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+
+// 1076.1 extension:
+void simultaneous_null_statement() :
+{/*@bgen(jjtree) simultaneous_null_statement */
+  ASTsimultaneous_null_statement jjtn000 = new ASTsimultaneous_null_statement(JJTSIMULTANEOUS_NULL_STATEMENT);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) simultaneous_null_statement */
+  try {
+/*@egen*/
+  [ label() ":"] <NULL> ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+
+
+//
+// parts of grammar, which have to be checked during semantic analysis
+// by semantic lookahead:
+//
+void block_label()       :
+{}
+{
+  label()
+}
+
+void block_statement_label()       :
+{}
+{
+  label()
+}
+
+void case_label()       :
+{}
+{
+  label()
+}
+
+void generate_label()       :
+{}
+{
+  label()
+}
+
+void generate_statement_label()       :
+{}
+{
+  label()
+}
+
+void if_label()       :
+{}
+{
+  label()
+}
+
+void instantiation_label()       :
+{}
+{
+  label()
+}
+
+void loop_label()       :
+{}
+{
+  label()
+}
+
+void process_label()       :
+{}
+{
+  label()
+}
+
+void architecture_simple_name()       :
+{}
+{
+  simple_name()
+}
+
+void attribute_simple_name()       :
+{}
+{
+  simple_name()
+  | <RANGE>
+}
+
+void component_simple_name()       :
+{}
+{
+  simple_name()
+}
+
+void configuration_simple_name()       :
+{}
+{
+  simple_name()
+}
+
+void element_simple_name()       :
+{}
+{
+  simple_name()
+}
+
+void entity_simple_name()       :
+{}
+{
+  simple_name()
+}
+
+void package_simple_name()       :
+{}
+{
+  simple_name()
+}
+
+
+
+void architecture_name()       :
+{}
+{
+  name()
+}
+
+void entity_name()       :
+{}
+{
+  name()           
+}
+
+void file_name()       :
+{}
+{
+  name()
+}
+
+void function_name()       :
+{}
+{
+  name()
+}
+
+void configuration_name()       :
+{}
+{
+  name()
+}
+
+void component_name()       :
+{}
+{
+  name()
+}
+
+void generic_name()       :
+{}
+{
+  name()
+}
+
+void group_template_name()       :
+{}
+{
+  name()
+}
+
+void parameter_name()       :
+{}
+{
+  name()
+}
+
+void physical_type_simple_name()       :
+{}
+{
+  simple_name() 
+}
+
+void port_name()       :
+{}
+{
+  name()
+}
+
+void procedure_name()       :
+{}
+{
+  name()
+}
+
+void range_attribute_name()       :
+{}
+{
+  name()
+}
+
+void signal_name()      :
+{}
+{
+  name()
+}
+
+//
+// Name, der einen Typen bezeichnet...
+//
+void type_name()      :
+{}
+{
+  name()
+}
+
+
+// 1076.1 extension:
+void record_nature_simple_name()       :
+{}
+{
+  simple_name()
+}
+
+void record_type_simple_name()       :
+{}
+{
+  simple_name()
+}
+
+void resolution_function_name()       :
+{}
+{
+  name()
+}
+
+void subtype_name()       :
+{}
+{
+  name()
+}
+
+void unit_name()       :
+{}
+{
+  name()
+}
+
+void variable_name()       :
+{}
+{
+  name()
+}
+
+void architecture_identifier()       :
+{}
+{
+  identifier()
+}
+
+void static_expression()       :
+{}
+{
+  expression()
+}
+
+
+void boolean_expression()       :
+{}
+{
+  expression()
+}
+
+void file_open_kind_expression()       :
+{}
+{
+  expression()
+}
+
+void guard_expression()       :
+{}
+{
+  expression()
+}
+
+void time_expression()       :
+{}
+{
+  expression() // unit_name()
+  // unit_name can be derived by expression!!! 
+}
+
+// 1076.1 extension:
+void time_or_real_expression()       :
+{}
+{
+  expression() // unit_name()
+  // unit_name can be derived by expression!!!
+}
+
+
+void value_expression()       :
+{}
+{
+  expression()
+}
+
+void string_expression()       :
+{}
+{
+  expression()
+}
+
+
+void guarded_signal_list()       :
+{}
+{
+  signal_list()
+}
+
+void parameter_association_list()       :
+{}
+{
+  association_list()
+}
+
+void port_association_list()       :
+{}
+{
+  association_list()
+}
+
+void generic_association_list()       :
+{}
+{
+  association_list()
+}
+
+void generic_interface_list()       :
+{}
+{
+  interface_list()
+}
+
+void parameter_interface_list()       :
+{}
+{
+  interface_list()
+}
+
+void port_interface_list()       :
+{}
+{
+  interface_list()
+}
+
+//
+// fraglich:
+//
+void formal_port_clause()       :
+{}
+{
+  port_clause()
+}
+
+void local_port_clause()       :
+{}
+{
+  port_clause()
+}
+
+void formal_generic_clause()       :
+{}
+{
+  generic_clause()
+}
+
+void local_generic_clause()       :
+{}
+{
+  generic_clause()
+}
+
+void element_subtype_indication()       :
+{}
+{
+  subtype_indication()
+}
+
+void discrete_subtype_indication()       :
+{}
+{
+  subtype_indication()
+}
+
+void loop_parameter_specification()       :
+{}
+{
+  parameter_specification()
+}
+
+void generate_parameter_specification()       :
+{}
+{
+  parameter_specification()
+}
+
+void passive_concurrent_procedure_call_statement()       :
+{}
+{
+  concurrent_procedure_call_statement()
+}
+
+void passive_process_statement()       :
+{}
+{
+  process_statement()
+}
+
+
+void magnitude_simple_expression()       :
+{}
+{ 
+  simple_expression() 
+}
+
+void phase_simple_expression()       :
+{}
+{
+  simple_expression()
+}
+
+
+void nature_name()       :
+{}
+{
+  name() 
+}
+
+void subnature_name()       :
+{}
+{
+  name()
+}
+
+/**
+ * 1076.1 extension:
+ */
+void terminal_name()       :
+{}
+{
+  name()
+}
+
+
+/**
+ * 1076.1 extension:
+ */
+void quantity_name()       :
+{}
+{
+  name()
+}
+
+/**
+ * 1076.1 extension:
+ */
+void plus_terminal_name()       :
+{}
+{
+  name()
+}
+
+/**
+ * 1076.1 extension:
+ */
+void minus_terminal_name()       :
+{}
+{
+  name()
+}
+
+
+/**
+ * still missing:
+ */
+void shared_variable_declaration() :
+{/*@bgen(jjtree) shared_variable_declaration */
+  ASTshared_variable_declaration jjtn000 = new ASTshared_variable_declaration(JJTSHARED_VARIABLE_DECLARATION);
+  boolean jjtc000 = true;
+  jjtree.openNodeScope(jjtn000);
+  jjtreeOpenNodeScope(jjtn000);
+/*@egen*/}
+{/*@bgen(jjtree) shared_variable_declaration */
+  try {
+/*@egen*/
+  [ <SHARED> ] <VARIABLE> identifier_list() ":"
+  subtype_indication() [ ":=" expression() ] ";"/*@bgen(jjtree)*/
+  } catch (Throwable jjte000) {
+    if (jjtc000) {
+      jjtree.clearNodeScope(jjtn000);
+      jjtc000 = false;
+    } else {
+      jjtree.popNode();
+    }
+    if (jjte000 instanceof RuntimeException) {
+      throw (RuntimeException)jjte000;
+    }
+    if (jjte000 instanceof ParseException) {
+      throw (ParseException)jjte000;
+    }
+    throw (Error)jjte000;
+  } finally {
+    if (jjtc000) {
+      jjtree.closeNodeScope(jjtn000, true);
+      if (jjtree.nodeCreated()) {
+       jjtreeCloseNodeScope(jjtn000);
+      }
+    }
+  }
+/*@egen*/
+}
+
+
+
+
+/**
+ *
+ * for error recovery:
+ *
+ */
+JAVACODE void error_skipto(int kind, String message) 
+{/*@bgen(jjtree) error_skipto */
+ASTerror_skipto jjtn000 = new ASTerror_skipto(JJTERROR_SKIPTO);
+boolean jjtc000 = true;
+jjtree.openNodeScope(jjtn000);
+jjtreeOpenNodeScope(jjtn000);
+try {
+/*@egen*/
+  errs.Error(message,null);
+  Token t;
+  do 
+  {
+    t = getNextToken();
+  } while ((t.kind != kind) && t.next != null);/*@bgen(jjtree)*/
+} finally {
+  if (jjtc000) {
+    jjtree.closeNodeScope(jjtn000, true);
+    if (jjtree.nodeCreated()) {
+     jjtreeCloseNodeScope(jjtn000);
+    }
+  }
+}
+/*@egen*/
+}
\ No newline at end of file
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/vhdl.jjt vdt/src/com/elphel/vdt/veditor/parser/vhdl/vhdl.jjt
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/vhdl.jjt	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/vhdl.jjt	2016-06-24 10:29:40.824496406 -0600
@@ -1,3443 +1,3443 @@
-
-/**
- *
- * VHDL-93, VHDL-AMS grammar for JavaCC 
- * (c) 1997 Christoph Grimm
- * 
- * EMail: grimm@ti.informatik.uni-frankfurt.de
- * Address:
- * Christoph Grimm
- * J. W. Goethe-University Frankfurt
- * Robert-Mayer-Strasse 11-15
- * 60054 Frankfurt
- * Germany
- *
- *
- * By using this file, I agree with the following:
- * -----------------------------------------------
- *
- * 1. This grammar is free for evaluation purposes.
- *
- * 2. You may use and modify it, but when distributing is, you must also
- *    include the original files and copyright notes from me.
- *
- * 3. For commercial use of derived works contact me.
- *   
- * 4. The grammar is NOT optimized for speed. The aim is to keep the grammar 
- *    similar to the original productions in the LRM.
- *
- * 5. Don't complain about errors - report them, maybe with fixes to me.
- *
- */
-
-
-options
-{
-  // DEBUG_PARSER = true;
-  // CHOICE_AMBIGUITY_CHECK=3;
-  IGNORE_CASE=false;
-  NODE_SCOPE_HOOK=true;
-  MULTI=true;
-}
-
- 
-
-
-/**
- * The parser is instanciated in the file vhdl.java
- */
-PARSER_BEGIN(VhdlParserCore)
-
-package net.sourceforge.veditor.parser.vhdl;
-
-@SuppressWarnings("all")
-
-public class VhdlParserCore
-{
-  /**
-   * Called, whenever a new node in jjtree is generated.
-   * - store first token of the production.
-   * - check, if production is supported in subsets that are to be
-   *   checked.
-   */
-   void jjtreeOpenNodeScope(Node n)
-  {
-    
-    ((SimpleNode) n).setFirstToken(getToken(1));
-    ((SimpleNode) n).setParser(this);
-  }
-
-  /**
-   * Called, whenever a node in jjtree is closed.
-   */
-   void jjtreeCloseNodeScope(Node n)
-  {
-    ((SimpleNode) n).setLastToken(getToken(0)); 
-  }
-  
-  public ErrorHandler getErrorHandler(){
-  	return errs;
-  }
-    
-  public SymbolTable getSymbolTable(){
-  	return m_SymbolTable;
-  }
-  
-  public void setSymbolTable(SymbolTable symbolTable){
-    m_SymbolTable=symbolTable;
-  }
-  
-  ErrorHandler errs = new ErrorHandler(this);
-  SymbolTable m_SymbolTable=null;
-}
-
-PARSER_END(VhdlParserCore)
-
-
-SKIP :
-{
-    " "
-  | "\n"
-  | "\r"
-  | "\t"
-  | "\f"
-}
-
-
-SPECIAL_TOKEN :
-{
-  <COMMENT: "--" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
-}
-
-
-/** 
- * Section 13: Lexical elements
- * with extensions from IEEE 1076.1
- */
-TOKEN [IGNORE_CASE] :
-{
-    <ABS:          "abs">
-  | <ACCESS:       "access">
-  | <ACROSS:       "across">
-  | <AFTER:        "after">
-  | <ALIAS:        "alias">
-  | <ALL:          "all">
-  | <AND:          "and">
-  | <ARCHITECTURE: "architecture">
-  | <ARRAY:        "array">
-  | <ASSERT:       "assert">
-  | <ATTRIBUTE:    "attribute">
-  | <BEGIN:        "begin">
-  | <BLOCK:        "block">
-  | <BODY:         "body">
-  | <BREAK:        "break">
-  | <BUFFER:       "buffer">
-  | <BUS:          "bus">
-  | <CASE:         "case">
-  | <COMPONENT:    "component">
-  | <CONFIGURATION: "configuration">
-  | <CONSTANT:      "constant">
-  | <DISCONNECT:    "disconnect">
-  | <DOWNTO:        "downto">
-  | <ELSE:          "else">
-  | <ELSIF:         "elsif">
-  | <END:           "end">
-  | <ENTITY:        "entity">
-  | <EXIT:          "exit">
-  | <FILE:          "file">
-  | <FOR:           "for">
-  | <FUNCTION:      "function">
-  | <GENERATE:      "generate">
-  | <GENERIC:       "generic">
-  | <GROUP:         "group">
-  | <GUARDED:       "guarded">
-  | <IF:            "if">
-  | <IMPURE:        "impure">
-  | <IN:            "in">
-  | <INERTIAL:      "inertial">
-  | <INOUT:         "inout">
-  | <IS:            "is">
-  | <LABEL:         "label">
-  | <LIBRARY:       "library">
-  | <LINKAGE:       "linkage">
-  | <LITERAL:       "literal">
-  | <LOOP:          "loop">
-  | <MAP:           "map">
-  | <MOD:           "mod">
-  | <NAND:          "nand">
-  | <NATURE:        "nature">
-  | <NEW:           "new">
-  | <NEXT:          "next">
-  | <NOISE:         "noise">
-  | <NOR:           "nor">
-  | <NOT:           "not">
-  | <NULL:          "null">
-  | <OF:            "of">
-  | <ON:            "on">
-  | <OPEN:          "open">
-  | <OR:            "or">
-  | <OTHERS:        "others">
-  | <OUT:           "out">
-  | <PACKAGE:       "package">
-  | <PORT:          "port">
-  | <POSTPONED:     "postponed">
-  | <PROCEDURAL:    "procedural">
-  | <PROCEDURE:     "procedure">
-  | <PROCESS:       "process">
-  | <PROTECTED:     "protected">
-  | <PURE:          "pure">
-  | <QUANTITY:      "quantity">
-  | <RANGE:         "range">
-  | <RECORD:        "record">
-  | <REGISTER:      "register">
-  | <REJECT:        "reject">
-  | <REM:           "rem">
-  | <REPORT:        "report">
-  | <RETURN:        "return">
-  | <ROL:           "rol">
-  | <ROR:           "ror">
-  | <SELECT:        "select">
-  | <SEVERITY:      "severity">
-  | <SIGNAL:        "signal">
-  | <SHARED:        "shared">
-  | <SLA:           "sla">
-  | <SLL:           "sll">
-  | <SPECTRUM:      "spectrum">
-  | <SRA:           "sra">
-  | <SRL:           "srl">
-  | <SUBNATURE:     "subnature">
-  | <SUBTYPE:       "subtype">
-  | <TERMINAL:      "terminal">
-  | <THEN:          "then">
-  | <THROUGH:       "through">
-  | <TO:            "to">
-  | <TOLERANCE:     "tolerance">
-  | <TRANSPORT:     "transport">
-  | <TYPE:          "type">
-  | <UNAFFECTED:    "unaffected">
-  | <UNITS:         "units">
-  | <UNTIL:         "until">
-  | <USE:           "use">
-  | <VARIABLE:      "variable">
-  | <WAIT:          "wait">
-  | <WHEN:          "when">
-  | <WHILE:         "while">
-  | <WITH:          "with">
-  | <XNOR:          "xnor">
-  | <XOR:           "xor">
-}
-
-
-
-TOKEN :
-{
-    <#upper_case_letter:               ["A"-"Z"]>
-  | <#lower_case_letter:               ["a"-"z"]>
-  | <#digit:                           ["0"-"9"]>
-  | <#extended_digit:                  ["0"-"9","A"-"F","a"-"f"]>
-  | <#special_character:               ["#","&","'","(",")","*","+",",","-",
-                                        ".","/",":",";","<","=",">","[","]",
-                                        "_","|"]>
-  | <#other_special_character:         ["!","$","%","@","?","^","`","{","}","~",
-                                        "\\"]>
-  | <#format_effector:                 ["\n","\t"]>
-  | <#base_specifier:                  ["B","O","X","b","o","x"]>
-  | <#underline:                       "_">
-  | <#letter:                          ["a"-"z","A"-"Z"]>
-  | <#letter_or_digit:                 ["a"-"z","A"-"Z","0"-"9"]>
-  | <#integer: <digit> (("_")? <digit>)*>
-  | <#base: <integer>>
-  | <#based_integer: (("_")? <extended_digit>)*>
-  | <based_literal: <base> "#" <based_integer> ("." <based_integer>)? "#" (<exponent>)?>
-  | <#basic_character: (<basic_graphic_character>|<format_effector>)>
-  | <#basic_graphic_character: (["A"-"Z"]|<digit>|<special_character>|" ")>
-  | <basic_identifier: <letter> ( ("_")? <letter_or_digit> )*>
-  | <bit_string_literal: <base_specifier> "\"" <bit_value> "\"">
-  | <#bit_value: <extended_digit> ( ("_")? <extended_digit>)*>
-  | <character_literal:  "'" (<graphic_character>|"\"") "'">
-  | <decimal_literal: <integer> ( "." <integer>)? ( <exponent> )?>
-  | <#exponent: ("E" ("+")? <integer>) | ("E" "-" <integer>)>
-  | <extended_identifier: "\\" <graphic_character> ( <graphic_character> )* "\\">
-  | <#graphic_character: (<basic_graphic_character>
-                          | <lower_case_letter>
-                          | <other_special_character>)>
-  | <string_literal: "\"" (<graphic_character>|"\"\"")* "\"">
-
-  | <EXP: "**">
-  | <MUL: "*">
-  | <DIV: "/">
-  | <ADD: "+">
-  | <SUB: "-">
-  | <CONCAT: "&">
-  | <EQ:  "=">
-  | <NEQ: "/=">
-  | <GE:  ">=">
-  | <LE:  "<=">
-  | <GT:  ">">
-  | <LO:  "<">
-  | <SEMICOLON: ";">
-  | <COLON: ":">
-  | <ASSIGN: ":=">
-  | <RARROW: "=>">
-}
-
-
-
-
-void abstract_literal() #void :
-{}
-{
-    <decimal_literal>
-  | <based_literal>
-}
-
-
-
-void access_type_definition() #void :
-{}
-{
-  <ACCESS> subtype_indication()
-}
-
-
-
-void actual_designator() #void :
-{}
-{
-    LOOKAHEAD(expression()) 
-    expression()
-  | LOOKAHEAD(signal_name())
-    signal_name()
-  | LOOKAHEAD(variable_name())
-    variable_name()
-  | LOOKAHEAD(file_name())
-    file_name()
-  | <OPEN>
-
-  // 1076.1 extensions:
-  | LOOKAHEAD(terminal_name())
-    terminal_name()
-  | quantity_name()
-}
-
-
-
-void actual_parameter_part() #void :
-{}
-{
-  parameter_association_list()
-}
-
-
-void actual_part() :
-{}
-{
-    LOOKAHEAD( function_name() "(" actual_designator() ")")
-    function_name() "(" actual_designator() ")"
-  | LOOKAHEAD( type_mark() "(" actual_designator() ")")
-    type_mark() "(" actual_designator() ")"
-  | actual_designator()
-}
-
-
-int adding_operator() #void :
-{}
-{
-    <ADD>               { return ADD; }
-  | <SUB>               { return SUB; }
-  | <CONCAT>            { return CONCAT; }
-}
-
-
-void aggregate() :
-{}
-{
-  "(" element_association()  ("," element_association())*  ")"
-}    
-
-void alias_declaration() :
-{}
-{
-  <ALIAS> alias_designator()
-   [ ":" subtype_indication() ] <IS> name() signature() ";"
-}
-
-
-void alias_designator() :
-{}
-{
-    identifier()
-  | <character_literal>
-  | operator_symbol()
-}
-
-void allocator() :
-{}
-{
-  <NEW>
-  (
-      LOOKAHEAD( type_mark() "'")
-      qualified_expression()
-    | subtype_indication()
-  )
-}
-
-
-
-void architecture_body() :
-{}
-{
-  <ARCHITECTURE> identifier() <OF> entity_name() <IS> { jjtThis.newBlock(); }
-    architecture_declarative_part()
-  <BEGIN>
-    architecture_statement_part()
-  <END> [ <ARCHITECTURE> ] [ architecture_simple_name() ] ";"
-
-  {
-    jjtThis.endBlock();
-    jjtThis.Check();
-  }
-}
-
-
-
-void architecture_declarative_part() :
-{}
-{
-  ( block_declarative_item() )*
-}
-
-void architecture_statement_part() :
-{}
-{
-  ( architecture_statement() )*
-}
-
-/**
- *  This rule also contains the concurrent statements.
- */
-void architecture_statement() #void :
-{}
-{
-  // 
-  // lookahead would really be annoying here. Therefore I have
-  // moved the concurrent statement into this rule.
-  // concurrent_statements:
-  //
-
-  try {
-
-    LOOKAHEAD([block_label() ":"] <BLOCK>)
-    block_statement()
-  | LOOKAHEAD([process_label() ":"] [<POSTPONED>] <PROCESS>)
-    process_statement()
-  | LOOKAHEAD([label() ":"] [<POSTPONED>] procedure_call() ";")
-    concurrent_procedure_call_statement()
-  | LOOKAHEAD([label() ":"] [<POSTPONED>] <ASSERT>)
-    concurrent_assertion_statement()
-  | LOOKAHEAD([label() ":"] [<POSTPONED>] conditional_signal_assignment()|
-              [label() ":"] [<POSTPONED>] selected_signal_assignment())
-    concurrent_signal_assignment_statement()
-  | LOOKAHEAD(instantiation_label() ":" instantiated_unit() )
-    component_instantiation_statement()
-  | LOOKAHEAD(generate_statement())
-    generate_statement()
-
-  /** 1076.1 extensions: */
-  | LOOKAHEAD(concurrent_break_statement())
-    concurrent_break_statement()
-  | simultaneous_statement()
-
-  }
-
-  /** Error handling: Skip until next semicolon */
-  catch(ParseException e)
-  {
-    error_skipto(SEMICOLON, "syntax error in statement");
-  }
-}
-
-
-/**
- * 1076.1 extension:
- */
-void array_nature_definition() #void  :
-{}
-{
-    LOOKAHEAD(<ARRAY> "(" index_subtype_definition() )
-    unconstrained_nature_definition()
-  | constrained_nature_definition()
-}
-
-/**
-  * 1076.1 extension:
-  */
-void unconstrained_nature_definition() :
-{}
-{
-  <ARRAY> "(" index_subtype_definition() ("," index_subtype_definition())* ")" 
-  <OF> subnature_indication()
-}
-
-/**
-  * 1076.1 extension:
-  */
-void constrained_nature_definition() :
-{}
-{
-  <ARRAY> index_constraint() <OF> subnature_indication()
-}
-
-
-void array_type_definition() #void:
-{}
-{
-    LOOKAHEAD(unconstrained_array_definition())
-    unconstrained_array_definition()
-  | constrained_array_definition()
-}
-
-void assertion() :
-{}
-{
-  <ASSERT> condition()
-  [ <REPORT> expression() ]
-  [ <SEVERITY> expression() ]
-}
-
-
-void assertion_statement() :
-{}
-{
-  [ label() ":" ] assertion() ";"
-}
-
-
-
-void association_element() :
-{}
-{
-  [ LOOKAHEAD( formal_part() "=>" ) formal_part() "=>" ]
-  actual_part()
-}
-
-void association_list() :
-{}
-{
-  association_element() ( "," association_element() )*
-}
-
-
-void attribute_declaration() :
-{}
-{
-  <ATTRIBUTE> identifier() ":" type_mark() ";"
-}
-
-
-void attribute_designator() #void :
-{}
-{
-  attribute_simple_name()
-}
-
-
-void attribute_name() :
-{}
-{
-  prefix() signature() "'" attribute_designator() [ "(" expression() ("," expression())* ")" ]
-}
-
-
-void attribute_specification() :
-{}
-{
-  <ATTRIBUTE> attribute_designator() <OF>
-  entity_specification() <IS> expression() ";"
-}
-
-void base_unit_declaration() #void :
-{}
-{
-  identifier() ";"
-}
-
-
-
-void binding_indication() :
-{}
-{
-  [ <USE> entity_aspect() ]
-  [ generic_map_aspect() ]
-  [ port_map_aspect() ]
-}
-
-void block_configuration() :
-{}
-{
-  <FOR> block_specification()
-                ( use_clause() )*
-                ( configuration_item() )*
-  <END> <FOR> ";"
-}
-
-void block_declarative_item() #void :
-{}
-{
-  try {
-
-    LOOKAHEAD(subprogram_declaration())
-    subprogram_declaration()
-  | subprogram_body()
-  | type_declaration()
-  | subtype_declaration()
-  | constant_declaration()
-  | signal_declaration()
-  | shared_variable_declaration()
-  | file_declaration()
-  | alias_declaration()
-  | component_declaration()
-  | LOOKAHEAD(attribute_declaration())
-    attribute_declaration()
-  | attribute_specification()
-  | configuration_specification()
-  | disconnection_specification()
-  | use_clause()
-  | LOOKAHEAD(<GROUP> identifier() <IS>)
-    group_template_declaration()
-  | group_declaration()
-
-  /** 1076.1 - Extensions: */
-  | nature_declaration()
-  | subnature_declaration()
-  | quantity_declaration()
-  | terminal_declaration()
-
-  }
-
-  // Error handling: skip until next semicolon
-  catch (ParseException e)
-  {
-    error_skipto(SEMICOLON, "syntax error in declarative item");
-  }
-}
-
-
-void block_declarative_part() :
-{}
-{
-  ( block_declarative_item() )*
-}
-
-void block_header() :
-{}
-{
-  [ generic_clause()  [ generic_map_aspect() ";" ] ]
-  [ port_clause()     [ port_map_aspect() ";"    ] ]
-}
-
-void block_specification() :
-{}
-{
-    LOOKAHEAD(architecture_name())
-    architecture_name()
-  | LOOKAHEAD(block_statement_label())
-    block_statement_label()
-  | LOOKAHEAD(generate_statement_label())
-    generate_statement_label() [ "(" index_specification() ")" ]
-}
-
-
-void block_statement() :
-{}
-{
-  block_label() ":"
-                <BLOCK> [ "(" guard_expression() ")" ] [ <IS> ]
-                        block_header()
-                        block_declarative_part()
-                <BEGIN>
-                        block_statement_part()
-                <END> <BLOCK> [ block_label() ] ";"
-}
-
-
-void block_statement_part() :
-{}
-{
-  (architecture_statement() )*
-}
-
-/**
- * Section 8.14: Break statement
- * 1076.1 extension:
- */
-void break_statement() :
-{}
-{
-  [label()  ":"] <BREAK> [break_list()] [<WHEN> condition() ] ";"
-}
-
-/**
- * 1076.1 extension:
- */
-void break_list() :
-{}
-{
-  break_element() ("," break_element() )*
-}
-
-/**
- * 1076.1 extension:
- */
-void break_element() :
-{}
-{
-  [selector_clause() ] quantity_name() "=>" expression()
-}
-
-/**
- * 1076.1 extension:
- */
-void selector_clause() #void :
-{}
-{
-  <FOR> quantity_name() <USE>
-}
-
-void case_statement() :
-{}
-{
-  [ case_label() ":" ]
-                <CASE> expression() <IS>
-                        case_statement_alternative()
-                        ( case_statement_alternative() )*
-                <END> <CASE> [ case_label() ] ";"
-}
-
-
-void case_statement_alternative() :
-{}
-{
-  <WHEN> choices() "=>"
-                sequence_of_statements()
-}
-
-
-void choice() :
-{}
-{
-  /** Dirty Solution */
-    LOOKAHEAD( discrete_range()  ("=>" | "|" | ";" | ",") )
-    discrete_range()
-  | LOOKAHEAD( simple_expression()  ("=>" | "|" | ";" | ",") )
-    simple_expression()
-  | element_simple_name()
-  | <OTHERS>
-}
-
-
-void choices() :
-{}
-{
-  choice() ( "|" choice() )*
-}
-
-
-void component_configuration() :
-{}
-{
-  <FOR> component_specification()
-                [ binding_indication() ";" ]
-                [ block_configuration() ]
-  <END> <FOR> ";"
-}
-
-void component_declaration() :
-{}
-{
-  <COMPONENT> identifier() [ <IS> ]
-      [ local_generic_clause() ]
-      [ local_port_clause() ]
-  <END> <COMPONENT> [ component_simple_name() ] ";"
-}
-
-void component_instantiation_statement() :
-{}
-{
-  instantiation_label() ":"
-         instantiated_unit()
-         [ generic_map_aspect() ]
-         [ port_map_aspect() ] ";"
-}
-
-
-// 1076.1 - extension:
-void composite_nature_definition() #void :
-{}
-{
-    array_nature_definition()
-  | record_nature_definition()
-}
-
-void component_specification() :
-{}
-{
-  instantiation_list() ":" component_name()
-}
-
-
-void composite_type_definition() :
-{}
-{
-    array_type_definition()
-  | record_type_definition()
-}
-
-
-void concurrent_assertion_statement() :
-{}
-{
-  [ label() ":" ] [ <POSTPONED> ] assertion() ";"
-}
-
-
-void concurrent_procedure_call_statement() :
-{}
-{
-  [ LOOKAHEAD( label() ":") label() ":" ]
-  [ <POSTPONED> ] procedure_call() ";"
-}
-
-void concurrent_signal_assignment_statement() :
-{}
-{
-    [ LOOKAHEAD( label() ":") label() ":" ]
-    [ <POSTPONED> ]
-    ( LOOKAHEAD(  target() "<=" options_() conditional_waveforms() ";") 
-        conditional_signal_assignment() 
-      | selected_signal_assignment() )
-}
-
-
-void condition() #void :
-{}
-{
-  boolean_expression()
-}
-
-
-void condition_clause() #void :
-{}
-{
-  <UNTIL> condition()
-}
-
-
-void conditional_signal_assignment() :
-{}
-{
-  target() "<=" options_() conditional_waveforms() ";"
-}
-
-
-void conditional_waveforms() :
-{}
-{
-  //( waveform() <WHEN> condition() <ELSE> )*
-  //waveform() [ <WHEN> condition() ]
-  waveform()
-    ( LOOKAHEAD( <WHEN> condition() <ELSE>)
-        <WHEN> condition() <ELSE> waveform() )*
-    [ <WHEN> condition() ]
-}
-
-
-void configuration_declaration() :
-{}
-{
-  <CONFIGURATION> identifier() <OF> entity_name() <IS>
-    configuration_declarative_part()
-    block_configuration()
-  <END> [ <CONFIGURATION> ] [ configuration_simple_name() ] ";"
-}
-
-
-void configuration_declarative_item() #void :
-{}
-{
-  try {
-    use_clause()
-  | attribute_specification()
-  | group_declaration()
-  }
-
-  catch(ParseException e)
-  {
-    error_skipto(SEMICOLON, "syntax error in declarative item");
-  }
-}
-
-
-void configuration_declarative_part() :
-{}
-{
-  ( configuration_declarative_item() )*
-}
-
-
-
-void configuration_item() #void :
-{}
-{
-    LOOKAHEAD(block_configuration())
-    block_configuration()
-  | component_configuration()
-}
-
-void configuration_specification() :
-{}
-{
-  <FOR> component_specification() binding_indication() ";"
-}
-
-void constant_declaration() :
-{}
-{
-  <CONSTANT> identifier_list() ":" subtype_indication()
-    [ ":=" expression() ] ";"
-}
-
-
-
-void constrained_array_definition() :
-{}
-{
-  <ARRAY> index_constraint() <OF> element_subtype_indication()
-}
-
-
-void constraint() #void :
-{}
-{
-    range_constraint()
-  | index_constraint()
-}
-
-void context_clause() :
-{}
-{
-  ( context_item() )*
-}
-
-void context_item() #void :
-{}
-{
-    library_clause()
-  | use_clause()
-}
-
-
-/** 
- * Section 4:
- * Declarations
- */
-
-
-/**
- * 1076.1 extension:
- */
-void terminal_declaration() :
-{}
-{
-  <TERMINAL> identifier_list() ":" subnature_indication() ";"
-}
-
-void terminal_aspect() :
-{}
-{
-  plus_terminal_name() [ <TO> minus_terminal_name() ]
-}
-
-
-void delay_mechanism() :
-{}
-{
-    <TRANSPORT>
-  | [ <REJECT> time_expression() ] <INERTIAL>
-}
-
-ASTdesign_file design_file() :
-{}
-{
-  ( design_unit() )*
-  { return jjtThis; }
-}
-
-
-void design_unit() :
-{}
-{
-  context_clause() library_unit()
-}
-
-void designator() #void :
-{}
-{
-    identifier()
-  | operator_symbol()
-}
-
-void direction() :
-{}
-{
-  <TO> | <DOWNTO>
-}
-
-
-void disconnection_specification() :
-{}
-{
-  <DISCONNECT> guarded_signal_specification() <AFTER>
-    time_expression() ";"
-}
-
-void discrete_range() #void  :
-{}
-{
-    LOOKAHEAD(simple_expression() direction() )
-    range()
-  | LOOKAHEAD( discrete_subtype_indication() )
-    discrete_subtype_indication()
-  | range() 
-}
-
-
-void element_association() #void :
-{}
-{
-  [ LOOKAHEAD(choices() "=>") choices() "=>" ]
-  expression()
-}
-
-
-void element_declaration() :
-{}
-{
-  identifier_list() ":" element_subtype_definition() ";"
-}
-
-
-void element_subtype_definition() #void :
-{}
-{
-  subtype_indication()
-}
-
-
-void entity_aspect() :
-{}
-{
-    <ENTITY> entity_name()
-    [ LOOKAHEAD("(" architecture_identifier() ")")
-    "(" architecture_identifier() ")" ]
-  | <CONFIGURATION> configuration_name()
-  | <OPEN>
-}
-
-/**
- * Section 5: Specifications
- */
-int entity_class() #void :
-{}
-{
-    <ENTITY>                    { return ENTITY; }
-  | <ARCHITECTURE>              { return ARCHITECTURE; }
-  | <CONFIGURATION>             { return CONFIGURATION; }
-  | <PROCEDURE>                 { return PROCEDURE; }
-  | <FUNCTION>                  { return FUNCTION; }
-  | <PACKAGE>                   { return PACKAGE; }
-  | <TYPE>                      { return TYPE; }
-  | <SUBTYPE>                   { return SUBTYPE; }
-  | <CONSTANT>                  { return CONSTANT; }
-  | <SIGNAL>                    { return SIGNAL; }
-  | <VARIABLE>                  { return VARIABLE; }
-  | <COMPONENT>                 { return COMPONENT; }
-  | <LABEL>                     { return LABEL; }
-  | <LITERAL>                   { return LITERAL; }
-  | <UNITS>                     { return UNITS; }
-  | <GROUP>                     { return GROUP; }
-  | <FILE>                      { return FILE; }
-
-  /** 1076.1 extensions: */
-  | <SUBNATURE>                 { return SUBNATURE; }
-  | <NATURE>                    { return NATURE; }
-  | <TERMINAL>                  { return TERMINAL; }
-}
-
-
-void entity_class_entry()  :
-{}
-{
-  entity_class() [ "<>" ]
-}
-
-
-void entity_class_entry_list() :
-{}
-{
-  entity_class_entry() ( "," entity_class_entry() )*
-}
-
-
-void entity_declaration() :
-{}
-{
-  <ENTITY> identifier() <IS>                       { jjtThis.newBlock(); }
-          entity_header()
-          entity_declarative_part()
-  [ <BEGIN>
-    entity_statement_part() ]
-  <END> [ <ENTITY> ] [ entity_simple_name() ] ";"
-
-  {
-    jjtThis.Check();
-    jjtThis.endBlock();
-  }
-}
-
-
-void entity_declarative_item() #void :
-{}
-{
-  try {
-    LOOKAHEAD(subprogram_declaration())
-    subprogram_declaration()
-  | subprogram_body()
-  | type_declaration()
-  | subtype_declaration()
-  | constant_declaration()
-  | signal_declaration()
-  | shared_variable_declaration()
-  | file_declaration()
-  | alias_declaration()
-  | LOOKAHEAD(attribute_declaration())
-    attribute_declaration()
-  | attribute_specification()
-  | disconnection_specification()
-  | use_clause()
-  | LOOKAHEAD(<GROUP> identifier() <IS>)
-    group_template_declaration()
-  | group_declaration()
-
-  // 1076.1 - Extensions:
-  | nature_declaration()
-  | subnature_declaration()
-  | terminal_declaration()
-  }
-  catch( ParseException e )
-  {
-    error_skipto(SEMICOLON, "syntax error in declarative item");
-  }
-}
-
-/**
- * 4.8: Nature Declaration
- * 1076.1 extension
- */
-void nature_declaration() :
-{}
-{
-  <NATURE> identifier() <IS> nature_definition() ";"
-}
-
-/**
- * 1076.1 extension
- */
-void nature_definition() #void :
-{}
-{
-    scalar_nature_definition()
-  | composite_nature_definition()
-}
-
-void subnature_declaration() :
-{}
-{
-  <SUBNATURE> identifier() <IS> subnature_indication() ";"
-}
-
-
-void subnature_indication() :
-{}
-{
-  nature_mark() [index_constraint() ] 
-  [ <TOLERANCE> string_expression() <ACROSS> string_expression() <THROUGH>]
-}
-
-void nature_mark() #void :
-{}
-{
-    LOOKAHEAD(nature_name())
-    nature_name() 
-  | LOOKAHEAD(subnature_name())
-    subnature_name()
-}
-
-void entity_declarative_part() :
-{}
-{
-  ( entity_declarative_item() )*
-}
-
-void entity_designator() :
-{}
-{
-  entity_tag() signature()
-}
-
-
-
-void entity_header() :
-{}
-{
-  [ formal_generic_clause() ]
-  [ formal_port_clause() ]
-}
-
-
-void entity_name_list() :
-{}
-{
-  entity_designator() ( "," entity_designator() )*
-  | <OTHERS>
-  | <ALL>
-}
-
-
-void entity_specification() :
-{}
-{
-        entity_name_list() ":" entity_class()
-}
-
-
-void entity_statement() #void :
-{}
-{   LOOKAHEAD( concurrent_assertion_statement() )
-    concurrent_assertion_statement()
-  | LOOKAHEAD([process_label() ":"] [<POSTPONED>] <PROCESS>)
-    passive_process_statement()
-  | passive_concurrent_procedure_call_statement()
-}
-
-
-void entity_statement_part() :
-{}
-{
-  ( entity_statement() )*
-}
-
-void entity_tag() :
-{}
-{
-    simple_name()
-  | <character_literal>
-  | operator_symbol()
-}
-
-
-void enumeration_literal() :
-{}
-{
-  <character_literal>
-  | identifier()
-}
-
-
-
-void enumeration_type_definition() :
-{}
-{
-  "(" enumeration_literal() ( "," enumeration_literal())* ")"
-}
-
-
-void exit_statement() :
-{}
-{
-  [ label() ":" ] <EXIT> [ loop_label() ]
-    [ <WHEN> condition() ] ";"
-}
-
-void expression() #void :
-{ int op; }
-{
-/**  relation() (
- *   ( <AND> relation() )* |
- *    ( <OR> relation() )*  |
- *    ( <XOR> relation() )* |
- *    [ <NAND> relation() ] |
- *    [ <NOR> relation() ]  |
- *    ( <XNOR> relation() )*
- *  )
- */
-  relation() 
-  ( LOOKAHEAD(1) op=logical_operator() relation()
-  #relation(2) )*
-
-}
-
-
-void factor() #void :
-{}
-{
-    <ABS> primary()
-  | <NOT> primary()
-  | primary() [ LOOKAHEAD("**" primary() ) <EXP> primary() #factor(2) ]
-}
-
-
-void file_declaration() :
-{}
-{
-  <FILE> identifier_list() ":" subtype_indication()
-     [ file_open_information() ] ";"
-}
-
-
-void file_logical_name() #void :
-{}
-{
-  string_expression()
-}
-
-
-void file_open_information() :
-{}
-{
-  <OPEN> file_open_kind_expression() <IS> file_logical_name()
-  | <IS> [ <IN> | <OUT> ] file_logical_name()
-}
-
-void file_type_definition() #void :
-{}
-{
-  <FILE> <OF> type_mark()
-}
-
-void floating_type_definition() #void :
-{}
-{
-  range_constraint()
-}
-
-
-void formal_designator() #void :
-{}
-{
-    LOOKAHEAD( generic_name() )
-    generic_name()
-  | LOOKAHEAD( port_name() )
-    port_name()
-  | parameter_name()
-}
-
-void formal_parameter_list() :
-{}
-{
-  parameter_interface_list()
-}
-
-
-void formal_part() #void :
-{}
-{
-    LOOKAHEAD( function_name() "(" formal_designator() ")")
-    function_name() "(" formal_designator() ")"
-  | LOOKAHEAD( type_mark() "(" formal_designator() ")")
-    type_mark() "(" formal_designator() ")"
-  | formal_designator()
-}
-
-void full_type_declaration() :
-{}
-{
-  <TYPE> identifier() <IS> type_definition() ";"
-}
-
-
-void function_call() :
-{}
-{
-  function_name()
-  [ LOOKAHEAD( "(" actual_parameter_part() ")" ) "(" actual_parameter_part() ")" ]
-}
-
-
-/**
- * Section 9.7
- */
-void generate_statement() :
-{}
-{
-  generate_label() ":"
-  generation_scheme() <GENERATE>
-    [ LOOKAHEAD(2) ( block_declarative_item() )* <BEGIN> ]
-    ( architecture_statement() )*
-  <END> <GENERATE> [ generate_label() ] ";"
-}
-
-/** 1076.1 extension: */
-void concurrent_break_statement() :
-{}
-{
-  [label() ":"] <BREAK> [break_list()] [sensitivity_clause() ] [ <WHEN> condition()] ";"
-}
-
-
-void generation_scheme() :
-{}
-{
-    <FOR> generate_parameter_specification()
-  | <IF> condition()
-}
-
-
-void generic_clause() :
-{}
-{
-  <GENERIC> "(" generic_list() ")" ";"
-}
-
-
-void generic_list() #void :
-{}
-{
-  generic_interface_list()
-}
-
-
-void generic_map_aspect() #void :
-{}
-{
-  <GENERIC> <MAP> "(" generic_association_list() ")"
-}
-
-
-void group_constituent() :
-{}
-{
-    name()
-  | <character_literal>
-}
-
-
-void group_constituent_list() :
-{}
-{
-  group_constituent() ( "," group_constituent() )*
-}
-
-
-void group_template_declaration() :
-{}
-{
-  <GROUP> identifier() <IS> "(" entity_class_entry_list() ")" ";"
-}
-
-void group_declaration() :
-{}
-{
-  <GROUP> identifier() ":" group_template_name()
-  "(" group_constituent_list() ")" ";"
-}
-
-
-
-void guarded_signal_specification() :
-{}
-{
-  guarded_signal_list() ":" type_mark()
-}
-
-
-void identifier() :
-{ Token t; }
-{  
-     t=<basic_identifier>    { jjtThis.name = t.image; }
-  |  t=<extended_identifier> { jjtThis.name = t.image; }
-}
-
-
-void identifier_list() :
-{}
-{
-  identifier() ( "," identifier() )*
-}
-
-
-void if_statement() :
-{}
-{
-  [ if_label() ":" ]
-  <IF> condition() <THEN>
-  sequence_of_statements()
-  ( <ELSIF> condition() <THEN>
-    sequence_of_statements() )*
-  [ <ELSE>
-    sequence_of_statements() ]
-  <END> <IF> [ if_label() ] ";"
-}
-
-void incomplete_type_declaration() :
-{}
-{
-  <TYPE> identifier() ";"
-}
-
-
-void index_constraint() :
-{}
-{
-  "(" discrete_range() ( "," discrete_range() )* ")"
-}
-
-
-
-void index_specification() :
-{}
-{
-    LOOKAHEAD( discrete_range() )
-    discrete_range()
-  | static_expression()
-}
-
-
-void index_subtype_definition() :
-{}
-{
-  type_mark() <RANGE> "<>"
-}
-
-void indexed_name() :
-{}
-{
-  prefix() "(" expression() ( "," expression() )* ")"
-}
-
-void instantiated_unit() :
-{}
-{
-    [ <COMPONENT> ] component_name()
-  | <ENTITY> entity_name() [ "(" architecture_identifier() ")" ]
-  | <CONFIGURATION> configuration_name()
-}
-
-
-void instantiation_list() :
-{}
-{
-    instantiation_label() ( "," instantiation_label() )*
-  | <OTHERS>
-  | <ALL>
-}
-
-void integer_type_definition() #void :
-{}
-{
-  range_constraint()
-}
-
-
-
-void interface_constant_declaration() :
-{}
-{
-  [ <CONSTANT> ] identifier_list() ":" [ <IN> ]
-    subtype_indication() [ ":=" static_expression() ]
-}
-
-/**
- * Section 4.3.2:
- */
-void interface_declaration() #void :
-{}
-{
-    LOOKAHEAD(interface_constant_declaration() ) 
-    interface_constant_declaration()
-  | LOOKAHEAD(interface_signal_declaration() )
-    interface_signal_declaration()
-  | LOOKAHEAD(interface_variable_declaration() )
-    interface_variable_declaration()
-  | LOOKAHEAD(interface_file_declaration() )
-    interface_file_declaration()
-
-  /** 1076.1 extensions: */
-  | interface_terminal_declaration() 
-  | interface_quantity_declaration()
-}
-
-
-/**
- * 1076.1 extension:
- */
-void interface_terminal_declaration()  :
-{}
-{
-  <TERMINAL> identifier_list() ":" subnature_indication()
-}
-
-
-/**
- * 1076.1 extension:
- */
-void interface_quantity_declaration() :
-{}
-{
-  <QUANTITY> identifier_list() ":" 
-  [ <IN> | <OUT> ] subtype_indication() [ ":=" static_expression() ]
-}
-
-
-void interface_element() #void :
-{}
-{
-  interface_declaration()
-}
-
-
-void interface_file_declaration() :
-{}
-{
-  <FILE> identifier_list() ":" subtype_indication()
-}
-
-
-void interface_list() :
-{}
-{
-  interface_element() ( ";" interface_element() )*
-}
-
-void interface_signal_declaration() :
-{}
-{
-  [<SIGNAL>] identifier_list() ":"
-  [ mode() ] subtype_indication() [ <BUS> ] [ ":=" static_expression() ]
-}
-
-
-void interface_variable_declaration() :
-{}
-{
-  [<VARIABLE>] identifier_list() ":"
-  [ mode() ] subtype_indication() [ ":=" static_expression() ]
-}
-
-
-
-void iteration_scheme() :
-{}
-{
-    <WHILE> condition()
-  | <FOR> loop_parameter_specification()
-}
-
-
-void label() #void :
-{}
-{
-  identifier()
-}
-
-
-
-void library_clause() #void :
-{}
-{
-  <LIBRARY> logical_name_list() ";"
-}
-
-
-void library_unit() #void :
-{}
-{   LOOKAHEAD(<ENTITY> | <CONFIGURATION> | <PACKAGE> identifier() )
-    primary_unit()
-  | secondary_unit()
-}
-
-
-
-void literal() :
-{}
-{
-    LOOKAHEAD( numeric_literal() )
-    numeric_literal()
-  | enumeration_literal()
-  | <string_literal>
-  | <bit_string_literal>
-  | <NULL>
-}
-
-
-void logical_name() #void :
-{}
-{
-  identifier()
-}
-
-
-
-void logical_name_list() :
-{}
-{
-  logical_name() ( "," logical_name() )*
-}
-
-
-int logical_operator() #void :
-{}
-{
-    <AND>             { return AND; }
-  | <OR>              { return OR; }
-  | <NAND>            { return NAND; }
-  | <NOR>             { return NOR; }
-  | <XOR>             { return XOR; }
-  | <XNOR>            { return XNOR; }
-}
-
-
-void loop_statement() :
-{}
-{
-  [ loop_label() ":" ]
-  [ iteration_scheme() ] <LOOP>
-                        sequence_of_statements()
-  <END> <LOOP> [ loop_label() ] ";"
-}
-
-
-int miscellaneous_operator() #void :
-{}
-{
-    <EXP>               { return EXP; }
-  | <ABS>               { return ABS; }
-  | <NOT>               { return NOT; }
-}
-
-
-void mode() :
-{}
-{
-    <IN>
-  | <OUT>
-  | <INOUT>
-  | <BUFFER>
-  | <LINKAGE>
-}
-
-int multiplying_operator() #void :
-{}
-{
-    "*"                 { return MUL; }
-  | "/"                 { return DIV; }
-  | <MOD>               { return MOD; }
-  | <REM>               { return REM; }
-}
-
-
-void name() :
-{}
-{
-/**  simple_name()
- * | operator_symbol()
- *  | selected_name()
- *  | indexed_name()
- *  | slice_name()
- *  | attribute_name()
- *
- * Kann ohne Linksrekursion wie folgt geschrieben werden:
- */
-  ( simple_name() | operator_symbol() )
-  [ LOOKAHEAD(name_extension()) name_extension()   ]
-}
-
-void name_extension() #void :
-{}
-{
-  (
-        LOOKAHEAD( signature() "'"  )
-        signature() "'" attribute_designator()
-        [ LOOKAHEAD( "(" expression() ")") "(" expression() ")"]
-      | "." suffix()
-      | LOOKAHEAD( "(" discrete_range() ")" ) 
-        "(" discrete_range() ")"  
-      | LOOKAHEAD( "(" expression() ("," expression() )* ")" )
-        "(" expression() ("," expression() )* ")"
-      /**
-       * The following production is already in sign. "'" ... ,
-       * since signature can be empty!
-       * | "'" attribute_designator() [ "(" expression() ")"]
-       */
-  )
-  [  LOOKAHEAD(name_extension() ) name_extension() ]
-}
-
-/**
- * 1076.1 extension:
- */
-void nature_element_declaration() :
-{}
-{
-  identifier_list() ":" element_subnature_definition()
-}
-
-/**
- * 1076.1 extension:
- */
-void element_subnature_definition() #void :
-{}
-{
-  subnature_indication()
-}
-
-
-void next_statement() :
-{}
-{                                                               
-  [ label() ":" ] <NEXT> [ loop_label() ] [ <WHEN> condition() ] ";"
-}
-
-void null_statement() :
-{}
-{
-  [ label() ":" ] <NULL> ";"
-}
-
-
-
-void numeric_literal() #void :
-{}
-{
-    LOOKAHEAD(physical_literal())
-    physical_literal()
-  | abstract_literal()
-}
-
-
-void object_declaration() #void :
-{}
-{
-  try {
-    constant_declaration()
-  | signal_declaration()
-  | variable_declaration()
-  | file_declaration()
-  /** 1076.1 extensions: */
-  | terminal_declaration()
-  | quantity_declaration()
-
-  }
-  catch( ParseException e )
-  {
-    error_skipto(SEMICOLON, "syntax error in declaration");
-  }
-}
-
-
-void operator_symbol() :
-{}
-{
-  <string_literal>
-}
-
-
-void options_() :
-{}
-{
-  [ <GUARDED> ] [ delay_mechanism() ]
-}
-
-
-void package_body() :
-{}
-{
-  <PACKAGE> <BODY> package_simple_name() <IS>
-       package_body_declarative_part()
-  <END> [ <PACKAGE> <BODY> ] [ package_simple_name() ] ";"
-}
-
-void package_body_declarative_item() #void :
-{}
-{
-  try {
-    LOOKAHEAD(subprogram_declaration())
-    subprogram_declaration()
-  | subprogram_body()
-  | type_declaration()
-  | subtype_declaration()
-  | constant_declaration()
-  | shared_variable_declaration()
-  | file_declaration()
-  | alias_declaration()
-  | use_clause()
-  | LOOKAHEAD(<GROUP> identifier() <IS>)
-    group_template_declaration()
-  | group_declaration()
-  }
-  catch( ParseException e )
-  {
-    error_skipto(SEMICOLON, "syntax error in declarative item");
-  }
-}
-
-
-void package_body_declarative_part() :
-{}
-{
-  ( package_body_declarative_item() )*
-}
-
-
-
-void package_declaration() :
-{}
-{
-  <PACKAGE> identifier() <IS>
-     package_declarative_part()
-  <END> [ <PACKAGE> ] [ package_simple_name() ] ";"
-}
-
-
-void package_declarative_item() #void :
-{}
-{
-  try {
-    subprogram_declaration()
-  | type_declaration()
-  | subtype_declaration()
-  | constant_declaration()
-  | signal_declaration()
-  | shared_variable_declaration()
-  | file_declaration()
-  | alias_declaration()
-  | component_declaration()
-  | LOOKAHEAD( attribute_declaration() )
-    attribute_declaration()
-  | attribute_specification()
-  | disconnection_specification()
-  | use_clause()
-  | LOOKAHEAD(<GROUP> identifier() <IS>)
-    group_template_declaration()
-  | group_declaration()
-
-  // 1076.1 extensions:
-  | nature_declaration()
-  | subnature_declaration()
-  | terminal_declaration()
-  }
-  catch(ParseException e)
-  {
-    error_skipto(SEMICOLON, "syntax error in declaration");
-  }
-}
-
-void package_declarative_part() :
-{}
-{
-  ( package_declarative_item() )*
-}
-
-
-void parameter_specification() :
-{}
-{
-  identifier() <IN> discrete_range()
-}
-
-void physical_literal() :
-{}
-{
-  [ LOOKAHEAD(abstract_literal() unit_name() )
-    abstract_literal() ]
-  unit_name()
-}
-
-
-void physical_type_definition() :
-{}
-{
-  range_constraint()
-  <UNITS>
-  base_unit_declaration()
-  ( secondary_unit_declaration() )*
-  <END> <UNITS> [ physical_type_simple_name() ]
-}
-
-
-void port_clause() :
-{}
-{
-  <PORT> "(" port_list() ")" ";"
-}
-
-void port_list() #void :
-{}
-{
-  port_interface_list()
-}
-
-
-void port_map_aspect() :
-{}
-{
-  <PORT> <MAP> "(" port_association_list() ")"
-}
-
-
-void prefix() :
-{}
-{
-    LOOKAHEAD( function_call() )
-    function_call()
-  | name()
-}
-
-
-void primary() #void :
-{}
-{
-    LOOKAHEAD( qualified_expression() )
-    qualified_expression()
-
-  | LOOKAHEAD( function_call() )
-    function_call()
-
-  | LOOKAHEAD(name())
-    name()
-
-  | LOOKAHEAD(literal())
-    literal()
-
-  | LOOKAHEAD( aggregate() )
-    aggregate()
-
-  | LOOKAHEAD( "(" expression() ")")
-    "(" expression() ")"
-
-  | LOOKAHEAD( type_conversion() )
-    type_conversion()
-
-  | allocator()
-
-}
-
-
-void primary_unit() #void :
-{}
-{
-    entity_declaration()
-  | configuration_declaration()
-  | LOOKAHEAD(<PACKAGE> identifier())
-    package_declaration()
-}
-
-
-void procedure_call() :
-{}
-{
-  procedure_name() [ "(" actual_parameter_part() ")" ]
-}
-
-void procedure_call_statement() :
-{}
-{
-   [ LOOKAHEAD( label() ":") label() ":" ]
-   procedure_call() ";"
-}
-
-
-void process_declarative_item() #void :
-{}
-{
-    LOOKAHEAD(subprogram_declaration())
-    subprogram_declaration()
-  | subprogram_body()
-  | type_declaration()
-  | subtype_declaration()
-  | constant_declaration()
-  | variable_declaration()
-  | file_declaration()
-  | alias_declaration()
-  | LOOKAHEAD( attribute_declaration() )
-    attribute_declaration()
-  | attribute_specification()
-  | use_clause()
-  | LOOKAHEAD( <GROUP> identifier() <IS> )
-    group_template_declaration()
-  | group_declaration()
-}
-
-void process_declarative_part() :
-{}
-{
-  ( process_declarative_item() )*
-}
-
-
-void process_statement() :
-{}
-{
-   [ process_label() ":" ]
-   [ <POSTPONED> ] <PROCESS>                    { jjtThis.newBlock(); }
-   [ "(" sensitivity_list() ")" ] [ <IS> ]
-     process_declarative_part()
-   <BEGIN>
-     process_statement_part()
-   <END> [ <POSTPONED> ] <PROCESS> [ process_label() ] ";"
-
-   {
-     jjtThis.Check();
-     jjtThis.endBlock();
-   }
-}
-
-
-void process_statement_part() :
-{}
-{
-  ( sequential_statement() )*
-}
-
-
-/*
-    VHDL 2002: protected types:
-*/
-
-void protected_type_body() #void :
-{}
-{
-  <PROTECTED> <BODY>
-    protected_type_body_declarative_part()
-  <END> <PROTECTED> <BODY> [ simple_name() ]
-}
-
-void protected_type_body_declarative_item() #void :
-{}
-{
-    LOOKAHEAD(subprogram_declaration())
-    subprogram_declaration()
-    | subprogram_body()
-    | type_declaration() 
-    | subtype_declaration() 
-    | constant_declaration() 
-    | variable_declaration() 
-    | file_declaration() 
-    | alias_declaration() 
-    | LOOKAHEAD(attribute_declaration())
-    attribute_declaration() 
-    | attribute_specification() 
-    | use_clause() 
-    | LOOKAHEAD(group_template_declaration())
-    group_template_declaration()
-    | group_declaration() 
-}
-
-void protected_type_body_declarative_part() #void :
-{}
-{ 
-  (protected_type_body_declarative_item())+
-}
-
-void protected_type_declaration() #void :
-{}
-{
-  <PROTECTED>
-    protected_type_declarative_part()
-  <END> <PROTECTED> [ simple_name() ]
-}
-
-void protected_type_declarative_item() #void :
-{}
-{
-    subprogram_declaration()
-    | attribute_declaration()
-    | use_clause()
-}
-
-void protected_type_declarative_part() #void :
-{}
-{ 
-  (protected_type_declarative_item())+
-}
-
-void protected_type_definition() #void :
-{}
-{
-    LOOKAHEAD(protected_type_body()) protected_type_body()
-    | protected_type_declaration()
-}
-
-void qualified_expression() :
-{}
-{
-  type_mark() "'"
-  (   LOOKAHEAD( aggregate() )
-      aggregate()
-    | "(" expression() ")"
-  )
-}
-
-void range() :
-{}
-{
-    LOOKAHEAD( simple_expression() direction() )
-    simple_expression() direction() simple_expression()
-  | range_attribute_name()
-}
-
-
-void range_constraint() #void :
-{}
-{
-  <RANGE> range()
-}
-
-void record_nature_definition() :
-{}
-{
-  <RECORD>
-  ( nature_element_declaration() )+
-  <END> <RECORD> [ record_nature_simple_name() ]
-}
-
-void record_type_definition() :
-{}
-{
-  <RECORD>
-  ( element_declaration() )+
-  <END> <RECORD> [ record_type_simple_name() ]
-}
-
-
-
-void relation() #void :
-{ int op; }
-{
-  shift_expression() 
-  [ LOOKAHEAD(1)
-  op=relational_operator()
-  shift_expression()
-  #shift_expression(2) ]
-}
-
-
-int relational_operator() #void :
-{}
-{
-    <EQ>                { return EQ; }
-  | <NEQ>               { return NEQ; } 
-  | <LO>                { return LO; }
-  | <LE>                { return LE; }
-  | <GT>                { return GT; }
-  | <GE>                { return GE; }
-}
-
-
-void report_statement() :
-{}
-{
-  [ label() ":" ]  <REPORT> expression()
-  [ <SEVERITY> expression() ] ";"
-}
-
-
-void return_statement() :
-{}
-{
-  [ label() ":" ] <RETURN> [ expression() ] ";"
-}
-
-
-// 1076.1 - extension:
-void scalar_nature_definition() :
-{}
-{
-  type_mark() <ACROSS> type_mark() <THROUGH>
-}
-
-
-void scalar_type_definition() #void :
-{}
-{
-    LOOKAHEAD(range_constraint() <UNITS> )
-    physical_type_definition()
-  |
-    LOOKAHEAD(enumeration_type_definition())
-    enumeration_type_definition()
-/**  | integer_type_definition()
- *  | floating_type_definition()
- * integer- and floating_type_definition are both range_constraint,
- * thus:
- */
-  |
-    range_constraint()
-}
-
-void secondary_unit() #void :
-{}
-{
-    LOOKAHEAD( <ARCHITECTURE> )
-    architecture_body()
-  | LOOKAHEAD( <PACKAGE> <BODY> )
-    package_body()
-}
-
-
-void secondary_unit_declaration() :
-{}
-{
-  identifier() "=" physical_literal() ";"
-}
-
-
-void selected_name() :
-{}
-{
-  /**
-   * prefix() "." suffix()
-   * results in left-recursion...
-   * the follwoing does the same (i hope ...)
-   */
-
-  ( simple_name() | operator_symbol() )
-  [ LOOKAHEAD( name_extension() )  name_extension() ]
-
-  /**
-   * semantic analysis has to ensure that last production
-   * was "." suffix()
-   */
-}
-
-
-void selected_signal_assignment() :
-{}
-{
-  <WITH> expression() <SELECT>
-  target()  "<=" options_() selected_waveforms() ";"
-}
-
-void selected_waveforms() :
-{}
-{
-  waveform() <WHEN> choices()
-  ("," waveform() <WHEN> choices() )*
-}
-
-void sensitivity_clause() #void :
-{}
-{
-  <ON> sensitivity_list()
-}
-
-
-void sensitivity_list() :
-{}
-{
-  signal_name() ( "," signal_name() )*
-}
-
-
-void sequence_of_statements() :
-{}
-{
-  ( sequential_statement() )*
-}
-
-void sequential_statement() #void :
-{}
-{
-  try {
-    (
-      LOOKAHEAD(3)
-      wait_statement()
-    | LOOKAHEAD(3)
-      assertion_statement()
-    | LOOKAHEAD(3)
-      report_statement()
-    | LOOKAHEAD(  [ label() ":" ] target() "<=" )
-      signal_assignment_statement()
-    | LOOKAHEAD(  [ label() ":" ] target() ":=" )
-      variable_assignment_statement()
-    | LOOKAHEAD(3)
-      procedure_call_statement()
-    | LOOKAHEAD(3)
-      if_statement()
-    | LOOKAHEAD(3)
-      case_statement()
-    | LOOKAHEAD(3)
-      loop_statement()
-    | LOOKAHEAD(3)
-      next_statement()
-    | LOOKAHEAD(3)
-      exit_statement()
-    | LOOKAHEAD(3)
-      return_statement()
-    | LOOKAHEAD(3)
-      null_statement()
-
-    /** 1076.1 extensions: */
-    | break_statement()
-    )
-  }
-
-  // Error handling: skip till next semicolon.
-  catch (ParseException e)
-  {
-    error_skipto(SEMICOLON, "syntax error in sequential statement");
-  } 
-}
-
-
-void shift_expression() #void :
-{ int op; }
-{
-  simple_expression() 
-  [ LOOKAHEAD(2) op=shift_operator()
-  simple_expression() #simple_expression(2)  ]
-}
-
-int shift_operator() #void :
-{}
-{
-    <SLL>               { return SLL; }
-  | <SRL>               { return SRL; }
-  | <SLA>               { return SLA; }
-  | <SRA>               { return SRA; }
-  | <ROL>               { return ROL; }
-  | <ROR>               { return ROR; }
-}
-
-void sign() :
-{}
-{
-    "+"
-  | "-"
-}
-
-
-void signal_assignment_statement() :
-{}
-{
-  [ LOOKAHEAD( label() ":") label() ":" ]
-  target() "<=" [ delay_mechanism() ] waveform() ";"
-
-}
-
-
-void signal_declaration() :
-{}
-{
-    <SIGNAL> identifier_list() ":"
-    subtype_indication() [ signal_kind() ] [ ":=" expression() ] ";"
-}
-
-
-void signal_kind() :
-{}
-{
-    <REGISTER>
-  | <BUS>
-}
-
-void signal_list() :
-{}
-{
-    signal_name() ( "," signal_name() )*
-  | <OTHERS>
-  | <ALL>
-}
-
-
-void signature() :
-{}
-{
-  [ type_mark() ( LOOKAHEAD( "," type_mark() ) "," type_mark() )* ]
-  [ <RETURN> type_mark() ]
-}
-
-
-void simple_expression() #void :
-{ int op; }
-{
-   [ sign() ] term()
-   ( LOOKAHEAD(2) op=adding_operator() term()
-     #term(2) )*
-}
-
-
-void simple_name() #void :
-{}
-{
-  identifier()
-}
-
-void slice_name() :
-{}
-{
-  prefix() "(" discrete_range() ")"
-}
-
-
-
-void subprogram_body() :
-{}
-{
-  subprogram_specification() <IS>
-     subprogram_declarative_part()
-  <BEGIN>
-         subprogram_statement_part()
-  <END> [ subprogram_kind() ] [ designator() ] ";"
-}
-
-
-void subprogram_declaration() #void :
-{}
-{
-  subprogram_specification() ";"
-}
-
-
-void subprogram_declarative_item() #void :
-{}
-{
-    LOOKAHEAD(subprogram_declaration())
-    subprogram_declaration()
-  | subprogram_body()
-  | type_declaration()
-  | subtype_declaration()
-  | constant_declaration()
-  | variable_declaration()
-  | file_declaration()
-  | alias_declaration()
-  | LOOKAHEAD(attribute_declaration())
-    attribute_declaration()
-  | attribute_specification()
-  | use_clause()
-  | LOOKAHEAD( <GROUP> identifier() <IS>)
-    group_template_declaration()
-  | group_declaration()
-}
-
-void subprogram_declarative_part() :
-{}
-{
-  ( subprogram_declarative_item() )*
-}
-
-
-int subprogram_kind() #void :
-{}
-{
-    <PROCEDURE>                 { return PROCEDURE; }
-  | <FUNCTION>                  { return FUNCTION; }
-}
-
-void subprogram_specification() :
-{}
-{
-  <PROCEDURE> designator() [ "(" formal_parameter_list() ")" ]
-  | [ <PURE> | <IMPURE> ]  <FUNCTION> designator()
-     [ "(" formal_parameter_list() ")" ]
-                <RETURN> type_mark()
-}
-
-
-
-void subprogram_statement_part() :
-{}
-{
-  ( sequential_statement() )*
-}
-
-
-void subtype_declaration() :
-{}
-{
-  <SUBTYPE> identifier() <IS> subtype_indication() ";"
-}
-
-
-/**
- * Section 4.1:
- */
-void subtype_indication() :
-{}
-{
-  /*
-   * enumeration resolves conflict ! After implementation of symbol tables
-   * this can be replaced by semantic lookahead.
-   */ 
-    LOOKAHEAD(resolution_function_name() type_mark() constraint())
-    resolution_function_name() type_mark() constraint() 
-      [ LOOKAHEAD(tolerance_aspect())tolerance_aspect() ]
-
-  | LOOKAHEAD( type_mark() constraint() )
-    type_mark() constraint() 
-      [ LOOKAHEAD(tolerance_aspect()) tolerance_aspect() ]
-
-  | LOOKAHEAD( resolution_function_name() type_mark() )
-    resolution_function_name() type_mark() 
-      [ LOOKAHEAD(tolerance_aspect())tolerance_aspect() ]
-
-  | LOOKAHEAD( type_mark() )
-    type_mark()  
-      [ LOOKAHEAD(tolerance_aspect()) tolerance_aspect() ]
-}
-
-
-/**
- * 1076.1 extension:
- */
-void tolerance_aspect() #void :
-{}
-{
-  <TOLERANCE> string_expression()
-}
-
-
-/**
- * Section 4.3.1.6: Quantity declaration
- * 1076.1 extension:
- */
-void quantity_declaration() #void :
-{}
-{
-    LOOKAHEAD(free_quantity_declaration() )
-    free_quantity_declaration()
-  | LOOKAHEAD(branch_quantity_declaration() )
-    branch_quantity_declaration()
-  | source_quantity_declaration()
-}
-
-/**
- * 1076.1 extension:
- */
-void free_quantity_declaration() :
-{}
-{
-  <QUANTITY> identifier_list() ":" subtype_indication() [":=" expression()] ";"
-}
-
-/**
- * 1076.1 extension:
- */
-void branch_quantity_declaration() :
-{}
-{
-  <QUANTITY> [LOOKAHEAD(across_aspect()) across_aspect()] 
-	     [LOOKAHEAD(through_aspect()) through_aspect()] 
-	     terminal_aspect() ";"
-}
-
-/**
- * 1076.1 extension:
- */
-void source_quantity_declaration() :
-{}
-{ 
-  <QUANTITY> identifier_list() ":" subtype_indication() source_aspect() ";"
-}
-
-/**
- * 1076.1 extension:
- */
-void across_aspect() :
-{}
-{
-  identifier_list() [ tolerance_aspect() ] [ ":=" expression() ] <ACROSS>
-}
-
-/**
- * 1076.1 extension:
- */
-void through_aspect() :
-{}
-{
-  identifier_list() [ tolerance_aspect() ] [ ":=" expression() ] <THROUGH>
-} 
-
-/**
- * 1076.1 extension:
- */
-void source_aspect() :
-{}
-{
-    <SPECTRUM> magnitude_simple_expression() "," phase_simple_expression() 
-  | <NOISE>    magnitude_simple_expression() 
-}
-
-void suffix() #void :
-{}
-{
-    simple_name()
-  | <character_literal>
-  | operator_symbol()
-  | <ALL>
-}
-
-void target() #void :
-{}
-{
-    name()
-  | aggregate()
-}
-
-
-void term() #void :
-{ int op; }
-{
-  factor() ( LOOKAHEAD(2) op = multiplying_operator() factor() #factor(2)
-  )*
-}
-
-void timeout_clause() #void :
-{}
-{
-  <FOR> time_or_real_expression()
-}
-
-
-void type_conversion() :
-{}
-{
-  type_mark() "(" expression() ")"
-}
-
-
-void type_declaration() #void :
-{}
-{
-    LOOKAHEAD( <TYPE> identifier() <IS> )
-    full_type_declaration()
-  | incomplete_type_declaration()
-}
-
-
-void type_definition() #void :
-{}
-{
-    scalar_type_definition()
-  | composite_type_definition()
-  | access_type_definition()
-  | file_type_definition()
-  | protected_type_definition()
-}
-
-
-void type_mark() #void :
-{}
-{
-    LOOKAHEAD(type_name())
-    type_name()
-  | LOOKAHEAD(subtype_name())
-    subtype_name()
-}
-
-
-void unconstrained_array_definition() :
-{}
-{
-  <ARRAY> "(" index_subtype_definition()
-    ( "," index_subtype_definition() )* ")"
-      <OF> element_subtype_indication()
-}
-
-
-void use_clause() :
-{}
-{
-   <USE> selected_name() ( "," selected_name() )* ";"
-}
-
-
-void variable_assignment_statement() :
-{}
-{
-  [ LOOKAHEAD( label() ":") label() ":" ]
-  target()  ":=" expression() ";"
-}
-
-
-void variable_declaration() :
-{}
-{
-  [ <SHARED> ] <VARIABLE> identifier_list() ":"
-  subtype_indication() [ ":=" expression() ] ";"
-}
-
-
-void wait_statement() :
-{}
-{
-   [ LOOKAHEAD( label() ) ":" label() ":"]
-   <WAIT> [ sensitivity_clause() ]
-   [ condition_clause() ] [ timeout_clause() ] ";"
-}
-
-
-void waveform() :
-{}
-{
-  waveform_element() ( "," waveform_element() )*
-  | <UNAFFECTED>
-}
-
-void waveform_element() :
-{}
-{
-     LOOKAHEAD(<NULL>)
-     <NULL>             [<AFTER> time_expression() ]
-  |  value_expression() [ <AFTER> time_expression() ]
-}
-
-
-/** 
- *Section 15: Simultaneous statements
- * 1076.1 extension
- */
-void simultaneous_statement_part()   :
-{}
-{
-  ( simultaneous_statement() )*
-}
-
-/**
- * 1076.1 extension:
- */
-void simultaneous_statement() #void :
-{}
-{
-    LOOKAHEAD(simple_simultaneous_statement())
-    simple_simultaneous_statement()
-  | LOOKAHEAD( [if_label()] ":" <IF> condition() <USE> )
-    simultaneous_if_statement()
-  | LOOKAHEAD(simultaneous_case_statement())
-    simultaneous_case_statement()
-  | LOOKAHEAD(4) // procedural is at least as 4th position...
-    simultaneous_procedural_statement()
-  | simultaneous_null_statement()
-}
-
-/**
- * 1076.1 extension:
- */
-void simple_simultaneous_statement() :
-{}
-{
-  [ LOOKAHEAD( label() ":") label() ":"] 
-  [<PURE>|<IMPURE>] simple_expression() 
-  "==" simple_expression() [ tolerance_aspect() ] ";"
-}
-
-
-/**
- * 1076.1 extension:
- */
-void simultaneous_if_statement() :
-{}
-{
-  [ if_label() ":"] <IF> condition() <USE>
-     simultaneous_statement_part()
-  ( <ELSIF> condition() <USE> simultaneous_statement_part() )*
-  [ <ELSE> simultaneous_statement_part() ]
-  <END> <USE> [ if_label()] ";"
-}
-
-
-/**
- * 1076.1 extension:
- */
-void simultaneous_case_statement() :
-{}
-{
-  [ case_label() ":"] <CASE> expression() <USE>
-    (simultaneous_alternative())*
-  <END> <CASE> [ case_label() ] ";"
-}
-
-
-/**
- * 1076.1 extension:
- */
-void simultaneous_alternative() :
-{}
-{
-  <WHEN> choices() <USE> simultaneous_statement_part()
-}
-
-
-/**
- * 1076.1 extension:
- */
-void simultaneous_procedural_statement() :
-{}
-{
-  [procedural_label() ":"] [<PURE>|<IMPURE>] <PROCEDURAL> [<IS>]
-    procedural_declarative_part()
-   <BEGIN>
-     procedural_statement_part()
-   <END> <PROCEDURAL> [ procedural_label()] ";"
-}
-
-
-// 1076.1 extension:
-void procedural_label() #void :
-{}
-{
-  label()
-}
-
-// 1076.1 extension:
-void procedural_declarative_part() :
-{}
-{
-  ( procedural_declarative_item() )*
-}
-
-/**
- * 1076.1 extension:
- */
-void procedural_declarative_item() #void :
-{}
-{
-    LOOKAHEAD(subprogram_declaration())
-    subprogram_declaration()
-  | subprogram_body()
-  | type_declaration()
-  | subtype_declaration()
-  | constant_declaration()
-  | variable_declaration()
-  | alias_declaration()
-  | LOOKAHEAD(attribute_declaration())
-    attribute_declaration()
-  | attribute_specification()
-  | use_clause()
-  | LOOKAHEAD(group_template_declaration())
-    group_template_declaration()
-  | group_declaration()
-}
-
-/**
- * 1076.1 extension:
- */
-void procedural_statement_part() :
-{}
-{
-  ( sequential_statement() )*
-}
-
-
-
-// 1076.1 extension:
-void simultaneous_null_statement() :
-{}
-{
-  [ label() ":"] <NULL> ";"
-}
-
-
-
-
-//
-// parts of grammar, which have to be checked during semantic analysis
-// by semantic lookahead:
-//
-void block_label() #void :
-{}
-{
-  label()
-}
-
-void block_statement_label() #void :
-{}
-{
-  label()
-}
-
-void case_label() #void :
-{}
-{
-  label()
-}
-
-void generate_label() #void :
-{}
-{
-  label()
-}
-
-void generate_statement_label() #void :
-{}
-{
-  label()
-}
-
-void if_label() #void :
-{}
-{
-  label()
-}
-
-void instantiation_label() #void :
-{}
-{
-  label()
-}
-
-void loop_label() #void :
-{}
-{
-  label()
-}
-
-void process_label() #void :
-{}
-{
-  label()
-}
-
-void architecture_simple_name() #void :
-{}
-{
-  simple_name()
-}
-
-void attribute_simple_name() #void :
-{}
-{
-  simple_name()
-  | <RANGE>
-}
-
-void component_simple_name() #void :
-{}
-{
-  simple_name()
-}
-
-void configuration_simple_name() #void :
-{}
-{
-  simple_name()
-}
-
-void element_simple_name() #void :
-{}
-{
-  simple_name()
-}
-
-void entity_simple_name() #void :
-{}
-{
-  simple_name()
-}
-
-void package_simple_name() #void :
-{}
-{
-  simple_name()
-}
-
-
-
-void architecture_name() #void :
-{}
-{
-  name()
-}
-
-void entity_name() #void :
-{}
-{
-  name()           
-}
-
-void file_name() #void :
-{}
-{
-  name()
-}
-
-void function_name() #void :
-{}
-{
-  name()
-}
-
-void configuration_name() #void :
-{}
-{
-  name()
-}
-
-void component_name() #void :
-{}
-{
-  name()
-}
-
-void generic_name() #void :
-{}
-{
-  name()
-}
-
-void group_template_name() #void :
-{}
-{
-  name()
-}
-
-void parameter_name() #void :
-{}
-{
-  name()
-}
-
-void physical_type_simple_name() #void :
-{}
-{
-  simple_name() 
-}
-
-void port_name() #void :
-{}
-{
-  name()
-}
-
-void procedure_name() #void :
-{}
-{
-  name()
-}
-
-void range_attribute_name() #void :
-{}
-{
-  name()
-}
-
-void signal_name() #void:
-{}
-{
-  name()
-}
-
-//
-// Name, der einen Typen bezeichnet...
-//
-void type_name() #void:
-{}
-{
-  name()
-}
-
-
-// 1076.1 extension:
-void record_nature_simple_name() #void :
-{}
-{
-  simple_name()
-}
-
-void record_type_simple_name() #void :
-{}
-{
-  simple_name()
-}
-
-void resolution_function_name() #void :
-{}
-{
-  name()
-}
-
-void subtype_name() #void :
-{}
-{
-  name()
-}
-
-void unit_name() #void :
-{}
-{
-  name()
-}
-
-void variable_name() #void :
-{}
-{
-  name()
-}
-
-void architecture_identifier() #void :
-{}
-{
-  identifier()
-}
-
-void static_expression() #void :
-{}
-{
-  expression()
-}
-
-
-void boolean_expression() #void :
-{}
-{
-  expression()
-}
-
-void file_open_kind_expression() #void :
-{}
-{
-  expression()
-}
-
-void guard_expression() #void :
-{}
-{
-  expression()
-}
-
-void time_expression() #void :
-{}
-{
-  expression() // unit_name()
-  // unit_name can be derived by expression!!! 
-}
-
-// 1076.1 extension:
-void time_or_real_expression() #void :
-{}
-{
-  expression() // unit_name()
-  // unit_name can be derived by expression!!!
-}
-
-
-void value_expression() #void :
-{}
-{
-  expression()
-}
-
-void string_expression() #void :
-{}
-{
-  expression()
-}
-
-
-void guarded_signal_list() #void :
-{}
-{
-  signal_list()
-}
-
-void parameter_association_list() #void :
-{}
-{
-  association_list()
-}
-
-void port_association_list() #void :
-{}
-{
-  association_list()
-}
-
-void generic_association_list() #void :
-{}
-{
-  association_list()
-}
-
-void generic_interface_list() #void :
-{}
-{
-  interface_list()
-}
-
-void parameter_interface_list() #void :
-{}
-{
-  interface_list()
-}
-
-void port_interface_list() #void :
-{}
-{
-  interface_list()
-}
-
-//
-// fraglich:
-//
-void formal_port_clause() #void :
-{}
-{
-  port_clause()
-}
-
-void local_port_clause() #void :
-{}
-{
-  port_clause()
-}
-
-void formal_generic_clause() #void :
-{}
-{
-  generic_clause()
-}
-
-void local_generic_clause() #void :
-{}
-{
-  generic_clause()
-}
-
-void element_subtype_indication() #void :
-{}
-{
-  subtype_indication()
-}
-
-void discrete_subtype_indication() #void :
-{}
-{
-  subtype_indication()
-}
-
-void loop_parameter_specification() #void :
-{}
-{
-  parameter_specification()
-}
-
-void generate_parameter_specification() #void :
-{}
-{
-  parameter_specification()
-}
-
-void passive_concurrent_procedure_call_statement() #void :
-{}
-{
-  concurrent_procedure_call_statement()
-}
-
-void passive_process_statement() #void :
-{}
-{
-  process_statement()
-}
-
-
-void magnitude_simple_expression() #void :
-{}
-{ 
-  simple_expression() 
-}
-
-void phase_simple_expression() #void :
-{}
-{
-  simple_expression()
-}
-
-
-void nature_name() #void :
-{}
-{
-  name() 
-}
-
-void subnature_name() #void :
-{}
-{
-  name()
-}
-
-/**
- * 1076.1 extension:
- */
-void terminal_name() #void :
-{}
-{
-  name()
-}
-
-
-/**
- * 1076.1 extension:
- */
-void quantity_name() #void :
-{}
-{
-  name()
-}
-
-/**
- * 1076.1 extension:
- */
-void plus_terminal_name() #void :
-{}
-{
-  name()
-}
-
-/**
- * 1076.1 extension:
- */
-void minus_terminal_name() #void :
-{}
-{
-  name()
-}
-
-
-/**
- * still missing:
- */
-void shared_variable_declaration() :
-{}
-{
-  [ <SHARED> ] <VARIABLE> identifier_list() ":"
-  subtype_indication() [ ":=" expression() ] ";"
-}
-
-
-
-
-/**
- *
- * for error recovery:
- *
- */
-JAVACODE void error_skipto(int kind, String message) 
-{
-  errs.Error(message,null);
-  Token t;
-  do 
-  {
-    t = getNextToken();
-  } while ((t.kind != kind) && t.next != null);
-}
-
-
+
+/**
+ *
+ * VHDL-93, VHDL-AMS grammar for JavaCC 
+ * (c) 1997 Christoph Grimm
+ * 
+ * EMail: grimm@ti.informatik.uni-frankfurt.de
+ * Address:
+ * Christoph Grimm
+ * J. W. Goethe-University Frankfurt
+ * Robert-Mayer-Strasse 11-15
+ * 60054 Frankfurt
+ * Germany
+ *
+ *
+ * By using this file, I agree with the following:
+ * -----------------------------------------------
+ *
+ * 1. This grammar is free for evaluation purposes.
+ *
+ * 2. You may use and modify it, but when distributing is, you must also
+ *    include the original files and copyright notes from me.
+ *
+ * 3. For commercial use of derived works contact me.
+ *   
+ * 4. The grammar is NOT optimized for speed. The aim is to keep the grammar 
+ *    similar to the original productions in the LRM.
+ *
+ * 5. Don't complain about errors - report them, maybe with fixes to me.
+ *
+ */
+
+
+options
+{
+  // DEBUG_PARSER = true;
+  // CHOICE_AMBIGUITY_CHECK=3;
+  IGNORE_CASE=false;
+  NODE_SCOPE_HOOK=true;
+  MULTI=true;
+}
+
+ 
+
+
+/**
+ * The parser is instanciated in the file vhdl.java
+ */
+PARSER_BEGIN(VhdlParserCore)
+
+package com.elphel.vdt.veditor.parser.vhdl;
+
+@SuppressWarnings("all")
+
+public class VhdlParserCore
+{
+  /**
+   * Called, whenever a new node in jjtree is generated.
+   * - store first token of the production.
+   * - check, if production is supported in subsets that are to be
+   *   checked.
+   */
+   void jjtreeOpenNodeScope(Node n)
+  {
+    
+    ((SimpleNode) n).setFirstToken(getToken(1));
+    ((SimpleNode) n).setParser(this);
+  }
+
+  /**
+   * Called, whenever a node in jjtree is closed.
+   */
+   void jjtreeCloseNodeScope(Node n)
+  {
+    ((SimpleNode) n).setLastToken(getToken(0)); 
+  }
+  
+  public ErrorHandler getErrorHandler(){
+  	return errs;
+  }
+    
+  public SymbolTable getSymbolTable(){
+  	return m_SymbolTable;
+  }
+  
+  public void setSymbolTable(SymbolTable symbolTable){
+    m_SymbolTable=symbolTable;
+  }
+  
+  ErrorHandler errs = new ErrorHandler(this);
+  SymbolTable m_SymbolTable=null;
+}
+
+PARSER_END(VhdlParserCore)
+
+
+SKIP :
+{
+    " "
+  | "\n"
+  | "\r"
+  | "\t"
+  | "\f"
+}
+
+
+SPECIAL_TOKEN :
+{
+  <COMMENT: "--" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
+}
+
+
+/** 
+ * Section 13: Lexical elements
+ * with extensions from IEEE 1076.1
+ */
+TOKEN [IGNORE_CASE] :
+{
+    <ABS:          "abs">
+  | <ACCESS:       "access">
+  | <ACROSS:       "across">
+  | <AFTER:        "after">
+  | <ALIAS:        "alias">
+  | <ALL:          "all">
+  | <AND:          "and">
+  | <ARCHITECTURE: "architecture">
+  | <ARRAY:        "array">
+  | <ASSERT:       "assert">
+  | <ATTRIBUTE:    "attribute">
+  | <BEGIN:        "begin">
+  | <BLOCK:        "block">
+  | <BODY:         "body">
+  | <BREAK:        "break">
+  | <BUFFER:       "buffer">
+  | <BUS:          "bus">
+  | <CASE:         "case">
+  | <COMPONENT:    "component">
+  | <CONFIGURATION: "configuration">
+  | <CONSTANT:      "constant">
+  | <DISCONNECT:    "disconnect">
+  | <DOWNTO:        "downto">
+  | <ELSE:          "else">
+  | <ELSIF:         "elsif">
+  | <END:           "end">
+  | <ENTITY:        "entity">
+  | <EXIT:          "exit">
+  | <FILE:          "file">
+  | <FOR:           "for">
+  | <FUNCTION:      "function">
+  | <GENERATE:      "generate">
+  | <GENERIC:       "generic">
+  | <GROUP:         "group">
+  | <GUARDED:       "guarded">
+  | <IF:            "if">
+  | <IMPURE:        "impure">
+  | <IN:            "in">
+  | <INERTIAL:      "inertial">
+  | <INOUT:         "inout">
+  | <IS:            "is">
+  | <LABEL:         "label">
+  | <LIBRARY:       "library">
+  | <LINKAGE:       "linkage">
+  | <LITERAL:       "literal">
+  | <LOOP:          "loop">
+  | <MAP:           "map">
+  | <MOD:           "mod">
+  | <NAND:          "nand">
+  | <NATURE:        "nature">
+  | <NEW:           "new">
+  | <NEXT:          "next">
+  | <NOISE:         "noise">
+  | <NOR:           "nor">
+  | <NOT:           "not">
+  | <NULL:          "null">
+  | <OF:            "of">
+  | <ON:            "on">
+  | <OPEN:          "open">
+  | <OR:            "or">
+  | <OTHERS:        "others">
+  | <OUT:           "out">
+  | <PACKAGE:       "package">
+  | <PORT:          "port">
+  | <POSTPONED:     "postponed">
+  | <PROCEDURAL:    "procedural">
+  | <PROCEDURE:     "procedure">
+  | <PROCESS:       "process">
+  | <PROTECTED:     "protected">
+  | <PURE:          "pure">
+  | <QUANTITY:      "quantity">
+  | <RANGE:         "range">
+  | <RECORD:        "record">
+  | <REGISTER:      "register">
+  | <REJECT:        "reject">
+  | <REM:           "rem">
+  | <REPORT:        "report">
+  | <RETURN:        "return">
+  | <ROL:           "rol">
+  | <ROR:           "ror">
+  | <SELECT:        "select">
+  | <SEVERITY:      "severity">
+  | <SIGNAL:        "signal">
+  | <SHARED:        "shared">
+  | <SLA:           "sla">
+  | <SLL:           "sll">
+  | <SPECTRUM:      "spectrum">
+  | <SRA:           "sra">
+  | <SRL:           "srl">
+  | <SUBNATURE:     "subnature">
+  | <SUBTYPE:       "subtype">
+  | <TERMINAL:      "terminal">
+  | <THEN:          "then">
+  | <THROUGH:       "through">
+  | <TO:            "to">
+  | <TOLERANCE:     "tolerance">
+  | <TRANSPORT:     "transport">
+  | <TYPE:          "type">
+  | <UNAFFECTED:    "unaffected">
+  | <UNITS:         "units">
+  | <UNTIL:         "until">
+  | <USE:           "use">
+  | <VARIABLE:      "variable">
+  | <WAIT:          "wait">
+  | <WHEN:          "when">
+  | <WHILE:         "while">
+  | <WITH:          "with">
+  | <XNOR:          "xnor">
+  | <XOR:           "xor">
+}
+
+
+
+TOKEN :
+{
+    <#upper_case_letter:               ["A"-"Z"]>
+  | <#lower_case_letter:               ["a"-"z"]>
+  | <#digit:                           ["0"-"9"]>
+  | <#extended_digit:                  ["0"-"9","A"-"F","a"-"f"]>
+  | <#special_character:               ["#","&","'","(",")","*","+",",","-",
+                                        ".","/",":",";","<","=",">","[","]",
+                                        "_","|"]>
+  | <#other_special_character:         ["!","$","%","@","?","^","`","{","}","~",
+                                        "\\"]>
+  | <#format_effector:                 ["\n","\t"]>
+  | <#base_specifier:                  ["B","O","X","b","o","x"]>
+  | <#underline:                       "_">
+  | <#letter:                          ["a"-"z","A"-"Z"]>
+  | <#letter_or_digit:                 ["a"-"z","A"-"Z","0"-"9"]>
+  | <#integer: <digit> (("_")? <digit>)*>
+  | <#base: <integer>>
+  | <#based_integer: (("_")? <extended_digit>)*>
+  | <based_literal: <base> "#" <based_integer> ("." <based_integer>)? "#" (<exponent>)?>
+  | <#basic_character: (<basic_graphic_character>|<format_effector>)>
+  | <#basic_graphic_character: (["A"-"Z"]|<digit>|<special_character>|" ")>
+  | <basic_identifier: <letter> ( ("_")? <letter_or_digit> )*>
+  | <bit_string_literal: <base_specifier> "\"" <bit_value> "\"">
+  | <#bit_value: <extended_digit> ( ("_")? <extended_digit>)*>
+  | <character_literal:  "'" (<graphic_character>|"\"") "'">
+  | <decimal_literal: <integer> ( "." <integer>)? ( <exponent> )?>
+  | <#exponent: ("E" ("+")? <integer>) | ("E" "-" <integer>)>
+  | <extended_identifier: "\\" <graphic_character> ( <graphic_character> )* "\\">
+  | <#graphic_character: (<basic_graphic_character>
+                          | <lower_case_letter>
+                          | <other_special_character>)>
+  | <string_literal: "\"" (<graphic_character>|"\"\"")* "\"">
+
+  | <EXP: "**">
+  | <MUL: "*">
+  | <DIV: "/">
+  | <ADD: "+">
+  | <SUB: "-">
+  | <CONCAT: "&">
+  | <EQ:  "=">
+  | <NEQ: "/=">
+  | <GE:  ">=">
+  | <LE:  "<=">
+  | <GT:  ">">
+  | <LO:  "<">
+  | <SEMICOLON: ";">
+  | <COLON: ":">
+  | <ASSIGN: ":=">
+  | <RARROW: "=>">
+}
+
+
+
+
+void abstract_literal() #void :
+{}
+{
+    <decimal_literal>
+  | <based_literal>
+}
+
+
+
+void access_type_definition() #void :
+{}
+{
+  <ACCESS> subtype_indication()
+}
+
+
+
+void actual_designator() #void :
+{}
+{
+    LOOKAHEAD(expression()) 
+    expression()
+  | LOOKAHEAD(signal_name())
+    signal_name()
+  | LOOKAHEAD(variable_name())
+    variable_name()
+  | LOOKAHEAD(file_name())
+    file_name()
+  | <OPEN>
+
+  // 1076.1 extensions:
+  | LOOKAHEAD(terminal_name())
+    terminal_name()
+  | quantity_name()
+}
+
+
+
+void actual_parameter_part() #void :
+{}
+{
+  parameter_association_list()
+}
+
+
+void actual_part() :
+{}
+{
+    LOOKAHEAD( function_name() "(" actual_designator() ")")
+    function_name() "(" actual_designator() ")"
+  | LOOKAHEAD( type_mark() "(" actual_designator() ")")
+    type_mark() "(" actual_designator() ")"
+  | actual_designator()
+}
+
+
+int adding_operator() #void :
+{}
+{
+    <ADD>               { return ADD; }
+  | <SUB>               { return SUB; }
+  | <CONCAT>            { return CONCAT; }
+}
+
+
+void aggregate() :
+{}
+{
+  "(" element_association()  ("," element_association())*  ")"
+}    
+
+void alias_declaration() :
+{}
+{
+  <ALIAS> alias_designator()
+   [ ":" subtype_indication() ] <IS> name() signature() ";"
+}
+
+
+void alias_designator() :
+{}
+{
+    identifier()
+  | <character_literal>
+  | operator_symbol()
+}
+
+void allocator() :
+{}
+{
+  <NEW>
+  (
+      LOOKAHEAD( type_mark() "'")
+      qualified_expression()
+    | subtype_indication()
+  )
+}
+
+
+
+void architecture_body() :
+{}
+{
+  <ARCHITECTURE> identifier() <OF> entity_name() <IS> { jjtThis.newBlock(); }
+    architecture_declarative_part()
+  <BEGIN>
+    architecture_statement_part()
+  <END> [ <ARCHITECTURE> ] [ architecture_simple_name() ] ";"
+
+  {
+    jjtThis.endBlock();
+    jjtThis.Check();
+  }
+}
+
+
+
+void architecture_declarative_part() :
+{}
+{
+  ( block_declarative_item() )*
+}
+
+void architecture_statement_part() :
+{}
+{
+  ( architecture_statement() )*
+}
+
+/**
+ *  This rule also contains the concurrent statements.
+ */
+void architecture_statement() #void :
+{}
+{
+  // 
+  // lookahead would really be annoying here. Therefore I have
+  // moved the concurrent statement into this rule.
+  // concurrent_statements:
+  //
+
+  try {
+
+    LOOKAHEAD([block_label() ":"] <BLOCK>)
+    block_statement()
+  | LOOKAHEAD([process_label() ":"] [<POSTPONED>] <PROCESS>)
+    process_statement()
+  | LOOKAHEAD([label() ":"] [<POSTPONED>] procedure_call() ";")
+    concurrent_procedure_call_statement()
+  | LOOKAHEAD([label() ":"] [<POSTPONED>] <ASSERT>)
+    concurrent_assertion_statement()
+  | LOOKAHEAD([label() ":"] [<POSTPONED>] conditional_signal_assignment()|
+              [label() ":"] [<POSTPONED>] selected_signal_assignment())
+    concurrent_signal_assignment_statement()
+  | LOOKAHEAD(instantiation_label() ":" instantiated_unit() )
+    component_instantiation_statement()
+  | LOOKAHEAD(generate_statement())
+    generate_statement()
+
+  /** 1076.1 extensions: */
+  | LOOKAHEAD(concurrent_break_statement())
+    concurrent_break_statement()
+  | simultaneous_statement()
+
+  }
+
+  /** Error handling: Skip until next semicolon */
+  catch(ParseException e)
+  {
+    error_skipto(SEMICOLON, "syntax error in statement");
+  }
+}
+
+
+/**
+ * 1076.1 extension:
+ */
+void array_nature_definition() #void  :
+{}
+{
+    LOOKAHEAD(<ARRAY> "(" index_subtype_definition() )
+    unconstrained_nature_definition()
+  | constrained_nature_definition()
+}
+
+/**
+  * 1076.1 extension:
+  */
+void unconstrained_nature_definition() :
+{}
+{
+  <ARRAY> "(" index_subtype_definition() ("," index_subtype_definition())* ")" 
+  <OF> subnature_indication()
+}
+
+/**
+  * 1076.1 extension:
+  */
+void constrained_nature_definition() :
+{}
+{
+  <ARRAY> index_constraint() <OF> subnature_indication()
+}
+
+
+void array_type_definition() #void:
+{}
+{
+    LOOKAHEAD(unconstrained_array_definition())
+    unconstrained_array_definition()
+  | constrained_array_definition()
+}
+
+void assertion() :
+{}
+{
+  <ASSERT> condition()
+  [ <REPORT> expression() ]
+  [ <SEVERITY> expression() ]
+}
+
+
+void assertion_statement() :
+{}
+{
+  [ label() ":" ] assertion() ";"
+}
+
+
+
+void association_element() :
+{}
+{
+  [ LOOKAHEAD( formal_part() "=>" ) formal_part() "=>" ]
+  actual_part()
+}
+
+void association_list() :
+{}
+{
+  association_element() ( "," association_element() )*
+}
+
+
+void attribute_declaration() :
+{}
+{
+  <ATTRIBUTE> identifier() ":" type_mark() ";"
+}
+
+
+void attribute_designator() #void :
+{}
+{
+  attribute_simple_name()
+}
+
+
+void attribute_name() :
+{}
+{
+  prefix() signature() "'" attribute_designator() [ "(" expression() ("," expression())* ")" ]
+}
+
+
+void attribute_specification() :
+{}
+{
+  <ATTRIBUTE> attribute_designator() <OF>
+  entity_specification() <IS> expression() ";"
+}
+
+void base_unit_declaration() #void :
+{}
+{
+  identifier() ";"
+}
+
+
+
+void binding_indication() :
+{}
+{
+  [ <USE> entity_aspect() ]
+  [ generic_map_aspect() ]
+  [ port_map_aspect() ]
+}
+
+void block_configuration() :
+{}
+{
+  <FOR> block_specification()
+                ( use_clause() )*
+                ( configuration_item() )*
+  <END> <FOR> ";"
+}
+
+void block_declarative_item() #void :
+{}
+{
+  try {
+
+    LOOKAHEAD(subprogram_declaration())
+    subprogram_declaration()
+  | subprogram_body()
+  | type_declaration()
+  | subtype_declaration()
+  | constant_declaration()
+  | signal_declaration()
+  | shared_variable_declaration()
+  | file_declaration()
+  | alias_declaration()
+  | component_declaration()
+  | LOOKAHEAD(attribute_declaration())
+    attribute_declaration()
+  | attribute_specification()
+  | configuration_specification()
+  | disconnection_specification()
+  | use_clause()
+  | LOOKAHEAD(<GROUP> identifier() <IS>)
+    group_template_declaration()
+  | group_declaration()
+
+  /** 1076.1 - Extensions: */
+  | nature_declaration()
+  | subnature_declaration()
+  | quantity_declaration()
+  | terminal_declaration()
+
+  }
+
+  // Error handling: skip until next semicolon
+  catch (ParseException e)
+  {
+    error_skipto(SEMICOLON, "syntax error in declarative item");
+  }
+}
+
+
+void block_declarative_part() :
+{}
+{
+  ( block_declarative_item() )*
+}
+
+void block_header() :
+{}
+{
+  [ generic_clause()  [ generic_map_aspect() ";" ] ]
+  [ port_clause()     [ port_map_aspect() ";"    ] ]
+}
+
+void block_specification() :
+{}
+{
+    LOOKAHEAD(architecture_name())
+    architecture_name()
+  | LOOKAHEAD(block_statement_label())
+    block_statement_label()
+  | LOOKAHEAD(generate_statement_label())
+    generate_statement_label() [ "(" index_specification() ")" ]
+}
+
+
+void block_statement() :
+{}
+{
+  block_label() ":"
+                <BLOCK> [ "(" guard_expression() ")" ] [ <IS> ]
+                        block_header()
+                        block_declarative_part()
+                <BEGIN>
+                        block_statement_part()
+                <END> <BLOCK> [ block_label() ] ";"
+}
+
+
+void block_statement_part() :
+{}
+{
+  (architecture_statement() )*
+}
+
+/**
+ * Section 8.14: Break statement
+ * 1076.1 extension:
+ */
+void break_statement() :
+{}
+{
+  [label()  ":"] <BREAK> [break_list()] [<WHEN> condition() ] ";"
+}
+
+/**
+ * 1076.1 extension:
+ */
+void break_list() :
+{}
+{
+  break_element() ("," break_element() )*
+}
+
+/**
+ * 1076.1 extension:
+ */
+void break_element() :
+{}
+{
+  [selector_clause() ] quantity_name() "=>" expression()
+}
+
+/**
+ * 1076.1 extension:
+ */
+void selector_clause() #void :
+{}
+{
+  <FOR> quantity_name() <USE>
+}
+
+void case_statement() :
+{}
+{
+  [ case_label() ":" ]
+                <CASE> expression() <IS>
+                        case_statement_alternative()
+                        ( case_statement_alternative() )*
+                <END> <CASE> [ case_label() ] ";"
+}
+
+
+void case_statement_alternative() :
+{}
+{
+  <WHEN> choices() "=>"
+                sequence_of_statements()
+}
+
+
+void choice() :
+{}
+{
+  /** Dirty Solution */
+    LOOKAHEAD( discrete_range()  ("=>" | "|" | ";" | ",") )
+    discrete_range()
+  | LOOKAHEAD( simple_expression()  ("=>" | "|" | ";" | ",") )
+    simple_expression()
+  | element_simple_name()
+  | <OTHERS>
+}
+
+
+void choices() :
+{}
+{
+  choice() ( "|" choice() )*
+}
+
+
+void component_configuration() :
+{}
+{
+  <FOR> component_specification()
+                [ binding_indication() ";" ]
+                [ block_configuration() ]
+  <END> <FOR> ";"
+}
+
+void component_declaration() :
+{}
+{
+  <COMPONENT> identifier() [ <IS> ]
+      [ local_generic_clause() ]
+      [ local_port_clause() ]
+  <END> <COMPONENT> [ component_simple_name() ] ";"
+}
+
+void component_instantiation_statement() :
+{}
+{
+  instantiation_label() ":"
+         instantiated_unit()
+         [ generic_map_aspect() ]
+         [ port_map_aspect() ] ";"
+}
+
+
+// 1076.1 - extension:
+void composite_nature_definition() #void :
+{}
+{
+    array_nature_definition()
+  | record_nature_definition()
+}
+
+void component_specification() :
+{}
+{
+  instantiation_list() ":" component_name()
+}
+
+
+void composite_type_definition() :
+{}
+{
+    array_type_definition()
+  | record_type_definition()
+}
+
+
+void concurrent_assertion_statement() :
+{}
+{
+  [ label() ":" ] [ <POSTPONED> ] assertion() ";"
+}
+
+
+void concurrent_procedure_call_statement() :
+{}
+{
+  [ LOOKAHEAD( label() ":") label() ":" ]
+  [ <POSTPONED> ] procedure_call() ";"
+}
+
+void concurrent_signal_assignment_statement() :
+{}
+{
+    [ LOOKAHEAD( label() ":") label() ":" ]
+    [ <POSTPONED> ]
+    ( LOOKAHEAD(  target() "<=" options_() conditional_waveforms() ";") 
+        conditional_signal_assignment() 
+      | selected_signal_assignment() )
+}
+
+
+void condition() #void :
+{}
+{
+  boolean_expression()
+}
+
+
+void condition_clause() #void :
+{}
+{
+  <UNTIL> condition()
+}
+
+
+void conditional_signal_assignment() :
+{}
+{
+  target() "<=" options_() conditional_waveforms() ";"
+}
+
+
+void conditional_waveforms() :
+{}
+{
+  //( waveform() <WHEN> condition() <ELSE> )*
+  //waveform() [ <WHEN> condition() ]
+  waveform()
+    ( LOOKAHEAD( <WHEN> condition() <ELSE>)
+        <WHEN> condition() <ELSE> waveform() )*
+    [ <WHEN> condition() ]
+}
+
+
+void configuration_declaration() :
+{}
+{
+  <CONFIGURATION> identifier() <OF> entity_name() <IS>
+    configuration_declarative_part()
+    block_configuration()
+  <END> [ <CONFIGURATION> ] [ configuration_simple_name() ] ";"
+}
+
+
+void configuration_declarative_item() #void :
+{}
+{
+  try {
+    use_clause()
+  | attribute_specification()
+  | group_declaration()
+  }
+
+  catch(ParseException e)
+  {
+    error_skipto(SEMICOLON, "syntax error in declarative item");
+  }
+}
+
+
+void configuration_declarative_part() :
+{}
+{
+  ( configuration_declarative_item() )*
+}
+
+
+
+void configuration_item() #void :
+{}
+{
+    LOOKAHEAD(block_configuration())
+    block_configuration()
+  | component_configuration()
+}
+
+void configuration_specification() :
+{}
+{
+  <FOR> component_specification() binding_indication() ";"
+}
+
+void constant_declaration() :
+{}
+{
+  <CONSTANT> identifier_list() ":" subtype_indication()
+    [ ":=" expression() ] ";"
+}
+
+
+
+void constrained_array_definition() :
+{}
+{
+  <ARRAY> index_constraint() <OF> element_subtype_indication()
+}
+
+
+void constraint() #void :
+{}
+{
+    range_constraint()
+  | index_constraint()
+}
+
+void context_clause() :
+{}
+{
+  ( context_item() )*
+}
+
+void context_item() #void :
+{}
+{
+    library_clause()
+  | use_clause()
+}
+
+
+/** 
+ * Section 4:
+ * Declarations
+ */
+
+
+/**
+ * 1076.1 extension:
+ */
+void terminal_declaration() :
+{}
+{
+  <TERMINAL> identifier_list() ":" subnature_indication() ";"
+}
+
+void terminal_aspect() :
+{}
+{
+  plus_terminal_name() [ <TO> minus_terminal_name() ]
+}
+
+
+void delay_mechanism() :
+{}
+{
+    <TRANSPORT>
+  | [ <REJECT> time_expression() ] <INERTIAL>
+}
+
+ASTdesign_file design_file() :
+{}
+{
+  ( design_unit() )*
+  { return jjtThis; }
+}
+
+
+void design_unit() :
+{}
+{
+  context_clause() library_unit()
+}
+
+void designator() #void :
+{}
+{
+    identifier()
+  | operator_symbol()
+}
+
+void direction() :
+{}
+{
+  <TO> | <DOWNTO>
+}
+
+
+void disconnection_specification() :
+{}
+{
+  <DISCONNECT> guarded_signal_specification() <AFTER>
+    time_expression() ";"
+}
+
+void discrete_range() #void  :
+{}
+{
+    LOOKAHEAD(simple_expression() direction() )
+    range()
+  | LOOKAHEAD( discrete_subtype_indication() )
+    discrete_subtype_indication()
+  | range() 
+}
+
+
+void element_association() #void :
+{}
+{
+  [ LOOKAHEAD(choices() "=>") choices() "=>" ]
+  expression()
+}
+
+
+void element_declaration() :
+{}
+{
+  identifier_list() ":" element_subtype_definition() ";"
+}
+
+
+void element_subtype_definition() #void :
+{}
+{
+  subtype_indication()
+}
+
+
+void entity_aspect() :
+{}
+{
+    <ENTITY> entity_name()
+    [ LOOKAHEAD("(" architecture_identifier() ")")
+    "(" architecture_identifier() ")" ]
+  | <CONFIGURATION> configuration_name()
+  | <OPEN>
+}
+
+/**
+ * Section 5: Specifications
+ */
+int entity_class() #void :
+{}
+{
+    <ENTITY>                    { return ENTITY; }
+  | <ARCHITECTURE>              { return ARCHITECTURE; }
+  | <CONFIGURATION>             { return CONFIGURATION; }
+  | <PROCEDURE>                 { return PROCEDURE; }
+  | <FUNCTION>                  { return FUNCTION; }
+  | <PACKAGE>                   { return PACKAGE; }
+  | <TYPE>                      { return TYPE; }
+  | <SUBTYPE>                   { return SUBTYPE; }
+  | <CONSTANT>                  { return CONSTANT; }
+  | <SIGNAL>                    { return SIGNAL; }
+  | <VARIABLE>                  { return VARIABLE; }
+  | <COMPONENT>                 { return COMPONENT; }
+  | <LABEL>                     { return LABEL; }
+  | <LITERAL>                   { return LITERAL; }
+  | <UNITS>                     { return UNITS; }
+  | <GROUP>                     { return GROUP; }
+  | <FILE>                      { return FILE; }
+
+  /** 1076.1 extensions: */
+  | <SUBNATURE>                 { return SUBNATURE; }
+  | <NATURE>                    { return NATURE; }
+  | <TERMINAL>                  { return TERMINAL; }
+}
+
+
+void entity_class_entry()  :
+{}
+{
+  entity_class() [ "<>" ]
+}
+
+
+void entity_class_entry_list() :
+{}
+{
+  entity_class_entry() ( "," entity_class_entry() )*
+}
+
+
+void entity_declaration() :
+{}
+{
+  <ENTITY> identifier() <IS>                       { jjtThis.newBlock(); }
+          entity_header()
+          entity_declarative_part()
+  [ <BEGIN>
+    entity_statement_part() ]
+  <END> [ <ENTITY> ] [ entity_simple_name() ] ";"
+
+  {
+    jjtThis.Check();
+    jjtThis.endBlock();
+  }
+}
+
+
+void entity_declarative_item() #void :
+{}
+{
+  try {
+    LOOKAHEAD(subprogram_declaration())
+    subprogram_declaration()
+  | subprogram_body()
+  | type_declaration()
+  | subtype_declaration()
+  | constant_declaration()
+  | signal_declaration()
+  | shared_variable_declaration()
+  | file_declaration()
+  | alias_declaration()
+  | LOOKAHEAD(attribute_declaration())
+    attribute_declaration()
+  | attribute_specification()
+  | disconnection_specification()
+  | use_clause()
+  | LOOKAHEAD(<GROUP> identifier() <IS>)
+    group_template_declaration()
+  | group_declaration()
+
+  // 1076.1 - Extensions:
+  | nature_declaration()
+  | subnature_declaration()
+  | terminal_declaration()
+  }
+  catch( ParseException e )
+  {
+    error_skipto(SEMICOLON, "syntax error in declarative item");
+  }
+}
+
+/**
+ * 4.8: Nature Declaration
+ * 1076.1 extension
+ */
+void nature_declaration() :
+{}
+{
+  <NATURE> identifier() <IS> nature_definition() ";"
+}
+
+/**
+ * 1076.1 extension
+ */
+void nature_definition() #void :
+{}
+{
+    scalar_nature_definition()
+  | composite_nature_definition()
+}
+
+void subnature_declaration() :
+{}
+{
+  <SUBNATURE> identifier() <IS> subnature_indication() ";"
+}
+
+
+void subnature_indication() :
+{}
+{
+  nature_mark() [index_constraint() ] 
+  [ <TOLERANCE> string_expression() <ACROSS> string_expression() <THROUGH>]
+}
+
+void nature_mark() #void :
+{}
+{
+    LOOKAHEAD(nature_name())
+    nature_name() 
+  | LOOKAHEAD(subnature_name())
+    subnature_name()
+}
+
+void entity_declarative_part() :
+{}
+{
+  ( entity_declarative_item() )*
+}
+
+void entity_designator() :
+{}
+{
+  entity_tag() signature()
+}
+
+
+
+void entity_header() :
+{}
+{
+  [ formal_generic_clause() ]
+  [ formal_port_clause() ]
+}
+
+
+void entity_name_list() :
+{}
+{
+  entity_designator() ( "," entity_designator() )*
+  | <OTHERS>
+  | <ALL>
+}
+
+
+void entity_specification() :
+{}
+{
+        entity_name_list() ":" entity_class()
+}
+
+
+void entity_statement() #void :
+{}
+{   LOOKAHEAD( concurrent_assertion_statement() )
+    concurrent_assertion_statement()
+  | LOOKAHEAD([process_label() ":"] [<POSTPONED>] <PROCESS>)
+    passive_process_statement()
+  | passive_concurrent_procedure_call_statement()
+}
+
+
+void entity_statement_part() :
+{}
+{
+  ( entity_statement() )*
+}
+
+void entity_tag() :
+{}
+{
+    simple_name()
+  | <character_literal>
+  | operator_symbol()
+}
+
+
+void enumeration_literal() :
+{}
+{
+  <character_literal>
+  | identifier()
+}
+
+
+
+void enumeration_type_definition() :
+{}
+{
+  "(" enumeration_literal() ( "," enumeration_literal())* ")"
+}
+
+
+void exit_statement() :
+{}
+{
+  [ label() ":" ] <EXIT> [ loop_label() ]
+    [ <WHEN> condition() ] ";"
+}
+
+void expression() #void :
+{ int op; }
+{
+/**  relation() (
+ *   ( <AND> relation() )* |
+ *    ( <OR> relation() )*  |
+ *    ( <XOR> relation() )* |
+ *    [ <NAND> relation() ] |
+ *    [ <NOR> relation() ]  |
+ *    ( <XNOR> relation() )*
+ *  )
+ */
+  relation() 
+  ( LOOKAHEAD(1) op=logical_operator() relation()
+  #relation(2) )*
+
+}
+
+
+void factor() #void :
+{}
+{
+    <ABS> primary()
+  | <NOT> primary()
+  | primary() [ LOOKAHEAD("**" primary() ) <EXP> primary() #factor(2) ]
+}
+
+
+void file_declaration() :
+{}
+{
+  <FILE> identifier_list() ":" subtype_indication()
+     [ file_open_information() ] ";"
+}
+
+
+void file_logical_name() #void :
+{}
+{
+  string_expression()
+}
+
+
+void file_open_information() :
+{}
+{
+  <OPEN> file_open_kind_expression() <IS> file_logical_name()
+  | <IS> [ <IN> | <OUT> ] file_logical_name()
+}
+
+void file_type_definition() #void :
+{}
+{
+  <FILE> <OF> type_mark()
+}
+
+void floating_type_definition() #void :
+{}
+{
+  range_constraint()
+}
+
+
+void formal_designator() #void :
+{}
+{
+    LOOKAHEAD( generic_name() )
+    generic_name()
+  | LOOKAHEAD( port_name() )
+    port_name()
+  | parameter_name()
+}
+
+void formal_parameter_list() :
+{}
+{
+  parameter_interface_list()
+}
+
+
+void formal_part() #void :
+{}
+{
+    LOOKAHEAD( function_name() "(" formal_designator() ")")
+    function_name() "(" formal_designator() ")"
+  | LOOKAHEAD( type_mark() "(" formal_designator() ")")
+    type_mark() "(" formal_designator() ")"
+  | formal_designator()
+}
+
+void full_type_declaration() :
+{}
+{
+  <TYPE> identifier() <IS> type_definition() ";"
+}
+
+
+void function_call() :
+{}
+{
+  function_name()
+  [ LOOKAHEAD( "(" actual_parameter_part() ")" ) "(" actual_parameter_part() ")" ]
+}
+
+
+/**
+ * Section 9.7
+ */
+void generate_statement() :
+{}
+{
+  generate_label() ":"
+  generation_scheme() <GENERATE>
+    [ LOOKAHEAD(2) ( block_declarative_item() )* <BEGIN> ]
+    ( architecture_statement() )*
+  <END> <GENERATE> [ generate_label() ] ";"
+}
+
+/** 1076.1 extension: */
+void concurrent_break_statement() :
+{}
+{
+  [label() ":"] <BREAK> [break_list()] [sensitivity_clause() ] [ <WHEN> condition()] ";"
+}
+
+
+void generation_scheme() :
+{}
+{
+    <FOR> generate_parameter_specification()
+  | <IF> condition()
+}
+
+
+void generic_clause() :
+{}
+{
+  <GENERIC> "(" generic_list() ")" ";"
+}
+
+
+void generic_list() #void :
+{}
+{
+  generic_interface_list()
+}
+
+
+void generic_map_aspect() #void :
+{}
+{
+  <GENERIC> <MAP> "(" generic_association_list() ")"
+}
+
+
+void group_constituent() :
+{}
+{
+    name()
+  | <character_literal>
+}
+
+
+void group_constituent_list() :
+{}
+{
+  group_constituent() ( "," group_constituent() )*
+}
+
+
+void group_template_declaration() :
+{}
+{
+  <GROUP> identifier() <IS> "(" entity_class_entry_list() ")" ";"
+}
+
+void group_declaration() :
+{}
+{
+  <GROUP> identifier() ":" group_template_name()
+  "(" group_constituent_list() ")" ";"
+}
+
+
+
+void guarded_signal_specification() :
+{}
+{
+  guarded_signal_list() ":" type_mark()
+}
+
+
+void identifier() :
+{ Token t; }
+{  
+     t=<basic_identifier>    { jjtThis.name = t.image; }
+  |  t=<extended_identifier> { jjtThis.name = t.image; }
+}
+
+
+void identifier_list() :
+{}
+{
+  identifier() ( "," identifier() )*
+}
+
+
+void if_statement() :
+{}
+{
+  [ if_label() ":" ]
+  <IF> condition() <THEN>
+  sequence_of_statements()
+  ( <ELSIF> condition() <THEN>
+    sequence_of_statements() )*
+  [ <ELSE>
+    sequence_of_statements() ]
+  <END> <IF> [ if_label() ] ";"
+}
+
+void incomplete_type_declaration() :
+{}
+{
+  <TYPE> identifier() ";"
+}
+
+
+void index_constraint() :
+{}
+{
+  "(" discrete_range() ( "," discrete_range() )* ")"
+}
+
+
+
+void index_specification() :
+{}
+{
+    LOOKAHEAD( discrete_range() )
+    discrete_range()
+  | static_expression()
+}
+
+
+void index_subtype_definition() :
+{}
+{
+  type_mark() <RANGE> "<>"
+}
+
+void indexed_name() :
+{}
+{
+  prefix() "(" expression() ( "," expression() )* ")"
+}
+
+void instantiated_unit() :
+{}
+{
+    [ <COMPONENT> ] component_name()
+  | <ENTITY> entity_name() [ "(" architecture_identifier() ")" ]
+  | <CONFIGURATION> configuration_name()
+}
+
+
+void instantiation_list() :
+{}
+{
+    instantiation_label() ( "," instantiation_label() )*
+  | <OTHERS>
+  | <ALL>
+}
+
+void integer_type_definition() #void :
+{}
+{
+  range_constraint()
+}
+
+
+
+void interface_constant_declaration() :
+{}
+{
+  [ <CONSTANT> ] identifier_list() ":" [ <IN> ]
+    subtype_indication() [ ":=" static_expression() ]
+}
+
+/**
+ * Section 4.3.2:
+ */
+void interface_declaration() #void :
+{}
+{
+    LOOKAHEAD(interface_constant_declaration() ) 
+    interface_constant_declaration()
+  | LOOKAHEAD(interface_signal_declaration() )
+    interface_signal_declaration()
+  | LOOKAHEAD(interface_variable_declaration() )
+    interface_variable_declaration()
+  | LOOKAHEAD(interface_file_declaration() )
+    interface_file_declaration()
+
+  /** 1076.1 extensions: */
+  | interface_terminal_declaration() 
+  | interface_quantity_declaration()
+}
+
+
+/**
+ * 1076.1 extension:
+ */
+void interface_terminal_declaration()  :
+{}
+{
+  <TERMINAL> identifier_list() ":" subnature_indication()
+}
+
+
+/**
+ * 1076.1 extension:
+ */
+void interface_quantity_declaration() :
+{}
+{
+  <QUANTITY> identifier_list() ":" 
+  [ <IN> | <OUT> ] subtype_indication() [ ":=" static_expression() ]
+}
+
+
+void interface_element() #void :
+{}
+{
+  interface_declaration()
+}
+
+
+void interface_file_declaration() :
+{}
+{
+  <FILE> identifier_list() ":" subtype_indication()
+}
+
+
+void interface_list() :
+{}
+{
+  interface_element() ( ";" interface_element() )*
+}
+
+void interface_signal_declaration() :
+{}
+{
+  [<SIGNAL>] identifier_list() ":"
+  [ mode() ] subtype_indication() [ <BUS> ] [ ":=" static_expression() ]
+}
+
+
+void interface_variable_declaration() :
+{}
+{
+  [<VARIABLE>] identifier_list() ":"
+  [ mode() ] subtype_indication() [ ":=" static_expression() ]
+}
+
+
+
+void iteration_scheme() :
+{}
+{
+    <WHILE> condition()
+  | <FOR> loop_parameter_specification()
+}
+
+
+void label() #void :
+{}
+{
+  identifier()
+}
+
+
+
+void library_clause() #void :
+{}
+{
+  <LIBRARY> logical_name_list() ";"
+}
+
+
+void library_unit() #void :
+{}
+{   LOOKAHEAD(<ENTITY> | <CONFIGURATION> | <PACKAGE> identifier() )
+    primary_unit()
+  | secondary_unit()
+}
+
+
+
+void literal() :
+{}
+{
+    LOOKAHEAD( numeric_literal() )
+    numeric_literal()
+  | enumeration_literal()
+  | <string_literal>
+  | <bit_string_literal>
+  | <NULL>
+}
+
+
+void logical_name() #void :
+{}
+{
+  identifier()
+}
+
+
+
+void logical_name_list() :
+{}
+{
+  logical_name() ( "," logical_name() )*
+}
+
+
+int logical_operator() #void :
+{}
+{
+    <AND>             { return AND; }
+  | <OR>              { return OR; }
+  | <NAND>            { return NAND; }
+  | <NOR>             { return NOR; }
+  | <XOR>             { return XOR; }
+  | <XNOR>            { return XNOR; }
+}
+
+
+void loop_statement() :
+{}
+{
+  [ loop_label() ":" ]
+  [ iteration_scheme() ] <LOOP>
+                        sequence_of_statements()
+  <END> <LOOP> [ loop_label() ] ";"
+}
+
+
+int miscellaneous_operator() #void :
+{}
+{
+    <EXP>               { return EXP; }
+  | <ABS>               { return ABS; }
+  | <NOT>               { return NOT; }
+}
+
+
+void mode() :
+{}
+{
+    <IN>
+  | <OUT>
+  | <INOUT>
+  | <BUFFER>
+  | <LINKAGE>
+}
+
+int multiplying_operator() #void :
+{}
+{
+    "*"                 { return MUL; }
+  | "/"                 { return DIV; }
+  | <MOD>               { return MOD; }
+  | <REM>               { return REM; }
+}
+
+
+void name() :
+{}
+{
+/**  simple_name()
+ * | operator_symbol()
+ *  | selected_name()
+ *  | indexed_name()
+ *  | slice_name()
+ *  | attribute_name()
+ *
+ * Kann ohne Linksrekursion wie folgt geschrieben werden:
+ */
+  ( simple_name() | operator_symbol() )
+  [ LOOKAHEAD(name_extension()) name_extension()   ]
+}
+
+void name_extension() #void :
+{}
+{
+  (
+        LOOKAHEAD( signature() "'"  )
+        signature() "'" attribute_designator()
+        [ LOOKAHEAD( "(" expression() ")") "(" expression() ")"]
+      | "." suffix()
+      | LOOKAHEAD( "(" discrete_range() ")" ) 
+        "(" discrete_range() ")"  
+      | LOOKAHEAD( "(" expression() ("," expression() )* ")" )
+        "(" expression() ("," expression() )* ")"
+      /**
+       * The following production is already in sign. "'" ... ,
+       * since signature can be empty!
+       * | "'" attribute_designator() [ "(" expression() ")"]
+       */
+  )
+  [  LOOKAHEAD(name_extension() ) name_extension() ]
+}
+
+/**
+ * 1076.1 extension:
+ */
+void nature_element_declaration() :
+{}
+{
+  identifier_list() ":" element_subnature_definition()
+}
+
+/**
+ * 1076.1 extension:
+ */
+void element_subnature_definition() #void :
+{}
+{
+  subnature_indication()
+}
+
+
+void next_statement() :
+{}
+{                                                               
+  [ label() ":" ] <NEXT> [ loop_label() ] [ <WHEN> condition() ] ";"
+}
+
+void null_statement() :
+{}
+{
+  [ label() ":" ] <NULL> ";"
+}
+
+
+
+void numeric_literal() #void :
+{}
+{
+    LOOKAHEAD(physical_literal())
+    physical_literal()
+  | abstract_literal()
+}
+
+
+void object_declaration() #void :
+{}
+{
+  try {
+    constant_declaration()
+  | signal_declaration()
+  | variable_declaration()
+  | file_declaration()
+  /** 1076.1 extensions: */
+  | terminal_declaration()
+  | quantity_declaration()
+
+  }
+  catch( ParseException e )
+  {
+    error_skipto(SEMICOLON, "syntax error in declaration");
+  }
+}
+
+
+void operator_symbol() :
+{}
+{
+  <string_literal>
+}
+
+
+void options_() :
+{}
+{
+  [ <GUARDED> ] [ delay_mechanism() ]
+}
+
+
+void package_body() :
+{}
+{
+  <PACKAGE> <BODY> package_simple_name() <IS>
+       package_body_declarative_part()
+  <END> [ <PACKAGE> <BODY> ] [ package_simple_name() ] ";"
+}
+
+void package_body_declarative_item() #void :
+{}
+{
+  try {
+    LOOKAHEAD(subprogram_declaration())
+    subprogram_declaration()
+  | subprogram_body()
+  | type_declaration()
+  | subtype_declaration()
+  | constant_declaration()
+  | shared_variable_declaration()
+  | file_declaration()
+  | alias_declaration()
+  | use_clause()
+  | LOOKAHEAD(<GROUP> identifier() <IS>)
+    group_template_declaration()
+  | group_declaration()
+  }
+  catch( ParseException e )
+  {
+    error_skipto(SEMICOLON, "syntax error in declarative item");
+  }
+}
+
+
+void package_body_declarative_part() :
+{}
+{
+  ( package_body_declarative_item() )*
+}
+
+
+
+void package_declaration() :
+{}
+{
+  <PACKAGE> identifier() <IS>
+     package_declarative_part()
+  <END> [ <PACKAGE> ] [ package_simple_name() ] ";"
+}
+
+
+void package_declarative_item() #void :
+{}
+{
+  try {
+    subprogram_declaration()
+  | type_declaration()
+  | subtype_declaration()
+  | constant_declaration()
+  | signal_declaration()
+  | shared_variable_declaration()
+  | file_declaration()
+  | alias_declaration()
+  | component_declaration()
+  | LOOKAHEAD( attribute_declaration() )
+    attribute_declaration()
+  | attribute_specification()
+  | disconnection_specification()
+  | use_clause()
+  | LOOKAHEAD(<GROUP> identifier() <IS>)
+    group_template_declaration()
+  | group_declaration()
+
+  // 1076.1 extensions:
+  | nature_declaration()
+  | subnature_declaration()
+  | terminal_declaration()
+  }
+  catch(ParseException e)
+  {
+    error_skipto(SEMICOLON, "syntax error in declaration");
+  }
+}
+
+void package_declarative_part() :
+{}
+{
+  ( package_declarative_item() )*
+}
+
+
+void parameter_specification() :
+{}
+{
+  identifier() <IN> discrete_range()
+}
+
+void physical_literal() :
+{}
+{
+  [ LOOKAHEAD(abstract_literal() unit_name() )
+    abstract_literal() ]
+  unit_name()
+}
+
+
+void physical_type_definition() :
+{}
+{
+  range_constraint()
+  <UNITS>
+  base_unit_declaration()
+  ( secondary_unit_declaration() )*
+  <END> <UNITS> [ physical_type_simple_name() ]
+}
+
+
+void port_clause() :
+{}
+{
+  <PORT> "(" port_list() ")" ";"
+}
+
+void port_list() #void :
+{}
+{
+  port_interface_list()
+}
+
+
+void port_map_aspect() :
+{}
+{
+  <PORT> <MAP> "(" port_association_list() ")"
+}
+
+
+void prefix() :
+{}
+{
+    LOOKAHEAD( function_call() )
+    function_call()
+  | name()
+}
+
+
+void primary() #void :
+{}
+{
+    LOOKAHEAD( qualified_expression() )
+    qualified_expression()
+
+  | LOOKAHEAD( function_call() )
+    function_call()
+
+  | LOOKAHEAD(name())
+    name()
+
+  | LOOKAHEAD(literal())
+    literal()
+
+  | LOOKAHEAD( aggregate() )
+    aggregate()
+
+  | LOOKAHEAD( "(" expression() ")")
+    "(" expression() ")"
+
+  | LOOKAHEAD( type_conversion() )
+    type_conversion()
+
+  | allocator()
+
+}
+
+
+void primary_unit() #void :
+{}
+{
+    entity_declaration()
+  | configuration_declaration()
+  | LOOKAHEAD(<PACKAGE> identifier())
+    package_declaration()
+}
+
+
+void procedure_call() :
+{}
+{
+  procedure_name() [ "(" actual_parameter_part() ")" ]
+}
+
+void procedure_call_statement() :
+{}
+{
+   [ LOOKAHEAD( label() ":") label() ":" ]
+   procedure_call() ";"
+}
+
+
+void process_declarative_item() #void :
+{}
+{
+    LOOKAHEAD(subprogram_declaration())
+    subprogram_declaration()
+  | subprogram_body()
+  | type_declaration()
+  | subtype_declaration()
+  | constant_declaration()
+  | variable_declaration()
+  | file_declaration()
+  | alias_declaration()
+  | LOOKAHEAD( attribute_declaration() )
+    attribute_declaration()
+  | attribute_specification()
+  | use_clause()
+  | LOOKAHEAD( <GROUP> identifier() <IS> )
+    group_template_declaration()
+  | group_declaration()
+}
+
+void process_declarative_part() :
+{}
+{
+  ( process_declarative_item() )*
+}
+
+
+void process_statement() :
+{}
+{
+   [ process_label() ":" ]
+   [ <POSTPONED> ] <PROCESS>                    { jjtThis.newBlock(); }
+   [ "(" sensitivity_list() ")" ] [ <IS> ]
+     process_declarative_part()
+   <BEGIN>
+     process_statement_part()
+   <END> [ <POSTPONED> ] <PROCESS> [ process_label() ] ";"
+
+   {
+     jjtThis.Check();
+     jjtThis.endBlock();
+   }
+}
+
+
+void process_statement_part() :
+{}
+{
+  ( sequential_statement() )*
+}
+
+
+/*
+    VHDL 2002: protected types:
+*/
+
+void protected_type_body() #void :
+{}
+{
+  <PROTECTED> <BODY>
+    protected_type_body_declarative_part()
+  <END> <PROTECTED> <BODY> [ simple_name() ]
+}
+
+void protected_type_body_declarative_item() #void :
+{}
+{
+    LOOKAHEAD(subprogram_declaration())
+    subprogram_declaration()
+    | subprogram_body()
+    | type_declaration() 
+    | subtype_declaration() 
+    | constant_declaration() 
+    | variable_declaration() 
+    | file_declaration() 
+    | alias_declaration() 
+    | LOOKAHEAD(attribute_declaration())
+    attribute_declaration() 
+    | attribute_specification() 
+    | use_clause() 
+    | LOOKAHEAD(group_template_declaration())
+    group_template_declaration()
+    | group_declaration() 
+}
+
+void protected_type_body_declarative_part() #void :
+{}
+{ 
+  (protected_type_body_declarative_item())+
+}
+
+void protected_type_declaration() #void :
+{}
+{
+  <PROTECTED>
+    protected_type_declarative_part()
+  <END> <PROTECTED> [ simple_name() ]
+}
+
+void protected_type_declarative_item() #void :
+{}
+{
+    subprogram_declaration()
+    | attribute_declaration()
+    | use_clause()
+}
+
+void protected_type_declarative_part() #void :
+{}
+{ 
+  (protected_type_declarative_item())+
+}
+
+void protected_type_definition() #void :
+{}
+{
+    LOOKAHEAD(protected_type_body()) protected_type_body()
+    | protected_type_declaration()
+}
+
+void qualified_expression() :
+{}
+{
+  type_mark() "'"
+  (   LOOKAHEAD( aggregate() )
+      aggregate()
+    | "(" expression() ")"
+  )
+}
+
+void range() :
+{}
+{
+    LOOKAHEAD( simple_expression() direction() )
+    simple_expression() direction() simple_expression()
+  | range_attribute_name()
+}
+
+
+void range_constraint() #void :
+{}
+{
+  <RANGE> range()
+}
+
+void record_nature_definition() :
+{}
+{
+  <RECORD>
+  ( nature_element_declaration() )+
+  <END> <RECORD> [ record_nature_simple_name() ]
+}
+
+void record_type_definition() :
+{}
+{
+  <RECORD>
+  ( element_declaration() )+
+  <END> <RECORD> [ record_type_simple_name() ]
+}
+
+
+
+void relation() #void :
+{ int op; }
+{
+  shift_expression() 
+  [ LOOKAHEAD(1)
+  op=relational_operator()
+  shift_expression()
+  #shift_expression(2) ]
+}
+
+
+int relational_operator() #void :
+{}
+{
+    <EQ>                { return EQ; }
+  | <NEQ>               { return NEQ; } 
+  | <LO>                { return LO; }
+  | <LE>                { return LE; }
+  | <GT>                { return GT; }
+  | <GE>                { return GE; }
+}
+
+
+void report_statement() :
+{}
+{
+  [ label() ":" ]  <REPORT> expression()
+  [ <SEVERITY> expression() ] ";"
+}
+
+
+void return_statement() :
+{}
+{
+  [ label() ":" ] <RETURN> [ expression() ] ";"
+}
+
+
+// 1076.1 - extension:
+void scalar_nature_definition() :
+{}
+{
+  type_mark() <ACROSS> type_mark() <THROUGH>
+}
+
+
+void scalar_type_definition() #void :
+{}
+{
+    LOOKAHEAD(range_constraint() <UNITS> )
+    physical_type_definition()
+  |
+    LOOKAHEAD(enumeration_type_definition())
+    enumeration_type_definition()
+/**  | integer_type_definition()
+ *  | floating_type_definition()
+ * integer- and floating_type_definition are both range_constraint,
+ * thus:
+ */
+  |
+    range_constraint()
+}
+
+void secondary_unit() #void :
+{}
+{
+    LOOKAHEAD( <ARCHITECTURE> )
+    architecture_body()
+  | LOOKAHEAD( <PACKAGE> <BODY> )
+    package_body()
+}
+
+
+void secondary_unit_declaration() :
+{}
+{
+  identifier() "=" physical_literal() ";"
+}
+
+
+void selected_name() :
+{}
+{
+  /**
+   * prefix() "." suffix()
+   * results in left-recursion...
+   * the follwoing does the same (i hope ...)
+   */
+
+  ( simple_name() | operator_symbol() )
+  [ LOOKAHEAD( name_extension() )  name_extension() ]
+
+  /**
+   * semantic analysis has to ensure that last production
+   * was "." suffix()
+   */
+}
+
+
+void selected_signal_assignment() :
+{}
+{
+  <WITH> expression() <SELECT>
+  target()  "<=" options_() selected_waveforms() ";"
+}
+
+void selected_waveforms() :
+{}
+{
+  waveform() <WHEN> choices()
+  ("," waveform() <WHEN> choices() )*
+}
+
+void sensitivity_clause() #void :
+{}
+{
+  <ON> sensitivity_list()
+}
+
+
+void sensitivity_list() :
+{}
+{
+  signal_name() ( "," signal_name() )*
+}
+
+
+void sequence_of_statements() :
+{}
+{
+  ( sequential_statement() )*
+}
+
+void sequential_statement() #void :
+{}
+{
+  try {
+    (
+      LOOKAHEAD(3)
+      wait_statement()
+    | LOOKAHEAD(3)
+      assertion_statement()
+    | LOOKAHEAD(3)
+      report_statement()
+    | LOOKAHEAD(  [ label() ":" ] target() "<=" )
+      signal_assignment_statement()
+    | LOOKAHEAD(  [ label() ":" ] target() ":=" )
+      variable_assignment_statement()
+    | LOOKAHEAD(3)
+      procedure_call_statement()
+    | LOOKAHEAD(3)
+      if_statement()
+    | LOOKAHEAD(3)
+      case_statement()
+    | LOOKAHEAD(3)
+      loop_statement()
+    | LOOKAHEAD(3)
+      next_statement()
+    | LOOKAHEAD(3)
+      exit_statement()
+    | LOOKAHEAD(3)
+      return_statement()
+    | LOOKAHEAD(3)
+      null_statement()
+
+    /** 1076.1 extensions: */
+    | break_statement()
+    )
+  }
+
+  // Error handling: skip till next semicolon.
+  catch (ParseException e)
+  {
+    error_skipto(SEMICOLON, "syntax error in sequential statement");
+  } 
+}
+
+
+void shift_expression() #void :
+{ int op; }
+{
+  simple_expression() 
+  [ LOOKAHEAD(2) op=shift_operator()
+  simple_expression() #simple_expression(2)  ]
+}
+
+int shift_operator() #void :
+{}
+{
+    <SLL>               { return SLL; }
+  | <SRL>               { return SRL; }
+  | <SLA>               { return SLA; }
+  | <SRA>               { return SRA; }
+  | <ROL>               { return ROL; }
+  | <ROR>               { return ROR; }
+}
+
+void sign() :
+{}
+{
+    "+"
+  | "-"
+}
+
+
+void signal_assignment_statement() :
+{}
+{
+  [ LOOKAHEAD( label() ":") label() ":" ]
+  target() "<=" [ delay_mechanism() ] waveform() ";"
+
+}
+
+
+void signal_declaration() :
+{}
+{
+    <SIGNAL> identifier_list() ":"
+    subtype_indication() [ signal_kind() ] [ ":=" expression() ] ";"
+}
+
+
+void signal_kind() :
+{}
+{
+    <REGISTER>
+  | <BUS>
+}
+
+void signal_list() :
+{}
+{
+    signal_name() ( "," signal_name() )*
+  | <OTHERS>
+  | <ALL>
+}
+
+
+void signature() :
+{}
+{
+  [ type_mark() ( LOOKAHEAD( "," type_mark() ) "," type_mark() )* ]
+  [ <RETURN> type_mark() ]
+}
+
+
+void simple_expression() #void :
+{ int op; }
+{
+   [ sign() ] term()
+   ( LOOKAHEAD(2) op=adding_operator() term()
+     #term(2) )*
+}
+
+
+void simple_name() #void :
+{}
+{
+  identifier()
+}
+
+void slice_name() :
+{}
+{
+  prefix() "(" discrete_range() ")"
+}
+
+
+
+void subprogram_body() :
+{}
+{
+  subprogram_specification() <IS>
+     subprogram_declarative_part()
+  <BEGIN>
+         subprogram_statement_part()
+  <END> [ subprogram_kind() ] [ designator() ] ";"
+}
+
+
+void subprogram_declaration() #void :
+{}
+{
+  subprogram_specification() ";"
+}
+
+
+void subprogram_declarative_item() #void :
+{}
+{
+    LOOKAHEAD(subprogram_declaration())
+    subprogram_declaration()
+  | subprogram_body()
+  | type_declaration()
+  | subtype_declaration()
+  | constant_declaration()
+  | variable_declaration()
+  | file_declaration()
+  | alias_declaration()
+  | LOOKAHEAD(attribute_declaration())
+    attribute_declaration()
+  | attribute_specification()
+  | use_clause()
+  | LOOKAHEAD( <GROUP> identifier() <IS>)
+    group_template_declaration()
+  | group_declaration()
+}
+
+void subprogram_declarative_part() :
+{}
+{
+  ( subprogram_declarative_item() )*
+}
+
+
+int subprogram_kind() #void :
+{}
+{
+    <PROCEDURE>                 { return PROCEDURE; }
+  | <FUNCTION>                  { return FUNCTION; }
+}
+
+void subprogram_specification() :
+{}
+{
+  <PROCEDURE> designator() [ "(" formal_parameter_list() ")" ]
+  | [ <PURE> | <IMPURE> ]  <FUNCTION> designator()
+     [ "(" formal_parameter_list() ")" ]
+                <RETURN> type_mark()
+}
+
+
+
+void subprogram_statement_part() :
+{}
+{
+  ( sequential_statement() )*
+}
+
+
+void subtype_declaration() :
+{}
+{
+  <SUBTYPE> identifier() <IS> subtype_indication() ";"
+}
+
+
+/**
+ * Section 4.1:
+ */
+void subtype_indication() :
+{}
+{
+  /*
+   * enumeration resolves conflict ! After implementation of symbol tables
+   * this can be replaced by semantic lookahead.
+   */ 
+    LOOKAHEAD(resolution_function_name() type_mark() constraint())
+    resolution_function_name() type_mark() constraint() 
+      [ LOOKAHEAD(tolerance_aspect())tolerance_aspect() ]
+
+  | LOOKAHEAD( type_mark() constraint() )
+    type_mark() constraint() 
+      [ LOOKAHEAD(tolerance_aspect()) tolerance_aspect() ]
+
+  | LOOKAHEAD( resolution_function_name() type_mark() )
+    resolution_function_name() type_mark() 
+      [ LOOKAHEAD(tolerance_aspect())tolerance_aspect() ]
+
+  | LOOKAHEAD( type_mark() )
+    type_mark()  
+      [ LOOKAHEAD(tolerance_aspect()) tolerance_aspect() ]
+}
+
+
+/**
+ * 1076.1 extension:
+ */
+void tolerance_aspect() #void :
+{}
+{
+  <TOLERANCE> string_expression()
+}
+
+
+/**
+ * Section 4.3.1.6: Quantity declaration
+ * 1076.1 extension:
+ */
+void quantity_declaration() #void :
+{}
+{
+    LOOKAHEAD(free_quantity_declaration() )
+    free_quantity_declaration()
+  | LOOKAHEAD(branch_quantity_declaration() )
+    branch_quantity_declaration()
+  | source_quantity_declaration()
+}
+
+/**
+ * 1076.1 extension:
+ */
+void free_quantity_declaration() :
+{}
+{
+  <QUANTITY> identifier_list() ":" subtype_indication() [":=" expression()] ";"
+}
+
+/**
+ * 1076.1 extension:
+ */
+void branch_quantity_declaration() :
+{}
+{
+  <QUANTITY> [LOOKAHEAD(across_aspect()) across_aspect()] 
+	     [LOOKAHEAD(through_aspect()) through_aspect()] 
+	     terminal_aspect() ";"
+}
+
+/**
+ * 1076.1 extension:
+ */
+void source_quantity_declaration() :
+{}
+{ 
+  <QUANTITY> identifier_list() ":" subtype_indication() source_aspect() ";"
+}
+
+/**
+ * 1076.1 extension:
+ */
+void across_aspect() :
+{}
+{
+  identifier_list() [ tolerance_aspect() ] [ ":=" expression() ] <ACROSS>
+}
+
+/**
+ * 1076.1 extension:
+ */
+void through_aspect() :
+{}
+{
+  identifier_list() [ tolerance_aspect() ] [ ":=" expression() ] <THROUGH>
+} 
+
+/**
+ * 1076.1 extension:
+ */
+void source_aspect() :
+{}
+{
+    <SPECTRUM> magnitude_simple_expression() "," phase_simple_expression() 
+  | <NOISE>    magnitude_simple_expression() 
+}
+
+void suffix() #void :
+{}
+{
+    simple_name()
+  | <character_literal>
+  | operator_symbol()
+  | <ALL>
+}
+
+void target() #void :
+{}
+{
+    name()
+  | aggregate()
+}
+
+
+void term() #void :
+{ int op; }
+{
+  factor() ( LOOKAHEAD(2) op = multiplying_operator() factor() #factor(2)
+  )*
+}
+
+void timeout_clause() #void :
+{}
+{
+  <FOR> time_or_real_expression()
+}
+
+
+void type_conversion() :
+{}
+{
+  type_mark() "(" expression() ")"
+}
+
+
+void type_declaration() #void :
+{}
+{
+    LOOKAHEAD( <TYPE> identifier() <IS> )
+    full_type_declaration()
+  | incomplete_type_declaration()
+}
+
+
+void type_definition() #void :
+{}
+{
+    scalar_type_definition()
+  | composite_type_definition()
+  | access_type_definition()
+  | file_type_definition()
+  | protected_type_definition()
+}
+
+
+void type_mark() #void :
+{}
+{
+    LOOKAHEAD(type_name())
+    type_name()
+  | LOOKAHEAD(subtype_name())
+    subtype_name()
+}
+
+
+void unconstrained_array_definition() :
+{}
+{
+  <ARRAY> "(" index_subtype_definition()
+    ( "," index_subtype_definition() )* ")"
+      <OF> element_subtype_indication()
+}
+
+
+void use_clause() :
+{}
+{
+   <USE> selected_name() ( "," selected_name() )* ";"
+}
+
+
+void variable_assignment_statement() :
+{}
+{
+  [ LOOKAHEAD( label() ":") label() ":" ]
+  target()  ":=" expression() ";"
+}
+
+
+void variable_declaration() :
+{}
+{
+  [ <SHARED> ] <VARIABLE> identifier_list() ":"
+  subtype_indication() [ ":=" expression() ] ";"
+}
+
+
+void wait_statement() :
+{}
+{
+   [ LOOKAHEAD( label() ) ":" label() ":"]
+   <WAIT> [ sensitivity_clause() ]
+   [ condition_clause() ] [ timeout_clause() ] ";"
+}
+
+
+void waveform() :
+{}
+{
+  waveform_element() ( "," waveform_element() )*
+  | <UNAFFECTED>
+}
+
+void waveform_element() :
+{}
+{
+     LOOKAHEAD(<NULL>)
+     <NULL>             [<AFTER> time_expression() ]
+  |  value_expression() [ <AFTER> time_expression() ]
+}
+
+
+/** 
+ *Section 15: Simultaneous statements
+ * 1076.1 extension
+ */
+void simultaneous_statement_part()   :
+{}
+{
+  ( simultaneous_statement() )*
+}
+
+/**
+ * 1076.1 extension:
+ */
+void simultaneous_statement() #void :
+{}
+{
+    LOOKAHEAD(simple_simultaneous_statement())
+    simple_simultaneous_statement()
+  | LOOKAHEAD( [if_label()] ":" <IF> condition() <USE> )
+    simultaneous_if_statement()
+  | LOOKAHEAD(simultaneous_case_statement())
+    simultaneous_case_statement()
+  | LOOKAHEAD(4) // procedural is at least as 4th position...
+    simultaneous_procedural_statement()
+  | simultaneous_null_statement()
+}
+
+/**
+ * 1076.1 extension:
+ */
+void simple_simultaneous_statement() :
+{}
+{
+  [ LOOKAHEAD( label() ":") label() ":"] 
+  [<PURE>|<IMPURE>] simple_expression() 
+  "==" simple_expression() [ tolerance_aspect() ] ";"
+}
+
+
+/**
+ * 1076.1 extension:
+ */
+void simultaneous_if_statement() :
+{}
+{
+  [ if_label() ":"] <IF> condition() <USE>
+     simultaneous_statement_part()
+  ( <ELSIF> condition() <USE> simultaneous_statement_part() )*
+  [ <ELSE> simultaneous_statement_part() ]
+  <END> <USE> [ if_label()] ";"
+}
+
+
+/**
+ * 1076.1 extension:
+ */
+void simultaneous_case_statement() :
+{}
+{
+  [ case_label() ":"] <CASE> expression() <USE>
+    (simultaneous_alternative())*
+  <END> <CASE> [ case_label() ] ";"
+}
+
+
+/**
+ * 1076.1 extension:
+ */
+void simultaneous_alternative() :
+{}
+{
+  <WHEN> choices() <USE> simultaneous_statement_part()
+}
+
+
+/**
+ * 1076.1 extension:
+ */
+void simultaneous_procedural_statement() :
+{}
+{
+  [procedural_label() ":"] [<PURE>|<IMPURE>] <PROCEDURAL> [<IS>]
+    procedural_declarative_part()
+   <BEGIN>
+     procedural_statement_part()
+   <END> <PROCEDURAL> [ procedural_label()] ";"
+}
+
+
+// 1076.1 extension:
+void procedural_label() #void :
+{}
+{
+  label()
+}
+
+// 1076.1 extension:
+void procedural_declarative_part() :
+{}
+{
+  ( procedural_declarative_item() )*
+}
+
+/**
+ * 1076.1 extension:
+ */
+void procedural_declarative_item() #void :
+{}
+{
+    LOOKAHEAD(subprogram_declaration())
+    subprogram_declaration()
+  | subprogram_body()
+  | type_declaration()
+  | subtype_declaration()
+  | constant_declaration()
+  | variable_declaration()
+  | alias_declaration()
+  | LOOKAHEAD(attribute_declaration())
+    attribute_declaration()
+  | attribute_specification()
+  | use_clause()
+  | LOOKAHEAD(group_template_declaration())
+    group_template_declaration()
+  | group_declaration()
+}
+
+/**
+ * 1076.1 extension:
+ */
+void procedural_statement_part() :
+{}
+{
+  ( sequential_statement() )*
+}
+
+
+
+// 1076.1 extension:
+void simultaneous_null_statement() :
+{}
+{
+  [ label() ":"] <NULL> ";"
+}
+
+
+
+
+//
+// parts of grammar, which have to be checked during semantic analysis
+// by semantic lookahead:
+//
+void block_label() #void :
+{}
+{
+  label()
+}
+
+void block_statement_label() #void :
+{}
+{
+  label()
+}
+
+void case_label() #void :
+{}
+{
+  label()
+}
+
+void generate_label() #void :
+{}
+{
+  label()
+}
+
+void generate_statement_label() #void :
+{}
+{
+  label()
+}
+
+void if_label() #void :
+{}
+{
+  label()
+}
+
+void instantiation_label() #void :
+{}
+{
+  label()
+}
+
+void loop_label() #void :
+{}
+{
+  label()
+}
+
+void process_label() #void :
+{}
+{
+  label()
+}
+
+void architecture_simple_name() #void :
+{}
+{
+  simple_name()
+}
+
+void attribute_simple_name() #void :
+{}
+{
+  simple_name()
+  | <RANGE>
+}
+
+void component_simple_name() #void :
+{}
+{
+  simple_name()
+}
+
+void configuration_simple_name() #void :
+{}
+{
+  simple_name()
+}
+
+void element_simple_name() #void :
+{}
+{
+  simple_name()
+}
+
+void entity_simple_name() #void :
+{}
+{
+  simple_name()
+}
+
+void package_simple_name() #void :
+{}
+{
+  simple_name()
+}
+
+
+
+void architecture_name() #void :
+{}
+{
+  name()
+}
+
+void entity_name() #void :
+{}
+{
+  name()           
+}
+
+void file_name() #void :
+{}
+{
+  name()
+}
+
+void function_name() #void :
+{}
+{
+  name()
+}
+
+void configuration_name() #void :
+{}
+{
+  name()
+}
+
+void component_name() #void :
+{}
+{
+  name()
+}
+
+void generic_name() #void :
+{}
+{
+  name()
+}
+
+void group_template_name() #void :
+{}
+{
+  name()
+}
+
+void parameter_name() #void :
+{}
+{
+  name()
+}
+
+void physical_type_simple_name() #void :
+{}
+{
+  simple_name() 
+}
+
+void port_name() #void :
+{}
+{
+  name()
+}
+
+void procedure_name() #void :
+{}
+{
+  name()
+}
+
+void range_attribute_name() #void :
+{}
+{
+  name()
+}
+
+void signal_name() #void:
+{}
+{
+  name()
+}
+
+//
+// Name, der einen Typen bezeichnet...
+//
+void type_name() #void:
+{}
+{
+  name()
+}
+
+
+// 1076.1 extension:
+void record_nature_simple_name() #void :
+{}
+{
+  simple_name()
+}
+
+void record_type_simple_name() #void :
+{}
+{
+  simple_name()
+}
+
+void resolution_function_name() #void :
+{}
+{
+  name()
+}
+
+void subtype_name() #void :
+{}
+{
+  name()
+}
+
+void unit_name() #void :
+{}
+{
+  name()
+}
+
+void variable_name() #void :
+{}
+{
+  name()
+}
+
+void architecture_identifier() #void :
+{}
+{
+  identifier()
+}
+
+void static_expression() #void :
+{}
+{
+  expression()
+}
+
+
+void boolean_expression() #void :
+{}
+{
+  expression()
+}
+
+void file_open_kind_expression() #void :
+{}
+{
+  expression()
+}
+
+void guard_expression() #void :
+{}
+{
+  expression()
+}
+
+void time_expression() #void :
+{}
+{
+  expression() // unit_name()
+  // unit_name can be derived by expression!!! 
+}
+
+// 1076.1 extension:
+void time_or_real_expression() #void :
+{}
+{
+  expression() // unit_name()
+  // unit_name can be derived by expression!!!
+}
+
+
+void value_expression() #void :
+{}
+{
+  expression()
+}
+
+void string_expression() #void :
+{}
+{
+  expression()
+}
+
+
+void guarded_signal_list() #void :
+{}
+{
+  signal_list()
+}
+
+void parameter_association_list() #void :
+{}
+{
+  association_list()
+}
+
+void port_association_list() #void :
+{}
+{
+  association_list()
+}
+
+void generic_association_list() #void :
+{}
+{
+  association_list()
+}
+
+void generic_interface_list() #void :
+{}
+{
+  interface_list()
+}
+
+void parameter_interface_list() #void :
+{}
+{
+  interface_list()
+}
+
+void port_interface_list() #void :
+{}
+{
+  interface_list()
+}
+
+//
+// fraglich:
+//
+void formal_port_clause() #void :
+{}
+{
+  port_clause()
+}
+
+void local_port_clause() #void :
+{}
+{
+  port_clause()
+}
+
+void formal_generic_clause() #void :
+{}
+{
+  generic_clause()
+}
+
+void local_generic_clause() #void :
+{}
+{
+  generic_clause()
+}
+
+void element_subtype_indication() #void :
+{}
+{
+  subtype_indication()
+}
+
+void discrete_subtype_indication() #void :
+{}
+{
+  subtype_indication()
+}
+
+void loop_parameter_specification() #void :
+{}
+{
+  parameter_specification()
+}
+
+void generate_parameter_specification() #void :
+{}
+{
+  parameter_specification()
+}
+
+void passive_concurrent_procedure_call_statement() #void :
+{}
+{
+  concurrent_procedure_call_statement()
+}
+
+void passive_process_statement() #void :
+{}
+{
+  process_statement()
+}
+
+
+void magnitude_simple_expression() #void :
+{}
+{ 
+  simple_expression() 
+}
+
+void phase_simple_expression() #void :
+{}
+{
+  simple_expression()
+}
+
+
+void nature_name() #void :
+{}
+{
+  name() 
+}
+
+void subnature_name() #void :
+{}
+{
+  name()
+}
+
+/**
+ * 1076.1 extension:
+ */
+void terminal_name() #void :
+{}
+{
+  name()
+}
+
+
+/**
+ * 1076.1 extension:
+ */
+void quantity_name() #void :
+{}
+{
+  name()
+}
+
+/**
+ * 1076.1 extension:
+ */
+void plus_terminal_name() #void :
+{}
+{
+  name()
+}
+
+/**
+ * 1076.1 extension:
+ */
+void minus_terminal_name() #void :
+{}
+{
+  name()
+}
+
+
+/**
+ * still missing:
+ */
+void shared_variable_declaration() :
+{}
+{
+  [ <SHARED> ] <VARIABLE> identifier_list() ":"
+  subtype_indication() [ ":=" expression() ] ";"
+}
+
+
+
+
+/**
+ *
+ * for error recovery:
+ *
+ */
+JAVACODE void error_skipto(int kind, String message) 
+{
+  errs.Error(message,null);
+  Token t;
+  do 
+  {
+    t = getNextToken();
+  } while ((t.kind != kind) && t.next != null);
+}
+
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/VhdlOutlineElementFactory.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/VhdlOutlineElementFactory.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/VhdlOutlineElementFactory.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/VhdlOutlineElementFactory.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,489 +1,500 @@
-/*******************************************************************************
- * Copyright (c) 2006 Ali Ghorashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    Ali Ghorashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.parser.vhdl;
-
-import java.util.ArrayList;
-
-import net.sourceforge.veditor.parser.OutlineElement;
-import net.sourceforge.veditor.parser.OutlineElementFactory;
-
-import org.eclipse.core.resources.IFile;
-
-/** 
- * Class factory for Vhdl Outline Elements
- *
- */
-public class VhdlOutlineElementFactory extends OutlineElementFactory {
-	
-    private boolean isArchitecture (String type){return type.startsWith("architecture#");}
-    private boolean isPackageBody  (String type)  {return type.equals("packageBody#");   }
-    private boolean isPackageDecl  (String type)  {return type.equals("packageDecl#");   }
-    private boolean isFunction     (String type) { return type.startsWith("function#"); }
-    private boolean isFunctionDef  (String type) { return type.startsWith("functionDecl#"); }
-    private boolean isProcedureDef  (String type) { return type.startsWith("procedureDecl#"); }
-    private boolean isProcess      (String type){return type.startsWith("process#"); }
-    private boolean isProcedure    (String type){return type.startsWith("procedure#"); }
-    private boolean isComponentDecl(String type){return type.startsWith("componentDecl#"); }
-    private boolean isComponentInst(String type){return type.startsWith("componentInst#"); }
-    private boolean isEntityDecl   (String type){return type.startsWith("entityDecl#"); }
-    private boolean isEntityInst   (String type){return type.startsWith("entityInst#"); }
-    private boolean isPort         (String type){return type.toLowerCase().startsWith("port#"); }
-    private boolean isGeneric      (String type){return type.toLowerCase().startsWith("generic#"); }
-    private boolean isSignal       (String type){return type.toLowerCase().startsWith("signal#"); }
-    private boolean isVariable     (String type){return type.toLowerCase().startsWith("variable#"); }  
-    private boolean isConstant     (String type){return type.toLowerCase().startsWith("constant#"); }  
-    private boolean isAlias        (String type){return type.toLowerCase().startsWith("alias#"); }
-    private boolean isFile         (String type){return type.toLowerCase().startsWith("file#"); }
-    private boolean isRecordMember (String type){return type.toLowerCase().startsWith("recordmember#"); }
-    private boolean isTypeDecl     (String type){return type.toLowerCase().startsWith("type#"); }
-    private boolean isSubTypeDecl  (String type){return type.toLowerCase().startsWith("subtypedecl#"); }
-	
-	/**
-	 * All VHDL outline classes are derived from this one;
-	 *
-	 */
-	public class VhdlOutlineElement extends OutlineElement{
-		protected String m_ShortName;
-		protected String m_LongName;
-		protected String m_ImageName;
-		protected String[] m_TypeParts;
-		public VhdlOutlineElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
-			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
-			m_ShortName= m_Name;
-			m_LongName =  m_Name+" : "+m_Type;
-			m_TypeParts=m_Type.split("#");
-			m_ImageName="$nl$/icons/obj.gif";
-		}
-		public String GetImageName(){
-			return m_ImageName;
-		}
-		public String getShortName(){
-			return m_ShortName;
-		}
-		public String getLongName(){
-			return m_LongName;
-		}
-		public String getText(){
-			return m_ShortName;
-		}
-		public String getTypePart1(){
-			if(m_TypeParts.length > 1){
-				return m_TypeParts[1];
-			}
-	         return "";
-		}
-		public String getTypePart2(){
-			if (m_TypeParts.length > 2){
-				return m_TypeParts[2];
-			}	else 
-				return "";
-		}
-	}	
-	/**
-	 * Element type classes
-	 * @note type string: architecture#[EntityName]
-	 */
-	public class ArchitectureElement extends VhdlOutlineElement{
-		public ArchitectureElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
-			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
-			m_ImageName="$nl$/icons/arch.gif";			
-			m_LongName = String.format("architecture(%s) of %s", name,GetEntityName());
-			m_ShortName=m_LongName;
-		}	
-		public String GetEntityName(){			
-			if (m_TypeParts.length > 1){
-				return m_TypeParts[1];
-			}
-			else 
-				return "";
-		}
-	}
-	/**  @note type string: packageBody# */
-	public class PackageBodyElement extends VhdlOutlineElement{
-		public PackageBodyElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
-			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
-			m_ImageName="$nl$/icons/package_body.gif";
-			m_LongName = name+": Package Body";
-			m_ShortName=m_LongName;
-		}	
-	}
-	/**  @note type string: packageDecl# */
-	public class PackageDeclElement extends VhdlOutlineElement{
-		public PackageDeclElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
-			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
-			m_ImageName="$nl$/icons/package_decl.gif";
-			m_LongName=name+": Package Decl";
-			m_ShortName=name+" (pkg)";
-		}
-	}
-	/** This class is not meant to be instantiated directly */
-	public class VhdlSubprogram  extends VhdlOutlineElement{
-		protected VhdlSubprogram(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
-			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
-			
-			m_ShortName=m_Name;
-			
-			//set the long name			
-			Parameter[] params=getParameters();
-			if(params.length >1){
-				StringBuffer buffer=new StringBuffer(name);
-				buffer.append("(");
-				int lastComma=0;
-				for(Parameter param:params){
-					buffer.append(param.m_Name);
-					buffer.append(" : ");
-					buffer.append(param.m_Direction);
-					buffer.append(" ");
-					buffer.append(param.m_Type);
-					lastComma=buffer.length();
-					buffer.append(", ");
-				}
-				buffer.delete(lastComma, lastComma+1);
-				buffer.append(")");
-				m_LongName=buffer.toString();
-			}
-			else{
-				m_LongName=name;
-			}
-		}		
-		
-		/**
-		 * Gets a list of parameters
-		 * @return List of parameters for this sub program
-		 */
-		public Parameter[] getParameters(){
-			int idx;
-			ArrayList <Parameter> results=new ArrayList<Parameter>();
-			
-			for(idx=1;idx+2<m_TypeParts.length;idx+=3){
-				Parameter param=new Parameter();
-				param.m_Name=m_TypeParts[idx];
-				param.m_Type=m_TypeParts[idx+1];
-				param.m_Direction=m_TypeParts[idx+2];
-				results.add(param);
-			}					
-			return results.toArray(new Parameter[0]);
-		}		
-		
-		/** This class encapsulates parameter information */
-		public class Parameter{			
-			public String m_Name="";
-			public String m_Type="";
-			public String m_Direction="in";			
-		}
-	}
-	
-	/**  @note type string: function#[Parameters:name#type#direction]#return type */
-	public class FunctionElement extends VhdlSubprogram{
-		public FunctionElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
-			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
-			m_ImageName="$nl$/icons/f.gif";
-			
-			m_LongName+="return "+getType();
-		}	
-		
-		public String getReturnType(){
-			//the return type is the last field
-			if(m_TypeParts.length>0){
-				return m_TypeParts[m_TypeParts.length-1];
-			}
-			return "";
-		}
-	}
-	/**  @note type string: functionDecl#[Parameters:name#type#direction]#return type */
-	public class FunctionDefElement extends VhdlSubprogram{
-		public FunctionDefElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
-			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
-			m_ImageName="$nl$/icons/f_def.gif";
-			
-			m_LongName+="return "+getType();
-		}		
-		
-		public String getReturnType(){
-			//the return type is the last field
-			if(m_TypeParts.length>0){
-				return m_TypeParts[m_TypeParts.length-1];
-			}
-			return "";
-		}
-		public String getTypePartArgu(){
-			String replace="";
-		if (m_TypeParts.length>0){	
-		int i=	m_TypeParts.length/3;
-		for (int j=0;j<i;j++){
-			
-			replace	+=m_TypeParts[j*3+1]+" "+m_TypeParts[j*3+2]+",";
-			}
-		replace=replace.substring(0, replace.length()-1);
-			return replace;
-			
-		}
-		return replace;
-		}
-	}
-	/**  @note type string: procedure#[Parameters:name#type#direction] */
-	public class ProcedureElement extends VhdlSubprogram{
-		public ProcedureElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
-			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
-			m_ImageName="$nl$/icons/P.gif";		
-		}		
-	}
-	/**  @note type string: procedureDecl#[Parameters:name#type#direction] */
-	public class ProcedureDefElement extends VhdlSubprogram{
-		public ProcedureDefElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
-			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
-			m_ImageName="$nl$/icons/P.gif";		
-		}		
-	}
-	/**  @note type string: process#*/
-	public class ProcessElement extends VhdlOutlineElement{
-		public ProcessElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
-			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
-			m_ImageName="$nl$/icons/process.gif";
-			m_LongName=name+": process";
-			m_ShortName=m_LongName;
-		}		
-	}	
-	/**  @note type string: componentInst#[entity name] */
-	public class ComponentInstElement extends VhdlOutlineElement{
-		public ComponentInstElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
-			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
-			m_ImageName="$nl$/icons/green_tri.gif";			
-			m_LongName=String.format("%s : %s",name,GetEntityName());
-			m_ShortName=m_LongName;
-		}
-		public String GetEntityName(){			
-			if (m_TypeParts.length > 1){
-				return m_TypeParts[1];
-			}
-			else 
-				return "";
-		}
-	}
-	/**  @note type string: componentDecl# */
-	public class ComponentDeclElement extends VhdlOutlineElement{
-		public ComponentDeclElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
-			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
-			m_ImageName="$nl$/icons/blue_tri.gif";
-			m_LongName=name+" : component";
-			m_ShortName=name+" (cmp)";
-		}		
-	}
-	/**  @note type string: entityInst#[entity name] */
-	public class EntityInstElement extends VhdlOutlineElement{
-		public EntityInstElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
-			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
-			m_ImageName="$nl$/icons/gray_circ.gif";
-			m_LongName=name+" : "+GetEntityName();
-			m_ShortName=m_LongName;
-		}
-		public String GetEntityName(){			
-			if (m_TypeParts.length > 1){
-				return m_TypeParts[1];
-			}
-			else 
-				return "";
-		}
-	}
-	/**  @note type string: entityDecl# */
-	public class EntityDeclElement extends VhdlOutlineElement{
-		public EntityDeclElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
-			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
-			m_ImageName="$nl$/icons/gray_circ_small.gif";
-			m_LongName=name+" : entity" ;
-			m_ShortName=name+" (ent)";
-		}		
-	}
-	/**  @note type string: generic#[type] */
-	public class GenericElement extends VhdlOutlineElement{
-		public GenericElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
-			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
-			m_ImageName="$nl$/icons/generic.gif";
-			m_LongName=name+" : ";
-			if(m_TypeParts.length > 1){
-				m_LongName += m_TypeParts[1];
-			}
-			m_ShortName=m_LongName;
-		}		
-	}
-	/**  @note type string: signal#[type] */
-	public class VhdlSignalElement extends VhdlOutlineElement{
-		public VhdlSignalElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
-			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
-			m_ImageName="$nl$/icons/signal.gif";
-			m_LongName=name + " : " + GetSignalType() + getInitialValue();
-			m_ShortName=m_LongName;
-		}
-		public String GetSignalType(){
-			if(m_TypeParts.length > 1){
-				return m_TypeParts[1];
-			}
-			return "";
-		}
-
-		public String getInitialValue() {
-			if (m_TypeParts.length > 2) {
-				String m = ":=" + m_TypeParts[2];
-				return m;
-			}
-			return "";
-		}
-	}
-	/**  @note type string: variable#[type] */
-	public class VariableElement extends VhdlSignalElement{
-		public VariableElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
-			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
-			m_ImageName="$nl$/icons/variable_signal.gif";				
-		}
-	}
-	/**  @note type string: alias#[type] */
-	public class AliasElement extends VhdlSignalElement{
-		public AliasElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
-			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
-			m_ImageName="$nl$/icons/alias_signal.gif";				
-		}
-	}
-	/**  @note type string: constant#[type] */
-	public class ConstantElement extends VhdlSignalElement{
-		public ConstantElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
-			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
-			m_ImageName="$nl$/icons/constant_signal.gif";				
-		}
-	}
-	/**  @note type string: file# */
-	public class FileElement extends VhdlSignalElement{
-		public FileElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
-			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
-			m_ImageName="$nl$/icons/ar_obj.gif";				
-		}
-	}
-	public class TypeDecl extends VhdlOutlineElement{
-        public TypeDecl(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
-            super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
-            m_ImageName="$nl$/icons/type.gif";                
-        }
-    }
-	public class SubTypeDecl extends VhdlOutlineElement{
-        public SubTypeDecl(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
-            super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
-            m_ImageName="$nl$/icons/type.gif";                
-        }
-    }
-	/**  @note type string: port#[in,out,buffer,inout]#[type] */
-	public class VhdlPortElement extends VhdlOutlineElement{
-		public static final int INPUT	=0;
-		public static final int OUTPUT	=1;
-		public static final int INOUT	=2;
-		private int m_Direction;
-		
-		public String GetDirectionString(){
-			switch(m_Direction){
-			case INPUT:
-				return "in";
-			case OUTPUT:
-				return "out";
-			case INOUT:
-				return "inout";
-			default:
-				return "";
-			}
-		}
-		public VhdlPortElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
-			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
-			if(type.toLowerCase().startsWith("port#in#")){
-				m_Direction=INPUT;
-				m_ImageName="$nl$/icons/port_in.gif";
-			}
-			else if (type.toLowerCase().startsWith("port#out#")){
-				m_Direction = OUTPUT;
-				m_ImageName="$nl$/icons/port_out.gif";
-			}
-			else{
-				m_Direction = INOUT;
-				m_ImageName="$nl$/icons/port_inout.gif";
-			}	
-			m_LongName=String.format("Port %s %s : %s", GetDirectionString(),name,m_TypeParts[2]);
-			m_ShortName=String.format("%s : %s", name,m_TypeParts[2]);
-		}		
-	}
-	/**  @note type string: record# */
-	public class RecordMemberElement extends VhdlOutlineElement{
-		public RecordMemberElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
-			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
-			m_ImageName="$nl$/icons/obj.gif";		
-		}
-	}
-	
-	/**
-	 * Class Factory function
-	 */
-	public OutlineElement CreateElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file){		
-		if(isArchitecture(type)){
-			return new ArchitectureElement(name,type,startLine,startCol,endLine,endCol,file,true);
-		} else if (isPackageBody(type)){
-			return new PackageBodyElement(name,type,startLine,startCol,endLine,endCol,file,true);
-		}else if (isPackageDecl(type)){
-			return new PackageDeclElement(name,type,startLine,startCol,endLine,endCol,file,true);
-		}else if (isFunction(type)){
-			return new FunctionElement(name,type,startLine,startCol,endLine,endCol,file,true);
-		}else if (isFunctionDef(type)){
-			return new FunctionDefElement(name,type,startLine,startCol,endLine,endCol,file,true);
-		}else if (isProcedureDef(type)){
-			return new ProcedureDefElement(name,type,startLine,startCol,endLine,endCol,file,true);
-		}else if (isProcess(type)){
-			return new ProcessElement(name,type,startLine,startCol,endLine,endCol,file,true);
-		}else if (isProcedure(type)){
-			return new ProcedureElement(name,type,startLine,startCol,endLine,endCol,file,true);
-		}else if (isComponentDecl(type)){
-			return new ComponentDeclElement(name,type,startLine,startCol,endLine,endCol,file,true);
-		}else if (isComponentInst(type)){
-			return new ComponentInstElement(name,type,startLine,startCol,endLine,endCol,file,true);
-		}else if (isEntityDecl(type)){
-			return new EntityDeclElement(name,type,startLine,startCol,endLine,endCol,file,true);
-		}else if (isEntityInst(type)){
-			return new EntityInstElement(name,type,startLine,startCol,endLine,endCol,file,true);
-		}else if (isPort(type)){
-			return new VhdlPortElement(name,type,startLine,startCol,endLine,endCol,file,true);
-		}
-		else if (isGeneric(type)){
-			return new GenericElement(name,type,startLine,startCol,endLine,endCol,file,true);
-		}
-		else if (isSignal(type)){
-			return new VhdlSignalElement(name,type,startLine,startCol,endLine,endCol,file,true);
-		}
-		else if (isVariable(type)){
-			return new VariableElement(name,type,startLine,startCol,endLine,endCol,file,true);
-		}
-		else if (isConstant(type)){
-			return new ConstantElement(name,type,startLine,startCol,endLine,endCol,file,true);
-		}
-		else if (isAlias(type)){
-			return new AliasElement(name,type,startLine,startCol,endLine,endCol,file,true);
-		}
-		else if (isFile(type)){
-			return new FileElement(name,type,startLine,startCol,endLine,endCol,file,true);
-		}
-		else if (isRecordMember(type)){
-			return new RecordMemberElement(name,type,startLine,startCol,endLine,endCol,file,true);
-		}
-		else if (isTypeDecl(type)){
-            return new TypeDecl(name,type,startLine,startCol,endLine,endCol,file,true);
-        }
-		else if (isSubTypeDecl(type)){
-			return new SubTypeDecl(name,type,startLine,startCol,endLine,endCol,file,true);
-        }
-		
-		
-		
-		//default case
-		return new OutlineElement(name,type,startLine,startCol,endLine,endCol,file,true);
-	}
-}
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2006 Ali Ghorashi and others.
+ *
+ * Contributors:
+ *    Ali Ghorashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.parser.vhdl;
+
+import java.util.ArrayList;
+
+import com.elphel.vdt.veditor.parser.OutlineElement;
+import com.elphel.vdt.veditor.parser.OutlineElementFactory;
+
+import org.eclipse.core.resources.IFile;
+
+/** 
+ * Class factory for Vhdl Outline Elements
+ *
+ */
+public class VhdlOutlineElementFactory extends OutlineElementFactory {
+	
+    private boolean isArchitecture (String type){return type.startsWith("architecture#");}
+    private boolean isPackageBody  (String type)  {return type.equals("packageBody#");   }
+    private boolean isPackageDecl  (String type)  {return type.equals("packageDecl#");   }
+    private boolean isFunction     (String type) { return type.startsWith("function#"); }
+    private boolean isFunctionDef  (String type) { return type.startsWith("functionDecl#"); }
+    private boolean isProcedureDef  (String type) { return type.startsWith("procedureDecl#"); }
+    private boolean isProcess      (String type){return type.startsWith("process#"); }
+    private boolean isProcedure    (String type){return type.startsWith("procedure#"); }
+    private boolean isComponentDecl(String type){return type.startsWith("componentDecl#"); }
+    private boolean isComponentInst(String type){return type.startsWith("componentInst#"); }
+    private boolean isEntityDecl   (String type){return type.startsWith("entityDecl#"); }
+    private boolean isEntityInst   (String type){return type.startsWith("entityInst#"); }
+    private boolean isPort         (String type){return type.toLowerCase().startsWith("port#"); }
+    private boolean isGeneric      (String type){return type.toLowerCase().startsWith("generic#"); }
+    private boolean isSignal       (String type){return type.toLowerCase().startsWith("signal#"); }
+    private boolean isVariable     (String type){return type.toLowerCase().startsWith("variable#"); }  
+    private boolean isConstant     (String type){return type.toLowerCase().startsWith("constant#"); }  
+    private boolean isAlias        (String type){return type.toLowerCase().startsWith("alias#"); }
+    private boolean isFile         (String type){return type.toLowerCase().startsWith("file#"); }
+    private boolean isRecordMember (String type){return type.toLowerCase().startsWith("recordmember#"); }
+    private boolean isTypeDecl     (String type){return type.toLowerCase().startsWith("type#"); }
+    private boolean isSubTypeDecl  (String type){return type.toLowerCase().startsWith("subtypedecl#"); }
+	
+	/**
+	 * All VHDL outline classes are derived from this one;
+	 *
+	 */
+	public class VhdlOutlineElement extends OutlineElement{
+		protected String m_ShortName;
+		protected String m_LongName;
+		protected String m_ImageName;
+		protected String[] m_TypeParts;
+		public VhdlOutlineElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
+			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
+			m_ShortName= m_Name;
+			m_LongName =  m_Name+" : "+m_Type;
+			m_TypeParts=m_Type.split("#");
+			m_ImageName="$nl$/icons/obj.gif";
+		}
+		public String GetImageName(){
+			return m_ImageName;
+		}
+		public String getShortName(){
+			return m_ShortName;
+		}
+		public String getLongName(){
+			return m_LongName;
+		}
+		public String getText(){
+			return m_ShortName;
+		}
+		public String getTypePart1(){
+			if(m_TypeParts.length > 1){
+				return m_TypeParts[1];
+			}
+	         return "";
+		}
+		public String getTypePart2(){
+			if (m_TypeParts.length > 2){
+				return m_TypeParts[2];
+			}	else 
+				return "";
+		}
+	}	
+	/**
+	 * Element type classes
+	 * @note type string: architecture#[EntityName]
+	 */
+	public class ArchitectureElement extends VhdlOutlineElement{
+		public ArchitectureElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
+			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
+			m_ImageName="$nl$/icons/arch.gif";			
+			m_LongName = String.format("architecture(%s) of %s", name,GetEntityName());
+			m_ShortName=m_LongName;
+		}	
+		public String GetEntityName(){			
+			if (m_TypeParts.length > 1){
+				return m_TypeParts[1];
+			}
+			else 
+				return "";
+		}
+	}
+	/**  @note type string: packageBody# */
+	public class PackageBodyElement extends VhdlOutlineElement{
+		public PackageBodyElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
+			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
+			m_ImageName="$nl$/icons/package_body.gif";
+			m_LongName = name+": Package Body";
+			m_ShortName=m_LongName;
+		}	
+	}
+	/**  @note type string: packageDecl# */
+	public class PackageDeclElement extends VhdlOutlineElement{
+		public PackageDeclElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
+			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
+			m_ImageName="$nl$/icons/package_decl.gif";
+			m_LongName=name+": Package Decl";
+			m_ShortName=name+" (pkg)";
+		}
+	}
+	/** This class is not meant to be instantiated directly */
+	public class VhdlSubprogram  extends VhdlOutlineElement{
+		protected VhdlSubprogram(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
+			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
+			
+			m_ShortName=m_Name;
+			
+			//set the long name			
+			Parameter[] params=getParameters();
+			if(params.length >1){
+				StringBuffer buffer=new StringBuffer(name);
+				buffer.append("(");
+				int lastComma=0;
+				for(Parameter param:params){
+					buffer.append(param.m_Name);
+					buffer.append(" : ");
+					buffer.append(param.m_Direction);
+					buffer.append(" ");
+					buffer.append(param.m_Type);
+					lastComma=buffer.length();
+					buffer.append(", ");
+				}
+				buffer.delete(lastComma, lastComma+1);
+				buffer.append(")");
+				m_LongName=buffer.toString();
+			}
+			else{
+				m_LongName=name;
+			}
+		}		
+		
+		/**
+		 * Gets a list of parameters
+		 * @return List of parameters for this sub program
+		 */
+		public Parameter[] getParameters(){
+			int idx;
+			ArrayList <Parameter> results=new ArrayList<Parameter>();
+			
+			for(idx=1;idx+2<m_TypeParts.length;idx+=3){
+				Parameter param=new Parameter();
+				param.m_Name=m_TypeParts[idx];
+				param.m_Type=m_TypeParts[idx+1];
+				param.m_Direction=m_TypeParts[idx+2];
+				results.add(param);
+			}					
+			return results.toArray(new Parameter[0]);
+		}		
+		
+		/** This class encapsulates parameter information */
+		public class Parameter{			
+			public String m_Name="";
+			public String m_Type="";
+			public String m_Direction="in";			
+		}
+	}
+	
+	/**  @note type string: function#[Parameters:name#type#direction]#return type */
+	public class FunctionElement extends VhdlSubprogram{
+		public FunctionElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
+			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
+			m_ImageName="$nl$/icons/f.gif";
+			
+			m_LongName+="return "+getType();
+		}	
+		
+		public String getReturnType(){
+			//the return type is the last field
+			if(m_TypeParts.length>0){
+				return m_TypeParts[m_TypeParts.length-1];
+			}
+			return "";
+		}
+	}
+	/**  @note type string: functionDecl#[Parameters:name#type#direction]#return type */
+	public class FunctionDefElement extends VhdlSubprogram{
+		public FunctionDefElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
+			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
+			m_ImageName="$nl$/icons/f_def.gif";
+			
+			m_LongName+="return "+getType();
+		}		
+		
+		public String getReturnType(){
+			//the return type is the last field
+			if(m_TypeParts.length>0){
+				return m_TypeParts[m_TypeParts.length-1];
+			}
+			return "";
+		}
+		public String getTypePartArgu(){
+			String replace="";
+		if (m_TypeParts.length>0){	
+		int i=	m_TypeParts.length/3;
+		for (int j=0;j<i;j++){
+			
+			replace	+=m_TypeParts[j*3+1]+" "+m_TypeParts[j*3+2]+",";
+			}
+		replace=replace.substring(0, replace.length()-1);
+			return replace;
+			
+		}
+		return replace;
+		}
+	}
+	/**  @note type string: procedure#[Parameters:name#type#direction] */
+	public class ProcedureElement extends VhdlSubprogram{
+		public ProcedureElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
+			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
+			m_ImageName="$nl$/icons/P.gif";		
+		}		
+	}
+	/**  @note type string: procedureDecl#[Parameters:name#type#direction] */
+	public class ProcedureDefElement extends VhdlSubprogram{
+		public ProcedureDefElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
+			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
+			m_ImageName="$nl$/icons/P.gif";		
+		}		
+	}
+	/**  @note type string: process#*/
+	public class ProcessElement extends VhdlOutlineElement{
+		public ProcessElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
+			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
+			m_ImageName="$nl$/icons/process.gif";
+			m_LongName=name+": process";
+			m_ShortName=m_LongName;
+		}		
+	}	
+	/**  @note type string: componentInst#[entity name] */
+	public class ComponentInstElement extends VhdlOutlineElement{
+		public ComponentInstElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
+			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
+			m_ImageName="$nl$/icons/green_tri.gif";			
+			m_LongName=String.format("%s : %s",name,GetEntityName());
+			m_ShortName=m_LongName;
+		}
+		public String GetEntityName(){			
+			if (m_TypeParts.length > 1){
+				return m_TypeParts[1];
+			}
+			else 
+				return "";
+		}
+	}
+	/**  @note type string: componentDecl# */
+	public class ComponentDeclElement extends VhdlOutlineElement{
+		public ComponentDeclElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
+			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
+			m_ImageName="$nl$/icons/blue_tri.gif";
+			m_LongName=name+" : component";
+			m_ShortName=name+" (cmp)";
+		}		
+	}
+	/**  @note type string: entityInst#[entity name] */
+	public class EntityInstElement extends VhdlOutlineElement{
+		public EntityInstElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
+			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
+			m_ImageName="$nl$/icons/gray_circ.gif";
+			m_LongName=name+" : "+GetEntityName();
+			m_ShortName=m_LongName;
+		}
+		public String GetEntityName(){			
+			if (m_TypeParts.length > 1){
+				return m_TypeParts[1];
+			}
+			else 
+				return "";
+		}
+	}
+	/**  @note type string: entityDecl# */
+	public class EntityDeclElement extends VhdlOutlineElement{
+		public EntityDeclElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
+			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
+			m_ImageName="$nl$/icons/gray_circ_small.gif";
+			m_LongName=name+" : entity" ;
+			m_ShortName=name+" (ent)";
+		}		
+	}
+	/**  @note type string: generic#[type] */
+	public class GenericElement extends VhdlOutlineElement{
+		public GenericElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
+			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
+			m_ImageName="$nl$/icons/generic.gif";
+			m_LongName=name+" : ";
+			if(m_TypeParts.length > 1){
+				m_LongName += m_TypeParts[1];
+			}
+			m_ShortName=m_LongName;
+		}		
+	}
+	/**  @note type string: signal#[type] */
+	public class VhdlSignalElement extends VhdlOutlineElement{
+		public VhdlSignalElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
+			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
+			m_ImageName="$nl$/icons/signal.gif";
+			m_LongName=name + " : " + GetSignalType() + getInitialValue();
+			m_ShortName=m_LongName;
+		}
+		public String GetSignalType(){
+			if(m_TypeParts.length > 1){
+				return m_TypeParts[1];
+			}
+			return "";
+		}
+
+		public String getInitialValue() {
+			if (m_TypeParts.length > 2) {
+				String m = ":=" + m_TypeParts[2];
+				return m;
+			}
+			return "";
+		}
+	}
+	/**  @note type string: variable#[type] */
+	public class VariableElement extends VhdlSignalElement{
+		public VariableElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
+			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
+			m_ImageName="$nl$/icons/variable_signal.gif";				
+		}
+	}
+	/**  @note type string: alias#[type] */
+	public class AliasElement extends VhdlSignalElement{
+		public AliasElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
+			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
+			m_ImageName="$nl$/icons/alias_signal.gif";				
+		}
+	}
+	/**  @note type string: constant#[type] */
+	public class ConstantElement extends VhdlSignalElement{
+		public ConstantElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
+			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
+			m_ImageName="$nl$/icons/constant_signal.gif";				
+		}
+	}
+	/**  @note type string: file# */
+	public class FileElement extends VhdlSignalElement{
+		public FileElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
+			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
+			m_ImageName="$nl$/icons/ar_obj.gif";				
+		}
+	}
+	public class TypeDecl extends VhdlOutlineElement{
+        public TypeDecl(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
+            super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
+            m_ImageName="$nl$/icons/type.gif";                
+        }
+    }
+	public class SubTypeDecl extends VhdlOutlineElement{
+        public SubTypeDecl(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
+            super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
+            m_ImageName="$nl$/icons/type.gif";                
+        }
+    }
+	/**  @note type string: port#[in,out,buffer,inout]#[type] */
+	public class VhdlPortElement extends VhdlOutlineElement{
+		public static final int INPUT	=0;
+		public static final int OUTPUT	=1;
+		public static final int INOUT	=2;
+		private int m_Direction;
+		
+		public String GetDirectionString(){
+			switch(m_Direction){
+			case INPUT:
+				return "in";
+			case OUTPUT:
+				return "out";
+			case INOUT:
+				return "inout";
+			default:
+				return "";
+			}
+		}
+		public VhdlPortElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
+			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
+			if(type.toLowerCase().startsWith("port#in#")){
+				m_Direction=INPUT;
+				m_ImageName="$nl$/icons/port_in.gif";
+			}
+			else if (type.toLowerCase().startsWith("port#out#")){
+				m_Direction = OUTPUT;
+				m_ImageName="$nl$/icons/port_out.gif";
+			}
+			else{
+				m_Direction = INOUT;
+				m_ImageName="$nl$/icons/port_inout.gif";
+			}	
+			m_LongName=String.format("Port %s %s : %s", GetDirectionString(),name,m_TypeParts[2]);
+			m_ShortName=String.format("%s : %s", name,m_TypeParts[2]);
+		}		
+	}
+	/**  @note type string: record# */
+	public class RecordMemberElement extends VhdlOutlineElement{
+		public RecordMemberElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file,boolean bVisible){
+			super(name,type,startLine,startCol,endLine,endCol,file,bVisible);
+			m_ImageName="$nl$/icons/obj.gif";		
+		}
+	}
+	
+	/**
+	 * Class Factory function
+	 */
+	public OutlineElement CreateElement(String name,String type,int startLine,int startCol,int endLine,int endCol,IFile file){		
+		if(isArchitecture(type)){
+			return new ArchitectureElement(name,type,startLine,startCol,endLine,endCol,file,true);
+		} else if (isPackageBody(type)){
+			return new PackageBodyElement(name,type,startLine,startCol,endLine,endCol,file,true);
+		}else if (isPackageDecl(type)){
+			return new PackageDeclElement(name,type,startLine,startCol,endLine,endCol,file,true);
+		}else if (isFunction(type)){
+			return new FunctionElement(name,type,startLine,startCol,endLine,endCol,file,true);
+		}else if (isFunctionDef(type)){
+			return new FunctionDefElement(name,type,startLine,startCol,endLine,endCol,file,true);
+		}else if (isProcedureDef(type)){
+			return new ProcedureDefElement(name,type,startLine,startCol,endLine,endCol,file,true);
+		}else if (isProcess(type)){
+			return new ProcessElement(name,type,startLine,startCol,endLine,endCol,file,true);
+		}else if (isProcedure(type)){
+			return new ProcedureElement(name,type,startLine,startCol,endLine,endCol,file,true);
+		}else if (isComponentDecl(type)){
+			return new ComponentDeclElement(name,type,startLine,startCol,endLine,endCol,file,true);
+		}else if (isComponentInst(type)){
+			return new ComponentInstElement(name,type,startLine,startCol,endLine,endCol,file,true);
+		}else if (isEntityDecl(type)){
+			return new EntityDeclElement(name,type,startLine,startCol,endLine,endCol,file,true);
+		}else if (isEntityInst(type)){
+			return new EntityInstElement(name,type,startLine,startCol,endLine,endCol,file,true);
+		}else if (isPort(type)){
+			return new VhdlPortElement(name,type,startLine,startCol,endLine,endCol,file,true);
+		}
+		else if (isGeneric(type)){
+			return new GenericElement(name,type,startLine,startCol,endLine,endCol,file,true);
+		}
+		else if (isSignal(type)){
+			return new VhdlSignalElement(name,type,startLine,startCol,endLine,endCol,file,true);
+		}
+		else if (isVariable(type)){
+			return new VariableElement(name,type,startLine,startCol,endLine,endCol,file,true);
+		}
+		else if (isConstant(type)){
+			return new ConstantElement(name,type,startLine,startCol,endLine,endCol,file,true);
+		}
+		else if (isAlias(type)){
+			return new AliasElement(name,type,startLine,startCol,endLine,endCol,file,true);
+		}
+		else if (isFile(type)){
+			return new FileElement(name,type,startLine,startCol,endLine,endCol,file,true);
+		}
+		else if (isRecordMember(type)){
+			return new RecordMemberElement(name,type,startLine,startCol,endLine,endCol,file,true);
+		}
+		else if (isTypeDecl(type)){
+            return new TypeDecl(name,type,startLine,startCol,endLine,endCol,file,true);
+        }
+		else if (isSubTypeDecl(type)){
+			return new SubTypeDecl(name,type,startLine,startCol,endLine,endCol,file,true);
+        }
+		
+		
+		
+		//default case
+		return new OutlineElement(name,type,startLine,startCol,endLine,endCol,file,true);
+	}
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/VhdlParserCoreTreeConstants.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/VhdlParserCoreTreeConstants.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/VhdlParserCoreTreeConstants.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/VhdlParserCoreTreeConstants.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,383 +1,383 @@
-/* Generated By:JavaCC: Do not edit this line. VhdlParserCoreTreeConstants.java Version 5.0 */
-package net.sourceforge.veditor.parser.vhdl;
-
-public interface VhdlParserCoreTreeConstants
-{
-  public int JJTVOID = 0;
-  public int JJTACTUAL_PART = 1;
-  public int JJTAGGREGATE = 2;
-  public int JJTALIAS_DECLARATION = 3;
-  public int JJTALIAS_DESIGNATOR = 4;
-  public int JJTALLOCATOR = 5;
-  public int JJTARCHITECTURE_BODY = 6;
-  public int JJTARCHITECTURE_DECLARATIVE_PART = 7;
-  public int JJTARCHITECTURE_STATEMENT_PART = 8;
-  public int JJTUNCONSTRAINED_NATURE_DEFINITION = 9;
-  public int JJTCONSTRAINED_NATURE_DEFINITION = 10;
-  public int JJTASSERTION = 11;
-  public int JJTASSERTION_STATEMENT = 12;
-  public int JJTASSOCIATION_ELEMENT = 13;
-  public int JJTASSOCIATION_LIST = 14;
-  public int JJTATTRIBUTE_DECLARATION = 15;
-  public int JJTATTRIBUTE_NAME = 16;
-  public int JJTATTRIBUTE_SPECIFICATION = 17;
-  public int JJTBINDING_INDICATION = 18;
-  public int JJTBLOCK_CONFIGURATION = 19;
-  public int JJTBLOCK_DECLARATIVE_PART = 20;
-  public int JJTBLOCK_HEADER = 21;
-  public int JJTBLOCK_SPECIFICATION = 22;
-  public int JJTBLOCK_STATEMENT = 23;
-  public int JJTBLOCK_STATEMENT_PART = 24;
-  public int JJTBREAK_STATEMENT = 25;
-  public int JJTBREAK_LIST = 26;
-  public int JJTBREAK_ELEMENT = 27;
-  public int JJTCASE_STATEMENT = 28;
-  public int JJTCASE_STATEMENT_ALTERNATIVE = 29;
-  public int JJTCHOICE = 30;
-  public int JJTCHOICES = 31;
-  public int JJTCOMPONENT_CONFIGURATION = 32;
-  public int JJTCOMPONENT_DECLARATION = 33;
-  public int JJTCOMPONENT_INSTANTIATION_STATEMENT = 34;
-  public int JJTCOMPONENT_SPECIFICATION = 35;
-  public int JJTCOMPOSITE_TYPE_DEFINITION = 36;
-  public int JJTCONCURRENT_ASSERTION_STATEMENT = 37;
-  public int JJTCONCURRENT_PROCEDURE_CALL_STATEMENT = 38;
-  public int JJTCONCURRENT_SIGNAL_ASSIGNMENT_STATEMENT = 39;
-  public int JJTCONDITIONAL_SIGNAL_ASSIGNMENT = 40;
-  public int JJTCONDITIONAL_WAVEFORMS = 41;
-  public int JJTCONFIGURATION_DECLARATION = 42;
-  public int JJTCONFIGURATION_DECLARATIVE_PART = 43;
-  public int JJTCONFIGURATION_SPECIFICATION = 44;
-  public int JJTCONSTANT_DECLARATION = 45;
-  public int JJTCONSTRAINED_ARRAY_DEFINITION = 46;
-  public int JJTCONTEXT_CLAUSE = 47;
-  public int JJTTERMINAL_DECLARATION = 48;
-  public int JJTTERMINAL_ASPECT = 49;
-  public int JJTDELAY_MECHANISM = 50;
-  public int JJTDESIGN_FILE = 51;
-  public int JJTDESIGN_UNIT = 52;
-  public int JJTDIRECTION = 53;
-  public int JJTDISCONNECTION_SPECIFICATION = 54;
-  public int JJTELEMENT_DECLARATION = 55;
-  public int JJTENTITY_ASPECT = 56;
-  public int JJTENTITY_CLASS_ENTRY = 57;
-  public int JJTENTITY_CLASS_ENTRY_LIST = 58;
-  public int JJTENTITY_DECLARATION = 59;
-  public int JJTNATURE_DECLARATION = 60;
-  public int JJTSUBNATURE_DECLARATION = 61;
-  public int JJTSUBNATURE_INDICATION = 62;
-  public int JJTENTITY_DECLARATIVE_PART = 63;
-  public int JJTENTITY_DESIGNATOR = 64;
-  public int JJTENTITY_HEADER = 65;
-  public int JJTENTITY_NAME_LIST = 66;
-  public int JJTENTITY_SPECIFICATION = 67;
-  public int JJTENTITY_STATEMENT_PART = 68;
-  public int JJTENTITY_TAG = 69;
-  public int JJTENUMERATION_LITERAL = 70;
-  public int JJTENUMERATION_TYPE_DEFINITION = 71;
-  public int JJTEXIT_STATEMENT = 72;
-  public int JJTRELATION = 73;
-  public int JJTFACTOR = 74;
-  public int JJTFILE_DECLARATION = 75;
-  public int JJTFILE_OPEN_INFORMATION = 76;
-  public int JJTFORMAL_PARAMETER_LIST = 77;
-  public int JJTFULL_TYPE_DECLARATION = 78;
-  public int JJTFUNCTION_CALL = 79;
-  public int JJTGENERATE_STATEMENT = 80;
-  public int JJTCONCURRENT_BREAK_STATEMENT = 81;
-  public int JJTGENERATION_SCHEME = 82;
-  public int JJTGENERIC_CLAUSE = 83;
-  public int JJTGROUP_CONSTITUENT = 84;
-  public int JJTGROUP_CONSTITUENT_LIST = 85;
-  public int JJTGROUP_TEMPLATE_DECLARATION = 86;
-  public int JJTGROUP_DECLARATION = 87;
-  public int JJTGUARDED_SIGNAL_SPECIFICATION = 88;
-  public int JJTIDENTIFIER = 89;
-  public int JJTIDENTIFIER_LIST = 90;
-  public int JJTIF_STATEMENT = 91;
-  public int JJTINCOMPLETE_TYPE_DECLARATION = 92;
-  public int JJTINDEX_CONSTRAINT = 93;
-  public int JJTINDEX_SPECIFICATION = 94;
-  public int JJTINDEX_SUBTYPE_DEFINITION = 95;
-  public int JJTINDEXED_NAME = 96;
-  public int JJTINSTANTIATED_UNIT = 97;
-  public int JJTINSTANTIATION_LIST = 98;
-  public int JJTINTERFACE_CONSTANT_DECLARATION = 99;
-  public int JJTINTERFACE_TERMINAL_DECLARATION = 100;
-  public int JJTINTERFACE_QUANTITY_DECLARATION = 101;
-  public int JJTINTERFACE_FILE_DECLARATION = 102;
-  public int JJTINTERFACE_LIST = 103;
-  public int JJTINTERFACE_SIGNAL_DECLARATION = 104;
-  public int JJTINTERFACE_VARIABLE_DECLARATION = 105;
-  public int JJTITERATION_SCHEME = 106;
-  public int JJTLITERAL = 107;
-  public int JJTLOGICAL_NAME_LIST = 108;
-  public int JJTLOOP_STATEMENT = 109;
-  public int JJTMODE = 110;
-  public int JJTNAME = 111;
-  public int JJTNATURE_ELEMENT_DECLARATION = 112;
-  public int JJTNEXT_STATEMENT = 113;
-  public int JJTNULL_STATEMENT = 114;
-  public int JJTOPERATOR_SYMBOL = 115;
-  public int JJTOPTIONS_ = 116;
-  public int JJTPACKAGE_BODY = 117;
-  public int JJTPACKAGE_BODY_DECLARATIVE_PART = 118;
-  public int JJTPACKAGE_DECLARATION = 119;
-  public int JJTPACKAGE_DECLARATIVE_PART = 120;
-  public int JJTPARAMETER_SPECIFICATION = 121;
-  public int JJTPHYSICAL_LITERAL = 122;
-  public int JJTPHYSICAL_TYPE_DEFINITION = 123;
-  public int JJTPORT_CLAUSE = 124;
-  public int JJTPORT_MAP_ASPECT = 125;
-  public int JJTPREFIX = 126;
-  public int JJTPROCEDURE_CALL = 127;
-  public int JJTPROCEDURE_CALL_STATEMENT = 128;
-  public int JJTPROCESS_DECLARATIVE_PART = 129;
-  public int JJTPROCESS_STATEMENT = 130;
-  public int JJTPROCESS_STATEMENT_PART = 131;
-  public int JJTQUALIFIED_EXPRESSION = 132;
-  public int JJTRANGE = 133;
-  public int JJTRECORD_NATURE_DEFINITION = 134;
-  public int JJTRECORD_TYPE_DEFINITION = 135;
-  public int JJTSHIFT_EXPRESSION = 136;
-  public int JJTREPORT_STATEMENT = 137;
-  public int JJTRETURN_STATEMENT = 138;
-  public int JJTSCALAR_NATURE_DEFINITION = 139;
-  public int JJTSECONDARY_UNIT_DECLARATION = 140;
-  public int JJTSELECTED_NAME = 141;
-  public int JJTSELECTED_SIGNAL_ASSIGNMENT = 142;
-  public int JJTSELECTED_WAVEFORMS = 143;
-  public int JJTSENSITIVITY_LIST = 144;
-  public int JJTSEQUENCE_OF_STATEMENTS = 145;
-  public int JJTSIMPLE_EXPRESSION = 146;
-  public int JJTSIGN = 147;
-  public int JJTSIGNAL_ASSIGNMENT_STATEMENT = 148;
-  public int JJTSIGNAL_DECLARATION = 149;
-  public int JJTSIGNAL_KIND = 150;
-  public int JJTSIGNAL_LIST = 151;
-  public int JJTSIGNATURE = 152;
-  public int JJTTERM = 153;
-  public int JJTSLICE_NAME = 154;
-  public int JJTSUBPROGRAM_BODY = 155;
-  public int JJTSUBPROGRAM_DECLARATIVE_PART = 156;
-  public int JJTSUBPROGRAM_SPECIFICATION = 157;
-  public int JJTSUBPROGRAM_STATEMENT_PART = 158;
-  public int JJTSUBTYPE_DECLARATION = 159;
-  public int JJTSUBTYPE_INDICATION = 160;
-  public int JJTFREE_QUANTITY_DECLARATION = 161;
-  public int JJTBRANCH_QUANTITY_DECLARATION = 162;
-  public int JJTSOURCE_QUANTITY_DECLARATION = 163;
-  public int JJTACROSS_ASPECT = 164;
-  public int JJTTHROUGH_ASPECT = 165;
-  public int JJTSOURCE_ASPECT = 166;
-  public int JJTTYPE_CONVERSION = 167;
-  public int JJTUNCONSTRAINED_ARRAY_DEFINITION = 168;
-  public int JJTUSE_CLAUSE = 169;
-  public int JJTVARIABLE_ASSIGNMENT_STATEMENT = 170;
-  public int JJTVARIABLE_DECLARATION = 171;
-  public int JJTWAIT_STATEMENT = 172;
-  public int JJTWAVEFORM = 173;
-  public int JJTWAVEFORM_ELEMENT = 174;
-  public int JJTSIMULTANEOUS_STATEMENT_PART = 175;
-  public int JJTSIMPLE_SIMULTANEOUS_STATEMENT = 176;
-  public int JJTSIMULTANEOUS_IF_STATEMENT = 177;
-  public int JJTSIMULTANEOUS_CASE_STATEMENT = 178;
-  public int JJTSIMULTANEOUS_ALTERNATIVE = 179;
-  public int JJTSIMULTANEOUS_PROCEDURAL_STATEMENT = 180;
-  public int JJTPROCEDURAL_DECLARATIVE_PART = 181;
-  public int JJTPROCEDURAL_STATEMENT_PART = 182;
-  public int JJTSIMULTANEOUS_NULL_STATEMENT = 183;
-  public int JJTSHARED_VARIABLE_DECLARATION = 184;
-  public int JJTERROR_SKIPTO = 185;
-
-
-  public String[] jjtNodeName = {
-    "void",
-    "actual_part",
-    "aggregate",
-    "alias_declaration",
-    "alias_designator",
-    "allocator",
-    "architecture_body",
-    "architecture_declarative_part",
-    "architecture_statement_part",
-    "unconstrained_nature_definition",
-    "constrained_nature_definition",
-    "assertion",
-    "assertion_statement",
-    "association_element",
-    "association_list",
-    "attribute_declaration",
-    "attribute_name",
-    "attribute_specification",
-    "binding_indication",
-    "block_configuration",
-    "block_declarative_part",
-    "block_header",
-    "block_specification",
-    "block_statement",
-    "block_statement_part",
-    "break_statement",
-    "break_list",
-    "break_element",
-    "case_statement",
-    "case_statement_alternative",
-    "choice",
-    "choices",
-    "component_configuration",
-    "component_declaration",
-    "component_instantiation_statement",
-    "component_specification",
-    "composite_type_definition",
-    "concurrent_assertion_statement",
-    "concurrent_procedure_call_statement",
-    "concurrent_signal_assignment_statement",
-    "conditional_signal_assignment",
-    "conditional_waveforms",
-    "configuration_declaration",
-    "configuration_declarative_part",
-    "configuration_specification",
-    "constant_declaration",
-    "constrained_array_definition",
-    "context_clause",
-    "terminal_declaration",
-    "terminal_aspect",
-    "delay_mechanism",
-    "design_file",
-    "design_unit",
-    "direction",
-    "disconnection_specification",
-    "element_declaration",
-    "entity_aspect",
-    "entity_class_entry",
-    "entity_class_entry_list",
-    "entity_declaration",
-    "nature_declaration",
-    "subnature_declaration",
-    "subnature_indication",
-    "entity_declarative_part",
-    "entity_designator",
-    "entity_header",
-    "entity_name_list",
-    "entity_specification",
-    "entity_statement_part",
-    "entity_tag",
-    "enumeration_literal",
-    "enumeration_type_definition",
-    "exit_statement",
-    "relation",
-    "factor",
-    "file_declaration",
-    "file_open_information",
-    "formal_parameter_list",
-    "full_type_declaration",
-    "function_call",
-    "generate_statement",
-    "concurrent_break_statement",
-    "generation_scheme",
-    "generic_clause",
-    "group_constituent",
-    "group_constituent_list",
-    "group_template_declaration",
-    "group_declaration",
-    "guarded_signal_specification",
-    "identifier",
-    "identifier_list",
-    "if_statement",
-    "incomplete_type_declaration",
-    "index_constraint",
-    "index_specification",
-    "index_subtype_definition",
-    "indexed_name",
-    "instantiated_unit",
-    "instantiation_list",
-    "interface_constant_declaration",
-    "interface_terminal_declaration",
-    "interface_quantity_declaration",
-    "interface_file_declaration",
-    "interface_list",
-    "interface_signal_declaration",
-    "interface_variable_declaration",
-    "iteration_scheme",
-    "literal",
-    "logical_name_list",
-    "loop_statement",
-    "mode",
-    "name",
-    "nature_element_declaration",
-    "next_statement",
-    "null_statement",
-    "operator_symbol",
-    "options_",
-    "package_body",
-    "package_body_declarative_part",
-    "package_declaration",
-    "package_declarative_part",
-    "parameter_specification",
-    "physical_literal",
-    "physical_type_definition",
-    "port_clause",
-    "port_map_aspect",
-    "prefix",
-    "procedure_call",
-    "procedure_call_statement",
-    "process_declarative_part",
-    "process_statement",
-    "process_statement_part",
-    "qualified_expression",
-    "range",
-    "record_nature_definition",
-    "record_type_definition",
-    "shift_expression",
-    "report_statement",
-    "return_statement",
-    "scalar_nature_definition",
-    "secondary_unit_declaration",
-    "selected_name",
-    "selected_signal_assignment",
-    "selected_waveforms",
-    "sensitivity_list",
-    "sequence_of_statements",
-    "simple_expression",
-    "sign",
-    "signal_assignment_statement",
-    "signal_declaration",
-    "signal_kind",
-    "signal_list",
-    "signature",
-    "term",
-    "slice_name",
-    "subprogram_body",
-    "subprogram_declarative_part",
-    "subprogram_specification",
-    "subprogram_statement_part",
-    "subtype_declaration",
-    "subtype_indication",
-    "free_quantity_declaration",
-    "branch_quantity_declaration",
-    "source_quantity_declaration",
-    "across_aspect",
-    "through_aspect",
-    "source_aspect",
-    "type_conversion",
-    "unconstrained_array_definition",
-    "use_clause",
-    "variable_assignment_statement",
-    "variable_declaration",
-    "wait_statement",
-    "waveform",
-    "waveform_element",
-    "simultaneous_statement_part",
-    "simple_simultaneous_statement",
-    "simultaneous_if_statement",
-    "simultaneous_case_statement",
-    "simultaneous_alternative",
-    "simultaneous_procedural_statement",
-    "procedural_declarative_part",
-    "procedural_statement_part",
-    "simultaneous_null_statement",
-    "shared_variable_declaration",
-    "error_skipto",
-  };
-}
-/* JavaCC - OriginalChecksum=6a08b8a828aeb2581136b0ad42861a49 (do not edit this line) */
+/* Generated By:JavaCC: Do not edit this line. VhdlParserCoreTreeConstants.java Version 6.0_1 */
+package com.elphel.vdt.veditor.parser.vhdl;
+
+public interface VhdlParserCoreTreeConstants
+{
+  public int JJTVOID = 0;
+  public int JJTACTUAL_PART = 1;
+  public int JJTAGGREGATE = 2;
+  public int JJTALIAS_DECLARATION = 3;
+  public int JJTALIAS_DESIGNATOR = 4;
+  public int JJTALLOCATOR = 5;
+  public int JJTARCHITECTURE_BODY = 6;
+  public int JJTARCHITECTURE_DECLARATIVE_PART = 7;
+  public int JJTARCHITECTURE_STATEMENT_PART = 8;
+  public int JJTUNCONSTRAINED_NATURE_DEFINITION = 9;
+  public int JJTCONSTRAINED_NATURE_DEFINITION = 10;
+  public int JJTASSERTION = 11;
+  public int JJTASSERTION_STATEMENT = 12;
+  public int JJTASSOCIATION_ELEMENT = 13;
+  public int JJTASSOCIATION_LIST = 14;
+  public int JJTATTRIBUTE_DECLARATION = 15;
+  public int JJTATTRIBUTE_NAME = 16;
+  public int JJTATTRIBUTE_SPECIFICATION = 17;
+  public int JJTBINDING_INDICATION = 18;
+  public int JJTBLOCK_CONFIGURATION = 19;
+  public int JJTBLOCK_DECLARATIVE_PART = 20;
+  public int JJTBLOCK_HEADER = 21;
+  public int JJTBLOCK_SPECIFICATION = 22;
+  public int JJTBLOCK_STATEMENT = 23;
+  public int JJTBLOCK_STATEMENT_PART = 24;
+  public int JJTBREAK_STATEMENT = 25;
+  public int JJTBREAK_LIST = 26;
+  public int JJTBREAK_ELEMENT = 27;
+  public int JJTCASE_STATEMENT = 28;
+  public int JJTCASE_STATEMENT_ALTERNATIVE = 29;
+  public int JJTCHOICE = 30;
+  public int JJTCHOICES = 31;
+  public int JJTCOMPONENT_CONFIGURATION = 32;
+  public int JJTCOMPONENT_DECLARATION = 33;
+  public int JJTCOMPONENT_INSTANTIATION_STATEMENT = 34;
+  public int JJTCOMPONENT_SPECIFICATION = 35;
+  public int JJTCOMPOSITE_TYPE_DEFINITION = 36;
+  public int JJTCONCURRENT_ASSERTION_STATEMENT = 37;
+  public int JJTCONCURRENT_PROCEDURE_CALL_STATEMENT = 38;
+  public int JJTCONCURRENT_SIGNAL_ASSIGNMENT_STATEMENT = 39;
+  public int JJTCONDITIONAL_SIGNAL_ASSIGNMENT = 40;
+  public int JJTCONDITIONAL_WAVEFORMS = 41;
+  public int JJTCONFIGURATION_DECLARATION = 42;
+  public int JJTCONFIGURATION_DECLARATIVE_PART = 43;
+  public int JJTCONFIGURATION_SPECIFICATION = 44;
+  public int JJTCONSTANT_DECLARATION = 45;
+  public int JJTCONSTRAINED_ARRAY_DEFINITION = 46;
+  public int JJTCONTEXT_CLAUSE = 47;
+  public int JJTTERMINAL_DECLARATION = 48;
+  public int JJTTERMINAL_ASPECT = 49;
+  public int JJTDELAY_MECHANISM = 50;
+  public int JJTDESIGN_FILE = 51;
+  public int JJTDESIGN_UNIT = 52;
+  public int JJTDIRECTION = 53;
+  public int JJTDISCONNECTION_SPECIFICATION = 54;
+  public int JJTELEMENT_DECLARATION = 55;
+  public int JJTENTITY_ASPECT = 56;
+  public int JJTENTITY_CLASS_ENTRY = 57;
+  public int JJTENTITY_CLASS_ENTRY_LIST = 58;
+  public int JJTENTITY_DECLARATION = 59;
+  public int JJTNATURE_DECLARATION = 60;
+  public int JJTSUBNATURE_DECLARATION = 61;
+  public int JJTSUBNATURE_INDICATION = 62;
+  public int JJTENTITY_DECLARATIVE_PART = 63;
+  public int JJTENTITY_DESIGNATOR = 64;
+  public int JJTENTITY_HEADER = 65;
+  public int JJTENTITY_NAME_LIST = 66;
+  public int JJTENTITY_SPECIFICATION = 67;
+  public int JJTENTITY_STATEMENT_PART = 68;
+  public int JJTENTITY_TAG = 69;
+  public int JJTENUMERATION_LITERAL = 70;
+  public int JJTENUMERATION_TYPE_DEFINITION = 71;
+  public int JJTEXIT_STATEMENT = 72;
+  public int JJTRELATION = 73;
+  public int JJTFACTOR = 74;
+  public int JJTFILE_DECLARATION = 75;
+  public int JJTFILE_OPEN_INFORMATION = 76;
+  public int JJTFORMAL_PARAMETER_LIST = 77;
+  public int JJTFULL_TYPE_DECLARATION = 78;
+  public int JJTFUNCTION_CALL = 79;
+  public int JJTGENERATE_STATEMENT = 80;
+  public int JJTCONCURRENT_BREAK_STATEMENT = 81;
+  public int JJTGENERATION_SCHEME = 82;
+  public int JJTGENERIC_CLAUSE = 83;
+  public int JJTGROUP_CONSTITUENT = 84;
+  public int JJTGROUP_CONSTITUENT_LIST = 85;
+  public int JJTGROUP_TEMPLATE_DECLARATION = 86;
+  public int JJTGROUP_DECLARATION = 87;
+  public int JJTGUARDED_SIGNAL_SPECIFICATION = 88;
+  public int JJTIDENTIFIER = 89;
+  public int JJTIDENTIFIER_LIST = 90;
+  public int JJTIF_STATEMENT = 91;
+  public int JJTINCOMPLETE_TYPE_DECLARATION = 92;
+  public int JJTINDEX_CONSTRAINT = 93;
+  public int JJTINDEX_SPECIFICATION = 94;
+  public int JJTINDEX_SUBTYPE_DEFINITION = 95;
+  public int JJTINDEXED_NAME = 96;
+  public int JJTINSTANTIATED_UNIT = 97;
+  public int JJTINSTANTIATION_LIST = 98;
+  public int JJTINTERFACE_CONSTANT_DECLARATION = 99;
+  public int JJTINTERFACE_TERMINAL_DECLARATION = 100;
+  public int JJTINTERFACE_QUANTITY_DECLARATION = 101;
+  public int JJTINTERFACE_FILE_DECLARATION = 102;
+  public int JJTINTERFACE_LIST = 103;
+  public int JJTINTERFACE_SIGNAL_DECLARATION = 104;
+  public int JJTINTERFACE_VARIABLE_DECLARATION = 105;
+  public int JJTITERATION_SCHEME = 106;
+  public int JJTLITERAL = 107;
+  public int JJTLOGICAL_NAME_LIST = 108;
+  public int JJTLOOP_STATEMENT = 109;
+  public int JJTMODE = 110;
+  public int JJTNAME = 111;
+  public int JJTNATURE_ELEMENT_DECLARATION = 112;
+  public int JJTNEXT_STATEMENT = 113;
+  public int JJTNULL_STATEMENT = 114;
+  public int JJTOPERATOR_SYMBOL = 115;
+  public int JJTOPTIONS_ = 116;
+  public int JJTPACKAGE_BODY = 117;
+  public int JJTPACKAGE_BODY_DECLARATIVE_PART = 118;
+  public int JJTPACKAGE_DECLARATION = 119;
+  public int JJTPACKAGE_DECLARATIVE_PART = 120;
+  public int JJTPARAMETER_SPECIFICATION = 121;
+  public int JJTPHYSICAL_LITERAL = 122;
+  public int JJTPHYSICAL_TYPE_DEFINITION = 123;
+  public int JJTPORT_CLAUSE = 124;
+  public int JJTPORT_MAP_ASPECT = 125;
+  public int JJTPREFIX = 126;
+  public int JJTPROCEDURE_CALL = 127;
+  public int JJTPROCEDURE_CALL_STATEMENT = 128;
+  public int JJTPROCESS_DECLARATIVE_PART = 129;
+  public int JJTPROCESS_STATEMENT = 130;
+  public int JJTPROCESS_STATEMENT_PART = 131;
+  public int JJTQUALIFIED_EXPRESSION = 132;
+  public int JJTRANGE = 133;
+  public int JJTRECORD_NATURE_DEFINITION = 134;
+  public int JJTRECORD_TYPE_DEFINITION = 135;
+  public int JJTSHIFT_EXPRESSION = 136;
+  public int JJTREPORT_STATEMENT = 137;
+  public int JJTRETURN_STATEMENT = 138;
+  public int JJTSCALAR_NATURE_DEFINITION = 139;
+  public int JJTSECONDARY_UNIT_DECLARATION = 140;
+  public int JJTSELECTED_NAME = 141;
+  public int JJTSELECTED_SIGNAL_ASSIGNMENT = 142;
+  public int JJTSELECTED_WAVEFORMS = 143;
+  public int JJTSENSITIVITY_LIST = 144;
+  public int JJTSEQUENCE_OF_STATEMENTS = 145;
+  public int JJTSIMPLE_EXPRESSION = 146;
+  public int JJTSIGN = 147;
+  public int JJTSIGNAL_ASSIGNMENT_STATEMENT = 148;
+  public int JJTSIGNAL_DECLARATION = 149;
+  public int JJTSIGNAL_KIND = 150;
+  public int JJTSIGNAL_LIST = 151;
+  public int JJTSIGNATURE = 152;
+  public int JJTTERM = 153;
+  public int JJTSLICE_NAME = 154;
+  public int JJTSUBPROGRAM_BODY = 155;
+  public int JJTSUBPROGRAM_DECLARATIVE_PART = 156;
+  public int JJTSUBPROGRAM_SPECIFICATION = 157;
+  public int JJTSUBPROGRAM_STATEMENT_PART = 158;
+  public int JJTSUBTYPE_DECLARATION = 159;
+  public int JJTSUBTYPE_INDICATION = 160;
+  public int JJTFREE_QUANTITY_DECLARATION = 161;
+  public int JJTBRANCH_QUANTITY_DECLARATION = 162;
+  public int JJTSOURCE_QUANTITY_DECLARATION = 163;
+  public int JJTACROSS_ASPECT = 164;
+  public int JJTTHROUGH_ASPECT = 165;
+  public int JJTSOURCE_ASPECT = 166;
+  public int JJTTYPE_CONVERSION = 167;
+  public int JJTUNCONSTRAINED_ARRAY_DEFINITION = 168;
+  public int JJTUSE_CLAUSE = 169;
+  public int JJTVARIABLE_ASSIGNMENT_STATEMENT = 170;
+  public int JJTVARIABLE_DECLARATION = 171;
+  public int JJTWAIT_STATEMENT = 172;
+  public int JJTWAVEFORM = 173;
+  public int JJTWAVEFORM_ELEMENT = 174;
+  public int JJTSIMULTANEOUS_STATEMENT_PART = 175;
+  public int JJTSIMPLE_SIMULTANEOUS_STATEMENT = 176;
+  public int JJTSIMULTANEOUS_IF_STATEMENT = 177;
+  public int JJTSIMULTANEOUS_CASE_STATEMENT = 178;
+  public int JJTSIMULTANEOUS_ALTERNATIVE = 179;
+  public int JJTSIMULTANEOUS_PROCEDURAL_STATEMENT = 180;
+  public int JJTPROCEDURAL_DECLARATIVE_PART = 181;
+  public int JJTPROCEDURAL_STATEMENT_PART = 182;
+  public int JJTSIMULTANEOUS_NULL_STATEMENT = 183;
+  public int JJTSHARED_VARIABLE_DECLARATION = 184;
+  public int JJTERROR_SKIPTO = 185;
+
+
+  public String[] jjtNodeName = {
+    "void",
+    "actual_part",
+    "aggregate",
+    "alias_declaration",
+    "alias_designator",
+    "allocator",
+    "architecture_body",
+    "architecture_declarative_part",
+    "architecture_statement_part",
+    "unconstrained_nature_definition",
+    "constrained_nature_definition",
+    "assertion",
+    "assertion_statement",
+    "association_element",
+    "association_list",
+    "attribute_declaration",
+    "attribute_name",
+    "attribute_specification",
+    "binding_indication",
+    "block_configuration",
+    "block_declarative_part",
+    "block_header",
+    "block_specification",
+    "block_statement",
+    "block_statement_part",
+    "break_statement",
+    "break_list",
+    "break_element",
+    "case_statement",
+    "case_statement_alternative",
+    "choice",
+    "choices",
+    "component_configuration",
+    "component_declaration",
+    "component_instantiation_statement",
+    "component_specification",
+    "composite_type_definition",
+    "concurrent_assertion_statement",
+    "concurrent_procedure_call_statement",
+    "concurrent_signal_assignment_statement",
+    "conditional_signal_assignment",
+    "conditional_waveforms",
+    "configuration_declaration",
+    "configuration_declarative_part",
+    "configuration_specification",
+    "constant_declaration",
+    "constrained_array_definition",
+    "context_clause",
+    "terminal_declaration",
+    "terminal_aspect",
+    "delay_mechanism",
+    "design_file",
+    "design_unit",
+    "direction",
+    "disconnection_specification",
+    "element_declaration",
+    "entity_aspect",
+    "entity_class_entry",
+    "entity_class_entry_list",
+    "entity_declaration",
+    "nature_declaration",
+    "subnature_declaration",
+    "subnature_indication",
+    "entity_declarative_part",
+    "entity_designator",
+    "entity_header",
+    "entity_name_list",
+    "entity_specification",
+    "entity_statement_part",
+    "entity_tag",
+    "enumeration_literal",
+    "enumeration_type_definition",
+    "exit_statement",
+    "relation",
+    "factor",
+    "file_declaration",
+    "file_open_information",
+    "formal_parameter_list",
+    "full_type_declaration",
+    "function_call",
+    "generate_statement",
+    "concurrent_break_statement",
+    "generation_scheme",
+    "generic_clause",
+    "group_constituent",
+    "group_constituent_list",
+    "group_template_declaration",
+    "group_declaration",
+    "guarded_signal_specification",
+    "identifier",
+    "identifier_list",
+    "if_statement",
+    "incomplete_type_declaration",
+    "index_constraint",
+    "index_specification",
+    "index_subtype_definition",
+    "indexed_name",
+    "instantiated_unit",
+    "instantiation_list",
+    "interface_constant_declaration",
+    "interface_terminal_declaration",
+    "interface_quantity_declaration",
+    "interface_file_declaration",
+    "interface_list",
+    "interface_signal_declaration",
+    "interface_variable_declaration",
+    "iteration_scheme",
+    "literal",
+    "logical_name_list",
+    "loop_statement",
+    "mode",
+    "name",
+    "nature_element_declaration",
+    "next_statement",
+    "null_statement",
+    "operator_symbol",
+    "options_",
+    "package_body",
+    "package_body_declarative_part",
+    "package_declaration",
+    "package_declarative_part",
+    "parameter_specification",
+    "physical_literal",
+    "physical_type_definition",
+    "port_clause",
+    "port_map_aspect",
+    "prefix",
+    "procedure_call",
+    "procedure_call_statement",
+    "process_declarative_part",
+    "process_statement",
+    "process_statement_part",
+    "qualified_expression",
+    "range",
+    "record_nature_definition",
+    "record_type_definition",
+    "shift_expression",
+    "report_statement",
+    "return_statement",
+    "scalar_nature_definition",
+    "secondary_unit_declaration",
+    "selected_name",
+    "selected_signal_assignment",
+    "selected_waveforms",
+    "sensitivity_list",
+    "sequence_of_statements",
+    "simple_expression",
+    "sign",
+    "signal_assignment_statement",
+    "signal_declaration",
+    "signal_kind",
+    "signal_list",
+    "signature",
+    "term",
+    "slice_name",
+    "subprogram_body",
+    "subprogram_declarative_part",
+    "subprogram_specification",
+    "subprogram_statement_part",
+    "subtype_declaration",
+    "subtype_indication",
+    "free_quantity_declaration",
+    "branch_quantity_declaration",
+    "source_quantity_declaration",
+    "across_aspect",
+    "through_aspect",
+    "source_aspect",
+    "type_conversion",
+    "unconstrained_array_definition",
+    "use_clause",
+    "variable_assignment_statement",
+    "variable_declaration",
+    "wait_statement",
+    "waveform",
+    "waveform_element",
+    "simultaneous_statement_part",
+    "simple_simultaneous_statement",
+    "simultaneous_if_statement",
+    "simultaneous_case_statement",
+    "simultaneous_alternative",
+    "simultaneous_procedural_statement",
+    "procedural_declarative_part",
+    "procedural_statement_part",
+    "simultaneous_null_statement",
+    "shared_variable_declaration",
+    "error_skipto",
+  };
+}
+/* JavaCC - OriginalChecksum=3854802080c3977455449e5231b1044a (do not edit this line) */
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/VhdlParser.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/VhdlParser.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/VhdlParser.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/VhdlParser.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,857 +1,873 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-
-package net.sourceforge.veditor.parser.vhdl;
-
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.Vector;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-import net.sourceforge.veditor.VerilogPlugin;
-import net.sourceforge.veditor.parser.HdlParserException;
-import net.sourceforge.veditor.parser.IParser;
-import net.sourceforge.veditor.parser.OutlineContainer;
-import net.sourceforge.veditor.parser.OutlineDatabase;
-import net.sourceforge.veditor.parser.OutlineElementFactory;
-import net.sourceforge.veditor.parser.OutlineContainer.Collapsible;
-import net.sourceforge.veditor.parser.ParserReader;
-import net.sourceforge.veditor.parser.vhdl.ASTsubtype_declaration;
-import net.sourceforge.veditor.parser.vhdl.ASTsubtype_indication;
-import net.sourceforge.veditor.parser.vhdl.VhdlParserCore;
-import net.sourceforge.veditor.preference.PreferenceStrings;
-import net.sourceforge.veditor.semanticwarnings.SemanticWarnings;
-
-import org.eclipse.core.resources.IFile;
-import org.eclipse.core.resources.IMarker;
-import org.eclipse.core.resources.IProject;
-import org.eclipse.core.runtime.CoreException;
-
-/**
- * implementation class of VhdlParserCore<p/>
- * for separating definition from JavaCC code
- */
-public class VhdlParser implements IParser
-{
-	private IFile m_File;
-	private ParserReader m_Reader;
-	private static OutlineElementFactory m_OutlineElementFactory=new VhdlOutlineElementFactory();
-	//Minimum number of comment lines before they are collapsible
-	private final int COMMENT_LINE_GROUP=5;
-	private int m_StartCommentBlock;
-	private int m_LastCommentLine;
-	private int m_EndCommentBlock;
-	private int m_synopsisTranslateOff;
-	private OutlineContainer m_OutlineContainer;
-	private Pattern[] taskTokenPattern;
-	private Vector<Integer> m_lineOffsets;
-	
-	private VHDLParserThread parser;
-
-
-	public VhdlParser(ParserReader reader, IProject project, IFile file)
-	{
-		m_Reader = reader;
-		m_File = file;	
-		m_LastCommentLine=-1;
-		m_synopsisTranslateOff=-1;
-		OutlineDatabase database = OutlineDatabase.getProjectsDatabase(project);		
-		if(database != null){
-			m_OutlineContainer = database.getOutlineContainer(file);
-		}
-		parser = new VHDLParserThread(m_Reader,m_File);
-		
-		taskTokenPattern=new Pattern[taskCommentTokens.length];
-		for(int i=0; i< taskCommentTokens.length;i++){
-		    String regex=".*\\b("+taskCommentTokens[i]+")(\\b.*)";
-		    taskTokenPattern[i]= Pattern.compile(regex);
-		}
-		
-	}
-	
-	protected void addCollapsible(int startLine,int endLine){		
-		if(m_OutlineContainer!=null){
-			Collapsible c= m_OutlineContainer.new Collapsible(startLine,endLine);
-			m_OutlineContainer.addCollapsibleRegion(c);
-		}
-	}
-	protected void beginOutlineElement(int begin,int col,String name,String type){
-		
-		if(m_OutlineContainer!=null)
-			m_OutlineContainer.beginElement(name, type, begin, col, m_File, m_OutlineElementFactory);
-	}
-	protected void endOutlineElement(int end,int col,String name,String type){
-		if(m_OutlineContainer!=null)
-			m_OutlineContainer.endElement(name, type, end, col, m_File);
-	}
-		
-	/** 
-	 * Parses the file and updates the outline
-	 */	
-	public void parse() throws HdlParserException
-	{
-		String  sTime_out=VerilogPlugin.getPreferenceString(PreferenceStrings.MAX_PARSE_TIME);
-		int nTimeout;
-		try{
-			Integer time_out = Integer.parseInt(sTime_out);
-			nTimeout = time_out;
-		}catch (NumberFormatException e) {
-			//if we cannot parse the string
-			nTimeout=2000;
-		}
-		
-		try {
-			m_Reader.reset();
-		} catch (IOException e1) {			
-		}
-		Thread parsethread = new Thread(parser);
-		parsethread.start();
-		try {
-			parsethread.join(nTimeout);
-			if(parsethread.isAlive()) {
-				VerilogPlugin.println("VHDL Parser is taking too long parsing "+m_File.getName()+" . I'm killing it\n");
-				m_Reader.stop();
-				
-			}
-		} catch (InterruptedException e) {
-			HdlParserException hdlParserException=new HdlParserException(e);
-			updateMarkers();
-			throw hdlParserException;
-		}
-		
-		try {
-			ASTdesign_file designFile = parser.getResult();
-			if(designFile!=null) {
-				updateOutline(designFile);
-				parseLineComment();
-				VerilogPlugin.deleteMarkers(m_File);
-				SemanticWarnings warn = new SemanticWarnings(m_File);
-				warn.check(designFile);
-				updateMarkers();
-			} else {
-				designFile=new ASTdesign_file(VhdlParserCore.JJTDESIGN_FILE);
-				updateOutline(designFile);
-			}
-		} catch(HdlParserException e) {
-			updateMarkers();
-			//throw e;
-		}
-	}
-
-	/**
-	 * Updates the error and warning markers
-	 */
-	protected void updateMarkers(){
-		for(ErrorHandler.Error error:parser.getErrorHandler().getErrors()){
-			VerilogPlugin.setErrorMarker(m_File, error.getLine(), error.getMessage());
-		}
-		for(ErrorHandler.Error error:parser.getErrorHandler().getWarnings()){
-			VerilogPlugin.setErrorMarker(m_File, error.getLine(), error.getMessage());
-		}
-	}
-	
-	/**
-	 * Checks to see if a comment starts with one of the task tokens
-	 * @param comment The comment to check
-	 * @param msg String array to receive the message type associated with the string
-	 * @return The string of the Token. null if the comment does not have a task token
-	 */
-	protected String getTaskToken(String comment,String []msg ){
-	    	    
-	    for(Pattern pattern:taskTokenPattern){	        
-	        Matcher matcher= pattern.matcher(comment);
-	        if(matcher.find()){	            
-	            msg[0]=matcher.group(1)+matcher.group(2);
-	            return matcher.group(1);
-	        }
-	    }
-	    //if we get here, no task was found
-	    return null;
-	}
-	
-	/**
-	 * Adds a task to the given line based on the comment token
-	 * @param type
-	 * @param line
-	 */
-	protected void addTaskToLine(String type,String msg, int line){
-	    //The first marker is considered high priority
-	    if(type.startsWith(taskCommentTokens[0])){
-	        VerilogPlugin.setTaskMarker(m_File, line, msg,IMarker.PRIORITY_HIGH);
-	    }
-	    else{
-	        VerilogPlugin.setTaskMarker(m_File, line, msg,IMarker.PRIORITY_NORMAL);
-	    }
-	}
-	
-	/**
-	 * Removes a task from the given line
-	 * @param line Line number to remove the task from
-	 */
-	protected void removeTaskFromLine(int line){
-	    VerilogPlugin.clearAutoTaskMarker(m_File, line);
-	}
-	
-	/**
-	 * Removes all the auto generated tasks from the file
-	 */
-	protected void clearAutoTasks(){
-	    VerilogPlugin.clearAllAutoTaskMarkers(m_File);
-	}
-	/**
-	 * parse line comment for content outline
-	 */
-	protected void parseLineComment() {
-		m_lineOffsets = new Vector<Integer>();
-		try {
-			InputStreamReader newreader = new InputStreamReader(m_File.getContents());
-			clearAutoTasks();
-
-			int line = 1;
-			int column = 0;
-			int []c = new int[2];
-			int firstNonSpace=0;
-			int fileoffset=0;
-			m_lineOffsets.add(fileoffset);
-			
-			c[1]= newreader.read();
-			while ( c[1] != -1) {				
-				if(!Character.isWhitespace( c[1] ) && firstNonSpace==0){
-					firstNonSpace=column;
-				}
-				switch ( c[1] ) {
-					case '\n' :
-						line++;
-						m_lineOffsets.add(fileoffset);
-						column = 0;
-						firstNonSpace=0;
-						break;
-					case '-' :
-						//comment
-					if (c[0] == '-') {
-							StringBuffer commentstrbuf = new StringBuffer();
-							int readc = newreader.read();
-							fileoffset++;
-							while (readc != '\n' && readc != -1)
-							{
-								commentstrbuf.append((char)readc);
-								readc = newreader.read();
-								fileoffset++;
-							}
-							String comment = commentstrbuf.toString().trim();
-							if (comment != null){
-							    String []msg=new String[1];
-								addComment(line, comment,(column-1 == firstNonSpace));
-								//check to see if we need to add a task
-								String taskToken=getTaskToken(comment,msg);
-								if(taskToken != null){								    
-								    addTaskToLine(taskToken, msg[0], line);
-								}								
-								checkSynopsisTranslate(comment,line);
-							}
-							//if the beginning of the comment (the first "-" of "--") is
-							//the first non space character of the line 
-							if (column-1 == firstNonSpace) {
-								coalesceComments(line);
-							}
-							// increment the line counter because getLineComment
-							// consumes the new line character
-							line++;
-							m_lineOffsets.add(fileoffset);
-							column = 0;
-							c[0]=0;
-							c[1]=0;
-							firstNonSpace=0;
-						}
-						break;
-					default :
-						break;
-				}
-				c[0] = c[1];
-				c[1] = newreader.read();
-				column++;
-				fileoffset++;
-			}
-			//call one last time to catch the last comment
-			coalesceComments(Integer.MAX_VALUE);
-		}
-		catch (IOException e) {}
-		catch (CoreException e) {}
-	}
-
-	private void checkSynopsisTranslate(String line, int linenr) {
-		if(line.contains("synopsis translate off")) {
-			m_synopsisTranslateOff = linenr;
-		}
-		if(m_synopsisTranslateOff!=-1 && 
-			line.contains("synopsis translate on")) {
-			addCollapsible(m_synopsisTranslateOff, linenr);
-			m_synopsisTranslateOff=-1;
-		}
-	}
-
-	private void addComment(int line, String comment, boolean onlycomment)
-	{
-		if(m_OutlineContainer!=null)
-			m_OutlineContainer.addComment(line, comment, onlycomment);
-	}
-	/**
-	 * This function keeps track of contiguous comment blocks and 
-	 * adds a collapsible section if they exceed a threshold
-	 * @param line the line number of a complete comment line
-	 */
-	private void coalesceComments(int line){
-		//contiguous blocks
-		if (m_LastCommentLine + 1 == line)
-		{
-			//grow the block
-			m_EndCommentBlock=line;
-		}
-		else{
-			//if starting a new block
-			if((m_EndCommentBlock - m_StartCommentBlock+1) >= COMMENT_LINE_GROUP){
-				addCollapsible(m_StartCommentBlock, m_EndCommentBlock);
-			}
-			m_StartCommentBlock=line;
-			m_EndCommentBlock=line;
-		}
-		m_LastCommentLine=line;
-	}
-	
-	/**
-	 * Recursively updates the outline database
-	 * @param node top level node element;
-	 */
-	protected void updateOutline(SimpleNode node) {
-		int childNum = 0;
-		StringBuffer name = new StringBuffer();
-		StringBuffer type =  new StringBuffer();;
-		Boolean bNeetToOutline = false;
-		Boolean bIsCollapsible = false;
-	
-		// end of the tree
-		if (node == null) {
-			return;
-		} else if (node instanceof ASTarchitecture_body) {
-			bNeetToOutline = true;
-			bIsCollapsible = true;
-			childNum += examineArchitecture((ASTarchitecture_body) node, name,
-					type);
-
-		} else if (node instanceof ASTpackage_declaration) {
-			bNeetToOutline = true;
-			bIsCollapsible = true;
-			childNum += examinePackageDecl((ASTpackage_declaration) node, name,
-					type);
-		} else if (node instanceof ASTpackage_body) {
-			bNeetToOutline = true;
-			bIsCollapsible = true;
-			childNum += examinePackageBody((ASTpackage_body) node, name, type);
-		} else if (node instanceof ASTprocess_statement) {
-			bNeetToOutline = true;
-			childNum += examineProcess((ASTprocess_statement) node, name, type);
-		} else if (node.id == VhdlParserCore.JJTSUBPROGRAM_SPECIFICATION) {
-			bNeetToOutline = true;
-			bIsCollapsible = true;
-			childNum += examineSubProgramSpec((ASTsubprogram_specification)node,name,type);
-		} else if (node.id == VhdlParserCore.JJTSUBPROGRAM_BODY) {
-			bNeetToOutline = true;
-			bIsCollapsible = true;
-			childNum += examineSubProgramBody((ASTsubprogram_body)node,name,type);
-		} else if (node instanceof ASTcomponent_instantiation_statement) {
-			bNeetToOutline = true;
-			bIsCollapsible = true;
-			childNum += examineComponentInst((ASTcomponent_instantiation_statement) node,
-					name, type);
-		} else if (node instanceof ASTcomponent_declaration) {
-			bNeetToOutline = true;
-			bIsCollapsible = true;
-			childNum += examineComponentDecl((ASTcomponent_declaration) node,
-					name, type);
-		} else if (node instanceof ASTentity_declaration) {
-			bNeetToOutline = true;
-			bIsCollapsible = true;
-			childNum += examineEntityDecl((ASTentity_declaration) node, name,
-					type);
-
-		} else if (node instanceof ASTfull_type_declaration) {	
-			bNeetToOutline = true;
-			
-			for (Node c : ((ASTfull_type_declaration) node).children) {
-				if (!(c instanceof SimpleNode)) continue;
-				if (c instanceof ASTidentifier) {
-					ASTidentifier identifier = (ASTidentifier) c;
-					name.append(identifier.name);
-				}
-			}
-			type.append("type#");
-		} else if (node instanceof ASTrecord_type_definition) {		
-			childNum += examineRecordDeclaration((ASTrecord_type_definition)node);
-		} else if (node instanceof ASTsubtype_declaration) {
-			childNum += examineSubtypeDecl((ASTsubtype_declaration)node, name,type);
-			bNeetToOutline = true;
-		} else if (node instanceof ASTsubtype_indication) {		 
-			childNum += examineSubtypeIndication((ASTsubtype_indication)node, name,type);
-			//bNeetToOutline = true;
-		} else if (node instanceof ASTport_clause) {
-			childNum += examinePortClause((ASTport_clause) node);
-		} else if (node instanceof ASTgeneric_clause) {
-			childNum += examineGenericClause((ASTgeneric_clause) node);
-		} else if (node instanceof ASTvariable_declaration) {
-			childNum += examineDecl(node);
-		} else if (node instanceof ASTfile_declaration) {
-			childNum += examineDecl(node);
-		} else if (node instanceof ASTalias_declaration) {
-			childNum += examineAlias((ASTalias_declaration) node);
-		} else if (node instanceof ASTsignal_declaration) {
-			childNum += examineDecl(node);
-		} else if (node instanceof ASTconstant_declaration) {
-			childNum += examineDecl(node);
-		} else if (node instanceof ASTblock_statement) {
-			bIsCollapsible = true;
-		} else if (node instanceof ASTprocess_statement) {
-			bIsCollapsible = true;
-		} else if (node instanceof ASTgenerate_statement) {
-			bIsCollapsible = true;
-		}
-
-		// add the begin clause
-		if (bNeetToOutline) {
-			beginOutlineElement(node.getFirstToken().beginLine, node
-					.getFirstToken().beginColumn, name.toString(), type.toString());
-
-		}
-		// now process all the children
-		// here, we do not initialize the loop counter because some of
-		// the children may have been used up above
-		for (; childNum < node.getChildCount(); childNum++) {
-			updateOutline(node.getChild(childNum));
-		}
-
-		// add the end clause
-		if (bNeetToOutline) {
-			endOutlineElement(node.getLastToken().endLine,
-					node.getLastToken().endColumn, name.toString(), type.toString());
-		}
-		// add the item to the collapsible list
-		if (bIsCollapsible) {
-			addCollapsible(node.getFirstToken().beginLine,
-					node.getLastToken().endLine);
-		}
-	}
-	
-	/**
-	 * Breaks out an architecture body
-	 * @param archBody
-	 * @param name
-	 * @param type
-	 * @return number of children consumed by this function
-	 */
-	protected int examineArchitecture(ASTarchitecture_body archBody,StringBuffer name,StringBuffer type){
-		//get the name
-		name.append(archBody.getIdentifier());		
-		//get the entity name			
-		type.append("architecture#"+archBody.getEntityName());		
-		return 2;
-	}	
-	/**
-	 * Breaks out a package decl
-	 * @param packageDecl
-	 * @param name
-	 * @param type
-	 * @return  number of children consumed by this function
-	 */
-	protected int examinePackageDecl(ASTpackage_declaration packageDecl,StringBuffer name,StringBuffer type){
-		//get the name
-		name.append(packageDecl.getIdentifier());
-		type.append("packageDecl#");
-		return 1;
-	}
-	/**
-	 * Breaks out a package body
-	 * @param packageBody
-	 * @param name
-	 * @param type
-	 * @return  number of children consumed by this function
-	 */
-	protected int examinePackageBody(ASTpackage_body packageBody,StringBuffer name,StringBuffer type){
-		//get the name
-		name.append(packageBody.getIdentifier());		
-		type.append("packageBody#");			
-		return 1;
-	}
-	/**
-	 * Breaks out a process
-	 * @param processStatement
-	 * @param name
-	 * @param type
-	 * @return  number of children consumed by this function
-	 */
-	protected int examineProcess(ASTprocess_statement processStatement,StringBuffer name,StringBuffer type){
-		int results=0;		
-
-		//get the name
-		if(processStatement.getIdentifier()==null){
-			name.append("<unknown>");
-		}
-		else{
-			name.append(processStatement.getIdentifier());
-			results++;
-		}
-		type.append("process#");
-		return results;
-	}
-	/**
-	 * Breaks out a component declaration
-	 * @param componentDecl
-	 * @param name
-	 * @param type
-	 * @return  number of children consumed by this function
-	 */
-	protected int examineComponentDecl(ASTcomponent_declaration componentDecl,StringBuffer name,StringBuffer type){
-		name.append(componentDecl.getIdentifier());		
-		type.append("componentDecl#");
-		return 0;
-	}
-	/**
-	 * Breaks out a component,entity, and configuration instantiation 
-	 * @param componentInst
-	 * @param name
-	 * @param type
-	 * @return
-	 */
-	protected int examineComponentInst(ASTcomponent_instantiation_statement componentInst,StringBuffer name,StringBuffer type){
-		
-		ASTinstantiated_unit instantiatedUnit=componentInst.getInstatiatedUnit();
-		String instantType=instantiatedUnit.getType();
-		
-		name.append(componentInst.getIdentifier());
-		if(instantType.equalsIgnoreCase("entity")){
-			type.append("entityInst#");
-			
-			ASTname entityName = (ASTname)instantiatedUnit.getChild(0);
-			if (entityName.getChildCount() > 1 && entityName.getChild(1) instanceof ASTidentifier) {
-				// when using direct instantiation (<library>.<entity>)
-				type.append(((ASTidentifier)entityName.getChild(1)).first_token.toString());
-			} else {				
-				type.append(instantiatedUnit.getName());
-			}
-			
-			type.append("#");
-			type.append(instantiatedUnit.getidentifier());
-		}else if(instantType.equalsIgnoreCase("configuration")){
-			type.append("configurationInst#");
-			type.append(instantiatedUnit.getName());
-		}else {
-			type.append("componentInst#");
-			type.append(instantiatedUnit.getName());
-		}		
-		
-		return 1;
-	}
-	/**
-	 * Breaks out a component declaration
-	 * @param entityDecl
-	 * @param name
-	 * @param type
-	 * @return  number of children consumed by this function
-	 */
-	protected int examineEntityDecl(ASTentity_declaration entityDecl,StringBuffer name,StringBuffer type){
-		name.append(entityDecl.getIdentifier());
-		type.append("entityDecl#");	
-		return 0;
-	}
-	
-	protected int examineSubtypeDecl(ASTsubtype_declaration subtypeDecl,StringBuffer name,StringBuffer type){
-		name.append(subtypeDecl.getIdentifier());
-		type.append("subtypeDecl#");
-		return 0;
-	}
-	protected int examineSubtypeIndication(ASTsubtype_indication subtypeIndi,StringBuffer name,StringBuffer type){
-		name.append(subtypeIndi.getIdentifier());
-		type.append("subtypeIndi#");
-		return 0;
-	}
-	
- 	protected int examineRecordDeclaration(ASTrecord_type_definition recorddecl) {
-		String[] names2 = null;
-
-		for (Node c : recorddecl.children) {
-			if(! (c instanceof SimpleNode)) continue;
-			SimpleNode child = (SimpleNode) c;
-			String subtype = "";
-
-			if (child instanceof ASTelement_declaration) {
-				ASTelement_declaration var = (ASTelement_declaration) child;
-				names2 = var.getIdentifierList();
-				subtype = var.getSubType();
-			}
-
-			for (String identifier : names2) {
-				beginOutlineElement(child.getFirstToken().beginLine, child
-						.getFirstToken().beginColumn, identifier,"recordmember#"+subtype);
-				endOutlineElement(child.getLastToken().endLine, child
-						.getLastToken().endColumn, identifier, "recordmember#"+subtype);
-			}
-		}
-		return recorddecl.getChildCount();// no more update
-
-	}
-	
-	/**
-	 * Breaks out a port clause and adds its children to the outline
-	 * @param portClause
-	 * @return  number of children consumed by this function
-	 */
-	protected int examinePortClause(ASTport_clause portClause){
-		String []names=null;
-		String type;
-		
-		ASTinterface_list interfaceList=portClause.getInterfaceList();
-		for(Node c:interfaceList.children){
-			SimpleNode child=(SimpleNode)c;
-			type="port#";
-			if (child instanceof ASTinterface_file_declaration) {
-				ASTinterface_file_declaration file = (ASTinterface_file_declaration) child;
-				names=file.getIdentifierList();
-				type+="# #"+file.getSubType();	
-			} else	if (child instanceof ASTinterface_signal_declaration) {
-				ASTinterface_signal_declaration signal = (ASTinterface_signal_declaration) child;
-				names=signal.getIdentifierList();
-				type+=signal.getMode()+"#"+signal.getSubType();					
-			} else if (child instanceof ASTinterface_constant_declaration) {
-				ASTinterface_constant_declaration constant = (ASTinterface_constant_declaration) child;
-				names=constant.getIdentifierList();
-				type+="in#"+constant.getSubType();
-			} else if (child instanceof ASTinterface_variable_declaration) {
-				ASTinterface_variable_declaration var = (ASTinterface_variable_declaration) child;
-				names=var.getIdentifierList();
-				type+=var.getMode()+"#"+var.getSubType();
-			} else{
-				continue;
-			}				
-			//add all the identifiers
-			for(String identifier:names){
-				beginOutlineElement(
-						child.getFirstToken().beginLine,
-						child.getFirstToken().beginColumn,
-						identifier, 
-						type);
-				endOutlineElement(
-						child.getLastToken().endLine,
-						child.getLastToken().endColumn,
-						identifier, 
-						type);
-			}
-		}
-		return 1;
-	}
-	/**
-	 * Breaks out a generic clause and adds it children to the outline
-	 * @param genericClause
-	 * @return  number of children consumed by this function
-	 */
-	protected int examineGenericClause(ASTgeneric_clause genericClause) {
-		String[] names = null;
-		String type;
-
-		ASTinterface_list interfaceList = genericClause.getInterfaceList();
-		for (Node c : interfaceList.children) {
-			SimpleNode child = (SimpleNode) c;
-			type = "generic#";
-			if (child instanceof ASTinterface_file_declaration) {
-				ASTinterface_file_declaration file = (ASTinterface_file_declaration) child;
-				names = file.getIdentifierList();
-				type += "#" + file.getSubType();
-			} else if (child instanceof ASTinterface_signal_declaration) {
-				ASTinterface_signal_declaration signal = (ASTinterface_signal_declaration) child;
-				names = signal.getIdentifierList();
-				type += signal.getSubType();
-			} else if (child instanceof ASTinterface_constant_declaration) {
-				ASTinterface_constant_declaration constant = (ASTinterface_constant_declaration) child;
-				names = constant.getIdentifierList();
-				type += constant.getSubType();
-			} else if (child instanceof ASTinterface_variable_declaration) {
-				ASTinterface_variable_declaration var = (ASTinterface_variable_declaration) child;
-				names = var.getIdentifierList();
-				type += var.getSubType();
-			} else {
-				continue;
-			}
-			// add all the identifiers
-			for (String identifier : names) {
-				beginOutlineElement(child.getFirstToken().beginLine, child
-						.getFirstToken().beginColumn, identifier, type);
-				endOutlineElement(child.getLastToken().endLine, child
-						.getLastToken().endColumn, identifier, type);
-			}
-		}
-		return 1;
-	}
-	/**
-	 * Breaks out an alias declaration
-	 * @param alias
-	 * @return
-	 */
-	protected int examineAlias(ASTalias_declaration alias){
-		String name = alias.getIdentifier();
-		String type = "alias#" + alias.getName();
-		beginOutlineElement(alias.getFirstToken().beginLine, alias
-				.getFirstToken().beginColumn, name, type);
-		endOutlineElement(alias.getLastToken().endLine,
-				alias.getLastToken().endColumn, name, type);
-		return 1;
-	}
-	/**
-	 * Breaks out signal,variable,constant, and file type declarations and adds
-	 * them to the outline
-	 * @param node
-	 * @return  number of children consumed by this function
-	 */
-	protected int examineDecl(SimpleNode node){
-		String type=null;
-		String []names=null;
-		
-		if(node instanceof ASTvariable_declaration){
-			ASTvariable_declaration var = (ASTvariable_declaration) node;		
-			names=var.getIdentifierList();
-			type="variable#"+var.getSubType();
-		}else if(node instanceof ASTsignal_declaration){
-			ASTsignal_declaration signal = (ASTsignal_declaration) node;			
-			names=signal.getIdentifierList();
-			type="signal#"+signal.getSubType();
-		}else if(node instanceof ASTconstant_declaration){
-			ASTconstant_declaration constant = (ASTconstant_declaration) node;
-			names=constant.getIdentifierList();
-			type="constant#"+constant.getSubType();
-		}else if(node instanceof ASTfile_declaration){
-			ASTfile_declaration file = (ASTfile_declaration) node;
-			names=file.getIdentifierList();
-			type="file#"+file.getSubType();
-		}
-		
-		for(String identifier:names){
-			beginOutlineElement(
-					node.getFirstToken().beginLine,
-					node.getFirstToken().beginColumn,
-					identifier, 
-					type);
-			endOutlineElement(
-					node.getLastToken().endLine,
-					node.getLastToken().endColumn,
-					identifier, 
-					type);
-			
-		}
-		
-		return 1;
-	}
-	
-	/**
-	 * Examines a subprogram specification. There are assumed to occur out side of their body  
-	 * @param spec
-	 * @param name
-	 * @param type
-	 * @return number of child elements consumed by this function
-	 */
-	protected int examineSubProgramSpec(ASTsubprogram_specification spec,StringBuffer name,StringBuffer type){
-		String subType=spec.getType().toLowerCase();
-		
-		name.append(spec.getIdentifier());
-		if(subType.contains("function")){
-			type.append("functionDecl#");
-		}else if(subType.contains("procedure")){
-			type.append("procedureDecl#");
-		} else if(subType.contains("record")){
-				type.append("recordDecl#");
-		}
-		
-		ASTformal_parameter_list paramters=spec.getParameters();
-		examineParameterList(paramters, type);
-		return 1;
-	}
-	/**
-	 * Examines a subprogram specification. There are assumed to occur out side of their body  
-	 * @param spec
-	 * @param name
-	 * @param type
-	 * @return number of child elements consumed by this function
-	 */
-	protected int examineSubProgramBody(ASTsubprogram_body body,StringBuffer name,StringBuffer type){
-		ASTsubprogram_specification spec=body.getSpecification();
-		String subType=spec.getType().toLowerCase();
-		
-		name.append(spec.getIdentifier());
-		if(subType.contains("function")){
-			type.append("function#");
-		}else if(subType.contains("procedure")){
-			type.append("procedure#");
-		}else if(subType.contains("record")){
-			type.append("record#");
-		}
-		
-		ASTformal_parameter_list paramters=spec.getParameters();
-		examineParameterList(paramters, type);
-		
-		return 1;
-	}
-
-	int examineParameterList(ASTformal_parameter_list paramters,
-			StringBuffer type) {
-		String[] paramNames;
-		String paramType;
-
-		if (paramters != null) {
-			ASTinterface_list interfaceList = paramters.getInterfaceList();
-			for (Node c : interfaceList.children) {
-				SimpleNode child = (SimpleNode) c;
-				if (child instanceof ASTinterface_file_declaration) {
-					ASTinterface_file_declaration file = (ASTinterface_file_declaration) child;
-					paramNames = file.getIdentifierList();
-					paramType = file.getSubType() + "# ";
-				} else if (child instanceof ASTinterface_signal_declaration) {
-					ASTinterface_signal_declaration signal = (ASTinterface_signal_declaration) child;
-					paramNames = signal.getIdentifierList();
-					paramType = signal.getSubType() + "#" + signal.getMode()+ "#";;
-				} else if (child instanceof ASTinterface_constant_declaration) {
-					ASTinterface_constant_declaration constant = (ASTinterface_constant_declaration) child;
-					paramNames = constant.getIdentifierList();
-					paramType = constant.getSubType() + "#in#";
-				} else if (child instanceof ASTinterface_variable_declaration) {
-					ASTinterface_variable_declaration var = (ASTinterface_variable_declaration) child;
-					paramNames = var.getIdentifierList();
-					paramType = var.getSubType() + "#" + var.getMode()+ "#";;
-				} else {
-					continue;
-				}
-				// add all the parameters
-				for (String identifier : paramNames) {
-					type.append(identifier);
-					type.append("#" + paramType);
-				}
-			}			
-		}
-		return 1;
-	}
-
-	public int getContext()
-	{
-		return 0;
-	}
-}
-
-
-
-
-
-
-
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+
+package com.elphel.vdt.veditor.parser.vhdl;
+
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.util.Vector;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import com.elphel.vdt.veditor.VerilogPlugin;
+import com.elphel.vdt.veditor.parser.HdlParserException;
+import com.elphel.vdt.veditor.parser.IParser;
+import com.elphel.vdt.veditor.parser.OutlineContainer;
+import com.elphel.vdt.veditor.parser.OutlineDatabase;
+import com.elphel.vdt.veditor.parser.OutlineElementFactory;
+import com.elphel.vdt.veditor.parser.OutlineContainer.Collapsible;
+import com.elphel.vdt.veditor.parser.ParserReader;
+import com.elphel.vdt.veditor.parser.vhdl.ASTsubtype_declaration;
+import com.elphel.vdt.veditor.parser.vhdl.ASTsubtype_indication;
+import com.elphel.vdt.veditor.parser.vhdl.VhdlParserCore;
+import com.elphel.vdt.veditor.preference.PreferenceStrings;
+import com.elphel.vdt.veditor.semanticwarnings.SemanticWarnings;
+
+import org.eclipse.core.resources.IFile;
+import org.eclipse.core.resources.IMarker;
+import org.eclipse.core.resources.IProject;
+import org.eclipse.core.runtime.CoreException;
+
+/**
+ * implementation class of VhdlParserCore<p/>
+ * for separating definition from JavaCC code
+ */
+public class VhdlParser implements IParser
+{
+	private IFile m_File;
+	private ParserReader m_Reader;
+	private static OutlineElementFactory m_OutlineElementFactory=new VhdlOutlineElementFactory();
+	//Minimum number of comment lines before they are collapsible
+	private final int COMMENT_LINE_GROUP=5;
+	private int m_StartCommentBlock;
+	private int m_LastCommentLine;
+	private int m_EndCommentBlock;
+	private int m_synopsisTranslateOff;
+	private OutlineContainer m_OutlineContainer;
+	private Pattern[] taskTokenPattern;
+	private Vector<Integer> m_lineOffsets;
+	
+	private VHDLParserThread parser;
+
+
+	public VhdlParser(ParserReader reader, IProject project, IFile file)
+	{
+		m_Reader = reader;
+		m_File = file;	
+		m_LastCommentLine=-1;
+		m_synopsisTranslateOff=-1;
+		OutlineDatabase database = OutlineDatabase.getProjectsDatabase(project);		
+		if(database != null){
+			m_OutlineContainer = database.getOutlineContainer(file);
+		}
+		parser = new VHDLParserThread(m_Reader,m_File);
+		
+		taskTokenPattern=new Pattern[taskCommentTokens.length];
+		for(int i=0; i< taskCommentTokens.length;i++){
+		    String regex=".*\\b("+taskCommentTokens[i]+")(\\b.*)";
+		    taskTokenPattern[i]= Pattern.compile(regex);
+		}
+		
+	}
+	
+	protected void addCollapsible(int startLine,int endLine){		
+		if(m_OutlineContainer!=null){
+			Collapsible c= m_OutlineContainer.new Collapsible(startLine,endLine);
+			m_OutlineContainer.addCollapsibleRegion(c);
+		}
+	}
+	protected void beginOutlineElement(int begin,int col,String name,String type){
+		
+		if(m_OutlineContainer!=null)
+			m_OutlineContainer.beginElement(name, type, begin, col, m_File, m_OutlineElementFactory);
+	}
+	protected void endOutlineElement(int end,int col,String name,String type){
+		if(m_OutlineContainer!=null)
+			m_OutlineContainer.endElement(name, type, end, col, m_File);
+	}
+		
+	/** 
+	 * Parses the file and updates the outline
+	 */	
+	public void parse() throws HdlParserException
+	{
+		parse(1);
+	}
+
+	public void parse(int pass) throws HdlParserException
+	{
+		String  sTime_out=VerilogPlugin.getPreferenceString(PreferenceStrings.MAX_PARSE_TIME);
+		int nTimeout;
+		try{
+			Integer time_out = Integer.parseInt(sTime_out);
+			nTimeout = time_out;
+		}catch (NumberFormatException e) {
+			//if we cannot parse the string
+			nTimeout=2000;
+		}
+		
+		try {
+			m_Reader.reset();
+		} catch (IOException e1) {			
+		}
+		Thread parsethread = new Thread(parser);
+		parsethread.start();
+		try {
+			parsethread.join(nTimeout);
+			if(parsethread.isAlive()) {
+				VerilogPlugin.println("VHDL Parser is taking too long parsing "+m_File.getName()+" . I'm killing it\n");
+				m_Reader.stop();
+				
+			}
+		} catch (InterruptedException e) {
+			HdlParserException hdlParserException=new HdlParserException(e);
+			updateMarkers();
+			throw hdlParserException;
+		}
+		
+		try {
+			ASTdesign_file designFile = parser.getResult();
+			if(designFile!=null) {
+				updateOutline(designFile);
+				parseLineComment();
+				VerilogPlugin.deleteMarkers(m_File);
+				SemanticWarnings warn = new SemanticWarnings(m_File);
+				warn.check(designFile);
+				updateMarkers();
+			} else {
+				designFile=new ASTdesign_file(VhdlParserCore.JJTDESIGN_FILE);
+				updateOutline(designFile);
+			}
+		} catch(HdlParserException e) {
+			updateMarkers();
+			//throw e;
+		}
+	}
+
+	/**
+	 * Updates the error and warning markers
+	 */
+	protected void updateMarkers(){
+		for(ErrorHandler.Error error:parser.getErrorHandler().getErrors()){
+			VerilogPlugin.setErrorMarker(m_File, error.getLine(), error.getMessage());
+		}
+		for(ErrorHandler.Error error:parser.getErrorHandler().getWarnings()){
+			VerilogPlugin.setErrorMarker(m_File, error.getLine(), error.getMessage());
+		}
+	}
+	
+	/**
+	 * Checks to see if a comment starts with one of the task tokens
+	 * @param comment The comment to check
+	 * @param msg String array to receive the message type associated with the string
+	 * @return The string of the Token. null if the comment does not have a task token
+	 */
+	protected String getTaskToken(String comment,String []msg ){
+	    	    
+	    for(Pattern pattern:taskTokenPattern){	        
+	        Matcher matcher= pattern.matcher(comment);
+	        if(matcher.find()){	            
+	            msg[0]=matcher.group(1)+matcher.group(2);
+	            return matcher.group(1);
+	        }
+	    }
+	    //if we get here, no task was found
+	    return null;
+	}
+	
+	/**
+	 * Adds a task to the given line based on the comment token
+	 * @param type
+	 * @param line
+	 */
+	protected void addTaskToLine(String type,String msg, int line){
+	    //The first marker is considered high priority
+	    if(type.startsWith(taskCommentTokens[0])){
+	        VerilogPlugin.setTaskMarker(m_File, line, msg,IMarker.PRIORITY_HIGH);
+	    }
+	    else{
+	        VerilogPlugin.setTaskMarker(m_File, line, msg,IMarker.PRIORITY_NORMAL);
+	    }
+	}
+	
+	/**
+	 * Removes a task from the given line
+	 * @param line Line number to remove the task from
+	 */
+	protected void removeTaskFromLine(int line){
+	    VerilogPlugin.clearAutoTaskMarker(m_File, line);
+	}
+	
+	/**
+	 * Removes all the auto generated tasks from the file
+	 */
+	protected void clearAutoTasks(){
+	    VerilogPlugin.clearAllAutoTaskMarkers(m_File);
+	}
+	/**
+	 * parse line comment for content outline
+	 */
+	protected void parseLineComment() {
+		m_lineOffsets = new Vector<Integer>();
+		try {
+			InputStreamReader newreader = new InputStreamReader(m_File.getContents());
+			clearAutoTasks();
+
+			int line = 1;
+			int column = 0;
+			int []c = new int[2];
+			int firstNonSpace=0;
+			int fileoffset=0;
+			m_lineOffsets.add(fileoffset);
+			
+			c[1]= newreader.read();
+			while ( c[1] != -1) {				
+				if(!Character.isWhitespace( c[1] ) && firstNonSpace==0){
+					firstNonSpace=column;
+				}
+				switch ( c[1] ) {
+					case '\n' :
+						line++;
+						m_lineOffsets.add(fileoffset);
+						column = 0;
+						firstNonSpace=0;
+						break;
+					case '-' :
+						//comment
+					if (c[0] == '-') {
+							StringBuffer commentstrbuf = new StringBuffer();
+							int readc = newreader.read();
+							fileoffset++;
+							while (readc != '\n' && readc != -1)
+							{
+								commentstrbuf.append((char)readc);
+								readc = newreader.read();
+								fileoffset++;
+							}
+							String comment = commentstrbuf.toString().trim();
+							if (comment != null){
+							    String []msg=new String[1];
+								addComment(line, comment,(column-1 == firstNonSpace));
+								//check to see if we need to add a task
+								String taskToken=getTaskToken(comment,msg);
+								if(taskToken != null){								    
+								    addTaskToLine(taskToken, msg[0], line);
+								}								
+								checkSynopsisTranslate(comment,line);
+							}
+							//if the beginning of the comment (the first "-" of "--") is
+							//the first non space character of the line 
+							if (column-1 == firstNonSpace) {
+								coalesceComments(line);
+							}
+							// increment the line counter because getLineComment
+							// consumes the new line character
+							line++;
+							m_lineOffsets.add(fileoffset);
+							column = 0;
+							c[0]=0;
+							c[1]=0;
+							firstNonSpace=0;
+						}
+						break;
+					default :
+						break;
+				}
+				c[0] = c[1];
+				c[1] = newreader.read();
+				column++;
+				fileoffset++;
+			}
+			//call one last time to catch the last comment
+			coalesceComments(Integer.MAX_VALUE);
+		}
+		catch (IOException e) {}
+		catch (CoreException e) {}
+	}
+
+	private void checkSynopsisTranslate(String line, int linenr) {
+		if(line.contains("synopsis translate off")) {
+			m_synopsisTranslateOff = linenr;
+		}
+		if(m_synopsisTranslateOff!=-1 && 
+			line.contains("synopsis translate on")) {
+			addCollapsible(m_synopsisTranslateOff, linenr);
+			m_synopsisTranslateOff=-1;
+		}
+	}
+
+	private void addComment(int line, String comment, boolean onlycomment)
+	{
+		if(m_OutlineContainer!=null)
+			m_OutlineContainer.addComment(line, comment, onlycomment);
+	}
+	/**
+	 * This function keeps track of contiguous comment blocks and 
+	 * adds a collapsible section if they exceed a threshold
+	 * @param line the line number of a complete comment line
+	 */
+	private void coalesceComments(int line){
+		//contiguous blocks
+		if (m_LastCommentLine + 1 == line)
+		{
+			//grow the block
+			m_EndCommentBlock=line;
+		}
+		else{
+			//if starting a new block
+			if((m_EndCommentBlock - m_StartCommentBlock+1) >= COMMENT_LINE_GROUP){
+				addCollapsible(m_StartCommentBlock, m_EndCommentBlock);
+			}
+			m_StartCommentBlock=line;
+			m_EndCommentBlock=line;
+		}
+		m_LastCommentLine=line;
+	}
+	
+	/**
+	 * Recursively updates the outline database
+	 * @param node top level node element;
+	 */
+	protected void updateOutline(SimpleNode node) {
+		int childNum = 0;
+		StringBuffer name = new StringBuffer();
+		StringBuffer type =  new StringBuffer();;
+		Boolean bNeetToOutline = false;
+		Boolean bIsCollapsible = false;
+	
+		// end of the tree
+		if (node == null) {
+			return;
+		} else if (node instanceof ASTarchitecture_body) {
+			bNeetToOutline = true;
+			bIsCollapsible = true;
+			childNum += examineArchitecture((ASTarchitecture_body) node, name,
+					type);
+
+		} else if (node instanceof ASTpackage_declaration) {
+			bNeetToOutline = true;
+			bIsCollapsible = true;
+			childNum += examinePackageDecl((ASTpackage_declaration) node, name,
+					type);
+		} else if (node instanceof ASTpackage_body) {
+			bNeetToOutline = true;
+			bIsCollapsible = true;
+			childNum += examinePackageBody((ASTpackage_body) node, name, type);
+		} else if (node instanceof ASTprocess_statement) {
+			bNeetToOutline = true;
+			childNum += examineProcess((ASTprocess_statement) node, name, type);
+		} else if (node.id == VhdlParserCore.JJTSUBPROGRAM_SPECIFICATION) {
+			bNeetToOutline = true;
+			bIsCollapsible = true;
+			childNum += examineSubProgramSpec((ASTsubprogram_specification)node,name,type);
+		} else if (node.id == VhdlParserCore.JJTSUBPROGRAM_BODY) {
+			bNeetToOutline = true;
+			bIsCollapsible = true;
+			childNum += examineSubProgramBody((ASTsubprogram_body)node,name,type);
+		} else if (node instanceof ASTcomponent_instantiation_statement) {
+			bNeetToOutline = true;
+			bIsCollapsible = true;
+			childNum += examineComponentInst((ASTcomponent_instantiation_statement) node,
+					name, type);
+		} else if (node instanceof ASTcomponent_declaration) {
+			bNeetToOutline = true;
+			bIsCollapsible = true;
+			childNum += examineComponentDecl((ASTcomponent_declaration) node,
+					name, type);
+		} else if (node instanceof ASTentity_declaration) {
+			bNeetToOutline = true;
+			bIsCollapsible = true;
+			childNum += examineEntityDecl((ASTentity_declaration) node, name,
+					type);
+
+		} else if (node instanceof ASTfull_type_declaration) {	
+			bNeetToOutline = true;
+			
+			for (Node c : ((ASTfull_type_declaration) node).children) {
+				if (!(c instanceof SimpleNode)) continue;
+				if (c instanceof ASTidentifier) {
+					ASTidentifier identifier = (ASTidentifier) c;
+					name.append(identifier.name);
+				}
+			}
+			type.append("type#");
+		} else if (node instanceof ASTrecord_type_definition) {		
+			childNum += examineRecordDeclaration((ASTrecord_type_definition)node);
+		} else if (node instanceof ASTsubtype_declaration) {
+			childNum += examineSubtypeDecl((ASTsubtype_declaration)node, name,type);
+			bNeetToOutline = true;
+		} else if (node instanceof ASTsubtype_indication) {		 
+			childNum += examineSubtypeIndication((ASTsubtype_indication)node, name,type);
+			//bNeetToOutline = true;
+		} else if (node instanceof ASTport_clause) {
+			childNum += examinePortClause((ASTport_clause) node);
+		} else if (node instanceof ASTgeneric_clause) {
+			childNum += examineGenericClause((ASTgeneric_clause) node);
+		} else if (node instanceof ASTvariable_declaration) {
+			childNum += examineDecl(node);
+		} else if (node instanceof ASTfile_declaration) {
+			childNum += examineDecl(node);
+		} else if (node instanceof ASTalias_declaration) {
+			childNum += examineAlias((ASTalias_declaration) node);
+		} else if (node instanceof ASTsignal_declaration) {
+			childNum += examineDecl(node);
+		} else if (node instanceof ASTconstant_declaration) {
+			childNum += examineDecl(node);
+		} else if (node instanceof ASTblock_statement) {
+			bIsCollapsible = true;
+		} else if (node instanceof ASTprocess_statement) {
+			bIsCollapsible = true;
+		} else if (node instanceof ASTgenerate_statement) {
+			bIsCollapsible = true;
+		}
+
+		// add the begin clause
+		if (bNeetToOutline) {
+			beginOutlineElement(node.getFirstToken().beginLine, node
+					.getFirstToken().beginColumn, name.toString(), type.toString());
+
+		}
+		// now process all the children
+		// here, we do not initialize the loop counter because some of
+		// the children may have been used up above
+		for (; childNum < node.getChildCount(); childNum++) {
+			updateOutline(node.getChild(childNum));
+		}
+
+		// add the end clause
+		if (bNeetToOutline) {
+			endOutlineElement(node.getLastToken().endLine,
+					node.getLastToken().endColumn, name.toString(), type.toString());
+		}
+		// add the item to the collapsible list
+		if (bIsCollapsible) {
+			addCollapsible(node.getFirstToken().beginLine,
+					node.getLastToken().endLine);
+		}
+	}
+	
+	/**
+	 * Breaks out an architecture body
+	 * @param archBody
+	 * @param name
+	 * @param type
+	 * @return number of children consumed by this function
+	 */
+	protected int examineArchitecture(ASTarchitecture_body archBody,StringBuffer name,StringBuffer type){
+		//get the name
+		name.append(archBody.getIdentifier());		
+		//get the entity name			
+		type.append("architecture#"+archBody.getEntityName());		
+		return 2;
+	}	
+	/**
+	 * Breaks out a package decl
+	 * @param packageDecl
+	 * @param name
+	 * @param type
+	 * @return  number of children consumed by this function
+	 */
+	protected int examinePackageDecl(ASTpackage_declaration packageDecl,StringBuffer name,StringBuffer type){
+		//get the name
+		name.append(packageDecl.getIdentifier());
+		type.append("packageDecl#");
+		return 1;
+	}
+	/**
+	 * Breaks out a package body
+	 * @param packageBody
+	 * @param name
+	 * @param type
+	 * @return  number of children consumed by this function
+	 */
+	protected int examinePackageBody(ASTpackage_body packageBody,StringBuffer name,StringBuffer type){
+		//get the name
+		name.append(packageBody.getIdentifier());		
+		type.append("packageBody#");			
+		return 1;
+	}
+	/**
+	 * Breaks out a process
+	 * @param processStatement
+	 * @param name
+	 * @param type
+	 * @return  number of children consumed by this function
+	 */
+	protected int examineProcess(ASTprocess_statement processStatement,StringBuffer name,StringBuffer type){
+		int results=0;		
+
+		//get the name
+		if(processStatement.getIdentifier()==null){
+			name.append("<unknown>");
+		}
+		else{
+			name.append(processStatement.getIdentifier());
+			results++;
+		}
+		type.append("process#");
+		return results;
+	}
+	/**
+	 * Breaks out a component declaration
+	 * @param componentDecl
+	 * @param name
+	 * @param type
+	 * @return  number of children consumed by this function
+	 */
+	protected int examineComponentDecl(ASTcomponent_declaration componentDecl,StringBuffer name,StringBuffer type){
+		name.append(componentDecl.getIdentifier());		
+		type.append("componentDecl#");
+		return 0;
+	}
+	/**
+	 * Breaks out a component,entity, and configuration instantiation 
+	 * @param componentInst
+	 * @param name
+	 * @param type
+	 * @return
+	 */
+	protected int examineComponentInst(ASTcomponent_instantiation_statement componentInst,StringBuffer name,StringBuffer type){
+		
+		ASTinstantiated_unit instantiatedUnit=componentInst.getInstatiatedUnit();
+		String instantType=instantiatedUnit.getType();
+		
+		name.append(componentInst.getIdentifier());
+		if(instantType.equalsIgnoreCase("entity")){
+			type.append("entityInst#");
+			
+			ASTname entityName = (ASTname)instantiatedUnit.getChild(0);
+			if (entityName.getChildCount() > 1 && entityName.getChild(1) instanceof ASTidentifier) {
+				// when using direct instantiation (<library>.<entity>)
+				type.append(((ASTidentifier)entityName.getChild(1)).first_token.toString());
+			} else {				
+				type.append(instantiatedUnit.getName());
+			}
+			
+			type.append("#");
+			type.append(instantiatedUnit.getidentifier());
+		}else if(instantType.equalsIgnoreCase("configuration")){
+			type.append("configurationInst#");
+			type.append(instantiatedUnit.getName());
+		}else {
+			type.append("componentInst#");
+			type.append(instantiatedUnit.getName());
+		}		
+		
+		return 1;
+	}
+	/**
+	 * Breaks out a component declaration
+	 * @param entityDecl
+	 * @param name
+	 * @param type
+	 * @return  number of children consumed by this function
+	 */
+	protected int examineEntityDecl(ASTentity_declaration entityDecl,StringBuffer name,StringBuffer type){
+		name.append(entityDecl.getIdentifier());
+		type.append("entityDecl#");	
+		return 0;
+	}
+	
+	protected int examineSubtypeDecl(ASTsubtype_declaration subtypeDecl,StringBuffer name,StringBuffer type){
+		name.append(subtypeDecl.getIdentifier());
+		type.append("subtypeDecl#");
+		return 0;
+	}
+	protected int examineSubtypeIndication(ASTsubtype_indication subtypeIndi,StringBuffer name,StringBuffer type){
+		name.append(subtypeIndi.getIdentifier());
+		type.append("subtypeIndi#");
+		return 0;
+	}
+	
+ 	protected int examineRecordDeclaration(ASTrecord_type_definition recorddecl) {
+		String[] names2 = null;
+
+		for (Node c : recorddecl.children) {
+			if(! (c instanceof SimpleNode)) continue;
+			SimpleNode child = (SimpleNode) c;
+			String subtype = "";
+
+			if (child instanceof ASTelement_declaration) {
+				ASTelement_declaration var = (ASTelement_declaration) child;
+				names2 = var.getIdentifierList();
+				subtype = var.getSubType();
+			}
+
+			for (String identifier : names2) {
+				beginOutlineElement(child.getFirstToken().beginLine, child
+						.getFirstToken().beginColumn, identifier,"recordmember#"+subtype);
+				endOutlineElement(child.getLastToken().endLine, child
+						.getLastToken().endColumn, identifier, "recordmember#"+subtype);
+			}
+		}
+		return recorddecl.getChildCount();// no more update
+
+	}
+	
+	/**
+	 * Breaks out a port clause and adds its children to the outline
+	 * @param portClause
+	 * @return  number of children consumed by this function
+	 */
+	protected int examinePortClause(ASTport_clause portClause){
+		String []names=null;
+		String type;
+		
+		ASTinterface_list interfaceList=portClause.getInterfaceList();
+		for(Node c:interfaceList.children){
+			SimpleNode child=(SimpleNode)c;
+			type="port#";
+			if (child instanceof ASTinterface_file_declaration) {
+				ASTinterface_file_declaration file = (ASTinterface_file_declaration) child;
+				names=file.getIdentifierList();
+				type+="# #"+file.getSubType();	
+			} else	if (child instanceof ASTinterface_signal_declaration) {
+				ASTinterface_signal_declaration signal = (ASTinterface_signal_declaration) child;
+				names=signal.getIdentifierList();
+				type+=signal.getMode()+"#"+signal.getSubType();					
+			} else if (child instanceof ASTinterface_constant_declaration) {
+				ASTinterface_constant_declaration constant = (ASTinterface_constant_declaration) child;
+				names=constant.getIdentifierList();
+				type+="in#"+constant.getSubType();
+			} else if (child instanceof ASTinterface_variable_declaration) {
+				ASTinterface_variable_declaration var = (ASTinterface_variable_declaration) child;
+				names=var.getIdentifierList();
+				type+=var.getMode()+"#"+var.getSubType();
+			} else{
+				continue;
+			}				
+			//add all the identifiers
+			for(String identifier:names){
+				beginOutlineElement(
+						child.getFirstToken().beginLine,
+						child.getFirstToken().beginColumn,
+						identifier, 
+						type);
+				endOutlineElement(
+						child.getLastToken().endLine,
+						child.getLastToken().endColumn,
+						identifier, 
+						type);
+			}
+		}
+		return 1;
+	}
+	/**
+	 * Breaks out a generic clause and adds it children to the outline
+	 * @param genericClause
+	 * @return  number of children consumed by this function
+	 */
+	protected int examineGenericClause(ASTgeneric_clause genericClause) {
+		String[] names = null;
+		String type;
+
+		ASTinterface_list interfaceList = genericClause.getInterfaceList();
+		for (Node c : interfaceList.children) {
+			SimpleNode child = (SimpleNode) c;
+			type = "generic#";
+			if (child instanceof ASTinterface_file_declaration) {
+				ASTinterface_file_declaration file = (ASTinterface_file_declaration) child;
+				names = file.getIdentifierList();
+				type += "#" + file.getSubType();
+			} else if (child instanceof ASTinterface_signal_declaration) {
+				ASTinterface_signal_declaration signal = (ASTinterface_signal_declaration) child;
+				names = signal.getIdentifierList();
+				type += signal.getSubType();
+			} else if (child instanceof ASTinterface_constant_declaration) {
+				ASTinterface_constant_declaration constant = (ASTinterface_constant_declaration) child;
+				names = constant.getIdentifierList();
+				type += constant.getSubType();
+			} else if (child instanceof ASTinterface_variable_declaration) {
+				ASTinterface_variable_declaration var = (ASTinterface_variable_declaration) child;
+				names = var.getIdentifierList();
+				type += var.getSubType();
+			} else {
+				continue;
+			}
+			// add all the identifiers
+			for (String identifier : names) {
+				beginOutlineElement(child.getFirstToken().beginLine, child
+						.getFirstToken().beginColumn, identifier, type);
+				endOutlineElement(child.getLastToken().endLine, child
+						.getLastToken().endColumn, identifier, type);
+			}
+		}
+		return 1;
+	}
+	/**
+	 * Breaks out an alias declaration
+	 * @param alias
+	 * @return
+	 */
+	protected int examineAlias(ASTalias_declaration alias){
+		String name = alias.getIdentifier();
+		String type = "alias#" + alias.getName();
+		beginOutlineElement(alias.getFirstToken().beginLine, alias
+				.getFirstToken().beginColumn, name, type);
+		endOutlineElement(alias.getLastToken().endLine,
+				alias.getLastToken().endColumn, name, type);
+		return 1;
+	}
+	/**
+	 * Breaks out signal,variable,constant, and file type declarations and adds
+	 * them to the outline
+	 * @param node
+	 * @return  number of children consumed by this function
+	 */
+	protected int examineDecl(SimpleNode node){
+		String type=null;
+		String []names=null;
+		
+		if(node instanceof ASTvariable_declaration){
+			ASTvariable_declaration var = (ASTvariable_declaration) node;		
+			names=var.getIdentifierList();
+			type="variable#"+var.getSubType();
+		}else if(node instanceof ASTsignal_declaration){
+			ASTsignal_declaration signal = (ASTsignal_declaration) node;			
+			names=signal.getIdentifierList();
+			type="signal#"+signal.getSubType();
+		}else if(node instanceof ASTconstant_declaration){
+			ASTconstant_declaration constant = (ASTconstant_declaration) node;
+			names=constant.getIdentifierList();
+			type="constant#"+constant.getSubType();
+		}else if(node instanceof ASTfile_declaration){
+			ASTfile_declaration file = (ASTfile_declaration) node;
+			names=file.getIdentifierList();
+			type="file#"+file.getSubType();
+		}
+		
+		for(String identifier:names){
+			beginOutlineElement(
+					node.getFirstToken().beginLine,
+					node.getFirstToken().beginColumn,
+					identifier, 
+					type);
+			endOutlineElement(
+					node.getLastToken().endLine,
+					node.getLastToken().endColumn,
+					identifier, 
+					type);
+			
+		}
+		
+		return 1;
+	}
+	
+	/**
+	 * Examines a subprogram specification. There are assumed to occur out side of their body  
+	 * @param spec
+	 * @param name
+	 * @param type
+	 * @return number of child elements consumed by this function
+	 */
+	protected int examineSubProgramSpec(ASTsubprogram_specification spec,StringBuffer name,StringBuffer type){
+		String subType=spec.getType().toLowerCase();
+		
+		name.append(spec.getIdentifier());
+		if(subType.contains("function")){
+			type.append("functionDecl#");
+		}else if(subType.contains("procedure")){
+			type.append("procedureDecl#");
+		} else if(subType.contains("record")){
+				type.append("recordDecl#");
+		}
+		
+		ASTformal_parameter_list paramters=spec.getParameters();
+		examineParameterList(paramters, type);
+		return 1;
+	}
+	/**
+	 * Examines a subprogram specification. There are assumed to occur out side of their body  
+	 * @param spec
+	 * @param name
+	 * @param type
+	 * @return number of child elements consumed by this function
+	 */
+	protected int examineSubProgramBody(ASTsubprogram_body body,StringBuffer name,StringBuffer type){
+		ASTsubprogram_specification spec=body.getSpecification();
+		String subType=spec.getType().toLowerCase();
+		
+		name.append(spec.getIdentifier());
+		if(subType.contains("function")){
+			type.append("function#");
+		}else if(subType.contains("procedure")){
+			type.append("procedure#");
+		}else if(subType.contains("record")){
+			type.append("record#");
+		}
+		
+		ASTformal_parameter_list paramters=spec.getParameters();
+		examineParameterList(paramters, type);
+		
+		return 1;
+	}
+
+	int examineParameterList(ASTformal_parameter_list paramters,
+			StringBuffer type) {
+		String[] paramNames;
+		String paramType;
+
+		if (paramters != null) {
+			ASTinterface_list interfaceList = paramters.getInterfaceList();
+			for (Node c : interfaceList.children) {
+				SimpleNode child = (SimpleNode) c;
+				if (child instanceof ASTinterface_file_declaration) {
+					ASTinterface_file_declaration file = (ASTinterface_file_declaration) child;
+					paramNames = file.getIdentifierList();
+					paramType = file.getSubType() + "# ";
+				} else if (child instanceof ASTinterface_signal_declaration) {
+					ASTinterface_signal_declaration signal = (ASTinterface_signal_declaration) child;
+					paramNames = signal.getIdentifierList();
+					paramType = signal.getSubType() + "#" + signal.getMode()+ "#";;
+				} else if (child instanceof ASTinterface_constant_declaration) {
+					ASTinterface_constant_declaration constant = (ASTinterface_constant_declaration) child;
+					paramNames = constant.getIdentifierList();
+					paramType = constant.getSubType() + "#in#";
+				} else if (child instanceof ASTinterface_variable_declaration) {
+					ASTinterface_variable_declaration var = (ASTinterface_variable_declaration) child;
+					paramNames = var.getIdentifierList();
+					paramType = var.getSubType() + "#" + var.getMode()+ "#";;
+				} else {
+					continue;
+				}
+				// add all the parameters
+				for (String identifier : paramNames) {
+					type.append(identifier);
+					type.append("#" + paramType);
+				}
+			}			
+		}
+		return 1;
+	}
+
+	public int getContext()
+	{
+		return 0;
+	}
+}
+
+
+
+
+
+
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/VHDLParserThread.java vdt/src/com/elphel/vdt/veditor/parser/vhdl/VHDLParserThread.java
--- vdt-veditor/src/com/elphel/vdt/veditor/parser/vhdl/VHDLParserThread.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/parser/vhdl/VHDLParserThread.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,13 +1,13 @@
-package net.sourceforge.veditor.parser.vhdl;
+package com.elphel.vdt.veditor.parser.vhdl;
 
 import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStreamReader;
 
-import net.sourceforge.veditor.VerilogPlugin;
-import net.sourceforge.veditor.parser.HdlParserException;
-import net.sourceforge.veditor.parser.ParserReader;
-import net.sourceforge.veditor.preference.PreferenceStrings;
+import com.elphel.vdt.veditor.VerilogPlugin;
+import com.elphel.vdt.veditor.parser.HdlParserException;
+import com.elphel.vdt.veditor.parser.ParserReader;
+import com.elphel.vdt.veditor.preference.PreferenceStrings;
 
 import org.eclipse.core.resources.IFile;
 import org.eclipse.core.runtime.CoreException;
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/preference/AbstractPreferencePage.java vdt/src/com/elphel/vdt/veditor/preference/AbstractPreferencePage.java
--- vdt-veditor/src/com/elphel/vdt/veditor/preference/AbstractPreferencePage.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/preference/AbstractPreferencePage.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,28 +1,39 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.preference;
-
-import org.eclipse.jface.preference.PreferencePage;
-import org.eclipse.swt.widgets.Composite;
-import org.eclipse.swt.widgets.Control;
-import org.eclipse.ui.IWorkbench;
-import org.eclipse.ui.IWorkbenchPreferencePage;
-
-abstract public class AbstractPreferencePage extends PreferencePage
-		implements IWorkbenchPreferencePage
-{
-	abstract protected Control createContents(Composite parent);
-
-	public void init(IWorkbench workbench)
-	{
-	}
-
-}
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.preference;
+
+import org.eclipse.jface.preference.PreferencePage;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.ui.IWorkbench;
+import org.eclipse.ui.IWorkbenchPreferencePage;
+
+abstract public class AbstractPreferencePage extends PreferencePage
+		implements IWorkbenchPreferencePage
+{
+	abstract protected Control createContents(Composite parent);
+
+	public void init(IWorkbench workbench)
+	{
+	}
+
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/preference/AbstractSimplePreferencePage.java vdt/src/com/elphel/vdt/veditor/preference/AbstractSimplePreferencePage.java
--- vdt-veditor/src/com/elphel/vdt/veditor/preference/AbstractSimplePreferencePage.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/preference/AbstractSimplePreferencePage.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,49 +1,112 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.preference;
-
-import net.sourceforge.veditor.VerilogPlugin;
-
-import org.eclipse.jface.preference.BooleanFieldEditor;
-import org.eclipse.jface.preference.FieldEditorPreferencePage;
-import org.eclipse.jface.preference.StringFieldEditor;
-import org.eclipse.ui.IWorkbench;
-import org.eclipse.ui.IWorkbenchPreferencePage;
-
-/**
- * Simple preference page, which uses FieldEditor
- */
-abstract public class AbstractSimplePreferencePage extends
-		FieldEditorPreferencePage implements IWorkbenchPreferencePage
-{
-	public AbstractSimplePreferencePage()
-	{
-		super(GRID);
-		setPreferenceStore(VerilogPlugin.getPlugin().getPreferenceStore());
-	}
-
-	abstract protected void createFieldEditors();
-
-	protected void addStringField(String name, String label)
-	{
-		addField(new StringFieldEditor(name, label, getFieldEditorParent()));
-	}
-
-	protected void addBooleanField(String name, String label)
-	{
-		addField(new BooleanFieldEditor(name, label, getFieldEditorParent()));
-	}
-
-	public void init(IWorkbench workbench)
-	{
-	}
-}
-
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.preference;
+
+import com.elphel.vdt.veditor.VerilogPlugin;
+import com.elphel.vdt.veditor.document.HdlDocument;
+import com.elphel.vdt.veditor.editor.HdlEditor;
+import com.elphel.vdt.veditor.parser.HdlParserException;
+
+import org.eclipse.jface.preference.BooleanFieldEditor;
+import org.eclipse.jface.preference.FieldEditor;
+import org.eclipse.jface.preference.FieldEditorPreferencePage;
+import org.eclipse.jface.preference.ScaleFieldEditor;
+import org.eclipse.jface.preference.StringFieldEditor;
+import org.eclipse.swt.widgets.Display;
+import org.eclipse.ui.IWorkbench;
+import org.eclipse.ui.IWorkbenchPreferencePage;
+
+/**
+ * Simple preference page, which uses FieldEditor
+ */
+abstract public class AbstractSimplePreferencePage extends
+		FieldEditorPreferencePage implements IWorkbenchPreferencePage
+{
+	public AbstractSimplePreferencePage()
+	{
+		super(GRID);
+		setPreferenceStore(VerilogPlugin.getPlugin().getPreferenceStore());
+	}
+
+	abstract protected void createFieldEditors();
+
+	protected void addStringField(String name, String label)
+	{
+		addField(new StringFieldEditor(name, label, getFieldEditorParent()));
+	}
+
+	protected void addBooleanField(String name, String label)
+	{
+		addField(new BooleanFieldEditor(name, label, getFieldEditorParent()));
+	}
+// Andey
+	protected void addStringField(String name, String label, String toolTip)
+	{
+		FieldEditor fe=new StringFieldEditor(name, label, getFieldEditorParent());
+		fe.getLabelControl(getFieldEditorParent()).setToolTipText(toolTip);
+		addField(fe);
+	}
+	protected void addBooleanField(String name, String label, String toolTip)
+	{
+		BooleanFieldEditor fe=new BooleanFieldEditor(name, label, getFieldEditorParent());
+		fe.getDescriptionControl(getFieldEditorParent()).setToolTipText(toolTip);
+		addField(fe);
+	}
+	protected void addScaleField(String name, String label, int min, int max, int increment, int pageIncrement, String toolTip)
+	{
+		ScaleFieldEditor fe=new ScaleFieldEditor(name, label, getFieldEditorParent(),
+				min, max, increment, pageIncrement);
+		if (toolTip!=null) fe.getLabelControl(getFieldEditorParent()).setToolTipText(toolTip);
+		addField(fe);
+	}
+	//Andrey: Updating problem markers in the current editor window after preferences change
+	@Override
+	public boolean performOk(){
+		if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR)) {
+			System.out.println("AbstractSimplePreferencePage:performOk()");
+		}
+			Display.getDefault().asyncExec(new Runnable() {
+				public void run() {
+				HdlEditor current=HdlEditor.current();
+				if (current!=null) {
+					current.updatePagesIfFree(true); // Only if there is HDL editor in the editor
+					HdlDocument doc=current.getHdlDocument();
+					if (doc!=null)
+						try {
+							doc.uncondRefreshOutline();
+						} catch (HdlParserException e) {
+							System.out.println("Failed to doc.uncondRefreshOutline()");
+						}
+//					current.refreshEditor(); // This reload file to the editor, or changes are lost!
+				}
+			}
+		});
+        return super.performOk();
+	}
+
+	
+	public void init(IWorkbench workbench)
+	{
+//		System.out.println("AbstractSimplePreferencePage:init()");
+	}
+}
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/preference/CodeStylePreferencePage.java vdt/src/com/elphel/vdt/veditor/preference/CodeStylePreferencePage.java
--- vdt-veditor/src/com/elphel/vdt/veditor/preference/CodeStylePreferencePage.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/preference/CodeStylePreferencePage.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,74 +1,98 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2007 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.preference;
-
-import org.eclipse.jface.preference.RadioGroupFieldEditor;
-import org.eclipse.swt.widgets.Composite;
-
-public class CodeStylePreferencePage extends AbstractSimplePreferencePage
-{   
-	RadioGroupFieldEditor indentEditor;
-	RadioGroupFieldEditor indentSizeEditor;	
-
-	protected void createFieldEditors()
-	{
-		Composite parent = getFieldEditorParent();
-
-		indentEditor = new IndentFieldEditor(
-		        PreferenceStrings.INDENT_TYPE, "Indent character", 2,
-					new String[][]{
-							{"Tab",   PreferenceStrings.INDENT_TAB },
-							{"Space", PreferenceStrings.INDENT_SPACE}
-					},
-					parent);
-		addField(indentEditor);
-		
-		indentSizeEditor = new RadioGroupFieldEditor(
-		        PreferenceStrings.INDENT_SIZE, "Indent size", 4,
-				new String[][]{
-						{"2", PreferenceStrings.INDENT_SIZE_2},
-						{"3", PreferenceStrings.INDENT_SIZE_3},
-						{"4", PreferenceStrings.INDENT_SIZE_4},
-						{"8", PreferenceStrings.INDENT_SIZE_8}
-				},
-				parent);
-		addField(indentSizeEditor);
-		
-		String indent = getPreferenceStore().getString(PreferenceStrings.INDENT_TYPE);
-		indentSizeEditor.setEnabled(indent.equals(PreferenceStrings.INDENT_SPACE), parent);
-	}
-	
-	class IndentFieldEditor extends RadioGroupFieldEditor
-	{
-		public IndentFieldEditor(String name, String labelText, int numColumns,
-				String[][] labelAndValues, Composite parent)
-		{
-			super(name, labelText, numColumns, labelAndValues, parent);
-		}
-
-		protected void fireValueChanged(String property, Object oldValue,
-				Object newValue)
-		{
-			super.fireValueChanged(property, oldValue, newValue);
-			boolean sizeValid = newValue.equals(PreferenceStrings.INDENT_SPACE);
-			indentSizeEditor.setEnabled(sizeValid, getFieldEditorParent());
-		}
-    }
-}
-
-
-
-
-
-
-
-
-
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+/*******************************************************************************
+ * Copyright (c) 2004, 2007 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.preference;
+
+import org.eclipse.jface.preference.RadioGroupFieldEditor;
+import org.eclipse.swt.widgets.Composite;
+
+public class CodeStylePreferencePage extends AbstractSimplePreferencePage
+{   
+	RadioGroupFieldEditor indentEditor;
+	RadioGroupFieldEditor indentSizeEditor;	
+	RadioGroupFieldEditor instanceTemplateEditor;	
+
+	protected void createFieldEditors()
+	{
+		Composite parent = getFieldEditorParent();
+
+		indentEditor = new IndentFieldEditor(
+		        PreferenceStrings.INDENT_TYPE, "Indent character", 2,
+					new String[][]{
+							{"Tab",   PreferenceStrings.INDENT_TAB },
+							{"Space", PreferenceStrings.INDENT_SPACE}
+					},
+					parent);
+		addField(indentEditor);
+		
+		indentSizeEditor = new RadioGroupFieldEditor(
+		        PreferenceStrings.INDENT_SIZE, "Indent size", 4,
+				new String[][]{
+						{"2", PreferenceStrings.INDENT_SIZE_2},
+						{"3", PreferenceStrings.INDENT_SIZE_3},
+						{"4", PreferenceStrings.INDENT_SIZE_4},
+						{"8", PreferenceStrings.INDENT_SIZE_8}
+				},
+				parent);
+		addField(indentSizeEditor);
+		
+		String indent = getPreferenceStore().getString(PreferenceStrings.INDENT_TYPE);
+		indentSizeEditor.setEnabled(indent.equals(PreferenceStrings.INDENT_SPACE), parent);
+
+		instanceTemplateEditor = new RadioGroupFieldEditor(
+		        PreferenceStrings.INST_TEMPLATE, "Verilog module instance template", 4,
+				new String[][]{
+						{"No parameters", PreferenceStrings.INST_TEMPLATE_COMPACT},
+						{"Single line", PreferenceStrings.INST_TEMPLATE_SINGLE},
+						{"Multi-line", PreferenceStrings.INST_TEMPLATE_MULTI},
+						{"Multi-line, commented", PreferenceStrings.INST_TEMPLATE_COMMENTED}
+				},
+				parent);
+		addField(instanceTemplateEditor);
+		
+	}
+	
+	class IndentFieldEditor extends RadioGroupFieldEditor
+	{
+		public IndentFieldEditor(String name, String labelText, int numColumns,
+				String[][] labelAndValues, Composite parent)
+		{
+			super(name, labelText, numColumns, labelAndValues, parent);
+		}
+
+		protected void fireValueChanged(String property, Object oldValue,
+				Object newValue)
+		{
+			super.fireValueChanged(property, oldValue, newValue);
+			boolean sizeValid = newValue.equals(PreferenceStrings.INDENT_SPACE);
+			indentSizeEditor.setEnabled(sizeValid, getFieldEditorParent());
+		}
+    }
+}
+
+
+
+
+
+
+
+
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/preference/ColorPreferencePage.java vdt/src/com/elphel/vdt/veditor/preference/ColorPreferencePage.java
--- vdt-veditor/src/com/elphel/vdt/veditor/preference/ColorPreferencePage.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/preference/ColorPreferencePage.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,190 +1,203 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.preference;
-
-import net.sourceforge.veditor.VerilogPlugin;
-import net.sourceforge.veditor.editor.HdlTextAttribute;
-
-import org.eclipse.jface.preference.ColorSelector;
-import org.eclipse.jface.util.IPropertyChangeListener;
-import org.eclipse.jface.util.PropertyChangeEvent;
-import org.eclipse.swt.SWT;
-import org.eclipse.swt.events.SelectionAdapter;
-import org.eclipse.swt.events.SelectionEvent;
-import org.eclipse.swt.events.SelectionListener;
-import org.eclipse.swt.graphics.RGB;
-import org.eclipse.swt.layout.GridLayout;
-import org.eclipse.swt.widgets.Button;
-import org.eclipse.swt.widgets.Composite;
-import org.eclipse.swt.widgets.Control;
-import org.eclipse.swt.widgets.Label;
-import org.eclipse.swt.widgets.List;
-
-/**
- * Color Preference page
- */
-public class ColorPreferencePage extends AbstractPreferencePage
-{
-	public ColorPreferencePage()
-	{
-	}
-
-    private List colorList;
-	private ColorSelector colorSelector;
-	private Button boldButton;
-    private Button italicButton;
-    private FieldListener fieldListener = new FieldListener();
-
-    private class TextAttribute
-	{
-		public String key;
-		public String label;
-		
-		public TextAttribute(String key, String label)
-		{
-			this.key = key;
-			this.label = label;
-		}
-		public void updateFields()
-		{
-			RGB color = VerilogPlugin.getPreferenceColor("Color." + key);
-			colorSelector.setColorValue(color);
-			
-			boolean bold = VerilogPlugin.getPreferenceBoolean("Bold." + key);
-			boldButton.setSelection(bold);
-			
-			boolean italic = VerilogPlugin.getPreferenceBoolean("Italic." + key );
-			italicButton.setSelection(italic);
-		}
-		public void updatePreference()
-		{
-			RGB color = colorSelector.getColorValue();
-			VerilogPlugin.setPreference("Color." + key, color);
-			
-			boolean bold = boldButton.getSelection();
-			VerilogPlugin.setPreference("Bold." + key, bold);
-
-			boolean italic = italicButton.getSelection();
-			VerilogPlugin.setPreference("Italic." + key, italic);
-		}
-		public void loadDefault()
-		{
-			VerilogPlugin.setDefaultPreference("Color." + key);
-			VerilogPlugin.setDefaultPreference("Bold." + key);
-			VerilogPlugin.setDefaultPreference("Italic." + key);
-		}
-	}
-    private TextAttribute[] attributes = {
-			new TextAttribute("Default", "Default"),
-			new TextAttribute("SingleLineComment", "Single line comment"),
-			new TextAttribute("MultiLineComment", "Multi line comment"),
-			new TextAttribute("DoxygenComment", "Doxygen comment"),
-			new TextAttribute("KeyWord", "Reserved word"),
-			new TextAttribute("String", "String"),
-			new TextAttribute("Directive", "Directive"),
-			new TextAttribute("Types", "Types"),
-			new TextAttribute("AutoTasks", "Auto Tasks (FIXME,TODO,etc)")};
-
-    protected Control createContents(Composite parent)
-	{
-		Composite composite = new Composite(parent, SWT.NONE);
-
-		createColorSection(composite);
-
-		// initializeValues();
-		return composite;
-	}
-
-    private void createColorSection(Composite parent)
-	{
-		parent.setLayout(new GridLayout(2, false));
-		colorList = new List(parent, SWT.SINGLE | SWT.BORDER | SWT.V_SCROLL);
-		Composite attrField = new Composite(parent, SWT.NONE);
-		attrField.setLayout(new GridLayout(2, false));
-
-		new Label(attrField, SWT.NONE).setText("Color:");
-		colorSelector = new ColorSelector(attrField);
-		new Label(attrField, SWT.NONE).setText("Bold:");
-		boldButton = new Button(attrField, SWT.CHECK);
-		new Label(attrField, SWT.NONE).setText("Italic:");
-		italicButton = new Button(attrField, SWT.CHECK);
-		attributes[0].updateFields();
-
-		String labels[] = new String[attributes.length];
-		for (int i = 0; i < attributes.length; i++)
-		{
-			labels[i] = attributes[i].label;
-			//itemList.setItem(i, attributes[i].label);
-		}
-		colorList.setItems(labels);
-		colorList.addSelectionListener(new SelectionAdapter()
-		{
-			public void widgetSelected(SelectionEvent e)
-			{
-				int idx = colorList.getSelectionIndex();
-				if (idx >= 0)
-					attributes[idx].updateFields();
-			}
-		});
-		colorList.select(0);
-
-		colorSelector.addListener(fieldListener);
-		boldButton.addSelectionListener(fieldListener);
-		italicButton.addSelectionListener(fieldListener);
-	}
-    
-    private class FieldListener implements IPropertyChangeListener,
-			SelectionListener
-	{
-		public void propertyChange(PropertyChangeEvent event)
-		{
-			updatePreference();
-		}
-
-		public void widgetSelected(SelectionEvent e)
-		{
-			updatePreference();
-		}
-
-		public void widgetDefaultSelected(SelectionEvent e)
-		{
-			updatePreference();
-		}
-
-		private void updatePreference()
-		{
-			int idx = colorList.getSelectionIndex();
-			if (idx >= 0)
-				attributes[idx].updatePreference();
-		}
-	}
-
-    public boolean performOk()
-	{
-		super.performOk();
-		HdlTextAttribute.init();
-		return true;
-	}
-    
-    protected void performDefaults()
-    {
-    	super.performDefaults();
-		for (int i = 0; i < attributes.length; i++)
-		{
-			attributes[i].loadDefault();
-		}
-		int idx = colorList.getSelectionIndex();
-		if (idx >= 0)
-			attributes[idx].updateFields();
-    }
-
-}
-
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.preference;
+
+import com.elphel.vdt.veditor.VerilogPlugin;
+import com.elphel.vdt.veditor.editor.HdlTextAttribute;
+
+import org.eclipse.jface.preference.ColorSelector;
+import org.eclipse.jface.util.IPropertyChangeListener;
+import org.eclipse.jface.util.PropertyChangeEvent;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.SelectionAdapter;
+import org.eclipse.swt.events.SelectionEvent;
+import org.eclipse.swt.events.SelectionListener;
+import org.eclipse.swt.graphics.RGB;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Label;
+import org.eclipse.swt.widgets.List;
+
+/**
+ * Color Preference page
+ */
+public class ColorPreferencePage extends AbstractPreferencePage
+{
+	public ColorPreferencePage()
+	{
+	}
+
+    private List colorList;
+	private ColorSelector colorSelector;
+	private Button boldButton;
+    private Button italicButton;
+    private FieldListener fieldListener = new FieldListener();
+
+    private class TextAttribute
+	{
+		public String key;
+		public String label;
+		
+		public TextAttribute(String key, String label)
+		{
+			this.key = key;
+			this.label = label;
+		}
+		public void updateFields()
+		{
+			RGB color = VerilogPlugin.getPreferenceColor("Color." + key);
+			colorSelector.setColorValue(color);
+			
+			boolean bold = VerilogPlugin.getPreferenceBoolean("Bold." + key);
+			boldButton.setSelection(bold);
+			
+			boolean italic = VerilogPlugin.getPreferenceBoolean("Italic." + key );
+			italicButton.setSelection(italic);
+		}
+		public void updatePreference()
+		{
+			RGB color = colorSelector.getColorValue();
+			VerilogPlugin.setPreference("Color." + key, color);
+			
+			boolean bold = boldButton.getSelection();
+			VerilogPlugin.setPreference("Bold." + key, bold);
+
+			boolean italic = italicButton.getSelection();
+			VerilogPlugin.setPreference("Italic." + key, italic);
+		}
+		public void loadDefault()
+		{
+			VerilogPlugin.setDefaultPreference("Color." + key);
+			VerilogPlugin.setDefaultPreference("Bold." + key);
+			VerilogPlugin.setDefaultPreference("Italic." + key);
+		}
+	}
+    private TextAttribute[] attributes = {
+			new TextAttribute("Default", "Default"),
+			new TextAttribute("SingleLineComment", "Single line comment"),
+			new TextAttribute("MultiLineComment", "Multi line comment"),
+			new TextAttribute("DoxygenComment", "Doxygen comment"),
+			new TextAttribute("KeyWord", "Reserved word"),
+			new TextAttribute("String", "String"),
+			new TextAttribute("Directive", "Directive"),
+			new TextAttribute("Types", "Types"),
+			new TextAttribute("AutoTasks", "Auto Tasks (FIXME,TODO,etc)"),
+			new TextAttribute("DisabledCode", "Code disabled by `ifdef"),
+			};
+
+    protected Control createContents(Composite parent)
+	{
+		Composite composite = new Composite(parent, SWT.NONE);
+
+		createColorSection(composite);
+
+		// initializeValues();
+		return composite;
+	}
+
+    private void createColorSection(Composite parent)
+	{
+		parent.setLayout(new GridLayout(2, false));
+		colorList = new List(parent, SWT.SINGLE | SWT.BORDER | SWT.V_SCROLL);
+		Composite attrField = new Composite(parent, SWT.NONE);
+		attrField.setLayout(new GridLayout(2, false));
+
+		new Label(attrField, SWT.NONE).setText("Color:");
+		colorSelector = new ColorSelector(attrField);
+		new Label(attrField, SWT.NONE).setText("Bold:");
+		boldButton = new Button(attrField, SWT.CHECK);
+		new Label(attrField, SWT.NONE).setText("Italic:");
+		italicButton = new Button(attrField, SWT.CHECK);
+		attributes[0].updateFields();
+
+		String labels[] = new String[attributes.length];
+		for (int i = 0; i < attributes.length; i++)
+		{
+			labels[i] = attributes[i].label;
+			//itemList.setItem(i, attributes[i].label);
+		}
+		colorList.setItems(labels);
+		colorList.addSelectionListener(new SelectionAdapter()
+		{
+			public void widgetSelected(SelectionEvent e)
+			{
+				int idx = colorList.getSelectionIndex();
+				if (idx >= 0)
+					attributes[idx].updateFields();
+			}
+		});
+		colorList.select(0);
+
+		colorSelector.addListener(fieldListener);
+		boldButton.addSelectionListener(fieldListener);
+		italicButton.addSelectionListener(fieldListener);
+	}
+    
+    private class FieldListener implements IPropertyChangeListener,
+			SelectionListener
+	{
+		public void propertyChange(PropertyChangeEvent event)
+		{
+			updatePreference();
+		}
+
+		public void widgetSelected(SelectionEvent e)
+		{
+			updatePreference();
+		}
+
+		public void widgetDefaultSelected(SelectionEvent e)
+		{
+			updatePreference();
+		}
+
+		private void updatePreference()
+		{
+			int idx = colorList.getSelectionIndex();
+			if (idx >= 0)
+				attributes[idx].updatePreference();
+		}
+	}
+
+    public boolean performOk()
+	{
+		super.performOk();
+		HdlTextAttribute.init();
+		return true;
+	}
+    
+    protected void performDefaults()
+    {
+    	super.performDefaults();
+		for (int i = 0; i < attributes.length; i++)
+		{
+			attributes[i].loadDefault();
+		}
+		int idx = colorList.getSelectionIndex();
+		if (idx >= 0)
+			attributes[idx].updateFields();
+    }
+
+}
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/preference/ErrorParserPreferencePage.java vdt/src/com/elphel/vdt/veditor/preference/ErrorParserPreferencePage.java
--- vdt-veditor/src/com/elphel/vdt/veditor/preference/ErrorParserPreferencePage.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/preference/ErrorParserPreferencePage.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,325 +1,336 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.preference;
-
-import net.sourceforge.veditor.builder.ErrorParser;
-import org.eclipse.jface.dialogs.IInputValidator;
-import org.eclipse.jface.dialogs.InputDialog;
-import org.eclipse.swt.SWT;
-import org.eclipse.swt.events.ModifyEvent;
-import org.eclipse.swt.events.ModifyListener;
-import org.eclipse.swt.events.SelectionAdapter;
-import org.eclipse.swt.events.SelectionEvent;
-import org.eclipse.swt.layout.GridData;
-import org.eclipse.swt.layout.GridLayout;
-import org.eclipse.swt.widgets.Button;
-import org.eclipse.swt.widgets.Composite;
-import org.eclipse.swt.widgets.Control;
-import org.eclipse.swt.widgets.Label;
-import org.eclipse.swt.widgets.List;
-import org.eclipse.swt.widgets.Text;
-
-public class ErrorParserPreferencePage extends AbstractPreferencePage
-{
-
-	private java.util.List<ErrorParser> parserList;
-	private List compilerList;
-	Button newButton;
-	Button removeButton;
-	private Text errText;
-	private Button m_ErrorPatternButton;
-	private Text warnText;
-	private Button m_WarnPatternButton;
-	private Text infoText;
-	private Button m_InfoPatternButton;
-	
-	protected Control createContents(Composite parent)
-	{
-		Composite composite = new Composite(parent, SWT.NONE);
-		composite.setLayout(new GridLayout(1, false));
-
-		createSection(composite);
-		createTextField(composite);
-		initializeSelection();
-
-		return composite;
-	}
-	
-	private void createSection(Composite parent)
-	{
-		// create compiler selection
-		Composite field = new Composite(parent, SWT.NONE);
-		field.setLayout(new GridLayout(2, false));
-		compilerList = new List(field, SWT.SINGLE | SWT.BORDER | SWT.V_SCROLL);
-		GridData listgd = new GridData();
-		listgd.heightHint = 80;
-		compilerList.setLayoutData(listgd);
-
-		compilerList.addSelectionListener(new SelectionAdapter()
-		{
-			public void widgetSelected(SelectionEvent e)
-			{
-				int idx = compilerList.getSelectionIndex();
-				changeSelection(idx);
-			}
-		});
-		
-		createButtons(field);
-	}
-
-	private void createButtons(Composite field)
-	{
-		// create new/remove button
-		Composite buttonField = new Composite(field, SWT.NONE);
-		buttonField.setLayout(new GridLayout(1, false));
-		newButton = new Button(buttonField, SWT.PUSH);
-		removeButton = new Button(buttonField, SWT.PUSH);
-		newButton.setText("&New...");
-		removeButton.setText("&Remove");
-		GridData gd = new GridData(GridData.FILL_HORIZONTAL);
-		newButton.setLayoutData(gd);
-		removeButton.setLayoutData(gd);
-		
-		newButton.addSelectionListener(new SelectionAdapter()
-		{
-			public void widgetSelected(SelectionEvent e)
-			{
-				InputDialog dlog = new InputDialog(getShell(),
-						"New Error Parser", "Compiler name:", "",
-						new NameValidator());
-				dlog.open();
-				String name = dlog.getValue();
-				if (name != null && name.length() > 0)
-				{
-					addParser(name);
-				}
-			}
-		});
-		
-		removeButton.addSelectionListener(new SelectionAdapter()
-		{
-			public void widgetSelected(SelectionEvent e)
-			{
-				int idx = compilerList.getSelectionIndex();
-				if (idx < parserList.size() && ((ErrorParser)parserList.get(idx)).isEditable())
-				{
-					parserList.remove(idx);
-					updateSelection();
-
-					if (idx >= parserList.size())
-						idx = parserList.size() - 1;
-					changeSelection(idx);
-				}
-			}
-		});
-	}
-	
-	private void createTextField(Composite parent)
-	{
-		Composite field = new Composite(parent, SWT.NONE);
-		field.setLayout(new GridLayout(3, false));
-		GridData gd = new GridData(GridData.FILL_HORIZONTAL);
-		field.setLayoutData(gd);
-		
-		errText = createText(field, "Error Pattern:");
-		m_ErrorPatternButton=new Button(field,SWT.PUSH);
-		m_ErrorPatternButton.setText("...");
-		m_ErrorPatternButton.addSelectionListener(new PatternBuilderListener(errText));
-		warnText = createText(field, "Warning Pattern:");
-		m_WarnPatternButton=new Button(field,SWT.PUSH);
-		m_WarnPatternButton.setText("...");
-		m_WarnPatternButton.addSelectionListener(new PatternBuilderListener(warnText));
-		infoText = createText(field, "Info Pattern:");
-		m_InfoPatternButton=new Button(field,SWT.PUSH);
-		m_InfoPatternButton.setText("...");
-		m_InfoPatternButton.addSelectionListener(new PatternBuilderListener(infoText));
-		
-		errText.addModifyListener(new TextModifyListener(errText,0));
-		warnText.addModifyListener(new TextModifyListener(warnText,1));
-		infoText.addModifyListener(new TextModifyListener(infoText,2));
-	}
-	
-	private Text createText(Composite parent, String name)
-	{
-		Label label = new Label(parent, SWT.NULL);
-		label.setText(name);
-		Text text = new Text(parent, SWT.BORDER | SWT.SINGLE);
-		GridData gd = new GridData(GridData.FILL_HORIZONTAL);
-		text.setLayoutData(gd);
-
-		return text;
-	}
-
-	private void initializeSelection()
-	{
-		parserList = ErrorParser.getParserList();
-
-		updateSelection();
-		changeSelection(0);
-	}
-	
-	/**
-	 * add new parser
-	 * @param newCompiler	compiler name
-	 */
-	private void addParser(String newCompiler)
-	{
-		ErrorParser newParser = new ErrorParser(newCompiler);
-		newParser.setRegex("", "", "");
-		parserList.add(newParser);
-		updateSelection();
-
-		changeSelection(parserList.size() - 1);
-	}
-
-	/**
-	 * It is called when the parser list is modified
-	 */
-	private void updateSelection()
-	{
-		String labels[] = new String[parserList.size()];
-		for (int i = 0; i < parserList.size(); i++)
-		{
-			labels[i] = ((ErrorParser)parserList.get(i)).getCompilerName();
-		}
-		compilerList.setItems(labels);
-	}
-	
-	/**
-	 * It is called when the selection focus is changed
-	 */
-	private void changeSelection(int idx)
-	{
-		if (0 <= idx && idx < parserList.size())
-		{
-			compilerList.select(idx);
-			boolean removable = ((ErrorParser)parserList.get(idx)).isEditable();
-			removeButton.setEnabled(removable);
-		
-			updateTextField(idx);
-		}
-		else
-		{
-			// maybe never executed
-			removeButton.setEnabled(false);
-			updateTextField(-1);
-		}
-	}
-	
-	private void updateTextField(int idx)
-	{
-		if (idx >= 0 && idx < parserList.size())
-		{
-			ErrorParser parser = (ErrorParser)parserList.get(idx);
-			errText.setText(parser.getErrorRegex());
-			warnText.setText(parser.getWarningRegex());
-			infoText.setText(parser.getInfoRegex());
-		
-			boolean editable = ((ErrorParser)parserList.get(idx)).isEditable();
-			errText.setEditable(editable);
-			warnText.setEditable(editable);
-			infoText.setEditable(editable);
-			m_ErrorPatternButton.setEnabled(editable);
-			m_WarnPatternButton.setEnabled(editable);
-			m_InfoPatternButton.setEnabled(editable);
-		}
-		else
-		{
-			errText.setText("");
-			warnText.setText("");
-			infoText.setText("");
-			errText.setEditable(false);
-			warnText.setEditable(false);
-			infoText.setEditable(false);
-			m_ErrorPatternButton.setEnabled(false);
-			m_WarnPatternButton.setEnabled(false);
-			m_InfoPatternButton.setEnabled(false);
-		}
-	}
-
-	/**
-	 * for new compiler dialog
-	 */
-	private static class NameValidator implements IInputValidator
-	{
-		public String isValid(String newText)
-		{
-			if (newText.length() == 0)
-			{
-				return "Compiler name must be specified";
-			}
-			return null;
-		}
-	}
-	
-	/**
-	 * it is called when errText, warnText or infoText is modified
-	 */
-	private class TextModifyListener implements ModifyListener
-	{
-		private Text text;
-		private int mode;
-
-		public TextModifyListener(Text text, int mode)
-		{
-			this.text = text;
-			this.mode = mode;
-		}
-		public void modifyText(ModifyEvent e)
-		{
-			int idx = compilerList.getSelectionIndex();
-			ErrorParser parser = (ErrorParser)parserList.get(idx);
-			parser.setRegex(mode, text.getText());
-		}
-	}
-
-	public boolean performOk()
-	{
-		super.performOk();
-		ErrorParser.setParserList(parserList);
-		return true;
-	}
-
-    protected void performDefaults()
-    {
-    	super.performDefaults();
-    	ErrorParser.setDefaultParsers();
-    	initializeSelection();
-    }
-    
-    /**
-	 * Class called when the user presses pattern builder button
-	 *
-	 */
-	private class PatternBuilderListener extends SelectionAdapter {
-		Text m_TargetTextBox;
-
-		/**
-		 * Class constructor
-		 * 
-		 * @param text  The text box we need to fill the data with
-		 */
-		public PatternBuilderListener(Text text) {
-			super();
-			m_TargetTextBox = text;
-		}
-
-		public void widgetSelected(SelectionEvent e) {
-
-			PatternBuilderDialog dialog = new PatternBuilderDialog(getControl()
-					.getShell(),m_TargetTextBox.getText());
-			dialog.open();
-			m_TargetTextBox.setText(dialog.getPattern());
-			
-		}
-	}
-}
-
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.preference;
+
+import com.elphel.vdt.veditor.builder.ErrorParser;
+import org.eclipse.jface.dialogs.IInputValidator;
+import org.eclipse.jface.dialogs.InputDialog;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.ModifyEvent;
+import org.eclipse.swt.events.ModifyListener;
+import org.eclipse.swt.events.SelectionAdapter;
+import org.eclipse.swt.events.SelectionEvent;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Label;
+import org.eclipse.swt.widgets.List;
+import org.eclipse.swt.widgets.Text;
+
+public class ErrorParserPreferencePage extends AbstractPreferencePage
+{
+
+	private java.util.List<ErrorParser> parserList;
+	private List compilerList;
+	Button newButton;
+	Button removeButton;
+	private Text errText;
+	private Button m_ErrorPatternButton;
+	private Text warnText;
+	private Button m_WarnPatternButton;
+	private Text infoText;
+	private Button m_InfoPatternButton;
+	
+	protected Control createContents(Composite parent)
+	{
+		Composite composite = new Composite(parent, SWT.NONE);
+		composite.setLayout(new GridLayout(1, false));
+
+		createSection(composite);
+		createTextField(composite);
+		initializeSelection();
+
+		return composite;
+	}
+	
+	private void createSection(Composite parent)
+	{
+		// create compiler selection
+		Composite field = new Composite(parent, SWT.NONE);
+		field.setLayout(new GridLayout(2, false));
+		compilerList = new List(field, SWT.SINGLE | SWT.BORDER | SWT.V_SCROLL);
+		GridData listgd = new GridData();
+		listgd.heightHint = 80;
+		compilerList.setLayoutData(listgd);
+
+		compilerList.addSelectionListener(new SelectionAdapter()
+		{
+			public void widgetSelected(SelectionEvent e)
+			{
+				int idx = compilerList.getSelectionIndex();
+				changeSelection(idx);
+			}
+		});
+		
+		createButtons(field);
+	}
+
+	private void createButtons(Composite field)
+	{
+		// create new/remove button
+		Composite buttonField = new Composite(field, SWT.NONE);
+		buttonField.setLayout(new GridLayout(1, false));
+		newButton = new Button(buttonField, SWT.PUSH);
+		removeButton = new Button(buttonField, SWT.PUSH);
+		newButton.setText("&New...");
+		removeButton.setText("&Remove");
+		GridData gd = new GridData(GridData.FILL_HORIZONTAL);
+		newButton.setLayoutData(gd);
+		removeButton.setLayoutData(gd);
+		
+		newButton.addSelectionListener(new SelectionAdapter()
+		{
+			public void widgetSelected(SelectionEvent e)
+			{
+				InputDialog dlog = new InputDialog(getShell(),
+						"New Error Parser", "Compiler name:", "",
+						new NameValidator());
+				dlog.open();
+				String name = dlog.getValue();
+				if (name != null && name.length() > 0)
+				{
+					addParser(name);
+				}
+			}
+		});
+		
+		removeButton.addSelectionListener(new SelectionAdapter()
+		{
+			public void widgetSelected(SelectionEvent e)
+			{
+				int idx = compilerList.getSelectionIndex();
+				if (idx < parserList.size() && ((ErrorParser)parserList.get(idx)).isEditable())
+				{
+					parserList.remove(idx);
+					updateSelection();
+
+					if (idx >= parserList.size())
+						idx = parserList.size() - 1;
+					changeSelection(idx);
+				}
+			}
+		});
+	}
+	
+	private void createTextField(Composite parent)
+	{
+		Composite field = new Composite(parent, SWT.NONE);
+		field.setLayout(new GridLayout(3, false));
+		GridData gd = new GridData(GridData.FILL_HORIZONTAL);
+		field.setLayoutData(gd);
+		
+		errText = createText(field, "Error Pattern:");
+		m_ErrorPatternButton=new Button(field,SWT.PUSH);
+		m_ErrorPatternButton.setText("...");
+		m_ErrorPatternButton.addSelectionListener(new PatternBuilderListener(errText));
+		warnText = createText(field, "Warning Pattern:");
+		m_WarnPatternButton=new Button(field,SWT.PUSH);
+		m_WarnPatternButton.setText("...");
+		m_WarnPatternButton.addSelectionListener(new PatternBuilderListener(warnText));
+		infoText = createText(field, "Info Pattern:");
+		m_InfoPatternButton=new Button(field,SWT.PUSH);
+		m_InfoPatternButton.setText("...");
+		m_InfoPatternButton.addSelectionListener(new PatternBuilderListener(infoText));
+		
+		errText.addModifyListener(new TextModifyListener(errText,0));
+		warnText.addModifyListener(new TextModifyListener(warnText,1));
+		infoText.addModifyListener(new TextModifyListener(infoText,2));
+	}
+	
+	private Text createText(Composite parent, String name)
+	{
+		Label label = new Label(parent, SWT.NULL);
+		label.setText(name);
+		Text text = new Text(parent, SWT.BORDER | SWT.SINGLE);
+		GridData gd = new GridData(GridData.FILL_HORIZONTAL);
+		text.setLayoutData(gd);
+
+		return text;
+	}
+
+	private void initializeSelection()
+	{
+		parserList = ErrorParser.getParserList();
+
+		updateSelection();
+		changeSelection(0);
+	}
+	
+	/**
+	 * add new parser
+	 * @param newCompiler	compiler name
+	 */
+	private void addParser(String newCompiler)
+	{
+		ErrorParser newParser = new ErrorParser(newCompiler);
+		newParser.setRegex("", "", "");
+		parserList.add(newParser);
+		updateSelection();
+
+		changeSelection(parserList.size() - 1);
+	}
+
+	/**
+	 * It is called when the parser list is modified
+	 */
+	private void updateSelection()
+	{
+		String labels[] = new String[parserList.size()];
+		for (int i = 0; i < parserList.size(); i++)
+		{
+			labels[i] = ((ErrorParser)parserList.get(i)).getCompilerName();
+		}
+		compilerList.setItems(labels);
+	}
+	
+	/**
+	 * It is called when the selection focus is changed
+	 */
+	private void changeSelection(int idx)
+	{
+		if (0 <= idx && idx < parserList.size())
+		{
+			compilerList.select(idx);
+			boolean removable = ((ErrorParser)parserList.get(idx)).isEditable();
+			removeButton.setEnabled(removable);
+		
+			updateTextField(idx);
+		}
+		else
+		{
+			// maybe never executed
+			removeButton.setEnabled(false);
+			updateTextField(-1);
+		}
+	}
+	
+	private void updateTextField(int idx)
+	{
+		if (idx >= 0 && idx < parserList.size())
+		{
+			ErrorParser parser = (ErrorParser)parserList.get(idx);
+			errText.setText(parser.getErrorRegex());
+			warnText.setText(parser.getWarningRegex());
+			infoText.setText(parser.getInfoRegex());
+		
+			boolean editable = ((ErrorParser)parserList.get(idx)).isEditable();
+			errText.setEditable(editable);
+			warnText.setEditable(editable);
+			infoText.setEditable(editable);
+			m_ErrorPatternButton.setEnabled(editable);
+			m_WarnPatternButton.setEnabled(editable);
+			m_InfoPatternButton.setEnabled(editable);
+		}
+		else
+		{
+			errText.setText("");
+			warnText.setText("");
+			infoText.setText("");
+			errText.setEditable(false);
+			warnText.setEditable(false);
+			infoText.setEditable(false);
+			m_ErrorPatternButton.setEnabled(false);
+			m_WarnPatternButton.setEnabled(false);
+			m_InfoPatternButton.setEnabled(false);
+		}
+	}
+
+	/**
+	 * for new compiler dialog
+	 */
+	private static class NameValidator implements IInputValidator
+	{
+		public String isValid(String newText)
+		{
+			if (newText.length() == 0)
+			{
+				return "Compiler name must be specified";
+			}
+			return null;
+		}
+	}
+	
+	/**
+	 * it is called when errText, warnText or infoText is modified
+	 */
+	private class TextModifyListener implements ModifyListener
+	{
+		private Text text;
+		private int mode;
+
+		public TextModifyListener(Text text, int mode)
+		{
+			this.text = text;
+			this.mode = mode;
+		}
+		public void modifyText(ModifyEvent e)
+		{
+			int idx = compilerList.getSelectionIndex();
+			ErrorParser parser = (ErrorParser)parserList.get(idx);
+			parser.setRegex(mode, text.getText());
+		}
+	}
+
+	public boolean performOk()
+	{
+		super.performOk();
+		ErrorParser.setParserList(parserList);
+		return true;
+	}
+
+    protected void performDefaults()
+    {
+    	super.performDefaults();
+    	ErrorParser.setDefaultParsers();
+    	initializeSelection();
+    }
+    
+    /**
+	 * Class called when the user presses pattern builder button
+	 *
+	 */
+	private class PatternBuilderListener extends SelectionAdapter {
+		Text m_TargetTextBox;
+
+		/**
+		 * Class constructor
+		 * 
+		 * @param text  The text box we need to fill the data with
+		 */
+		public PatternBuilderListener(Text text) {
+			super();
+			m_TargetTextBox = text;
+		}
+
+		public void widgetSelected(SelectionEvent e) {
+
+			PatternBuilderDialog dialog = new PatternBuilderDialog(getControl()
+					.getShell(),m_TargetTextBox.getText());
+			dialog.open();
+			m_TargetTextBox.setText(dialog.getPattern());
+			
+		}
+	}
+}
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/preference/PatternBuilderDialog.java vdt/src/com/elphel/vdt/veditor/preference/PatternBuilderDialog.java
--- vdt-veditor/src/com/elphel/vdt/veditor/preference/PatternBuilderDialog.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/preference/PatternBuilderDialog.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,161 +1,172 @@
-/*******************************************************************************
- * Copyright (c) 2007 Ali Ghorashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    Ali Ghorashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.preference;
-
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-import net.sourceforge.veditor.builder.ErrorParser.ParseErrorString;
-
-import org.eclipse.jface.dialogs.Dialog;
-import org.eclipse.swt.SWT;
-import org.eclipse.swt.events.SelectionAdapter;
-import org.eclipse.swt.events.SelectionEvent;
-import org.eclipse.swt.layout.GridData;
-import org.eclipse.swt.layout.GridLayout;
-import org.eclipse.swt.widgets.Button;
-import org.eclipse.swt.widgets.Composite;
-import org.eclipse.swt.widgets.Control;
-import org.eclipse.swt.widgets.Label;
-import org.eclipse.swt.widgets.Shell;
-import org.eclipse.swt.widgets.Text;
-
-public class PatternBuilderDialog extends Dialog {
-	private String m_PatternString;
-	private Text m_Pattern;
-	private Text m_Sample;
-	private Text m_File;
-	private Text m_Line;
-	private Text m_Message;
-	
-	public PatternBuilderDialog(Shell parentShell,String pattern) {
-		super(parentShell);
-		m_PatternString=pattern;
-	}
-	
-	/**
-	 * Creates the dialog area
-	 */
-	protected Control createDialogArea(Composite parent){
-		final int labelWidth=60;		
-		final int textWidth=260;
-		final int multiLineHeight=100;
-		final int buttonWidth=60;
-		
-		Composite top=createComposite(parent, 1, SWT.NONE);
-		Label label;
-		
-		Composite userFields=createComposite(top, 2, SWT.BORDER);
-		//pattern
-		label=new Label(userFields,SWT.NONE);
-		label.setText("Pattern");
-		label.setLayoutData(new GridData(labelWidth,SWT.DEFAULT));
-		m_Pattern=new Text(userFields,SWT.BORDER | SWT.LEFT);
-		m_Pattern.setLayoutData(new GridData(textWidth,SWT.DEFAULT));
-		m_Pattern.setText(m_PatternString);
-		
-		//sample field
-		label=new Label(userFields,SWT.NONE);
-		label.setText("Sample");
-		label.setLayoutData(new GridData(labelWidth,SWT.DEFAULT));
-		m_Sample=new Text(userFields,SWT.BORDER | SWT.LEFT | SWT.MULTI | SWT.V_SCROLL|SWT.H_SCROLL);
-		m_Sample.setLayoutData(new GridData(textWidth,multiLineHeight));
-		
-		//check button
-		Button button=new Button(top,SWT.PUSH);
-		button.setText("Check");
-		button.setLayoutData(new GridData(buttonWidth,SWT.DEFAULT));
-		button.addSelectionListener(new CheckListener());
-		
-		label=new Label(top,SWT.NONE);
-		label.setText("Results");
-		
-		Composite results=createComposite(top, 2, SWT.BORDER);
-		//File
-		label=new Label(results,SWT.NONE);
-		label.setText("File");
-		label.setLayoutData(new GridData(labelWidth,SWT.DEFAULT));
-		m_File=new Text(results,SWT.BORDER | SWT.LEFT|SWT.READ_ONLY);
-		m_File.setLayoutData(new GridData(textWidth,SWT.DEFAULT));
-		//Line
-		label=new Label(results,SWT.NONE);
-		label.setText("Line");
-		label.setLayoutData(new GridData(labelWidth,SWT.DEFAULT));
-		m_Line=new Text(results,SWT.BORDER | SWT.LEFT|SWT.READ_ONLY);
-		m_Line.setLayoutData(new GridData(textWidth,SWT.DEFAULT));
-		//message
-		label=new Label(results,SWT.NONE);
-		label.setText("Message");
-		label.setLayoutData(new GridData(labelWidth,SWT.DEFAULT));
-		m_Message=new Text(results,SWT.BORDER | SWT.LEFT | SWT.MULTI | SWT.H_SCROLL| SWT.V_SCROLL|SWT.READ_ONLY);
-		m_Message.setLayoutData(new GridData(textWidth,multiLineHeight));
-		
-		return top;
-	}
-	
-	
-	/**
-	 * Greates a composite group
-	 * @param parent parent control
-	 * @param column number of columns
-	 * @param style Additional styles
-	 * @return the created composite
-	 */
-	private Composite createComposite(Composite parent, int column,int style)
-	{
-		Composite group = new Composite(parent, style);
-		group.setLayout(new GridLayout(column, false));
-		GridData gd = new GridData();
-		gd.horizontalAlignment = GridData.FILL;
-		gd.grabExcessHorizontalSpace = true;
-		group.setLayoutData(gd);
-		return group;
-	}
-	
-	/**
-	 * Gets the pattern string
-	 * @return Pattern string
-	 */
-	public String getPattern(){
-		return m_PatternString;
-	}
-	
-   /**
-    * Called when the OK button is pressed
-    */
-   protected void okPressed() {
-	   m_PatternString=m_Pattern.getText();	   
-	   super.okPressed();	   		
-	}
-   
-   /**
-    * This Class is called when the user 
-    *
-    */
-   private class CheckListener extends SelectionAdapter {
-		public void widgetSelected(SelectionEvent e) {
-			ParseErrorString parser = new ParseErrorString(m_Pattern.getText());
-			boolean success = parser.parse(m_Sample.getText());
-				
-			if (success) {
-				m_File.setText(parser.filename);
-				m_Line.setText(""+parser.linenr);
-				m_Message.setText(parser.message);
-			} else {
-				m_File.setText("");
-				m_Line.setText("");
-				m_Message.setText("Pattern does not match anything in the sample!!");
-			}
-
-		}
-	}
-
-}
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2007 Ali Ghorashi and others.
+ *
+ * Contributors:
+ *    Ali Ghorashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.preference;
+
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import com.elphel.vdt.veditor.builder.ErrorParser.ParseErrorString;
+
+import org.eclipse.jface.dialogs.Dialog;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.SelectionAdapter;
+import org.eclipse.swt.events.SelectionEvent;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Label;
+import org.eclipse.swt.widgets.Shell;
+import org.eclipse.swt.widgets.Text;
+
+public class PatternBuilderDialog extends Dialog {
+	private String m_PatternString;
+	private Text m_Pattern;
+	private Text m_Sample;
+	private Text m_File;
+	private Text m_Line;
+	private Text m_Message;
+	
+	public PatternBuilderDialog(Shell parentShell,String pattern) {
+		super(parentShell);
+		m_PatternString=pattern;
+	}
+	
+	/**
+	 * Creates the dialog area
+	 */
+	protected Control createDialogArea(Composite parent){
+		final int labelWidth=60;		
+		final int textWidth=260;
+		final int multiLineHeight=100;
+		final int buttonWidth=60;
+		
+		Composite top=createComposite(parent, 1, SWT.NONE);
+		Label label;
+		
+		Composite userFields=createComposite(top, 2, SWT.BORDER);
+		//pattern
+		label=new Label(userFields,SWT.NONE);
+		label.setText("Pattern");
+		label.setLayoutData(new GridData(labelWidth,SWT.DEFAULT));
+		m_Pattern=new Text(userFields,SWT.BORDER | SWT.LEFT);
+		m_Pattern.setLayoutData(new GridData(textWidth,SWT.DEFAULT));
+		m_Pattern.setText(m_PatternString);
+		
+		//sample field
+		label=new Label(userFields,SWT.NONE);
+		label.setText("Sample");
+		label.setLayoutData(new GridData(labelWidth,SWT.DEFAULT));
+		m_Sample=new Text(userFields,SWT.BORDER | SWT.LEFT | SWT.MULTI | SWT.V_SCROLL|SWT.H_SCROLL);
+		m_Sample.setLayoutData(new GridData(textWidth,multiLineHeight));
+		
+		//check button
+		Button button=new Button(top,SWT.PUSH);
+		button.setText("Check");
+		button.setLayoutData(new GridData(buttonWidth,SWT.DEFAULT));
+		button.addSelectionListener(new CheckListener());
+		
+		label=new Label(top,SWT.NONE);
+		label.setText("Results");
+		
+		Composite results=createComposite(top, 2, SWT.BORDER);
+		//File
+		label=new Label(results,SWT.NONE);
+		label.setText("File");
+		label.setLayoutData(new GridData(labelWidth,SWT.DEFAULT));
+		m_File=new Text(results,SWT.BORDER | SWT.LEFT|SWT.READ_ONLY);
+		m_File.setLayoutData(new GridData(textWidth,SWT.DEFAULT));
+		//Line
+		label=new Label(results,SWT.NONE);
+		label.setText("Line");
+		label.setLayoutData(new GridData(labelWidth,SWT.DEFAULT));
+		m_Line=new Text(results,SWT.BORDER | SWT.LEFT|SWT.READ_ONLY);
+		m_Line.setLayoutData(new GridData(textWidth,SWT.DEFAULT));
+		//message
+		label=new Label(results,SWT.NONE);
+		label.setText("Message");
+		label.setLayoutData(new GridData(labelWidth,SWT.DEFAULT));
+		m_Message=new Text(results,SWT.BORDER | SWT.LEFT | SWT.MULTI | SWT.H_SCROLL| SWT.V_SCROLL|SWT.READ_ONLY);
+		m_Message.setLayoutData(new GridData(textWidth,multiLineHeight));
+		
+		return top;
+	}
+	
+	
+	/**
+	 * Greates a composite group
+	 * @param parent parent control
+	 * @param column number of columns
+	 * @param style Additional styles
+	 * @return the created composite
+	 */
+	private Composite createComposite(Composite parent, int column,int style)
+	{
+		Composite group = new Composite(parent, style);
+		group.setLayout(new GridLayout(column, false));
+		GridData gd = new GridData();
+		gd.horizontalAlignment = GridData.FILL;
+		gd.grabExcessHorizontalSpace = true;
+		group.setLayoutData(gd);
+		return group;
+	}
+	
+	/**
+	 * Gets the pattern string
+	 * @return Pattern string
+	 */
+	public String getPattern(){
+		return m_PatternString;
+	}
+	
+   /**
+    * Called when the OK button is pressed
+    */
+   protected void okPressed() {
+	   m_PatternString=m_Pattern.getText();	   
+	   super.okPressed();	   		
+	}
+   
+   /**
+    * This Class is called when the user 
+    *
+    */
+   private class CheckListener extends SelectionAdapter {
+		public void widgetSelected(SelectionEvent e) {
+			ParseErrorString parser = new ParseErrorString(m_Pattern.getText());
+			boolean success = parser.parse(m_Sample.getText());
+				
+			if (success) {
+				m_File.setText(parser.filename);
+				m_Line.setText(""+parser.linenr);
+				m_Message.setText(parser.message);
+			} else {
+				m_File.setText("");
+				m_Line.setText("");
+				m_Message.setText("Pattern does not match anything in the sample!!");
+			}
+
+		}
+	}
+
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/preference/PreferenceInitializer.java vdt/src/com/elphel/vdt/veditor/preference/PreferenceInitializer.java
--- vdt-veditor/src/com/elphel/vdt/veditor/preference/PreferenceInitializer.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/preference/PreferenceInitializer.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,151 +1,214 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.preference;
-
-import net.sourceforge.veditor.VerilogPlugin;
-
-import org.eclipse.core.runtime.preferences.AbstractPreferenceInitializer;
-import org.eclipse.jface.preference.IPreferenceStore;
-
-public class PreferenceInitializer extends AbstractPreferenceInitializer implements PreferenceStrings
-{
-
-        
-	public PreferenceInitializer()
-	{
-		super();
-	}
-
-	/**
-	 * Error parser
-	 * <PRE>
-	 *  version number for future extension 
-	 *  (
-	 *    compiler name
-	 *    error matching pattern
-	 *    warning matching pattern
-	 *    info matching pattern
-	 *  )*
-	 * </PRE>
-	 */
-	
-	public void initializeDefaultPreferences()
-	{	
-		//IEclipsePreferences preferences = ConfigurationScope.INSTANCE.getNode(VerilogPlugin.ID);
-		IPreferenceStore preferences = VerilogPlugin.getStore();
-	
-		setDefaultAttr(preferences, PreferenceStrings.DOXGEN_COMMENT, "64,64,128");
-		setDefaultAttr(preferences, PreferenceStrings.SINGLE_LINE_COMMENT, "00,128,128");
-		setDefaultAttr(preferences, PreferenceStrings.MULTI_LINE_COMMENT, "00,128,128");
-		setDefaultAttr(preferences, PreferenceStrings.STRING, "00,00,128");
-		setDefaultAttr(preferences, PreferenceStrings.DEFAULT, "00,00,00");
-		setDefaultAttr(preferences, PreferenceStrings.KEYWORD, "127,00,85", true);
-		setDefaultAttr(preferences, PreferenceStrings.DIRECTIVE, "127,00,85", true);
-		setDefaultAttr(preferences, PreferenceStrings.TYPES, "64,64,255");
-		setDefaultAttr(preferences, PreferenceStrings.AUTO_TASKS, "127,159,191",true,true);
-
-		preferences.setDefault(PreferenceStrings.MODULE_PARAMETERS, false);
-		preferences.setDefault(PreferenceStrings.ENABLE_SCAN_PROJECT, true);
-		preferences.setDefault(PreferenceStrings.MAX_PARSE_LINES, "50000");
-		preferences.setDefault(PreferenceStrings.MAX_PARSE_TIME, "2000");
-		preferences.setDefault(PreferenceStrings.SORT_OUTLINE, false);
-		preferences.setDefault(PreferenceStrings.FILTER_SINGALS_IN_OUTLINE, false);
-		preferences.setDefault(PreferenceStrings.FILTER_PORTS_IN_OUTLINE, false);
-		
-		preferences.setDefault(PreferenceStrings.SAVE_BEFORE_COMPILE,true);
-		preferences.setDefault(PreferenceStrings.COMPILE_COMMAND, "vcom %p%f");
-		preferences.setDefault(PreferenceStrings.SYNTH_COMMAND, "vcom -check_synthesis %p%f");
-		preferences.setDefault(PreferenceStrings.COMPILE_FOLDER, "simulation");
-		
-		preferences.setDefault(PreferenceStrings.ERROR_PARSER, "1\n");
-		
-		preferences.setDefault(PreferenceStrings.INDENT_TYPE,PreferenceStrings.INDENT_SPACE);
-		preferences.setDefault(PreferenceStrings.INDENT_SIZE, PreferenceStrings.INDENT_SIZE_4);
-		preferences.setDefault(PreferenceStrings.NO_SPACE_IN_BRACKET, true);
-		preferences.setDefault(PreferenceStrings.PAD_OPERATORS, true);
-		preferences.setDefault(PreferenceStrings.INDENT_LIBRARY, false);
-		setDefaultStyleSpace(preferences);
-		setDefaultWarning(preferences);
-	}
-	
-	private void setDefaultAttr(IPreferenceStore preferences, String name,
-			String color)
-	{
-		setDefaultAttr(preferences, name, color, false);
-	}
-
-	private void setDefaultAttr(IPreferenceStore preferences, String name,
-			String color, boolean bold)
-	{
-		preferences.setDefault("Color." + name, color);
-		preferences.setDefault("Bold." + name, bold);
-		preferences.setDefault("Italic." + name, false);
-	}
-	
-	private void setDefaultAttr(IPreferenceStore preferences, String name,
-            String color, boolean bold,boolean italic)
-    {
-        preferences.setDefault("Color." + name, color);
-        preferences.setDefault("Bold." + name, bold);
-        preferences.setDefault("Italic." + name, italic);
-    }
-	
-	private void setDefaultStyleSpace(IPreferenceStore preferences)
-	{
-		Object values[][] = new Object[][] {
-				{ PreferenceStrings.SPACE_BEFORE_OPERATOR_2, true },
-				{ PreferenceStrings.SPACE_AFTER_OPERATOR_2, true },
-				{ PreferenceStrings.SPACE_BEFORE_OPERATOR_1, true },
-				{ PreferenceStrings.SPACE_AFTER_OPERATOR_1, false },
-				{ PreferenceStrings.SPACE_BEFORE_COMMA, false },
-				{ PreferenceStrings.SPACE_AFTER_COMMA, true },
-				{ PreferenceStrings.SPACE_BEFORE_SEMICOLON, false },
-				{ PreferenceStrings.SPACE_BEFORE_OPEN_PAREN, false },
-				{ PreferenceStrings.SPACE_AFTER_OPEN_PAREN, false },
-				{ PreferenceStrings.SPACE_BEFORE_CLOSE_PAREN, false },
-				{ PreferenceStrings.SPACE_BEFORE_OPEN_BRACKET, false },
-				{ PreferenceStrings.SPACE_AFTER_OPEN_BRACKET, false },
-				{ PreferenceStrings.SPACE_BEFORE_CLOSE_BRACKET, false },
-				{ PreferenceStrings.SPACE_BEFORE_OPEN_BRACE, false },
-				{ PreferenceStrings.SPACE_AFTER_OPEN_BRACE, false },
-				{ PreferenceStrings.SPACE_BEFORE_CLOSE_BRACE, false },
-				{ PreferenceStrings.SPACE_BEFORE_CASE_COLON, false },
-				{ PreferenceStrings.SPACE_AFTER_CASE_COLON, true },
-				{ PreferenceStrings.SPACE_AFTER_IF, true },
-				{ PreferenceStrings.SPACE_AFTER_FOR, true },
-				{ PreferenceStrings.SPACE_AFTER_WHILE, true },
-				{ PreferenceStrings.SPACE_AFTER_REPEAT, true } };
-		for (int i = 0; i < values.length; i++)
-		{
-			boolean flag = ((Boolean)values[i][1]).booleanValue();
-			preferences.setDefault(values[i][0].toString(), flag);
-		}
-	}
-	
-	private void setDefaultWarning(IPreferenceStore preferences) {
-		Object values[][] = new Object[][] { 
-				{ SEMANTIC_WARNING, true },
-				{ WARNING_UNRESOLVED, true },
-				{ WARNING_NO_USED_ASIGNED, true }, 
-				{ WARNING_BIT_WIDTH, true },
-				{ WARNING_INT_CONSTANT, false },
-				{ WARNING_BLOCKING_ASSIGNMENT, true },
-				{ WARNING_BLOCKING_ASSIGNMENT_IN_ALWAYS, false },
-				{ WARNING_UNRESOLVED_MODULE, true },
-				{ WARNING_MODULE_CONNECTION, true } };
-		for (int i = 0; i < values.length; i++) {
-			boolean flag = ((Boolean) values[i][1]).booleanValue();
-			preferences.setDefault(values[i][0].toString(), flag);
-		}
-	}
-}
-
-
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.preference;
+
+import com.elphel.vdt.veditor.VerilogPlugin;
+
+import org.eclipse.core.runtime.preferences.AbstractPreferenceInitializer;
+import org.eclipse.jface.preference.IPreferenceStore;
+
+public class PreferenceInitializer extends AbstractPreferenceInitializer implements PreferenceStrings
+{
+
+        
+	public PreferenceInitializer()
+	{
+		super();
+	}
+
+	/**
+	 * Error parser
+	 * <PRE>
+	 *  version number for future extension 
+	 *  (
+	 *    compiler name
+	 *    error matching pattern
+	 *    warning matching pattern
+	 *    info matching pattern
+	 *  )*
+	 * </PRE>
+	 */
+	
+	public void initializeDefaultPreferences()
+	{	
+		//IEclipsePreferences preferences = ConfigurationScope.INSTANCE.getNode(VerilogPlugin.ID);
+		IPreferenceStore preferences = VerilogPlugin.getStore();
+	
+		setDefaultAttr(preferences, PreferenceStrings.DOXGEN_COMMENT, "64,64,128");
+		setDefaultAttr(preferences, PreferenceStrings.SINGLE_LINE_COMMENT, "00,128,128");
+		setDefaultAttr(preferences, PreferenceStrings.MULTI_LINE_COMMENT, "00,128,128");
+		setDefaultAttr(preferences, PreferenceStrings.STRING, "00,00,128");
+		setDefaultAttr(preferences, PreferenceStrings.DEFAULT, "00,00,00");
+		setDefaultAttr(preferences, PreferenceStrings.KEYWORD, "127,00,85", true);
+		setDefaultAttr(preferences, PreferenceStrings.DIRECTIVE, "127,00,85", true);
+		setDefaultAttr(preferences, PreferenceStrings.TYPES, "64,64,255");
+		setDefaultAttr(preferences, PreferenceStrings.AUTO_TASKS, "127,159,191",true,true);
+		setDefaultAttr(preferences, PreferenceStrings.DISABLED_CODE, "230,230,230");
+		preferences.setDefault(PreferenceStrings.DISABLED_CODE_ENABLE, true);
+
+		preferences.setDefault(PreferenceStrings.MODULE_PARAMETERS, false);
+		preferences.setDefault(PreferenceStrings.ENABLE_SCAN_PROJECT, true);
+		preferences.setDefault(PreferenceStrings.SCAN_RESET, false);
+		preferences.setDefault(PreferenceStrings.MIN_RESCAN_TIME, "1000");
+//		preferences.setDefault(PreferenceStrings.MIN_REPARSE_TIME, "2000");
+		preferences.setDefault(PreferenceStrings.MIN_REPARSE_TIME, 2000);
+		preferences.setDefault(PreferenceStrings.REPARSE_ON_TYPE, true);
+		preferences.setDefault(PreferenceStrings.SYNC_OUTLINE, true);
+		
+		
+
+		preferences.setDefault(PreferenceStrings.MAX_PARSE_LINES, "50000");
+		preferences.setDefault(PreferenceStrings.MAX_PARSE_TIME, "2000");
+		preferences.setDefault(PreferenceStrings.SORT_OUTLINE, false);
+		preferences.setDefault(PreferenceStrings.TOP_DIR_ONLY, true);
+		preferences.setDefault(PreferenceStrings.EXCLUDE_DIRS_REGEX, ".*unisims.*");
+		preferences.setDefault(PreferenceStrings.FULL_REPARSE, true);
+		
+		preferences.setDefault(PreferenceStrings.EDITOR_AUTO_INCLUDE, true);
+		preferences.setDefault(PreferenceStrings.EDITOR_AUTO_INCLUDE_NAME, ".editor_defines");
+		
+		
+		preferences.setDefault(PreferenceStrings.FILTER_SINGALS_IN_OUTLINE, true);
+		preferences.setDefault(PreferenceStrings.FILTER_PORTS_IN_OUTLINE, true);
+		preferences.setDefault(PreferenceStrings.FILTER_PARAMETERS_IN_OUTLINE, true);
+		
+		preferences.setDefault(PreferenceStrings.DEBUG_LAUNCHING, false);
+		preferences.setDefault(PreferenceStrings.DEBUG_PARSING, false);
+		preferences.setDefault(PreferenceStrings.DEBUG_DATABASE, false);
+		preferences.setDefault(PreferenceStrings.DEBUG_TOOL_SEQUENCE, false);
+		preferences.setDefault(PreferenceStrings.DEBUG_THREAD_CONFICT, false);
+		preferences.setDefault(PreferenceStrings.DEBUG_EDITOR, false);
+		preferences.setDefault(PreferenceStrings.DEBUG_CLOSURE, false);
+		preferences.setDefault(PreferenceStrings.DEBUG_PREPROC, false);
+		preferences.setDefault(PreferenceStrings.DEBUG_DISABLED, false);
+		
+		preferences.setDefault(PreferenceStrings.DEBUG_OTHER, false);
+		
+		preferences.setDefault(PreferenceStrings.LOCAL_ECHO, true);
+		preferences.setDefault(PreferenceStrings.WARNING_MISSING_ABSOLUTE_RESOURCE, false);
+		
+		preferences.setDefault(PreferenceStrings.SAVE_BEFORE_COMPILE,true);
+		
+		preferences.setDefault(PreferenceStrings.VERILOG_EXT,".v .vh .tf");
+		preferences.setDefault(PreferenceStrings.VHDL_EXT,".vhd");
+
+		
+		
+		preferences.setDefault(PreferenceStrings.COMPILE_COMMAND, "vcom %p%f");
+		preferences.setDefault(PreferenceStrings.SYNTH_COMMAND, "vcom -check_synthesis %p%f");
+		preferences.setDefault(PreferenceStrings.COMPILE_FOLDER, "simulation");
+		
+		preferences.setDefault(PreferenceStrings.ERROR_PARSER, "1\n");
+		
+		preferences.setDefault(PreferenceStrings.INDENT_TYPE,PreferenceStrings.INDENT_SPACE);
+		preferences.setDefault(PreferenceStrings.INDENT_SIZE, PreferenceStrings.INDENT_SIZE_4);
+		preferences.setDefault(PreferenceStrings.INST_TEMPLATE, PreferenceStrings.INST_TEMPLATE_COMMENTED);
+		preferences.setDefault(PreferenceStrings.NO_SPACE_IN_BRACKET, true);
+		preferences.setDefault(PreferenceStrings.PAD_OPERATORS, true);
+		preferences.setDefault(PreferenceStrings.INDENT_LIBRARY, false);
+		setDefaultStyleSpace(preferences);
+		setDefaultWarning(preferences);
+	}
+	
+	private void setDefaultAttr(IPreferenceStore preferences, String name,
+			String color)
+	{
+		setDefaultAttr(preferences, name, color, false);
+	}
+
+	private void setDefaultAttr(IPreferenceStore preferences, String name,
+			String color, boolean bold)
+	{
+		preferences.setDefault("Color." + name, color);
+		preferences.setDefault("Bold." + name, bold);
+		preferences.setDefault("Italic." + name, false);
+	}
+	
+	private void setDefaultAttr(IPreferenceStore preferences, String name,
+            String color, boolean bold,boolean italic)
+    {
+        preferences.setDefault("Color." + name, color);
+        preferences.setDefault("Bold." + name, bold);
+        preferences.setDefault("Italic." + name, italic);
+    }
+	
+	private void setDefaultStyleSpace(IPreferenceStore preferences)
+	{
+		Object values[][] = new Object[][] {
+				{ PreferenceStrings.SPACE_BEFORE_OPERATOR_2, true },
+				{ PreferenceStrings.SPACE_AFTER_OPERATOR_2, true },
+				{ PreferenceStrings.SPACE_BEFORE_OPERATOR_1, true },
+				{ PreferenceStrings.SPACE_AFTER_OPERATOR_1, false },
+				{ PreferenceStrings.SPACE_BEFORE_COMMA, false },
+				{ PreferenceStrings.SPACE_AFTER_COMMA, true },
+				{ PreferenceStrings.SPACE_BEFORE_SEMICOLON, false },
+				{ PreferenceStrings.SPACE_BEFORE_OPEN_PAREN, false },
+				{ PreferenceStrings.SPACE_AFTER_OPEN_PAREN, false },
+				{ PreferenceStrings.SPACE_BEFORE_CLOSE_PAREN, false },
+				{ PreferenceStrings.SPACE_BEFORE_OPEN_BRACKET, false },
+				{ PreferenceStrings.SPACE_AFTER_OPEN_BRACKET, false },
+				{ PreferenceStrings.SPACE_BEFORE_CLOSE_BRACKET, false },
+				{ PreferenceStrings.SPACE_BEFORE_OPEN_BRACE, false },
+				{ PreferenceStrings.SPACE_AFTER_OPEN_BRACE, false },
+				{ PreferenceStrings.SPACE_BEFORE_CLOSE_BRACE, false },
+				{ PreferenceStrings.SPACE_BEFORE_CASE_COLON, false },
+				{ PreferenceStrings.SPACE_AFTER_CASE_COLON, true },
+				{ PreferenceStrings.SPACE_AFTER_IF, true },
+				{ PreferenceStrings.SPACE_AFTER_FOR, true },
+				{ PreferenceStrings.SPACE_AFTER_WHILE, true },
+				{ PreferenceStrings.SPACE_AFTER_REPEAT, true } };
+		for (int i = 0; i < values.length; i++)
+		{
+			boolean flag = ((Boolean)values[i][1]).booleanValue();
+			preferences.setDefault(values[i][0].toString(), flag);
+		}
+	}
+	
+	private void setDefaultWarning(IPreferenceStore preferences) {
+		Object values[][] = new Object[][] { 
+				{ SEMANTIC_WARNING, true },
+				{ IGNORE_SUPPRESS_WARNINGS, false },
+				{ SUPPRESS_WARNINGS_ANYLEVEL, true },
+				{ WARNING_UNRESOLVED, true },
+				{ WARNING_NO_USED_ASIGNED, true }, 
+				{ WARNING_BIT_WIDTH, true },
+				{ WARNING_BITWISE_WIDTH, true },
+				{ WARNING_CONDITION_WIDTH,false},
+				{ WARNING_CONTEXT_DETERMINED_WIDTH, false },
+				{ WARNING_BIT_RANGE, true },
+				{ WARNING_INT_CONSTANT, false },
+				{ WARNING_FORCEINT32BIT, false },
+				{ WARNING_SKIP_PRIMITIVES, true},
+				{ WARNING_BLOCKING_ASSIGNMENT, true },
+				{ WARNING_BLOCKING_ASSIGNMENT_IN_ALWAYS, false },
+				{ WARNING_UNRESOLVED_MODULE, true },
+				{ WARNING_DUPLICATE_MODULE, true },
+				{ WARNING_MODULE_CONNECTION, true },
+				{ WARNING_UNSUPPORTED, false }	};
+		for (int i = 0; i < values.length; i++) {
+			boolean flag = ((Boolean) values[i][1]).booleanValue();
+			preferences.setDefault(values[i][0].toString(), flag);
+		}
+	}
+}
+
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/preference/PreferenceStrings.java vdt/src/com/elphel/vdt/veditor/preference/PreferenceStrings.java
--- vdt-veditor/src/com/elphel/vdt/veditor/preference/PreferenceStrings.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/preference/PreferenceStrings.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,12 +1,23 @@
-/*******************************************************************************
- * Copyright (c) 2011 Ali Ghorashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+/*******************************************************************************
+ * Copyright (c) 2011 Ali Ghorashi and others.
  *
  *******************************************************************************/
-package net.sourceforge.veditor.preference;
+package com.elphel.vdt.veditor.preference;
 
 /** 
  *  This class is meant to be used as the repository for preference
@@ -24,10 +35,36 @@
     public static final String INDENT_SIZE_4 = "4";
     public static final String INDENT_SIZE_8 = "8";
     
+    public static final String INST_TEMPLATE = "Style.instTemplate";
+    public static final String INST_TEMPLATE_COMPACT =   "Compact";
+    public static final String INST_TEMPLATE_SINGLE  =   "Single-line";
+    public static final String INST_TEMPLATE_MULTI   =   "Multiline";
+    public static final String INST_TEMPLATE_COMMENTED = "Commented";
+    
     public static final String SCAN_ENABLE = "ScanProject.Enable";
+    public static final String SCAN_RESET = "ScanProject.Reset";
     public static final String CONTENT_ASSIST_MODULE_PARAM = "ContentAssist.ModuleParameter";
     public static final String MAX_PARSE_LINES = "ScanProject.MaxFileLines";
+
+    public static final String MIN_REPARSE_TIME = "Parser.MinReparse";
+    public static final String REPARSE_ON_TYPE =  "Parser.OnType";
+    public static final String SYNC_OUTLINE =     "Editor.SynOutline";
+    
+    public static final String MIN_RESCAN_TIME = "ScanProject.MinRebuild";
     public static final String MAX_PARSE_TIME  = "ScanProject.MaxScanTime";
+    public static final String DEBUG_LAUNCHING  = "Debug.Launching";
+    public static final String DEBUG_PARSING    = "Debug.Parsing";
+    public static final String DEBUG_DATABASE  = "Debug.Database";
+    public static final String DEBUG_TOOL_SEQUENCE  = "Debug.ToolsSequence";
+    public static final String DEBUG_THREAD_CONFICT  = "Debug.ThreadConflict";
+    public static final String DEBUG_EDITOR  = "Debug.Editor";
+    public static final String DEBUG_CLOSURE  = "Debug.Closure";
+    public static final String DEBUG_PREPROC  = "Debug.Preprocessor";
+    public static final String DEBUG_DISABLED  = "Debug.Disabled";
+    
+    public static final String DEBUG_OTHER  = "Debug.Other";
+    public static final String LOCAL_ECHO  = "Local.Echo";
+	public static final String WARNING_MISSING_ABSOLUTE_RESOURCE = "Warning.MissingAbsoluteResource";
     
    public static final String NO_SPACE_IN_BRACKET="Style.noSpaceInBracket";     
    public static final String SPACE_BEFORE_OPERATOR_2="Style.spaceBeforeOperator2"; 
@@ -72,27 +109,57 @@
    public static final String DEFAULT = "Default";
    public static final String KEYWORD = "KeyWord";
    public static final String DIRECTIVE = "Directive";
-   public static final String TYPES = "Types";
-   public static final String AUTO_TASKS = "AutoTasks";
+   public static final String TYPES = "Types";
+   public static final String AUTO_TASKS = "AutoTasks";
+   public static final String DISABLED_CODE =        "DisabledCode"; // for color
+   public static final String DISABLED_CODE_ENABLE = "DisabledCode.Enable";
+   public static final String DISABLED_CODE_KEY =    "DisabledCode";
    
    public static final String MODULE_PARAMETERS= "ContentAssist.ModuleParameter";
    public static final String ENABLE_SCAN_PROJECT= "ScanProject.Enable";
    public static final String SORT_OUTLINE = "Outline.Sort";
+   public static final String TOP_DIR_ONLY =       "Hierarchy.TopOnly";
+   public static final String EXCLUDE_DIRS_REGEX = "Hierarchy.ExcludeRegex";
+   public static final String FULL_REPARSE =       "Hierarchy.FullReparse";
+   
+   public static final String EDITOR_AUTO_INCLUDE =      "Editor.AutoInclude";
+   public static final String EDITOR_AUTO_INCLUDE_NAME = "Editor.AutoIncludeName";
+   
+   
    public static final String FILTER_SINGALS_IN_OUTLINE="Outline.FilterSignals";
    public static final String FILTER_PORTS_IN_OUTLINE="Outline.FilterPorts";
+   public static final String FILTER_PARAMETERS_IN_OUTLINE="Outline.FilterParameters";
    public static final String SAVE_BEFORE_COMPILE="Compile.SaveBeforeCompile";
+   
+   public static final String VERILOG_EXT="Verilog.Extensions";
+   public static final String VHDL_EXT="VHDL.Extensions";
+   
    public static final String COMPILE_COMMAND="Compile.command";
    public static final String SYNTH_COMMAND="Synthesize.command";
    public static final String COMPILE_FOLDER="Compile.Folder";
    public static final String ERROR_PARSER="ErrorParser";
     
 	public static final String SEMANTIC_WARNING = "Warning";
+	public static final String IGNORE_SUPPRESS_WARNINGS = "Warning.IgnoreSuppress";
+	public static final String SUPPRESS_WARNINGS_ANYLEVEL = "Warning.SuppressAnylLevel";
 	public static final String WARNING_UNRESOLVED = "Warning.unresolvedSignal";
 	public static final String WARNING_NO_USED_ASIGNED = "Warning.noUsedAsigned";
 	public static final String WARNING_BIT_WIDTH = "Warning.bitWidth";
+	public static final String WARNING_BITWISE_WIDTH = "Warning.bitwiseWidth";
+	public static final String WARNING_CONTEXT_DETERMINED_WIDTH = "Warning.contextDeterminedWidth";
+	public static final String WARNING_CONDITION_WIDTH = "Warning.conditionWidth";
+	
+	
+	public static final String WARNING_BIT_RANGE = "Warning.bitRange";
 	public static final String WARNING_INT_CONSTANT = "Warning.integerConstant";
 	public static final String WARNING_BLOCKING_ASSIGNMENT = "Warning.blockingAssignment";
 	public static final String WARNING_BLOCKING_ASSIGNMENT_IN_ALWAYS = "Warning.blockingAssignmentInAlways";
 	public static final String WARNING_UNRESOLVED_MODULE = "Warning.unresolvedModule";
+	public static final String WARNING_DUPLICATE_MODULE = "Warning.duplicateModule";
+	
 	public static final String WARNING_MODULE_CONNECTION = "Warning.moduleConnection";
+	public static final String WARNING_FORCEINT32BIT = "Warning.ForceInt32Bit";
+	public static final String WARNING_SKIP_PRIMITIVES = "Warning.SkipPrimitives";
+	
+	public static final String WARNING_UNSUPPORTED = "Warning.Unsupported";
 }
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/preference/PreferenceStrings.java.bak vdt/src/com/elphel/vdt/veditor/preference/PreferenceStrings.java.bak
--- vdt-veditor/src/com/elphel/vdt/veditor/preference/PreferenceStrings.java.bak	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/preference/PreferenceStrings.java.bak	1969-12-31 17:00:00.000000000 -0700
@@ -1,93 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2011 Ali Ghorashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- *******************************************************************************/
-package net.sourceforge.veditor.preference;
-
-/** 
- *  This class is meant to be used as the repository for preference
- *  strings. 
- * @author gho18481
- *
- */
-public interface PreferenceStrings {
-    public static final String INDENT_TYPE = "Style.indent";
-    public static final String INDENT_SPACE = "Space";
-    public static final String INDENT_TAB = "Tab";
-    public static final String INDENT_SIZE = "Style.indentSize";
-    public static final String INDENT_SIZE_2 = "2";
-    public static final String INDENT_SIZE_3 = "3";
-    public static final String INDENT_SIZE_4 = "4";
-    public static final String INDENT_SIZE_8 = "8";
-    
-    public static final String SCAN_ENABLE = "ScanProject.Enable";
-    public static final String CONTENT_ASSIST_MODULE_PARAM = "ContentAssist.ModuleParameter";
-    public static final String MAX_PARSE_LINES = "ScanProject.MaxFileLines";
-    public static final String MAX_PARSE_TIME  = "ScanProject.MaxScanTime";
-    
-   public static final String NO_SPACE_IN_BRACKET="Style.noSpaceInBracket";     
-   public static final String SPACE_BEFORE_OPERATOR_2="Style.spaceBeforeOperator2"; 
-   public static final String SPACE_AFTER_OPERATOR_2="Style.spaceAfterOperator2";  
-   public static final String SPACE_BEFORE_OPERATOR_1="Style.spaceBeforeOperator1"; 
-   public static final String SPACE_AFTER_OPERATOR_1="Style.spaceAfterOperator1";  
-   public static final String SPACE_BEFORE_COMMA="Style.spaceBeforeComma";     
-   public static final String SPACE_AFTER_COMMA="Style.spaceAfterComma";      
-   public static final String SPACE_BEFORE_SEMICOLON="Style.spaceBeforeSemicolon"; 
-   public static final String SPACE_BEFORE_OPEN_PAREN="Style.spaceBeforeOpenParen"; 
-   public static final String SPACE_AFTER_OPEN_PAREN="Style.spaceAfterOpenParen";  
-   public static final String SPACE_BEFORE_CLOSE_PAREN = "Style.spaceBeforeCloseParen";
-   public static final String SPACE_BEFORE_OPEN_BRACKET= "Style.spaceBeforeOpenBracket";
-   public static final String SPACE_AFTER_OPEN_BRACKET="Style.spaceAfterOpenBracket";
-   public static final String SPACE_BEFORE_CLOSE_BRACKET="Style.spaceBeforeCloseBracket";
-   public static final String SPACE_BEFORE_OPEN_BRACE="Style.spaceBeforeOpenBrace"; 
-   public static final String SPACE_AFTER_OPEN_BRACE="Style.spaceAfterOpenBrace";  
-   public static final String SPACE_BEFORE_CLOSE_BRACE="Style.spaceBeforeCloseBrace";
-   public static final String SPACE_BEFORE_CASE_COLON="Style.spaceBeforeCaseColon"; 
-   public static final String SPACE_AFTER_CASE_COLON="Style.spaceAfterCaseColon";  
-   public static final String SPACE_AFTER_IF="Style.spaceAfterIf";         
-   public static final String SPACE_AFTER_FOR="Style.spaceAfterFor";        
-   public static final String SPACE_AFTER_WHILE="Style.spaceAfterWhile";      
-   public static final String SPACE_AFTER_REPEAT="Style.spaceAfterRepeat";     
-    
-   public static final String PAD_OPERATORS="Style.Vhdl.PadOperators";
-   public static final String INDENT_LIBRARY="Style.Vhdl.IndentLibrary";
-   public static final String KEYWORDS_LOWERCASE="Style.Vhdl.KeywordsLowercase";
-   public static final String ALIGNONARROWRIGHT="Style.Vhdl.AlignOnArrowRight";
-   public static final String ALIGNONARROWLEFT="Style.Vhdl.AlignOnArrowLeft";
-   public static final String ALIGNONCOLON="Style.Vhdl.AlignOnColon";
-   
-   public static final String DOXGEN_COMMENT =  "DoxygenComment";
-   public static final String SINGLE_LINE_COMMENT = "SingleLineComment";
-   public static final String MULTI_LINE_COMMENT = "MultiLineComment";
-   public static final String STRING = "String";
-   public static final String DEFAULT = "Default";
-   public static final String KEYWORD = "KeyWord";
-   public static final String DIRECTIVE = "Directive";
-   public static final String TYPES = "Types";
-   public static final String AUTO_TASKS = "AutoTasks";
-   
-   public static final String MODULE_PARAMETERS= "ContentAssist.ModuleParameter";
-   public static final String ENABLE_SCAN_PROJECT= "ScanProject.Enable";
-   public static final String SORT_OUTLINE = "Outline.Sort";
-   public static final String FILTER_SINGALS_IN_OUTLINE="Outline.FilterSignals";
-   public static final String FILTER_PORTS_IN_OUTLINE="Outline.FilterPorts";
-   public static final String SAVE_BEFORE_COMPILE="Compile.SaveBeforeCompile";
-   public static final String COMPILE_COMMAND="Compile.command";
-   public static final String SYNTH_COMMAND="Synthesize.command";
-   public static final String COMPILE_FOLDER="Compile.Folder";
-   public static final String ERROR_PARSER="ErrorParser";
-    
-	public static final String SEMANTIC_WARNING = "Warning";
-	public static final String WARNING_UNRESOLVED = "Warning.unresolvedSignal";
-	public static final String WARNING_NO_USED_ASIGNED = "Warning.noUsedAsigned";
-	public static final String WARNING_BIT_WIDTH = "Warning.bitWidth";
-	public static final String WARNING_INT_CONSTANT = "Warning.integerConstant";
-	public static final String WARNING_BLOCKING_ASSIGNMENT = "Warning.blockingAssignment";
-	public static final String WARNING_BLOCKING_ASSIGNMENT_IN_ALWAYS = "Warning.blockingAssignmentInAlways";
-	public static final String WARNING_UNRESOLVED_MODULE = "Warning.unresolvedModule";
-	public static final String WARNING_MODULE_CONNECTION = "Warning.moduleConnection";
-}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/preference/TemplatePreferencePage.java vdt/src/com/elphel/vdt/veditor/preference/TemplatePreferencePage.java
--- vdt-veditor/src/com/elphel/vdt/veditor/preference/TemplatePreferencePage.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/preference/TemplatePreferencePage.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,99 +1,110 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    Ali Ghorashi - Initial Implementation
- *******************************************************************************/
-package net.sourceforge.veditor.preference;
-
-import org.eclipse.jface.text.Document;
-import org.eclipse.jface.text.IDocument;
-import org.eclipse.jface.text.source.SourceViewer;
-import org.eclipse.jface.text.source.SourceViewerConfiguration;
-import org.eclipse.jface.text.templates.Template;
-import org.eclipse.jface.text.templates.persistence.TemplatePersistenceData;
-import org.eclipse.jface.viewers.IStructuredSelection;
-import org.eclipse.swt.SWT;
-import org.eclipse.swt.widgets.Composite;
-
-import net.sourceforge.veditor.VerilogPlugin;
-import net.sourceforge.veditor.editor.*;
-
-
-/**
- * Templates preference
- */
-public class TemplatePreferencePage extends org.eclipse.ui.texteditor.templates.TemplatePreferencePage
-{
-	public TemplatePreferencePage(){
-		super();
-		HdlTextAttribute.init();
-		setTemplateStore(VerilogPlugin.getPlugin().getTemplateStore());
-		setContextTypeRegistry(VerilogPlugin.getPlugin().getContextTypeRegistry());		
-	}
-	
-	/**
-	 * Returns whether the formatter preference checkbox should be shown.
-	 *
-	 * @return <code>true</code> if the formatter preference checkbox should
-	 *         be shown, <code>false</code> otherwise
-	 */
-	protected boolean isShowFormatterSetting() {
-		return false;
-	}
-	
-	/**
-	 * Creates, configures and returns a source viewer to present the template
-	 * pattern on the preference page. Clients may override to provide a custom
-	 * source viewer featuring e.g. syntax coloring.
-	 *
-	 * @param parent the parent control
-	 * @return a configured source viewer
-	 */
-	protected SourceViewer createViewer(Composite parent) {
-		SourceViewer viewer= new SourceViewer(parent, null, null, false, SWT.BORDER | SWT.V_SCROLL | SWT.H_SCROLL);
-		SourceViewerConfiguration configuration= new SourceViewerConfiguration();
-		viewer.configure(configuration);
-		IDocument document= new Document();
-		viewer.setDocument(document);
-		return viewer;
-	}
-	
-	/**
-	 * Updates the pattern viewer.
-	 */
-	protected void updateViewerInput() {
-		IStructuredSelection selection= (IStructuredSelection) getTableViewer().getSelection();
-
-		if (selection.size() == 1) {
-			TemplatePersistenceData data= (TemplatePersistenceData) selection.getFirstElement();
-			Template template= data.getTemplate();
-			if(template.getContextTypeId().contains("vhdl"))
-			{
-				getViewer().unconfigure();
-				SourceViewerConfiguration configuration= HdlSourceViewerConfiguration.createForVhdl(new VerilogEditor());
-				getViewer().configure(configuration);
-				
-				
-			}
-			else if(template.getContextTypeId().contains("verilog"))
-			{
-				getViewer().unconfigure();
-				SourceViewerConfiguration configuration= HdlSourceViewerConfiguration.createForVerilog(new VhdlEditor());
-				getViewer().configure(configuration);
-			}
-			else
-			{
-				getViewer().unconfigure();
-				SourceViewerConfiguration configuration= new SourceViewerConfiguration();
-				getViewer().configure(configuration);
-			}
-		} 
-		super.updateViewerInput();
-	}
-}
-
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+/*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    Ali Ghorashi - Initial Implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.preference;
+
+import org.eclipse.jface.text.Document;
+import org.eclipse.jface.text.IDocument;
+import org.eclipse.jface.text.source.SourceViewer;
+import org.eclipse.jface.text.source.SourceViewerConfiguration;
+import org.eclipse.jface.text.templates.Template;
+import org.eclipse.jface.text.templates.persistence.TemplatePersistenceData;
+import org.eclipse.jface.viewers.IStructuredSelection;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.widgets.Composite;
+
+import com.elphel.vdt.veditor.VerilogPlugin;
+import com.elphel.vdt.veditor.editor.*;
+
+
+/**
+ * Templates preference
+ */
+public class TemplatePreferencePage extends org.eclipse.ui.texteditor.templates.TemplatePreferencePage
+{
+	public TemplatePreferencePage(){
+		super();
+		HdlTextAttribute.init();
+		setTemplateStore(VerilogPlugin.getPlugin().getTemplateStore());
+		setContextTypeRegistry(VerilogPlugin.getPlugin().getContextTypeRegistry());		
+	}
+	
+	/**
+	 * Returns whether the formatter preference checkbox should be shown.
+	 *
+	 * @return <code>true</code> if the formatter preference checkbox should
+	 *         be shown, <code>false</code> otherwise
+	 */
+	protected boolean isShowFormatterSetting() {
+		return false;
+	}
+	
+	/**
+	 * Creates, configures and returns a source viewer to present the template
+	 * pattern on the preference page. Clients may override to provide a custom
+	 * source viewer featuring e.g. syntax coloring.
+	 *
+	 * @param parent the parent control
+	 * @return a configured source viewer
+	 */
+	protected SourceViewer createViewer(Composite parent) {
+		SourceViewer viewer= new SourceViewer(parent, null, null, false, SWT.BORDER | SWT.V_SCROLL | SWT.H_SCROLL);
+		SourceViewerConfiguration configuration= new SourceViewerConfiguration();
+		viewer.configure(configuration);
+		IDocument document= new Document();
+		viewer.setDocument(document);
+		return viewer;
+	}
+	
+	/**
+	 * Updates the pattern viewer.
+	 */
+	protected void updateViewerInput() {
+		IStructuredSelection selection= (IStructuredSelection) getTableViewer().getSelection();
+
+		if (selection.size() == 1) {
+			TemplatePersistenceData data= (TemplatePersistenceData) selection.getFirstElement();
+			Template template= data.getTemplate();
+			if(template.getContextTypeId().contains("vhdl"))
+			{
+				getViewer().unconfigure();
+				SourceViewerConfiguration configuration= HdlSourceViewerConfiguration.createForVhdl(new VerilogEditor());
+				getViewer().configure(configuration);
+				
+				
+			}
+			else if(template.getContextTypeId().contains("verilog"))
+			{
+				getViewer().unconfigure();
+				SourceViewerConfiguration configuration= HdlSourceViewerConfiguration.createForVerilog(new VhdlEditor());
+				getViewer().configure(configuration);
+			}
+			else
+			{
+				getViewer().unconfigure();
+				SourceViewerConfiguration configuration= new SourceViewerConfiguration();
+				getViewer().configure(configuration);
+			}
+		} 
+		super.updateViewerInput();
+	}
+}
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/preference/TopPreferencePage.java vdt/src/com/elphel/vdt/veditor/preference/TopPreferencePage.java
--- vdt-veditor/src/com/elphel/vdt/veditor/preference/TopPreferencePage.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/preference/TopPreferencePage.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,90 +1,143 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.preference;
-
-import net.sourceforge.veditor.builder.SimulatorPropertyPage;
-
-import org.eclipse.debug.ui.StringVariableSelectionDialog;
-import org.eclipse.jface.preference.StringFieldEditor;
-import org.eclipse.swt.SWT;
-import org.eclipse.swt.events.SelectionAdapter;
-import org.eclipse.swt.events.SelectionEvent;
-import org.eclipse.swt.layout.GridData;
-import org.eclipse.swt.layout.GridLayout;
-import org.eclipse.swt.widgets.Button;
-import org.eclipse.swt.widgets.Composite;
-import org.eclipse.ui.IWorkbench;
-import org.eclipse.ui.PlatformUI;
-
-/**
- * Top Preference page
- */
-public class TopPreferencePage extends AbstractSimplePreferencePage
-{
-	public TopPreferencePage()
-	{
-	}
-
-	protected void createFieldEditors()
-	{
-		addBooleanField(PreferenceStrings.CONTENT_ASSIST_MODULE_PARAM,
-				"Generate module parameter with instantiation(Verilog-2001)");
-		addBooleanField(PreferenceStrings.SCAN_ENABLE, "Enable Scan Project");
-		addStringField(PreferenceStrings.MAX_PARSE_TIME,"Max amount time spent scanning files (mS)");
-		addStringField(PreferenceStrings.MAX_PARSE_LINES,"Maximum number of lines in a file to scan");
-		addBooleanField(PreferenceStrings.SORT_OUTLINE, "Sort in Outline/Hierarchy");
-		addBooleanField(PreferenceStrings.FILTER_SINGALS_IN_OUTLINE, "Filter Signals in Outline");
-		addBooleanField(PreferenceStrings.FILTER_PORTS_IN_OUTLINE, "Filter Ports in Outline");
-		addBooleanField(PreferenceStrings.SAVE_BEFORE_COMPILE,"Save File Before Compile");
-		
-		//mg
-//		addStringField(PreferenceStrings.COMPILE_COMMAND, "Compile command");
-//		addStringField(PreferenceStrings.SYNTH_COMMAND, "Synthesize command");
-//		addStringField(PreferenceStrings.COMPILE_FOLDER, "Compile folder");
-		addCommandField( PreferenceStrings.COMPILE_COMMAND, "Compile command" );
-		addCommandField( PreferenceStrings.SYNTH_COMMAND, "Synthesize command" );
-		addCommandField( PreferenceStrings.COMPILE_FOLDER, "Compile folder" );
-		//mg-----------------------
-
-	}
-
-	//mg
-	private void addCommandField( final String name, final String label ) {
-		final StringFieldEditor comp = new StringFieldEditor( name, label,
-				getFieldEditorParent() );
-		addField( comp );
-
-		final Button button = new Button( getFieldEditorParent(), SWT.NONE );
-		button.addSelectionListener( new SelectionAdapter() {
-
-			public void widgetSelected( final SelectionEvent e ) {
-				final StringVariableSelectionDialog dialog = new StringVariableSelectionDialog(
-						PlatformUI.getWorkbench().getActiveWorkbenchWindow()
-						.getShell() );
-				dialog.open();
-				final String var = dialog.getVariableExpression();
-				comp.getTextControl( getFieldEditorParent() ).insert( var );
-			}
-		} );
-		button.setText( "Variables..." );
-		GridData data = new GridData();
-		data.horizontalSpan = 2;
-		data.horizontalAlignment = SWT.END;
-		button.setLayoutData( data ); 
-	}
-	//mg-------------
-
-	public void init(IWorkbench workbench)
-	{
-	}
-
-}
-
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.preference;
+
+import org.eclipse.debug.ui.StringVariableSelectionDialog;
+import org.eclipse.jface.preference.StringFieldEditor;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.SelectionAdapter;
+import org.eclipse.swt.events.SelectionEvent;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.ui.IWorkbench;
+import org.eclipse.ui.PlatformUI;
+
+/**
+ * Top Preference page
+ */
+public class TopPreferencePage extends AbstractSimplePreferencePage
+{
+	public TopPreferencePage()
+	{
+	}
+
+	protected void createFieldEditors()
+	{
+		addBooleanField(PreferenceStrings.CONTENT_ASSIST_MODULE_PARAM,
+				"Generate module parameter with instantiation(Verilog-2001)");
+		
+		addBooleanField(PreferenceStrings.WARNING_MISSING_ABSOLUTE_RESOURCE, "Show problem of missing resource with absolute path by error parser");
+		addBooleanField(PreferenceStrings.LOCAL_ECHO, "Local echo for generated commands on remote console");
+		addBooleanField(PreferenceStrings.SCAN_ENABLE, "Enable Scan Project");
+		addBooleanField(PreferenceStrings.SCAN_RESET,  "Reset database before re-scanning files");
+		addBooleanField(PreferenceStrings.DEBUG_LAUNCHING, "Debug tool launching");
+		addBooleanField(PreferenceStrings.DEBUG_PARSING, "Debug tool error parsing");
+		
+		addBooleanField(PreferenceStrings.DEBUG_DATABASE,  "Monitor database operations");
+		addBooleanField(PreferenceStrings.DEBUG_TOOL_SEQUENCE,  "Debug tool sequencing");
+		addBooleanField(PreferenceStrings.DEBUG_THREAD_CONFICT,  "Debug thread conflict in parameter access");
+		addBooleanField(PreferenceStrings.DEBUG_EDITOR,    "Debug editor");
+		addBooleanField(PreferenceStrings.DEBUG_CLOSURE,   "Debug tool closure calculation");
+		addBooleanField(PreferenceStrings.DEBUG_PREPROC,   "Debug pre-processor");
+		addBooleanField(PreferenceStrings.DEBUG_DISABLED,  "Debug disabled code");
+		addBooleanField(PreferenceStrings.DEBUG_OTHER,     "Other debug output");
+		addBooleanField(PreferenceStrings.REPARSE_ON_TYPE, "Syntax check while typing","Enable syntax/semantic check while editing file");
+		addBooleanField(PreferenceStrings.SYNC_OUTLINE,    "Synchronize outline","Syncronize outline view to the cursor in editor window");
+		addBooleanField(PreferenceStrings.DISABLED_CODE_ENABLE,    "Show disabled code");
+		
+//		addStringField(PreferenceStrings.MIN_REPARSE_TIME,
+//				"Minimal re-parse time (mS)", "Minimal time between re-parsing of the editor text caused by modifications");
+		addScaleField(PreferenceStrings.MIN_REPARSE_TIME,
+				"Minimal re-parse time (0.2 to 5sec)",
+				200,5000,100,1000,
+				"Minimal time between re-parsing of the editor text caused by modifications");
+//addScaleField(String name, String label, int min, int max, int increment, int pageIncrement, String toolTip)
+		
+		addStringField(PreferenceStrings.MIN_RESCAN_TIME,"Minimal time between database rescan while parsing files (mS)");
+		
+		addStringField(PreferenceStrings.MAX_PARSE_TIME,"Max amount time spent scanning files (mS)");
+		addStringField(PreferenceStrings.MAX_PARSE_LINES,"Maximum number of lines in a file to scan");
+		addBooleanField(PreferenceStrings.SORT_OUTLINE, "Sort in Outline/Hierarchy");
+		 /*TODO: Use work sets to filter hierarchy tree */
+		addBooleanField(PreferenceStrings.TOP_DIR_ONLY, "Filter top level modules in Hierarchy view",
+				"Do not show top level (not referenced) top level modules in Hierarchy view, if their full path matches regex below");
+		addStringField (PreferenceStrings.EXCLUDE_DIRS_REGEX,"Exclude top level modules","Regex to exclude top level modules from filtered Hierarchy view");
+		addBooleanField(PreferenceStrings.FULL_REPARSE, "Re-parse filtered",
+				"Full re-parse filtered (excluding specified libraries) files to refresh problem markers after the database is (re) built");
+		
+		addStringField (PreferenceStrings.EDITOR_AUTO_INCLUDE_NAME,"auto-include path",
+				"Path of the file with macro defines (relative to the project) that will be included into each parsed f file");
+		addBooleanField(PreferenceStrings.EDITOR_AUTO_INCLUDE, "auto-include defines",
+				"Enable use of defines auto-include file");
+		
+		addBooleanField(PreferenceStrings.FILTER_SINGALS_IN_OUTLINE, "Filter Signals in Outline", "Do not show signals in Outline view");
+		addBooleanField(PreferenceStrings.FILTER_PORTS_IN_OUTLINE, "Filter Ports in Outline", "Do not show ports in Outline view");
+		addBooleanField(PreferenceStrings.FILTER_PARAMETERS_IN_OUTLINE, "Filter Parameters in Outline", "Do not show parameters in Outline view");
+				
+		addBooleanField(PreferenceStrings.SAVE_BEFORE_COMPILE,"Save File Before Compile");
+		
+		addStringField(PreferenceStrings.VERILOG_EXT, "Verilog file extensions");
+		addStringField(PreferenceStrings.VHDL_EXT, "VHDL file extensions");
+
+		//mg
+//		addStringField(PreferenceStrings.COMPILE_COMMAND, "Compile command");
+//		addStringField(PreferenceStrings.SYNTH_COMMAND, "Synthesize command");
+//		addStringField(PreferenceStrings.COMPILE_FOLDER, "Compile folder");
+		addCommandField( PreferenceStrings.COMPILE_COMMAND, "Compile command" );
+		addCommandField( PreferenceStrings.SYNTH_COMMAND, "Synthesize command" );
+		addCommandField( PreferenceStrings.COMPILE_FOLDER, "Compile folder" );
+		//mg-----------------------
+
+	}
+
+	//mg
+	private void addCommandField( final String name, final String label ) {
+		final StringFieldEditor comp = new StringFieldEditor( name, label,
+				getFieldEditorParent() );
+		addField( comp );
+
+		final Button button = new Button( getFieldEditorParent(), SWT.NONE );
+		button.addSelectionListener( new SelectionAdapter() {
+
+			public void widgetSelected( final SelectionEvent e ) {
+				final StringVariableSelectionDialog dialog = new StringVariableSelectionDialog(
+						PlatformUI.getWorkbench().getActiveWorkbenchWindow()
+						.getShell() );
+				dialog.open();
+				final String var = dialog.getVariableExpression();
+				comp.getTextControl( getFieldEditorParent() ).insert( var );
+			}
+		} );
+		button.setText( "Variables..." );
+		GridData data = new GridData();
+		data.horizontalSpan = 2;
+		data.horizontalAlignment = SWT.END;
+		button.setLayoutData( data ); 
+	}
+	//mg-------------
+
+	public void init(IWorkbench workbench)
+	{
+	}
+
+}
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/preference/TopPreferencePage.java.bak vdt/src/com/elphel/vdt/veditor/preference/TopPreferencePage.java.bak
--- vdt-veditor/src/com/elphel/vdt/veditor/preference/TopPreferencePage.java.bak	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/preference/TopPreferencePage.java.bak	1969-12-31 17:00:00.000000000 -0700
@@ -1,46 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.preference;
-
-import org.eclipse.ui.IWorkbench;
-
-/**
- * Top Preference page
- */
-public class TopPreferencePage extends AbstractSimplePreferencePage
-{
-	public TopPreferencePage()
-	{
-	}
-
-	protected void createFieldEditors()
-	{
-		addBooleanField(PreferenceStrings.CONTENT_ASSIST_MODULE_PARAM,
-				"Generate module parameter with instantiation(Verilog-2001)");
-		addBooleanField(PreferenceStrings.SCAN_ENABLE, "Enable Scan Project");
-		addStringField(PreferenceStrings.MAX_PARSE_TIME,"Max amount time spent scanning files (mS)");
-		addStringField(PreferenceStrings.MAX_PARSE_LINES,"Maximum number of lines in a file to scan");
-		addBooleanField(PreferenceStrings.SORT_OUTLINE, "Sort in Outline/Hierarchy");
-		addBooleanField(PreferenceStrings.FILTER_SINGALS_IN_OUTLINE, "Filter Signals in Outline");
-		addBooleanField(PreferenceStrings.FILTER_PORTS_IN_OUTLINE, "Filter Ports in Outline");
-		addBooleanField(PreferenceStrings.SAVE_BEFORE_COMPILE,"Save File Before Compile");
-		addStringField(PreferenceStrings.COMPILE_COMMAND, "Compile command");
-		addStringField(PreferenceStrings.SYNTH_COMMAND, "Synthesize command");
-		addStringField(PreferenceStrings.COMPILE_FOLDER, "Compile folder");
-		
-	}
-
-	public void init(IWorkbench workbench)
-	{
-	}
-
-}
-
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/preference/VerilogCodeStylePreferencePage.java vdt/src/com/elphel/vdt/veditor/preference/VerilogCodeStylePreferencePage.java
--- vdt-veditor/src/com/elphel/vdt/veditor/preference/VerilogCodeStylePreferencePage.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/preference/VerilogCodeStylePreferencePage.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,52 +1,63 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2007 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.preference;
-
-import org.eclipse.jface.preference.BooleanFieldEditor;
-import org.eclipse.swt.widgets.Composite;
-
-public class VerilogCodeStylePreferencePage extends AbstractSimplePreferencePage
-{
-
-	protected void createFieldEditors()
-	{
-		Composite parent = getFieldEditorParent();
-
-		String names[][] = new String[][] {
-            { PreferenceStrings.NO_SPACE_IN_BRACKET  , "No space in bracket"},
-            { PreferenceStrings.SPACE_BEFORE_OPERATOR_2, "add space before binary operator" },
-            { PreferenceStrings.SPACE_AFTER_OPERATOR_2, "add space after binary operator" },
-            { PreferenceStrings.SPACE_BEFORE_OPERATOR_1, "add space before unary operator" },
-            { PreferenceStrings.SPACE_AFTER_OPERATOR_1, "add space after unary operator" },
-            { PreferenceStrings.SPACE_BEFORE_COMMA, "add space before comma" },
-            { PreferenceStrings.SPACE_AFTER_COMMA, "add space after comma" },
-            { PreferenceStrings.SPACE_BEFORE_SEMICOLON, "add space before semiclon" },
-            { PreferenceStrings.SPACE_BEFORE_OPEN_PAREN, "add space before opening parenthesis" },
-            { PreferenceStrings.SPACE_AFTER_OPEN_PAREN, "add space after opening parenthesis" },
-            { PreferenceStrings.SPACE_BEFORE_CLOSE_PAREN, "add space before closing parenthesis" },
-            { PreferenceStrings.SPACE_BEFORE_OPEN_BRACKET, "add space before opening bracket" },
-            { PreferenceStrings.SPACE_AFTER_OPEN_BRACKET, "add space after opening bracket" },
-            { PreferenceStrings.SPACE_BEFORE_CLOSE_BRACKET, "add space before closing bracket" },
-            { PreferenceStrings.SPACE_BEFORE_OPEN_BRACE, "add space before opening brace" },
-            { PreferenceStrings.SPACE_AFTER_OPEN_BRACE, "add space after opening brace" },
-            { PreferenceStrings.SPACE_BEFORE_CLOSE_BRACE, "add space before closing brace" },
-            { PreferenceStrings.SPACE_BEFORE_CASE_COLON, "add space before colon in case" },
-            { PreferenceStrings.SPACE_AFTER_CASE_COLON, "add space after colon in case" },
-            { PreferenceStrings.SPACE_AFTER_IF, "add space after if" },
-            { PreferenceStrings.SPACE_AFTER_FOR, "add space after for" },
-            { PreferenceStrings.SPACE_AFTER_WHILE, "add space after while" },
-            { PreferenceStrings.SPACE_AFTER_REPEAT, "add space after repeat" } };
-		for (int i = 0; i < names.length; i++)
-		{
-			addField(new BooleanFieldEditor(names[i][0], names[i][1], parent));
-		}
-	}
-}
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+/*******************************************************************************
+ * Copyright (c) 2004, 2007 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.preference;
+
+import org.eclipse.jface.preference.BooleanFieldEditor;
+import org.eclipse.swt.widgets.Composite;
+
+public class VerilogCodeStylePreferencePage extends AbstractSimplePreferencePage
+{
+
+	protected void createFieldEditors()
+	{
+		Composite parent = getFieldEditorParent();
+
+		String names[][] = new String[][] {
+            { PreferenceStrings.NO_SPACE_IN_BRACKET  , "No space in bracket"},
+            { PreferenceStrings.SPACE_BEFORE_OPERATOR_2, "add space before binary operator" },
+            { PreferenceStrings.SPACE_AFTER_OPERATOR_2, "add space after binary operator" },
+            { PreferenceStrings.SPACE_BEFORE_OPERATOR_1, "add space before unary operator" },
+            { PreferenceStrings.SPACE_AFTER_OPERATOR_1, "add space after unary operator" },
+            { PreferenceStrings.SPACE_BEFORE_COMMA, "add space before comma" },
+            { PreferenceStrings.SPACE_AFTER_COMMA, "add space after comma" },
+            { PreferenceStrings.SPACE_BEFORE_SEMICOLON, "add space before semiclon" },
+            { PreferenceStrings.SPACE_BEFORE_OPEN_PAREN, "add space before opening parenthesis" },
+            { PreferenceStrings.SPACE_AFTER_OPEN_PAREN, "add space after opening parenthesis" },
+            { PreferenceStrings.SPACE_BEFORE_CLOSE_PAREN, "add space before closing parenthesis" },
+            { PreferenceStrings.SPACE_BEFORE_OPEN_BRACKET, "add space before opening bracket" },
+            { PreferenceStrings.SPACE_AFTER_OPEN_BRACKET, "add space after opening bracket" },
+            { PreferenceStrings.SPACE_BEFORE_CLOSE_BRACKET, "add space before closing bracket" },
+            { PreferenceStrings.SPACE_BEFORE_OPEN_BRACE, "add space before opening brace" },
+            { PreferenceStrings.SPACE_AFTER_OPEN_BRACE, "add space after opening brace" },
+            { PreferenceStrings.SPACE_BEFORE_CLOSE_BRACE, "add space before closing brace" },
+            { PreferenceStrings.SPACE_BEFORE_CASE_COLON, "add space before colon in case" },
+            { PreferenceStrings.SPACE_AFTER_CASE_COLON, "add space after colon in case" },
+            { PreferenceStrings.SPACE_AFTER_IF, "add space after if" },
+            { PreferenceStrings.SPACE_AFTER_FOR, "add space after for" },
+            { PreferenceStrings.SPACE_AFTER_WHILE, "add space after while" },
+            { PreferenceStrings.SPACE_AFTER_REPEAT, "add space after repeat" } };
+		for (int i = 0; i < names.length; i++)
+		{
+			addField(new BooleanFieldEditor(names[i][0], names[i][1], parent));
+		}
+	}
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/preference/VerilogWarningPreferencePage.java vdt/src/com/elphel/vdt/veditor/preference/VerilogWarningPreferencePage.java
--- vdt-veditor/src/com/elphel/vdt/veditor/preference/VerilogWarningPreferencePage.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/preference/VerilogWarningPreferencePage.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,14 +1,29 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2012 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+/*******************************************************************************
+ * Copyright (c) 2004, 2012 KOBAYASHI Tadashi and others.
  *
  * Contributors:
  *    KOBAYASHI Tadashi - initial API and implementation
  *******************************************************************************/
-package net.sourceforge.veditor.preference;
+package com.elphel.vdt.veditor.preference;
+
+import org.eclipse.jface.util.PropertyChangeEvent;
+
+import com.elphel.vdt.veditor.VerilogPlugin;
 
 
 public class VerilogWarningPreferencePage extends AbstractSimplePreferencePage implements PreferenceStrings
@@ -19,16 +34,34 @@
             {WARNING_UNRESOLVED, "Unresolved signal"},
             {WARNING_NO_USED_ASIGNED, "No used or assignd signal, function or task"},
             {WARNING_BIT_WIDTH, "Bit width mismatch"},
+            {WARNING_BITWISE_WIDTH, "Bitwise operators width mismatch","Bit width mismatch in bitwise operators"},
+            {WARNING_CONDITION_WIDTH,"Condition width > 1","Condition in \"condition?A:B\" width is not 1"},
+            {WARNING_CONTEXT_DETERMINED_WIDTH,"Context-determined width",
+            	"Warn when result of  operations ~,+,-,*,/,%,&,|,^,^~,~^ is extended to match the left side"},
+            {WARNING_BIT_RANGE, "Bit range mismatch","Specified bit/bit range does not fit in declared variable range"},
             {WARNING_INT_CONSTANT, "Bit width mismatch with integer constant"},
+            {WARNING_FORCEINT32BIT,"Force integer width 32 bit fixed","Force integer variable 32 bit (and warn width mismatch in assignments), if unchecked - treat as undefined width"},
             {WARNING_BLOCKING_ASSIGNMENT, "Blocking and non-blocking assignment in a block"},
             {WARNING_BLOCKING_ASSIGNMENT_IN_ALWAYS, "Blocking assignment in always block"},
             {WARNING_UNRESOLVED_MODULE, "Unresolved module"},
-            {WARNING_MODULE_CONNECTION, "Checking module port connection"}
+            {WARNING_DUPLICATE_MODULE, "Duplicate module","Same module defined multiple times"},
+            {WARNING_MODULE_CONNECTION, "Checking module port connection"},
+            {WARNING_SKIP_PRIMITIVES, "Skip primitives"," Do not verify used/assigned status inside primitives (tables are not supported)"},
+            {WARNING_UNSUPPORTED, "Unsupported features","Warn on unsupported/partially supported features"}
 		};
 
 		for (int i = 0; i < names.length; i++) {
-			addBooleanField(names[i][0], names[i][1]);
+			if (names[i].length>2) addBooleanField(names[i][0], names[i][1], names[i][2]);
+			else addBooleanField(names[i][0], names[i][1]);
+		}
+	}
+	@Override
+	public boolean performOk(){
+		if (VerilogPlugin.getPreferenceBoolean(PreferenceStrings.DEBUG_EDITOR)) {
+			System.out.println("VerilogWarningPreferencePage:performOk()");
 		}
+        return super.performOk();
 	}
+
 }
 
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/preference/VhdlCodeStylePreferencePage.java vdt/src/com/elphel/vdt/veditor/preference/VhdlCodeStylePreferencePage.java
--- vdt-veditor/src/com/elphel/vdt/veditor/preference/VhdlCodeStylePreferencePage.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/preference/VhdlCodeStylePreferencePage.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,34 +1,45 @@
-/*******************************************************************************
- * Copyright (c) 2006 Ali Ghorashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    Ali Ghorashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.preference;
-
-
-import org.eclipse.jface.preference.BooleanFieldEditor;
-import org.eclipse.swt.widgets.Composite;
-
-public class VhdlCodeStylePreferencePage extends AbstractSimplePreferencePage {
-
-	@Override
-	protected void createFieldEditors() {
-		Composite parent = getFieldEditorParent();
-		addField(new BooleanFieldEditor(PreferenceStrings.PAD_OPERATORS,"Pad operators",parent));
-		addField(new BooleanFieldEditor(PreferenceStrings.INDENT_LIBRARY,"Indent Library use",parent));
-		addField(new BooleanFieldEditor(PreferenceStrings.KEYWORDS_LOWERCASE,"keywords in lowercase",parent));
-		addField(new BooleanFieldEditor(PreferenceStrings.ALIGNONARROWRIGHT,"Align On =>",parent));
-		addField(new BooleanFieldEditor(PreferenceStrings.ALIGNONARROWLEFT,"Align On <=",parent));
-		addField(new BooleanFieldEditor(PreferenceStrings.ALIGNONCOLON,"Align On :",parent));
-		//not supported for now
-		//addField( new BooleanFieldEditor( PreferenceStrings.ALIGNONCOMMENT,"Align On --", parent ) );
-		addField( new BooleanFieldEditor( PreferenceStrings.ALIGNONASSIGNMENT,"Align On :=", parent ) );
-		addField( new BooleanFieldEditor( PreferenceStrings.ALIGNINOUT, "Align After \"in\", \"out\", \"inout\" and \"buffer\"", parent ) );
-	}
-
-}
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2006 Ali Ghorashi and others.
+ *
+ * Contributors:
+ *    Ali Ghorashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.preference;
+
+
+import org.eclipse.jface.preference.BooleanFieldEditor;
+import org.eclipse.swt.widgets.Composite;
+
+public class VhdlCodeStylePreferencePage extends AbstractSimplePreferencePage {
+
+	@Override
+	protected void createFieldEditors() {
+		Composite parent = getFieldEditorParent();
+		addField(new BooleanFieldEditor(PreferenceStrings.PAD_OPERATORS,"Pad operators",parent));
+		addField(new BooleanFieldEditor(PreferenceStrings.INDENT_LIBRARY,"Indent Library use",parent));
+		addField(new BooleanFieldEditor(PreferenceStrings.KEYWORDS_LOWERCASE,"keywords in lowercase",parent));
+		addField(new BooleanFieldEditor(PreferenceStrings.ALIGNONARROWRIGHT,"Align On =>",parent));
+		addField(new BooleanFieldEditor(PreferenceStrings.ALIGNONARROWLEFT,"Align On <=",parent));
+		addField(new BooleanFieldEditor(PreferenceStrings.ALIGNONCOLON,"Align On :",parent));
+		//not supported for now
+		//addField( new BooleanFieldEditor( PreferenceStrings.ALIGNONCOMMENT,"Align On --", parent ) );
+		addField( new BooleanFieldEditor( PreferenceStrings.ALIGNONASSIGNMENT,"Align On :=", parent ) );
+		addField( new BooleanFieldEditor( PreferenceStrings.ALIGNINOUT, "Align After \"in\", \"out\", \"inout\" and \"buffer\"", parent ) );
+	}
+
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/preference/VhdlCodeStylePreferencePage.java.bak vdt/src/com/elphel/vdt/veditor/preference/VhdlCodeStylePreferencePage.java.bak
--- vdt-veditor/src/com/elphel/vdt/veditor/preference/VhdlCodeStylePreferencePage.java.bak	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/preference/VhdlCodeStylePreferencePage.java.bak	1969-12-31 17:00:00.000000000 -0700
@@ -1,30 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2006 Ali Ghorashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    Ali Ghorashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.preference;
-
-
-import org.eclipse.jface.preference.BooleanFieldEditor;
-import org.eclipse.swt.widgets.Composite;
-
-public class VhdlCodeStylePreferencePage extends AbstractSimplePreferencePage {
-
-	@Override
-	protected void createFieldEditors() {
-		Composite parent = getFieldEditorParent();
-		addField(new BooleanFieldEditor(PreferenceStrings.PAD_OPERATORS,"Pad operators",parent));
-		addField(new BooleanFieldEditor(PreferenceStrings.INDENT_LIBRARY,"Indent Library use",parent));
-		addField(new BooleanFieldEditor(PreferenceStrings.KEYWORDS_LOWERCASE,"keywords in lowercase",parent));
-		addField(new BooleanFieldEditor(PreferenceStrings.ALIGNONARROWRIGHT,"Align On =>",parent));
-		addField(new BooleanFieldEditor(PreferenceStrings.ALIGNONARROWLEFT,"Align On <=",parent));
-		addField(new BooleanFieldEditor(PreferenceStrings.ALIGNONCOLON,"Align On :",parent));
-	}
-
-}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/preference/VhdlWarningPreferencePage.java vdt/src/com/elphel/vdt/veditor/preference/VhdlWarningPreferencePage.java
--- vdt-veditor/src/com/elphel/vdt/veditor/preference/VhdlWarningPreferencePage.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/preference/VhdlWarningPreferencePage.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,14 +1,25 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2012 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+/*******************************************************************************
+ * Copyright (c) 2004, 2012 KOBAYASHI Tadashi and others.
  *
  * Contributors:
  *    KOBAYASHI Tadashi - initial API and implementation
  *******************************************************************************/
-package net.sourceforge.veditor.preference;
+package com.elphel.vdt.veditor.preference;
 
 
 public class VhdlWarningPreferencePage extends AbstractSimplePreferencePage
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/preference/WarningPreferencePage.java vdt/src/com/elphel/vdt/veditor/preference/WarningPreferencePage.java
--- vdt-veditor/src/com/elphel/vdt/veditor/preference/WarningPreferencePage.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/preference/WarningPreferencePage.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,21 +1,36 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2012 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+/*******************************************************************************
+ * Copyright (c) 2004, 2012 KOBAYASHI Tadashi and others.
  *
  * Contributors:
  *    KOBAYASHI Tadashi - initial API and implementation
  *******************************************************************************/
-package net.sourceforge.veditor.preference;
+package com.elphel.vdt.veditor.preference;
 
 
 public class WarningPreferencePage extends AbstractSimplePreferencePage
 {   
 	protected void createFieldEditors()
 	{
-		addBooleanField(PreferenceStrings.SEMANTIC_WARNING, "Enable Warning");
+		addBooleanField(PreferenceStrings.SEMANTIC_WARNING, "Enable Warnings");
+		addBooleanField(PreferenceStrings.IGNORE_SUPPRESS_WARNINGS, "Ignore SuppressWarnings",
+				"Ignore 'SuppressWarnings' in the previous line and 'SuppressThisWarning' in the current line (combined with 'all' or tool name or 'VEeditor')");
+		addBooleanField(PreferenceStrings.SUPPRESS_WARNINGS_ANYLEVEL, "SuppressWarnings in hierarchy",
+				"Allow 'SuppressWarnings'/'SuppressThisWarning' directives (for external tools) at any level in the hierarchy.");
 	}
 }
 
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/semanticwarnings/SemanticWarnings.java vdt/src/com/elphel/vdt/veditor/semanticwarnings/SemanticWarnings.java
--- vdt-veditor/src/com/elphel/vdt/veditor/semanticwarnings/SemanticWarnings.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/semanticwarnings/SemanticWarnings.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,11 +1,11 @@
-package net.sourceforge.veditor.semanticwarnings;
+package com.elphel.vdt.veditor.semanticwarnings;
 
 import java.util.Vector;
 
 import org.eclipse.core.resources.IFile;
-import net.sourceforge.veditor.VerilogPlugin;
-import net.sourceforge.veditor.parser.vhdl.*;
-import net.sourceforge.veditor.semanticwarnings.VariableStore.DeclaredSymbol;
+import com.elphel.vdt.veditor.VerilogPlugin;
+import com.elphel.vdt.veditor.parser.vhdl.*;
+import com.elphel.vdt.veditor.semanticwarnings.VariableStore.DeclaredSymbol;
 
 public class SemanticWarnings {
 	private IFile m_File;
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/semanticwarnings/VariableStore.java vdt/src/com/elphel/vdt/veditor/semanticwarnings/VariableStore.java
--- vdt-veditor/src/com/elphel/vdt/veditor/semanticwarnings/VariableStore.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/semanticwarnings/VariableStore.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,8 +1,8 @@
-package net.sourceforge.veditor.semanticwarnings;
+package com.elphel.vdt.veditor.semanticwarnings;
 
 import java.util.Vector;
 
-import net.sourceforge.veditor.parser.vhdl.*;
+import com.elphel.vdt.veditor.parser.vhdl.*;
 
 public class VariableStore {
 	public static class DeclaredSymbol {
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/templates/HdlContextType.java vdt/src/com/elphel/vdt/veditor/templates/HdlContextType.java
--- vdt-veditor/src/com/elphel/vdt/veditor/templates/HdlContextType.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/templates/HdlContextType.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,32 +1,32 @@
-package net.sourceforge.veditor.templates;
-
-import org.eclipse.jface.text.templates.GlobalTemplateVariables;
-import org.eclipse.jface.text.templates.TemplateContextType;
-
-public class HdlContextType extends TemplateContextType{
-	
-	/** This context's id */
-	public static final String CONTEXT_TYPE= "net.sourceforge.veditor.HdlContext"; 
-
-	/**
-	 * Creates a new HdlContextType context type. 
-	 */
-	public HdlContextType() {
-		super();
-		addGlobalResolvers();
-	}
-
-	protected void addGlobalResolvers() {		
-		addResolver(new GlobalTemplateVariables.Cursor());
-		addResolver(new GlobalTemplateVariables.WordSelection());
-		addResolver(new GlobalTemplateVariables.LineSelection());
-		addResolver(new GlobalTemplateVariables.Dollar());
-		addResolver(new GlobalTemplateVariables.Date());
-		addResolver(new GlobalTemplateVariables.Year());
-		addResolver(new GlobalTemplateVariables.Time());
-		addResolver(new GlobalTemplateVariables.User());
-		//mg
-		addResolver( new VhdlTemplateVariable.Brief() );
-		//mg-------------------
-	}
-}
+package com.elphel.vdt.veditor.templates;
+
+import org.eclipse.jface.text.templates.GlobalTemplateVariables;
+import org.eclipse.jface.text.templates.TemplateContextType;
+
+public class HdlContextType extends TemplateContextType{
+	
+	/** This context's id */
+	public static final String CONTEXT_TYPE= "com.elphel.vdt.veditor.HdlContext"; 
+
+	/**
+	 * Creates a new HdlContextType context type. 
+	 */
+	public HdlContextType() {
+		super();
+		addGlobalResolvers();
+	}
+
+	protected void addGlobalResolvers() {		
+		addResolver(new GlobalTemplateVariables.Cursor());
+		addResolver(new GlobalTemplateVariables.WordSelection());
+		addResolver(new GlobalTemplateVariables.LineSelection());
+		addResolver(new GlobalTemplateVariables.Dollar());
+		addResolver(new GlobalTemplateVariables.Date());
+		addResolver(new GlobalTemplateVariables.Year());
+		addResolver(new GlobalTemplateVariables.Time());
+		addResolver(new GlobalTemplateVariables.User());
+		//mg
+		addResolver( new VhdlTemplateVariable.Brief() );
+		//mg-------------------
+	}
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/templates/TemplateWithIndent.java vdt/src/com/elphel/vdt/veditor/templates/TemplateWithIndent.java
--- vdt-veditor/src/com/elphel/vdt/veditor/templates/TemplateWithIndent.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/templates/TemplateWithIndent.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,28 +1,28 @@
-package net.sourceforge.veditor.templates;
-
-import org.eclipse.jface.text.templates.Template;
-
-public class TemplateWithIndent extends Template
-{
-	private String indent;
-
-	public TemplateWithIndent(Template parent, String indent)
-	{
-		super(parent);
-		this.indent = indent;
-	}
-	
-	public String getPattern()
-	{
-		StringBuffer pattern = new StringBuffer();
-		int length = super.getPattern().length();
-		for(int i = 0; i < length; i++)
-		{
-			char c = super.getPattern().charAt(i);
-			pattern.append(c);
-			if (c == '\n')
-				pattern.append(indent);
-		}
-		return pattern.toString();
-	}
-}
+package com.elphel.vdt.veditor.templates;
+
+import org.eclipse.jface.text.templates.Template;
+
+public class TemplateWithIndent extends Template
+{
+	private String indent;
+
+	public TemplateWithIndent(Template parent, String indent)
+	{
+		super(parent);
+		this.indent = indent;
+	}
+	
+	public String getPattern()
+	{
+		StringBuffer pattern = new StringBuffer();
+		int length = super.getPattern().length();
+		for(int i = 0; i < length; i++)
+		{
+			char c = super.getPattern().charAt(i);
+			pattern.append(c);
+			if (c == '\n')
+				pattern.append(indent);
+		}
+		return pattern.toString();
+	}
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/templates/VerilogInModuleContextType.java vdt/src/com/elphel/vdt/veditor/templates/VerilogInModuleContextType.java
--- vdt-veditor/src/com/elphel/vdt/veditor/templates/VerilogInModuleContextType.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/templates/VerilogInModuleContextType.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,6 +1,6 @@
-package net.sourceforge.veditor.templates;
-
-public class VerilogInModuleContextType extends HdlContextType{
-	/** This context's id */
-	public static final String CONTEXT_TYPE= "net.sourceforge.veditor.verilogInModule"; 
-}
+package com.elphel.vdt.veditor.templates;
+
+public class VerilogInModuleContextType extends HdlContextType{
+	/** This context's id */
+	public static final String CONTEXT_TYPE= "com.elphel.vdt.veditor.verilogInModule"; 
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/templates/VerilogInStatementContextType.java vdt/src/com/elphel/vdt/veditor/templates/VerilogInStatementContextType.java
--- vdt-veditor/src/com/elphel/vdt/veditor/templates/VerilogInStatementContextType.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/templates/VerilogInStatementContextType.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,6 +1,6 @@
-package net.sourceforge.veditor.templates;
-
-public class VerilogInStatementContextType extends HdlContextType{
-	/** This context's id */
-	public static final String CONTEXT_TYPE= "net.sourceforge.veditor.verilogInStatement"; 
-}
+package com.elphel.vdt.veditor.templates;
+
+public class VerilogInStatementContextType extends HdlContextType{
+	/** This context's id */
+	public static final String CONTEXT_TYPE= "com.elphel.vdt.veditor.verilogInStatement"; 
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/templates/VerilogNewFileContext.java vdt/src/com/elphel/vdt/veditor/templates/VerilogNewFileContext.java
--- vdt-veditor/src/com/elphel/vdt/veditor/templates/VerilogNewFileContext.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/templates/VerilogNewFileContext.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,16 +1,27 @@
-/*******************************************************************************
- * Copyright (c) 2006 Ali Ghorashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    Ali Ghorashi - initial API and implementation
- *******************************************************************************/
-package net.sourceforge.veditor.templates;
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2006 Ali Ghorashi and others.
+ *
+ * Contributors:
+ *    Ali Ghorashi - initial API and implementation
+ *******************************************************************************/
+package com.elphel.vdt.veditor.templates;
 
 public class VerilogNewFileContext extends HdlContextType {
 	/** This context's id */
-	public static final String	CONTEXT_TYPE	= "net.sourceforge.veditor.templates.verilog.context.newfile";
+	public static final String	CONTEXT_TYPE	= "com.elphel.vdt.veditor.templates.verilog.context.newfile";
 }
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/templates/VerilogOutModuleContextType.java vdt/src/com/elphel/vdt/veditor/templates/VerilogOutModuleContextType.java
--- vdt-veditor/src/com/elphel/vdt/veditor/templates/VerilogOutModuleContextType.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/templates/VerilogOutModuleContextType.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,6 +1,6 @@
-package net.sourceforge.veditor.templates;
-
-public class VerilogOutModuleContextType extends HdlContextType{
-	/** This context's id */
-	public static final String CONTEXT_TYPE= "net.sourceforge.veditor.verilogOutModule"; 
-}
+package com.elphel.vdt.veditor.templates;
+
+public class VerilogOutModuleContextType extends HdlContextType{
+	/** This context's id */
+	public static final String CONTEXT_TYPE= "com.elphel.vdt.veditor.verilogOutModule"; 
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/templates/VhdlGlobalContext.java vdt/src/com/elphel/vdt/veditor/templates/VhdlGlobalContext.java
--- vdt-veditor/src/com/elphel/vdt/veditor/templates/VhdlGlobalContext.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/templates/VhdlGlobalContext.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,6 +1,6 @@
-package net.sourceforge.veditor.templates;
-
-public class VhdlGlobalContext extends HdlContextType{
-	/** This context's id */
-	public static final String CONTEXT_TYPE= "net.sourceforge.veditor.templates.vhdl.context.global"; 
-}
+package com.elphel.vdt.veditor.templates;
+
+public class VhdlGlobalContext extends HdlContextType{
+	/** This context's id */
+	public static final String CONTEXT_TYPE= "com.elphel.vdt.veditor.templates.vhdl.context.global"; 
+}
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/templates/VhdlNewFileContext.java vdt/src/com/elphel/vdt/veditor/templates/VhdlNewFileContext.java
--- vdt-veditor/src/com/elphel/vdt/veditor/templates/VhdlNewFileContext.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/templates/VhdlNewFileContext.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,16 +1,27 @@
-/*******************************************************************************
- * Copyright (c) 2013 VEditor Team
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+/*******************************************************************************
+ * Copyright (c) 2013 VEditor Team
  *
  * Contributors:
  *   Maximilian Girlich - initial API and implementation
  *******************************************************************************/
-package net.sourceforge.veditor.templates;
+package com.elphel.vdt.veditor.templates;
 
 public class VhdlNewFileContext extends HdlContextType {
 	/** This context's id */
-	public static final String	CONTEXT_TYPE	= "net.sourceforge.veditor.templates.vhdl.context.newfile";
+	public static final String	CONTEXT_TYPE	= "com.elphel.vdt.veditor.templates.vhdl.context.newfile";
 }
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/templates/VhdlTemplateVariable.java vdt/src/com/elphel/vdt/veditor/templates/VhdlTemplateVariable.java
--- vdt-veditor/src/com/elphel/vdt/veditor/templates/VhdlTemplateVariable.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/templates/VhdlTemplateVariable.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,5 +1,5 @@
 //mg
-package net.sourceforge.veditor.templates;
+package com.elphel.vdt.veditor.templates;
 
 import org.eclipse.jface.text.templates.SimpleTemplateVariableResolver;
 import org.eclipse.jface.text.templates.TemplateContext;
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/VerilogPerspective.java vdt/src/com/elphel/vdt/veditor/VerilogPerspective.java
--- vdt-veditor/src/com/elphel/vdt/veditor/VerilogPerspective.java	2016-06-24 10:29:40.848495740 -0600
+++ vdt/src/com/elphel/vdt/veditor/VerilogPerspective.java	2016-06-24 10:29:40.816496628 -0600
@@ -1,84 +1,130 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-
-package net.sourceforge.veditor;
-
-import org.eclipse.ui.IFolderLayout;
-import org.eclipse.ui.IPageLayout;
-import org.eclipse.ui.IPerspectiveFactory;
-import org.eclipse.ui.IViewLayout;
-
-public class VerilogPerspective implements IPerspectiveFactory
-{
-	private static final String ID_HIERARCHY = "net.sourceforge.veditor.editor.ModuleHierarchyView";
-
-	private static final String ID_CONSOLE = "org.eclipse.ui.console.ConsoleView";
-	
-	public VerilogPerspective()
-	{
-		super();
-	}
-
-	public void createInitialLayout(IPageLayout layout)
-	{
-		defineLayout(layout);
-		defineActions(layout);
-	}
-
-	private void defineLayout(IPageLayout layout)
-	{
-		IFolderLayout left = layout.createFolder("Left", IPageLayout.LEFT,
-				0.25f, IPageLayout.ID_EDITOR_AREA);
-		IFolderLayout bottom = layout.createFolder("Bottom",
-				IPageLayout.BOTTOM, 0.75f, IPageLayout.ID_EDITOR_AREA);
-		IFolderLayout right = layout.createFolder("Right", IPageLayout.RIGHT,
-				0.75f, IPageLayout.ID_EDITOR_AREA);
-
-		addView(layout, left, IPageLayout.ID_RES_NAV);
-		addView(layout, right, IPageLayout.ID_OUTLINE);
-		addView(layout, right, ID_HIERARCHY);
-		addView(layout, bottom, IPageLayout.ID_PROBLEM_VIEW);
-		addView(layout, bottom, ID_CONSOLE);
-	}
-
-	private void addView(IPageLayout parent, IFolderLayout folder, String viewid)
-	{
-		folder.addView(viewid);
-		IViewLayout layout = parent.getViewLayout(viewid);
-		if (layout != null)
-		{
-			layout.setCloseable(true);
-			layout.setMoveable(true);
-		}
-	}
-
-	private void defineActions(IPageLayout layout)
-	{
-		layout.addShowViewShortcut(IPageLayout.ID_RES_NAV);
-		layout.addShowViewShortcut(IPageLayout.ID_OUTLINE);
-		layout.addShowViewShortcut(ID_HIERARCHY);
-		layout.addShowViewShortcut(IPageLayout.ID_PROBLEM_VIEW);
-		layout.addShowViewShortcut(ID_CONSOLE);
-
-		layout.addNewWizardShortcut("net.sourceforge.veditor.wizard.NewVerilogWizard");
-		layout.addNewWizardShortcut("net.sourceforge.veditor.wizard.NewVhdlWizard");
-		layout.addNewWizardShortcut("org.eclipse.ui.wizards.new.folder");
-		layout.addNewWizardShortcut("org.eclipse.ui.wizards.new.file");
-	}
-}
-
-
-
-
-
-
-
-
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+
+package com.elphel.vdt.veditor;
+
+import com.elphel.vdt.VDT;
+
+import org.eclipse.ui.IFolderLayout;
+import org.eclipse.ui.IPageLayout;
+import org.eclipse.ui.IPerspectiveFactory;
+import org.eclipse.ui.IViewLayout;
+
+public class VerilogPerspective implements IPerspectiveFactory
+{
+	private static final String ID_HIERARCHY = "com.elphel.vdt.veditor.editor.ModuleHierarchyView";
+
+	private static final String ID_CONSOLE = "org.eclipse.ui.console.ConsoleView";
+	
+	public VerilogPerspective()
+	{
+		super();
+	}
+
+	public void createInitialLayout(IPageLayout layout)
+	{
+		defineLayout(layout);
+		defineActions(layout);
+	}
+
+	private void defineLayout(IPageLayout layout)
+	{
+        // Editors are placed for free.
+        String editorArea = layout.getEditorArea();
+        
+        // create folder for views.
+        String left_top_id = "left_top";
+        String left_bottom_id = "left_bottom";
+        String right_id = "right";
+        String right_bottom_id = "right_bottom";
+        
+        IFolderLayout left_top =     layout.createFolder(left_top_id, IPageLayout.LEFT,       0.25f, editorArea);
+        IFolderLayout left_bottom =  layout.createFolder(left_bottom_id, IPageLayout.BOTTOM,  0.5f,  left_top_id);
+		IFolderLayout right =        layout.createFolder(right_id,       IPageLayout.RIGHT,   0.75f, editorArea);
+        IFolderLayout bottom =       layout.createFolder(right_bottom_id, IPageLayout.BOTTOM, 0.8f,  editorArea);
+
+		addView(layout, left_top, IPageLayout.ID_RES_NAV);
+		addView(layout, right,    IPageLayout.ID_OUTLINE);
+//		addView(layout, left_bottom, IPageLayout.ID_OUTLINE); // just temporarily
+        left_bottom.addView(VDT.ID_DESINGFLOW_VIEW);
+		addView(layout, right, ID_HIERARCHY);
+		addView(layout, bottom, IPageLayout.ID_PROBLEM_VIEW);
+		addView(layout, bottom, ID_CONSOLE);
+		/*
+        IFolderLayout left_top = layout.createFolder(left_top_id, IPageLayout.LEFT, 0.25f, editorArea);
+        IFolderLayout left_bottom = layout.createFolder(left_bottom_id, IPageLayout.BOTTOM, 0.5f, left_top_id);
+        IFolderLayout right_bottom = layout.createFolder(right_bottom_id, IPageLayout.BOTTOM, 0.8f, editorArea);
+
+        left_top.addView(IPageLayout.ID_RES_NAV);
+        left_top.addView(VDT.ID_NAVIGATOR_VIEW);
+        left_bottom.addView(VDT.ID_DESINGFLOW_VIEW);
+        right_bottom.addView(IConsoleConstants.ID_CONSOLE_VIEW);//VDT.ID_LOG_VIEW);
+
+		IFolderLayout left = layout.createFolder("Left", IPageLayout.LEFT,      0.25f, IPageLayout.ID_EDITOR_AREA);
+		IFolderLayout bottom = layout.createFolder("Bottom",IPageLayout.BOTTOM, 0.75f, IPageLayout.ID_EDITOR_AREA);
+		IFolderLayout right = layout.createFolder("Right", IPageLayout.RIGHT,   0.75f, IPageLayout.ID_EDITOR_AREA);
+
+		addView(layout, left, IPageLayout.ID_RES_NAV);
+		addView(layout, right, IPageLayout.ID_OUTLINE);
+		addView(layout, right, ID_HIERARCHY);
+		addView(layout, bottom, IPageLayout.ID_PROBLEM_VIEW);
+		addView(layout, bottom, ID_CONSOLE);
+
+		 */
+	}
+
+	private void addView(IPageLayout parent, IFolderLayout folder, String viewid)
+	{
+		folder.addView(viewid);
+		IViewLayout layout = parent.getViewLayout(viewid);
+		if (layout != null)
+		{
+			layout.setCloseable(true);
+			layout.setMoveable(true);
+		}
+	}
+
+	private void defineActions(IPageLayout layout)
+	{
+		layout.addShowViewShortcut(IPageLayout.ID_RES_NAV);
+		layout.addShowViewShortcut(IPageLayout.ID_OUTLINE);
+		layout.addShowViewShortcut(ID_HIERARCHY);
+		layout.addShowViewShortcut(IPageLayout.ID_PROBLEM_VIEW);
+		layout.addShowViewShortcut(ID_CONSOLE);
+
+		layout.addShowViewShortcut(VDT.ID_DESINGFLOW_VIEW);
+		
+
+		layout.addNewWizardShortcut("com.elphel.vdt.veditor.wizard.NewVerilogWizard");
+		layout.addNewWizardShortcut("com.elphel.vdt.veditor.wizard.NewVhdlWizard");
+		layout.addNewWizardShortcut("org.eclipse.ui.wizards.new.folder");
+		layout.addNewWizardShortcut("org.eclipse.ui.wizards.new.file");
+	}
+}
+
+
+
+
+
+
+
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/VerilogPlugin.java vdt/src/com/elphel/vdt/veditor/VerilogPlugin.java
--- vdt-veditor/src/com/elphel/vdt/veditor/VerilogPlugin.java	2016-06-24 10:29:40.848495740 -0600
+++ vdt/src/com/elphel/vdt/veditor/VerilogPlugin.java	2016-06-24 10:29:40.816496628 -0600
@@ -1,532 +1,729 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-
-package net.sourceforge.veditor;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-
-import net.sourceforge.veditor.templates.VerilogInModuleContextType;
-import net.sourceforge.veditor.templates.VerilogInStatementContextType;
-import net.sourceforge.veditor.templates.VerilogNewFileContext;
-import net.sourceforge.veditor.templates.VerilogOutModuleContextType;
-import net.sourceforge.veditor.templates.VhdlGlobalContext;
-import net.sourceforge.veditor.templates.VhdlNewFileContext;
-
-import org.eclipse.core.resources.IMarker;
-import org.eclipse.core.resources.IResource;
-import org.eclipse.core.resources.IWorkspace;
-import org.eclipse.core.resources.ResourcesPlugin;
-import org.eclipse.core.runtime.CoreException;
-import org.eclipse.core.runtime.IStatus;
-import org.eclipse.core.runtime.QualifiedName;
-import org.eclipse.core.runtime.Status;
-import org.eclipse.jface.preference.IPreferenceStore;
-import org.eclipse.jface.preference.PreferenceConverter;
-import org.eclipse.jface.resource.ImageDescriptor;
-import org.eclipse.jface.resource.ImageRegistry;
-import org.eclipse.jface.text.templates.ContextTypeRegistry;
-import org.eclipse.jface.text.templates.persistence.TemplateStore;
-import org.eclipse.swt.graphics.Image;
-import org.eclipse.swt.graphics.RGB;
-import org.eclipse.ui.console.ConsolePlugin;
-import org.eclipse.ui.console.IConsole;
-import org.eclipse.ui.console.IConsoleManager;
-import org.eclipse.ui.console.IPatternMatchListener;
-import org.eclipse.ui.console.MessageConsole;
-import org.eclipse.ui.console.MessageConsoleStream;
-import org.eclipse.ui.editors.text.templates.ContributionContextTypeRegistry;
-import org.eclipse.ui.editors.text.templates.ContributionTemplateStore;
-import org.eclipse.ui.plugin.AbstractUIPlugin;
-
-/**
- * The main plugin class
- */
-public class VerilogPlugin extends AbstractUIPlugin
-{
-	private static final String CONSOLE_NAME = "veditor";
-	private static VerilogPlugin plugin;
-	private static final String INTERNALMARKER_TYPE = "org.eclipse.core.resources.problemmarker";
-	private static final String EXTERNALMARKER_TYPE = "net.sourceforge.veditor.builderproblemmarker";
-	private static final String AUTO_TASK_MARKER = "net.sourceforge.veditor.autotaskmarker";
-	private static final String OUTLINE_DATABASE_ID = "OutlineDatabase";
-	private static final String COLLAPSIBLE_PROPERTY_ID = "collapsible";
-	private static final String HIERARCHY_ID = "Hierarchy";
-	private static final String CUSTTOM_TEMPLATES_PREFERENCE_NAME = "net.sourceforge.veditor.templatesStore";	
-	protected TemplateStore templateStore;
-	protected ContributionContextTypeRegistry contextTypeRegistry;
-	public static final String ID="net.sourceforge.veditor";
-
-	public VerilogPlugin()
-	{
-		super();
-		plugin = this;		
-		templateStore=null;
-		contextTypeRegistry=null;
-	}
-
-	/**
-	 * Returns the shared instance.
-	 */
-	public static VerilogPlugin getPlugin()
-	{
-		return plugin;
-	}
-	/**
-	 * 
-	 * @return Database Outline id
-	 */
-	public static QualifiedName getOutlineDatabaseId(){
-		return new QualifiedName(ID,OUTLINE_DATABASE_ID);
-	}
-	public static QualifiedName getCollapsibleId(){
-		return new QualifiedName(ID,COLLAPSIBLE_PROPERTY_ID);
-	}
-	public static QualifiedName getHierarchyId(){
-		return new QualifiedName(ID,HIERARCHY_ID);
-	}
-
-	/**
-	 * Returns PreferenceStore
-	 */
-	public static IPreferenceStore getStore()
-	{
-		return getPlugin().getPreferenceStore();
-	}
-	
-	/**
-	 * Gets the image descriptor for a given image name
-	 * @param imageName image file name
-	 * @return Image descriptor 
-	 */
-	public ImageDescriptor getImageDescriptor(String imageName){
-		return VerilogPlugin.imageDescriptorFromPlugin(	VerilogPlugin.ID, imageName);
-	}
-	/** 
-	 * Returns an image from the registery
-	 * @param imageName the name of the image file
-	 */
-	public Image getImage(String imageName) {
-		VerilogPlugin plugin = VerilogPlugin.getPlugin();
-		ImageRegistry registry = plugin.getImageRegistry();
-		Image results = null;
-
-		results = registry.get(imageName);
-		results = registry.get(imageName);
-		if (results == null) {
-			ImageDescriptor desc = getImageDescriptor(imageName);
-			registry.put(imageName, desc);
-			results = registry.get(imageName);
-		}		
-		return results;
-	}
-	
-	/**
-	 * Returns the workspace instance.
-	 */
-	public static IWorkspace getWorkspace()
-	{
-		return ResourcesPlugin.getWorkspace();
-	}
-
-	/**
-	 * Returns the string from the plugin preferences
-	 */
-	public static String getPreferenceString(String key)
-	{		
-		if ( getStore().contains(key) ){
-			return getStore().getString(key);
-		}
-		else{
-			return getStore().getDefaultString(key);
-		}
-	}
-
-	/**
-	 * Returns the string from the plugin preferences
-	 */
-	public static boolean getPreferenceBoolean(String key)
-	{
-		if ( getStore().contains(key) ){
-			return getStore().getBoolean(key);
-		}
-		else{
-			return getStore().getDefaultBoolean(key);
-		}
-	}
-	
-	/**
-	 * Returns the RGB from the plugin preferences
-	 */
-	public static RGB getPreferenceColor(String key)
-	{
-		return PreferenceConverter.getColor(getStore(), key);
-	}
-	
-	/**
-	 * Returns the string list separated by "\n" from the plugin preferences
-	 */
-	public static List<String> getPreferenceStrings(String key)
-	{
-		String string = getPreferenceString(key);
-		if (string == null)
-			return null;
-
-		int index = string.indexOf('\n');
-		if (index >= 0)
-		{
-			// check version number
-			if (!string.substring(0, index).equals("1"))
-				return null;
-		}
-	
-		List<String> list = new ArrayList<String>();
-		int length = string.length();
-		while(index >= 0 && index < length - 1)
-		{
-			int next = string.indexOf('\n', index + 1);
-			if (next >= 0)
-			{
-				list.add(string.substring(index + 1, next));
-			}
-			index = next;
-		}
-		return list;
-	}
-	
-	/**
-	 * set the string to the plugin preferences
-	 */
-	public static void setPreference(String key, String value)
-	{
-		getStore().setValue(key, value);
-	}
-
-	/**
-	 * set the string to the plugin preferences
-	 */
-	public static void setPreference(String key, boolean value)
-	{
-		getStore().setValue(key, value);
-	}
-	
-	/**
-	 * set the RGB to the plugin preferences
-	 */
-	public static void setPreference(String key, RGB rgb)
-	{
-		PreferenceConverter.setValue(getStore(), key, rgb);
-	}
-	
-	/**
-	 * set the string list separated by "\n"
-	 */
-	public static void setPreference(String key, List<String> list)
-	{
-		StringBuffer value = new StringBuffer("1\n");
-		Iterator<String> i = list.iterator();
-		while(i.hasNext())
-		{
-			value.append(i.next().toString());
-			value.append("\n");
-		}
-		setPreference(key, value.toString());
-	}
-	
-	/**
-	 * initialize default
-	 */
-	public static void setDefaultPreference(String key)
-	{
-		getStore().setToDefault(key);
-	}
-
-	/**
-	 * Show message in console view
-	 */
-	public static void println(String msg)
-	{
-		MessageConsoleStream out = findConsole(CONSOLE_NAME).newMessageStream();
-		out.println(msg);
-	}
-	
-	/**
-	 * FIXME:
-	 * I cannot use clearConsole!
-	 * When clearConsole is called, println is ignored
-	 */
-	public static void clear()
-	{
-		findConsole(CONSOLE_NAME).clearConsole();
-	}
-	
-	private static MessageConsole findConsole(String name)
-	{
-		IConsoleManager man = ConsolePlugin.getDefault().getConsoleManager();
-		IConsole[] consoles = man.getConsoles();
-		for (int i = 0; i < consoles.length; i++)
-		{
-			if (consoles[i].getName().equals(name))
-				return (MessageConsole)consoles[i];
-		}
-
-		// if not exists, add new console
-		MessageConsole newConsole = new MessageConsole(name, null);
-		man.addConsoles(new IConsole[]{newConsole});
-		return newConsole;
-	}
-	
-	public static void removePatternMatchListener(IPatternMatchListener list) {
-		findConsole(CONSOLE_NAME).removePatternMatchListener(list);
-	}
-	
-	public static void addPatternMatchListener(IPatternMatchListener list) {
-		findConsole(CONSOLE_NAME).addPatternMatchListener(list);
-	}
-	
-
-	public static void setErrorMarker(IResource file, int lineNumber, String msg)
-	{
-		setProblemMarker(file, IMarker.SEVERITY_ERROR, lineNumber, msg);
-	}
-
-	public static void setWarningMarker(IResource file, int lineNumber,
-			String msg)
-	{
-		if (getPreferenceBoolean("Warning"))
-			setProblemMarker(file, IMarker.SEVERITY_WARNING, lineNumber, msg);
-	}
-
-	public static void setInfoMarker(IResource file, int lineNumber, String msg)
-	{
-		setProblemMarker(file, IMarker.SEVERITY_INFO, lineNumber, msg);
-	}
-
-	/**
-	 * Creates a task marker
-	 * @param file The resource that needs the task added
-	 * @param lineNumber The line number of the task
-	 * @param msg Task message
-	 */
-	public static void setTaskMarker(IResource file,int lineNumber,String msg,int priority){
-	    //if there's already a marker at this location, remove it
-	    clearAutoTaskMarker(file,lineNumber);
-	    try {
-            IMarker marker = createAutoMarker(file);
-            marker.setAttribute(IMarker.MESSAGE, msg);
-            marker.setAttribute(IMarker.LINE_NUMBER, lineNumber);
-            marker.setAttribute(IMarker.PRIORITY,priority);
-            marker.setAttribute(IMarker.USER_EDITABLE, false);
-        } catch (CoreException e) {           
-            e.printStackTrace();
-        }
-	    
-	}
-	
-	public static IMarker createAutoMarker(IResource file){
-	    try {
-	         IMarker marker = file.createMarker(AUTO_TASK_MARKER);
-	         return marker;
-	      } catch (CoreException e) {
-	         // You need to handle the cases where attribute value is rejected
-	          e.printStackTrace();
-	      }
-	      return null;
-	}
-	/**
-	 * Removes a task marker from the given file and line number
-	 * @param file The resource that has the task in it
-	 * @param lineNumber The line number of the task
-	 */
-	public static void clearAutoTaskMarker(IResource file,int lineNumber){
-	    IMarker[] markers;
-        try {
-            markers = file.findMarkers(AUTO_TASK_MARKER, true, IResource.DEPTH_INFINITE);
-            for (int i = 0; i < markers.length; i++){                
-                Integer tempLineNumber = (Integer)markers[i].getAttribute(IMarker.LINE_NUMBER);
-                //if the line numbers match, remove the marker
-                if(tempLineNumber == lineNumber){
-                    markers[i].delete();
-                    break;
-                }
-            }
-                
-        } catch (CoreException e) {           
-            e.printStackTrace();
-        }
-        
-	}
-	
-	/**
-	 * Removes all the tasks from the file
-	 * @param file The file to remove the tasks from
-	 */
-	public static void clearAllAutoTaskMarkers(IResource file){
-	    IMarker [] markers;
-        try {
-            markers = file.findMarkers(AUTO_TASK_MARKER, false, IResource.DEPTH_INFINITE);
-            for (int i = 0; i < markers.length; i++){        
-                markers[i].delete();       
-                
-            }                
-        } catch (CoreException e) {           
-            e.printStackTrace();
-        }
-	}
-
-	public static void setProblemMarker(IResource file, int level,
-			int lineNumber, String msg)
-	{
-		try
-		{
-			IMarker marker = file.createMarker(INTERNALMARKER_TYPE);
-			marker.setAttribute(IMarker.SEVERITY, level);
-			marker.setAttribute(IMarker.LINE_NUMBER, lineNumber);
-			marker.setAttribute(IMarker.MESSAGE, msg);
-		}
-		catch (CoreException e)
-		{
-		}
-	}
-
-	public static void setExternalProblemMarker(IResource file, int level,
-			int lineNumber, String msg)
-	{
-		try
-		{
-			IMarker marker = file.createMarker(EXTERNALMARKER_TYPE);
-			marker.setAttribute(IMarker.SEVERITY, level);
-			marker.setAttribute(IMarker.LINE_NUMBER, lineNumber);
-			marker.setAttribute(IMarker.MESSAGE, msg);
-		}
-		catch (CoreException e)
-		{
-		}
-	}
-	
-	public static void deleteMarkers(IResource project) {
-		try {
-			project.deleteMarkers(INTERNALMARKER_TYPE, true, IResource.DEPTH_INFINITE);
-		} catch (CoreException e) {
-		}
-	}
-
-	public static void deleteExternalMarkers(IResource project) {
-		try {
-			project.deleteMarkers(EXTERNALMARKER_TYPE, true, IResource.DEPTH_INFINITE);
-		} catch (CoreException e) {
-		}
-	}
-	/**
-	 * Returns this plug-in's template store.
-	 * 
-	 * @return the template store of this plug-in instance
-	 */
-	public TemplateStore getTemplateStore() {
-		if (templateStore == null) {
-			templateStore= new ContributionTemplateStore(getContextTypeRegistry(), getPlugin().getPreferenceStore(), CUSTTOM_TEMPLATES_PREFERENCE_NAME);
-			try {
-				templateStore.load();
-			} catch (IOException e) {
-				getPlugin().getLog().log(new Status(IStatus.ERROR, "net.sourceforge.veditor", IStatus.OK, "", e)); //$NON-NLS-1$ //$NON-NLS-2$
-			}
-		}
-		return templateStore;
-	}
-
-	/**
-	 * Returns this plug-in's context type registry.
-	 * 
-	 * @return the context type registry for this plug-in instance
-	 */
-	public ContextTypeRegistry getContextTypeRegistry() {
-		if (contextTypeRegistry == null) {
-			// create an configure the contexts available in the template editor
-			contextTypeRegistry= new ContributionContextTypeRegistry();
-
-			contextTypeRegistry.addContextType( VhdlNewFileContext.CONTEXT_TYPE );
-			contextTypeRegistry.addContextType( VerilogNewFileContext.CONTEXT_TYPE );
-			contextTypeRegistry.addContextType(VhdlGlobalContext.CONTEXT_TYPE);
-			contextTypeRegistry.addContextType(VerilogInStatementContextType.CONTEXT_TYPE);
-			contextTypeRegistry.addContextType(VerilogInModuleContextType.CONTEXT_TYPE);
-			contextTypeRegistry.addContextType(VerilogOutModuleContextType.CONTEXT_TYPE);
-		}
-		return contextTypeRegistry;
-	}
-	
-	/**
-	 * Aligns a string on the given character
-	 * @param s The string to align
-	 * @param c Character to align on
-	 * @param count nth occurrence of the character
-	 * @return The aligned string
-	 */
-	public static String alignOnChar(String s,char c,int count){
-		String lines[]=s.split("\n");
-		String results="";
-		int maxOffset=0,index,index_count;
-		
-		//find the offset the of character
-		for(int nLine=0; nLine < lines.length;nLine++){
-			index=0;
-			index_count=0;
-			//search for the Nth occurrence
-			while(index !=-1 && index_count < count){
-				index=lines[nLine].indexOf(c, index);
-				index_count++;
-			}
-			if(index > maxOffset){
-				maxOffset=index;
-			}
-		}
-		//now align
-		for(int nLine=0; nLine < lines.length;nLine++){				
-			index=0;
-			index_count=0;
-			//search for the Nth occurrence
-			while(index !=-1 && index_count < count){
-				index=lines[nLine].indexOf(c, index);
-				index_count++;
-			}
-			if(index != -1){
-				String padding="";
-				for(int j=index;j<maxOffset;j++){
-					padding+=" ";
-				}
-				lines[nLine]=lines[nLine].substring(0, index) + 
-						     padding + 
-						     lines[nLine].substring(index, lines[nLine].length());
-			}
-		}
-		//assemble the lines
-		for(int nLine=0; nLine < lines.length;nLine++){
-			results+=lines[nLine]+"\n";
-		}
-		return results;
-	}
-
-	public static String getIndentationString() {
-		String indentationstring = "";
-		if (VerilogPlugin.getPreferenceString("Style.indent").equals("Tab"))
-			indentationstring = "\t";
-		else
-		{
-			int size = Integer.parseInt(VerilogPlugin.getPreferenceString("Style.indentSize"));
-			for(int i=0;i<size;i++){
-				indentationstring+=" ";
-			}		
-		}
-		return indentationstring;
-	}
-}
-
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+
+package com.elphel.vdt.veditor;
+
+
+import java.io.File;
+import java.net.URL;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.regex.Pattern;
+
+import com.elphel.vdt.VDT;
+import com.elphel.vdt.core.launching.VDTErrorParser;
+import com.elphel.vdt.ui.MessageUI;
+import com.elphel.vdt.veditor.preference.PreferenceStrings;
+import com.elphel.vdt.veditor.templates.VerilogInModuleContextType;
+import com.elphel.vdt.veditor.templates.VerilogInStatementContextType;
+import com.elphel.vdt.veditor.templates.VerilogNewFileContext;
+import com.elphel.vdt.veditor.templates.VerilogOutModuleContextType;
+import com.elphel.vdt.veditor.templates.VhdlGlobalContext;
+import com.elphel.vdt.veditor.templates.VhdlNewFileContext;
+
+import org.eclipse.core.resources.IMarker;
+import org.eclipse.core.resources.IResource;
+import org.eclipse.core.resources.IWorkspace;
+import org.eclipse.core.resources.ResourcesPlugin;
+import org.eclipse.core.runtime.CoreException;
+import org.eclipse.core.runtime.FileLocator;
+import org.eclipse.core.runtime.IStatus;
+//import org.eclipse.core.runtime.Platform;
+import org.eclipse.core.runtime.QualifiedName;
+import org.eclipse.core.runtime.Status;
+import org.eclipse.jface.preference.IPreferenceStore;
+import org.eclipse.jface.preference.PreferenceConverter;
+import org.eclipse.jface.resource.ImageDescriptor;
+import org.eclipse.jface.resource.ImageRegistry;
+import org.eclipse.jface.text.templates.ContextTypeRegistry;
+import org.eclipse.jface.text.templates.persistence.TemplateStore;
+import org.eclipse.swt.graphics.Image;
+import org.eclipse.swt.graphics.RGB;
+import org.eclipse.swt.widgets.Display;
+import org.eclipse.swt.widgets.Shell;
+import org.eclipse.ui.IWorkbenchWindow;
+import org.eclipse.ui.PlatformUI;
+import org.eclipse.ui.console.ConsolePlugin;
+import org.eclipse.ui.console.IConsole;
+import org.eclipse.ui.console.IConsoleManager;
+import org.eclipse.ui.console.IPatternMatchListener;
+import org.eclipse.ui.console.MessageConsole;
+import org.eclipse.ui.console.MessageConsoleStream;
+import org.eclipse.ui.editors.text.templates.ContributionContextTypeRegistry;
+import org.eclipse.ui.editors.text.templates.ContributionTemplateStore;
+import org.eclipse.ui.plugin.AbstractUIPlugin;
+import org.eclipse.ui.texteditor.MarkerUtilities;
+
+
+/**
+ * The main plugin class
+ */
+public class VerilogPlugin extends AbstractUIPlugin
+{
+	private static final String CONSOLE_NAME = "VDT Plug-in";
+	private static VerilogPlugin plugin;
+	private static final String INTERNALMARKER_TYPE = "org.eclipse.core.resources.problemmarker";
+	private static final String EXTERNALMARKER_TYPE = "com.elphel.vdt.veditor.builderproblemmarker";
+	private static final String AUTO_TASK_MARKER = "com.elphel.vdt.veditor.autotaskmarker";
+	private static final String OUTLINE_DATABASE_ID = "OutlineDatabase";
+	private static final String COLLAPSIBLE_PROPERTY_ID = "collapsible";
+	private static final String HIERARCHY_ID = "Hierarchy";
+	private static final String CUSTTOM_TEMPLATES_PREFERENCE_NAME = "com.elphel.vdt.veditor.templatesStore";	
+	protected TemplateStore templateStore;
+	protected ContributionContextTypeRegistry contextTypeRegistry;
+	public static final String ID="com.elphel.vdt.veditor";
+	private static final String HDL_DOCUMENT_ID = "HdlDocument";
+
+	private static String installLocation; // From VDT 
+	
+	public VerilogPlugin()
+	{
+		super();
+		plugin = this;		
+		templateStore=null;
+		contextTypeRegistry=null;
+	}
+	
+	public static VDTErrorParser vdtErrorParser= new VDTErrorParser();
+	public static VDTErrorParser getVDTErrorParser(){
+		return vdtErrorParser;
+	}
+	
+	
+/* methods copied from VDT */
+    public static String getVdtId() {
+        return VDT.ID_VDT;
+    }
+
+   /**
+     * Returns the standard display to be used. The method first checks, if
+     * the thread calling this method has an associated display. If so, this
+     * display is returned. Otherwise the method returns the default display.
+     */
+    public static Display getStandardDisplay() {
+        Display display = Display.getCurrent();
+        if (display == null) {
+            display = Display.getDefault();
+        }
+        return display;
+    }
+	
+    /**
+     * Returns the shared instance.
+     */
+	
+	public static VerilogPlugin getDefault() {
+		return plugin;
+	}
+
+	public static IWorkbenchWindow getActiveWorkbenchWindow() {
+        IWorkbenchWindow window = getDefault().getWorkbench().getActiveWorkbenchWindow();
+        if (window == null)
+            window = PlatformUI.getWorkbench().getActiveWorkbenchWindow();          
+        return window;
+    }
+	
+    public static Shell getActiveWorkbenchShell() {
+        IWorkbenchWindow window = getActiveWorkbenchWindow();
+        if (window != null) {
+            return window.getShell();
+        }
+        return null;
+    }
+    /**
+     * Show message in console view
+     */
+    public static void print(String msg) {
+        MessageConsoleStream out = findConsole(CONSOLE_NAME).newMessageStream();
+        out.print(msg);
+    }
+    
+    public static void clearConsole() {
+        findConsole(CONSOLE_NAME).clearConsole();
+    }
+
+    public static String getInstallLocation() {
+        if (installLocation == null) {
+            installLocation = getLocation("/").getAbsolutePath();
+        }
+        return installLocation;    
+    }
+    public static File getLocation(String pluginRelativePath) {
+        URL url = plugin.getBundle().getEntry(pluginRelativePath);
+        
+        try {
+//            url = Platform.asLocalURL(url);
+            url = FileLocator.toFileURL(url);
+        } catch (IOException e) {
+            MessageUI.error(e);
+        }
+        
+        return new File(url.getFile());
+    } // getLocation()
+   
+	
+	/* ENDOF methods copied from VDT */	
+	
+	/**
+	 * Returns the shared instance.
+	 */
+	public static VerilogPlugin getPlugin()
+	{
+		return plugin;
+	}
+	/**
+	 * 
+	 * @return Database Outline id
+	 */
+	public static QualifiedName getOutlineDatabaseId(){
+		return new QualifiedName(ID,OUTLINE_DATABASE_ID);
+	}
+	public static QualifiedName getCollapsibleId(){
+		return new QualifiedName(ID,COLLAPSIBLE_PROPERTY_ID);
+	}
+	public static QualifiedName getHierarchyId(){
+		return new QualifiedName(ID,HIERARCHY_ID);
+	}
+	public static QualifiedName getHdlDocumentId(){
+		return new QualifiedName(ID,HDL_DOCUMENT_ID);
+	}
+
+	/**
+	 * Returns PreferenceStore
+	 */
+	public static IPreferenceStore getStore()
+	{
+		return getPlugin().getPreferenceStore();
+	}
+	
+	/**
+	 * Gets the image descriptor for a given image name
+	 * @param imageName image file name
+	 * @return Image descriptor 
+	 */
+	public ImageDescriptor getImageDescriptor(String imageName){
+		return VerilogPlugin.imageDescriptorFromPlugin(	VerilogPlugin.ID, imageName);
+	}
+	/** 
+	 * Returns an image from the registery
+	 * @param imageName the name of the image file
+	 */
+	public Image getImage(String imageName) {
+		VerilogPlugin plugin = VerilogPlugin.getPlugin();
+		ImageRegistry registry = plugin.getImageRegistry();
+		Image results = null;
+
+		results = registry.get(imageName);
+		results = registry.get(imageName);
+		if (results == null) {
+			ImageDescriptor desc = getImageDescriptor(imageName);
+			registry.put(imageName, desc);
+			results = registry.get(imageName);
+		}		
+		return results;
+	}
+	
+	/**
+	 * Returns the workspace instance.
+	 */
+	public static IWorkspace getWorkspace()
+	{
+		return ResourcesPlugin.getWorkspace();
+	}
+
+	/**
+	 * Returns the string from the plugin preferences
+	 */
+	public static String getPreferenceString(String key)
+	{		
+		if ( getStore().contains(key) ){
+			return getStore().getString(key);
+		}
+		else{
+			return getStore().getDefaultString(key);
+		}
+	}
+
+	/**
+	 * Returns int from the plugin preferences
+	 */
+	public static int getPreferenceInt(String key)
+	{
+		if ( getStore().contains(key) ){
+			return getStore().getInt(key);
+		}
+		else{
+			return getStore().getDefaultInt(key);
+		}
+	}
+
+	
+	/**
+	 * Returns the string from the plugin preferences
+	 */
+	public static boolean getPreferenceBoolean(String key)
+	{
+		if ( getStore().contains(key) ){
+			return getStore().getBoolean(key);
+		}
+		else{
+			return getStore().getDefaultBoolean(key);
+		}
+	}
+	
+	/**
+	 * Returns the RGB from the plugin preferences
+	 */
+	public static RGB getPreferenceColor(String key)
+	{
+		return PreferenceConverter.getColor(getStore(), key);
+	}
+	
+	/**
+	 * Returns the string list separated by "\n" from the plugin preferences
+	 */
+	public static List<String> getPreferenceStrings(String key)
+	{
+		String string = getPreferenceString(key);
+		if (string == null)
+			return null;
+
+		int index = string.indexOf('\n');
+		if (index >= 0)
+		{
+			// check version number
+			if (!string.substring(0, index).equals("1"))
+				return null;
+		}
+	
+		List<String> list = new ArrayList<String>();
+		int length = string.length();
+		while(index >= 0 && index < length - 1)
+		{
+			int next = string.indexOf('\n', index + 1);
+			if (next >= 0)
+			{
+				list.add(string.substring(index + 1, next));
+			}
+			index = next;
+		}
+		return list;
+	}
+	
+	/**
+	 * set the string to the plugin preferences
+	 */
+	public static void setPreference(String key, String value)
+	{
+		getStore().setValue(key, value);
+	}
+
+	/**
+	 * set the string to the plugin preferences
+	 */
+	public static void setPreference(String key, boolean value)
+	{
+		getStore().setValue(key, value);
+	}
+	
+	/**
+	 * set the RGB to the plugin preferences
+	 */
+	public static void setPreference(String key, RGB rgb)
+	{
+		PreferenceConverter.setValue(getStore(), key, rgb);
+	}
+	
+	/**
+	 * set the string list separated by "\n"
+	 */
+	public static void setPreference(String key, List<String> list)
+	{
+		StringBuffer value = new StringBuffer("1\n");
+		Iterator<String> i = list.iterator();
+		while(i.hasNext())
+		{
+			value.append(i.next().toString());
+			value.append("\n");
+		}
+		setPreference(key, value.toString());
+	}
+	
+	/**
+	 * initialize default
+	 */
+	public static void setDefaultPreference(String key)
+	{
+		getStore().setToDefault(key);
+	}
+
+	/**
+	 * Show message in console view
+	 */
+	public static void println(String msg)
+	{
+		MessageConsoleStream out = findConsole(CONSOLE_NAME).newMessageStream();
+		out.println(msg);
+	}
+	
+	/**
+	 * FIXME:
+	 * I cannot use clearConsole!
+	 * When clearConsole is called, println is ignored
+	 */
+	public static void clear()
+	{
+		findConsole(CONSOLE_NAME).clearConsole();
+	}
+	
+	private static MessageConsole findConsole(String name)
+	{
+		IConsoleManager man = ConsolePlugin.getDefault().getConsoleManager();
+		IConsole[] consoles = man.getConsoles();
+		for (int i = 0; i < consoles.length; i++)
+		{
+			if (consoles[i].getName().equals(name))
+				return (MessageConsole)consoles[i];
+		}
+
+		// if not exists, add new console
+		MessageConsole newConsole = new MessageConsole(name, null);
+		man.addConsoles(new IConsole[]{newConsole});
+		return newConsole;
+	}
+	
+	public static void removePatternMatchListener(IPatternMatchListener list) {
+		findConsole(CONSOLE_NAME).removePatternMatchListener(list);
+	}
+	
+	public static void addPatternMatchListener(IPatternMatchListener list) {
+		findConsole(CONSOLE_NAME).addPatternMatchListener(list);
+	}
+	
+
+	public static void setErrorMarker(IResource file, int lineNumber, String msg)
+	{
+		setProblemMarker(file, IMarker.SEVERITY_ERROR, lineNumber, msg);
+	}
+
+	public static void setWarningMarker(IResource file, int lineNumber,
+			String msg)
+	{
+		if (getPreferenceBoolean("Warning"))
+			setProblemMarker(file, IMarker.SEVERITY_WARNING, lineNumber, msg);
+	}
+
+	public static void setInfoMarker(IResource file, int lineNumber, String msg)
+	{
+		setProblemMarker(file, IMarker.SEVERITY_INFO, lineNumber, msg);
+	}
+
+	public static void setErrorMarker(IResource file, int lineNumber, int startPos, int endPos, String msg)
+	{
+		setProblemMarker(file, IMarker.SEVERITY_ERROR, lineNumber, startPos, endPos, msg);
+	}
+
+	public static void setWarningMarker(IResource file, int lineNumber, int startPos, int endPos,
+			String msg)
+	{
+		if (getPreferenceBoolean("Warning"))
+			setProblemMarker(file, IMarker.SEVERITY_WARNING, lineNumber, startPos, endPos, msg);
+	}
+
+	public static void setInfoMarker(IResource file, int lineNumber, int startPos, int endPos, String msg)
+	{
+		setProblemMarker(file, IMarker.SEVERITY_INFO, lineNumber, startPos, endPos, msg);
+	}
+	
+	
+	/**
+	 * Creates a task marker
+	 * @param file The resource that needs the task added
+	 * @param lineNumber The line number of the task
+	 * @param msg Task message
+	 */
+	public static void setTaskMarker(IResource file,int lineNumber,String msg,int priority){
+	    //if there's already a marker at this location, remove it
+	    clearAutoTaskMarker(file,lineNumber);
+	    try {
+            IMarker marker = createAutoMarker(file);
+            marker.setAttribute(IMarker.MESSAGE, msg);
+            marker.setAttribute(IMarker.LINE_NUMBER, lineNumber);
+            marker.setAttribute(IMarker.PRIORITY,priority);
+            marker.setAttribute(IMarker.USER_EDITABLE, false);
+        } catch (CoreException e) {           
+            e.printStackTrace();
+        }
+	    
+	}
+	
+	public static IMarker createAutoMarker(IResource file){
+	    try {
+	         IMarker marker = file.createMarker(AUTO_TASK_MARKER);
+	         return marker;
+	      } catch (CoreException e) {
+	         // You need to handle the cases where attribute value is rejected
+	          e.printStackTrace();
+	      }
+	      return null;
+	}
+	/**
+	 * Removes a task marker from the given file and line number
+	 * @param file The resource that has the task in it
+	 * @param lineNumber The line number of the task
+	 */
+	public static void clearAutoTaskMarker(IResource file,int lineNumber){
+	    IMarker[] markers;
+        try {
+            markers = file.findMarkers(AUTO_TASK_MARKER, true, IResource.DEPTH_INFINITE);
+            for (int i = 0; i < markers.length; i++){                
+                Integer tempLineNumber = (Integer)markers[i].getAttribute(IMarker.LINE_NUMBER);
+                //if the line numbers match, remove the marker
+                if(tempLineNumber == lineNumber){
+                    markers[i].delete();
+                    break;
+                }
+            }
+                
+        } catch (CoreException e) {           
+            e.printStackTrace();
+        }
+        
+	}
+	
+	/**
+	 * Removes all the tasks from the file
+	 * @param file The file to remove the tasks from
+	 */
+	public static void clearAllAutoTaskMarkers(IResource file){
+	    IMarker [] markers;
+        try {
+            markers = file.findMarkers(AUTO_TASK_MARKER, false, IResource.DEPTH_INFINITE);
+            for (int i = 0; i < markers.length; i++){        
+                markers[i].delete();       
+                
+            }                
+        } catch (CoreException e) {           
+            e.printStackTrace();
+        }
+	}
+
+	public static void setProblemMarker(IResource file, int level,
+			int lineNumber, String msg)
+	{
+		setProblemMarker(file, level,lineNumber, -1, -1,  msg);
+	}
+
+	public static void setProblemMarker(IResource file, int level,
+			int lineNumber, int startPos, int endPos, String msg)
+	{
+		if (filterMarkes(file,false)) return;
+		HashMap<String,Object> map = new HashMap<String,Object>();
+		MarkerUtilities.setLineNumber(map, lineNumber);
+		if (startPos>0) MarkerUtilities.setCharStart(map,startPos);
+		if (endPos>0) MarkerUtilities.setCharEnd  (map,endPos);
+		MarkerUtilities.setMessage  (map,msg);
+		map.put(IMarker.SEVERITY, new Integer(level));
+		try {
+			MarkerUtilities.createMarker(file,map,INTERNALMARKER_TYPE);
+		} catch (CoreException e){
+		}
+/*
+These attributes must exist when the marker is created for the marker to appear in an editor.
+The most common mistake is to create the marker and then add the attributes in a separate operation. 		
+*/
+	}
+	/**
+	 * Do not show problems in filtered libraries, when filter is enabled
+	 * The same filter is set for in Hierarchy view and may be toggled 
+	 * by a button there 
+	 * @param file File to consider
+	 * @return true if the file should be excluded from markers, false - markers stay
+	 */
+	public static boolean filterMarkes(IResource file, boolean alwaysFilter)	{
+		if (alwaysFilter || VerilogPlugin.getPreferenceBoolean(PreferenceStrings.TOP_DIR_ONLY)) {
+			try {
+				Pattern pattern=Pattern.compile(VerilogPlugin.getPreferenceString(PreferenceStrings.EXCLUDE_DIRS_REGEX));
+				if (pattern.matcher(file.toString()).find()) return true;
+			} catch (Exception e){
+				return false; // Bad pattern, show problems in all files
+			}
+		}
+		return false;
+	}
+	
+	
+	public static void setExternalProblemMarker(IResource file, int level,
+			int lineNumber, String msg)
+	{
+		setExternalProblemMarker(file,level, lineNumber, -1, -1, msg);
+	}
+
+	public static void setExternalProblemMarker(IResource file, int level,
+			int lineNumber, int startPos, int endPos, String msg)
+	{
+/*		try
+		{
+			IMarker marker = file.createMarker(EXTERNALMARKER_TYPE);
+			marker.setAttribute(IMarker.SEVERITY, level);
+			marker.setAttribute(IMarker.LINE_NUMBER, lineNumber);
+			marker.setAttribute(IMarker.MESSAGE, msg);
+			marker.setAttribute(IMarker.CHAR_START,startPos);
+			marker.setAttribute(IMarker.CHAR_END,endPos);
+		}
+		catch (CoreException e)
+		{
+		}
+*/		
+//		if (filterMarkes(file,false)) return;
+		HashMap<String,Object> map = new HashMap<String,Object>();
+		MarkerUtilities.setLineNumber(map, lineNumber);
+		if (startPos>0) MarkerUtilities.setCharStart(map,startPos);
+		if (endPos>0) MarkerUtilities.setCharEnd  (map,endPos);
+		MarkerUtilities.setMessage  (map,msg);
+		map.put(IMarker.SEVERITY, new Integer(level));
+		try {
+			MarkerUtilities.createMarker(file,map,EXTERNALMARKER_TYPE);  /* Applies error markers to a file */
+		} catch (CoreException e){
+		}
+//}		
+	}
+	
+	public static void deleteMarkers(IResource project) {
+		try {
+			project.deleteMarkers(INTERNALMARKER_TYPE, true, IResource.DEPTH_INFINITE);
+		} catch (CoreException e) {
+		}
+	}
+
+	public static void deleteExternalMarkers(IResource project) {
+		try {
+			project.deleteMarkers(EXTERNALMARKER_TYPE, true, IResource.DEPTH_INFINITE);
+		} catch (CoreException e) {
+		}
+	}
+	/**
+	 * Returns this plug-in's template store.
+	 * 
+	 * @return the template store of this plug-in instance
+	 */
+	public TemplateStore getTemplateStore() {
+		if (templateStore == null) {
+			templateStore= new ContributionTemplateStore(getContextTypeRegistry(), getPlugin().getPreferenceStore(), CUSTTOM_TEMPLATES_PREFERENCE_NAME);
+			try {
+				templateStore.load();
+			} catch (IOException e) {
+				getPlugin().getLog().log(new Status(IStatus.ERROR, "com.elphel.vdt.veditor", IStatus.OK, "", e)); //$NON-NLS-1$ //$NON-NLS-2$
+			}
+		}
+		return templateStore;
+	}
+
+	/**
+	 * Returns this plug-in's context type registry.
+	 * 
+	 * @return the context type registry for this plug-in instance
+	 */
+	public ContextTypeRegistry getContextTypeRegistry() {
+		if (contextTypeRegistry == null) {
+			// create an configure the contexts available in the template editor
+			contextTypeRegistry= new ContributionContextTypeRegistry();
+
+			contextTypeRegistry.addContextType( VhdlNewFileContext.CONTEXT_TYPE );
+			contextTypeRegistry.addContextType( VerilogNewFileContext.CONTEXT_TYPE );
+			contextTypeRegistry.addContextType(VhdlGlobalContext.CONTEXT_TYPE);
+			contextTypeRegistry.addContextType(VerilogInStatementContextType.CONTEXT_TYPE);
+			contextTypeRegistry.addContextType(VerilogInModuleContextType.CONTEXT_TYPE);
+			contextTypeRegistry.addContextType(VerilogOutModuleContextType.CONTEXT_TYPE);
+		}
+		return contextTypeRegistry;
+	}
+	
+	/**
+	 * Aligns a string on the given character
+	 * @param s The string to align
+	 * @param c Character to align on
+	 * @param count nth occurrence of the character
+	 * @return The aligned string
+	 */
+	public static String alignOnChar(String s,char c,int count){
+		String lines[]=s.split("\n");
+		String results="";
+		int maxOffset=0,index,index_count;
+		
+		//find the offset the of character
+		for(int nLine=0; nLine < lines.length;nLine++){
+			index=0;
+			index_count=0;
+			//search for the Nth occurrence
+			while(index !=-1 && index_count < count){
+				index=lines[nLine].indexOf(c, index);
+				index_count++;
+			}
+			if(index > maxOffset){
+				maxOffset=index;
+			}
+		}
+		//now align
+		for(int nLine=0; nLine < lines.length;nLine++){				
+			index=0;
+			index_count=0;
+			//search for the Nth occurrence
+			while(index !=-1 && index_count < count){
+				index=lines[nLine].indexOf(c, index);
+				index_count++;
+			}
+			if(index != -1){
+				String padding="";
+				for(int j=index;j<maxOffset;j++){
+					padding+=" ";
+				}
+				lines[nLine]=lines[nLine].substring(0, index) + 
+						     padding + 
+						     lines[nLine].substring(index, lines[nLine].length());
+			}
+		}
+		//assemble the lines
+		for(int nLine=0; nLine < lines.length;nLine++){
+			results+=lines[nLine]+"\n";
+		}
+		return results;
+	}
+
+	public static String getIndentationString() {
+		String indentationstring = "";
+		if (VerilogPlugin.getPreferenceString("Style.indent").equals("Tab"))
+			indentationstring = "\t";
+		else
+		{
+			int size = Integer.parseInt(VerilogPlugin.getPreferenceString("Style.indentSize"));
+			for(int i=0;i<size;i++){
+				indentationstring+=" ";
+			}		
+		}
+		return indentationstring;
+	}
+}
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/wizard/NewHdlWizard.java vdt/src/com/elphel/vdt/veditor/wizard/NewHdlWizard.java
--- vdt-veditor/src/com/elphel/vdt/veditor/wizard/NewHdlWizard.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/wizard/NewHdlWizard.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,179 +1,190 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-
-package net.sourceforge.veditor.wizard;
-
-import org.eclipse.jface.viewers.IStructuredSelection;
-import org.eclipse.jface.wizard.Wizard;
-import org.eclipse.ui.INewWizard;
-import org.eclipse.ui.IWorkbench;
-import org.eclipse.core.runtime.*;
-import org.eclipse.jface.operation.*;
-import java.lang.reflect.InvocationTargetException;
-import org.eclipse.jface.dialogs.MessageDialog;
-import org.eclipse.jface.viewers.ISelection;
-import org.eclipse.core.resources.*;
-import org.eclipse.core.runtime.CoreException;
-import java.io.*;
-import org.eclipse.ui.*;
-import org.eclipse.ui.ide.IDE;
-
-abstract public class NewHdlWizard extends Wizard implements INewWizard
-{
-	private NewHdlWizardPage page;
-
-	private ISelection selection;
-
-	public NewHdlWizard()
-	{
-		super();
-		setNeedsProgressMonitor(true);
-	}
-
-	public void addPages(String extension)
-	{
-		page = new NewHdlWizardPage(selection, extension);
-		addPage(page);
-	}
-
-	public boolean performFinish()
-	{
-		final String containerName = page.getContainerName();
-		final String moduleName = page.getModuleName();
-		final String fileName = page.getFileName();
-		final String brief = page.getBrief();
-		final String template = page.getTemplatePattern();
-
-		IRunnableWithProgress op = new IRunnableWithProgress()
-		{
-			public void run(IProgressMonitor monitor)
-					throws InvocationTargetException
-			{
-				try
-				{
-					doFinish( template, containerName, moduleName, brief, fileName, monitor );					
-
-				}
-				catch (CoreException e)
-				{
-					throw new InvocationTargetException(e);
-				}
-				finally
-				{
-					monitor.done();
-				}
-			}
-		};
-		try
-		{
-			getContainer().run(true, false, op);
-		}
-		catch (InterruptedException e)
-		{
-			return false;
-		}
-		catch (InvocationTargetException e)
-		{
-			Throwable realException = e.getTargetException();
-			MessageDialog.openError(getShell(), "Error", realException
-					.getMessage());
-			return false;
-		}
-		return true;
-	}
-	
-//	private void doFinish(String containerName, String moduleName,
-//			String fileName, IProgressMonitor monitor) throws CoreException
-	//mg
-	private void doFinish( final String template, final String containerName, final String moduleName, final String brief,
-			final String fileName, final IProgressMonitor monitor ) throws CoreException
-	//mg--------------------------
-	{
-		monitor.beginTask("Creating " + fileName, 2);
-
-		// check folder
-		IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();
-		IResource resource = root.findMember(new Path(containerName));
-		if (!resource.exists() || !(resource instanceof IContainer))
-		{
-			throwCoreException("Container " + containerName
-					+ " does not exist.");
-		}
-		IContainer container = (IContainer) resource;
-
-		// create file
-		final IFile file = container.getFile(new Path(fileName));
-		if (file.exists())
-		{
-			throwCoreException("File " + fileName + " already exists.");
-		}
-		try
-		{
-//			InputStream stream = openContentStream(moduleName);
-			//mg
-			final InputStream stream = openContentStream( template, moduleName, brief );
-			//mg------------------
-			file.create(stream, true, monitor);
-			stream.close();
-		}
-		catch (IOException e)
-		{
-		}
-		monitor.worked(1);
-		
-		monitor.setTaskName("Opening file for editing...");
-		getShell().getDisplay().asyncExec(new Runnable()
-		{
-			public void run()
-			{
-				IWorkbenchPage page = PlatformUI.getWorkbench()
-						.getActiveWorkbenchWindow().getActivePage();
-				try
-				{
-					IDE.openEditor(page, file, true);
-				}
-				catch (PartInitException e)
-				{
-				}
-			}
-		});
-		monitor.worked(2);
-	}
-	
-
-	private InputStream openContentStream( final String template, final String moduleName, final String brief ) {
-
-		String contents = getInitialContents( template, moduleName, brief );
-
-		return new ByteArrayInputStream(contents.getBytes());
-	}
-	
-	abstract String getInitialContents( String templatePattern, String moduleName, String brief );
-
-	private void throwCoreException(String message) throws CoreException
-	{
-		IStatus status = new Status(IStatus.ERROR, "Verilog/VHDL", IStatus.OK,
-				message, null);
-		throw new CoreException(status);
-	}
-
-	public void init(IWorkbench workbench, IStructuredSelection selection)
-	{
-		this.selection = selection;
-	}
-}
-
-
-
-
-
-
-
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+
+package com.elphel.vdt.veditor.wizard;
+
+import org.eclipse.jface.viewers.IStructuredSelection;
+import org.eclipse.jface.wizard.Wizard;
+import org.eclipse.ui.INewWizard;
+import org.eclipse.ui.IWorkbench;
+import org.eclipse.core.runtime.*;
+import org.eclipse.jface.operation.*;
+import java.lang.reflect.InvocationTargetException;
+import org.eclipse.jface.dialogs.MessageDialog;
+import org.eclipse.jface.viewers.ISelection;
+import org.eclipse.core.resources.*;
+import org.eclipse.core.runtime.CoreException;
+import java.io.*;
+import org.eclipse.ui.*;
+import org.eclipse.ui.ide.IDE;
+
+abstract public class NewHdlWizard extends Wizard implements INewWizard
+{
+	private NewHdlWizardPage page;
+
+	private ISelection selection;
+
+	public NewHdlWizard()
+	{
+		super();
+		setNeedsProgressMonitor(true);
+	}
+
+	public void addPages(String extension)
+	{
+		page = new NewHdlWizardPage(selection, extension);
+		addPage(page);
+	}
+
+	public boolean performFinish()
+	{
+		final String containerName = page.getContainerName();
+		final String moduleName = page.getModuleName();
+		final String fileName = page.getFileName();
+		final String brief = page.getBrief();
+		final String template = page.getTemplatePattern();
+
+		IRunnableWithProgress op = new IRunnableWithProgress()
+		{
+			public void run(IProgressMonitor monitor)
+					throws InvocationTargetException
+			{
+				try
+				{
+					doFinish( template, containerName, moduleName, brief, fileName, monitor );					
+
+				}
+				catch (CoreException e)
+				{
+					throw new InvocationTargetException(e);
+				}
+				finally
+				{
+					monitor.done();
+				}
+			}
+		};
+		try
+		{
+			getContainer().run(true, false, op);
+		}
+		catch (InterruptedException e)
+		{
+			return false;
+		}
+		catch (InvocationTargetException e)
+		{
+			Throwable realException = e.getTargetException();
+			MessageDialog.openError(getShell(), "Error", realException
+					.getMessage());
+			return false;
+		}
+		return true;
+	}
+	
+//	private void doFinish(String containerName, String moduleName,
+//			String fileName, IProgressMonitor monitor) throws CoreException
+	//mg
+	private void doFinish( final String template, final String containerName, final String moduleName, final String brief,
+			final String fileName, final IProgressMonitor monitor ) throws CoreException
+	//mg--------------------------
+	{
+		monitor.beginTask("Creating " + fileName, 2);
+
+		// check folder
+		IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();
+		IResource resource = root.findMember(new Path(containerName));
+		if (!resource.exists() || !(resource instanceof IContainer))
+		{
+			throwCoreException("Container " + containerName
+					+ " does not exist.");
+		}
+		IContainer container = (IContainer) resource;
+
+		// create file
+		final IFile file = container.getFile(new Path(fileName));
+		if (file.exists())
+		{
+			throwCoreException("File " + fileName + " already exists.");
+		}
+		try
+		{
+//			InputStream stream = openContentStream(moduleName);
+			//mg
+			final InputStream stream = openContentStream( template, moduleName, brief );
+			//mg------------------
+			file.create(stream, true, monitor);
+			stream.close();
+		}
+		catch (IOException e)
+		{
+		}
+		monitor.worked(1);
+		
+		monitor.setTaskName("Opening file for editing...");
+		getShell().getDisplay().asyncExec(new Runnable()
+		{
+			public void run()
+			{
+				IWorkbenchPage page = PlatformUI.getWorkbench()
+						.getActiveWorkbenchWindow().getActivePage();
+				try
+				{
+					IDE.openEditor(page, file, true);
+				}
+				catch (PartInitException e)
+				{
+				}
+			}
+		});
+		monitor.worked(2);
+	}
+	
+
+	private InputStream openContentStream( final String template, final String moduleName, final String brief ) {
+
+		String contents = getInitialContents( template, moduleName, brief );
+
+		return new ByteArrayInputStream(contents.getBytes());
+	}
+	
+	abstract String getInitialContents( String templatePattern, String moduleName, String brief );
+
+	private void throwCoreException(String message) throws CoreException
+	{
+		IStatus status = new Status(IStatus.ERROR, "Verilog/VHDL", IStatus.OK,
+				message, null);
+		throw new CoreException(status);
+	}
+
+	public void init(IWorkbench workbench, IStructuredSelection selection)
+	{
+		this.selection = selection;
+	}
+}
+
+
+
+
+
+
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/wizard/NewHdlWizardPage.java vdt/src/com/elphel/vdt/veditor/wizard/NewHdlWizardPage.java
--- vdt-veditor/src/com/elphel/vdt/veditor/wizard/NewHdlWizardPage.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/wizard/NewHdlWizardPage.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,425 +1,454 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-
-package net.sourceforge.veditor.wizard;
-
-import java.util.LinkedList;
-import java.util.Stack;
-
-import net.sourceforge.veditor.VerilogPlugin;
-import net.sourceforge.veditor.editor.HdlSourceViewerConfiguration;
-import net.sourceforge.veditor.editor.VerilogEditor;
-import net.sourceforge.veditor.editor.VhdlEditor;
-import net.sourceforge.veditor.templates.VerilogNewFileContext;
-import net.sourceforge.veditor.templates.VhdlNewFileContext;
-
-import org.eclipse.core.resources.IContainer;
-import org.eclipse.core.resources.IFile;
-import org.eclipse.core.resources.IResource;
-import org.eclipse.core.resources.ResourcesPlugin;
-import org.eclipse.core.runtime.Path;
-import org.eclipse.jface.text.Document;
-import org.eclipse.jface.text.IDocument;
-import org.eclipse.jface.text.source.SourceViewer;
-import org.eclipse.jface.text.source.SourceViewerConfiguration;
-import org.eclipse.jface.text.templates.Template;
-import org.eclipse.jface.viewers.ISelection;
-import org.eclipse.jface.viewers.IStructuredSelection;
-import org.eclipse.jface.wizard.WizardPage;
-import org.eclipse.swt.SWT;
-import org.eclipse.swt.custom.CCombo;
-import org.eclipse.swt.events.ModifyEvent;
-import org.eclipse.swt.events.ModifyListener;
-import org.eclipse.swt.events.SelectionAdapter;
-import org.eclipse.swt.events.SelectionEvent;
-import org.eclipse.swt.events.SelectionListener;
-import org.eclipse.swt.graphics.Color;
-import org.eclipse.swt.layout.GridData;
-import org.eclipse.swt.layout.GridLayout;
-import org.eclipse.swt.widgets.Button;
-import org.eclipse.swt.widgets.Composite;
-import org.eclipse.swt.widgets.Control;
-import org.eclipse.swt.widgets.Display;
-import org.eclipse.swt.widgets.Label;
-import org.eclipse.swt.widgets.Text;
-import org.eclipse.ui.dialogs.ContainerSelectionDialog;
-
-public class NewHdlWizardPage extends WizardPage
-{
-	private Text containerText;
-	private Text moduleText;
-	private ISelection selection;
-	private String extension;
-	private CCombo				templateCombo;	
-	private Text				briefText;
-	private Text				templateDescription;
-	private SourceViewer		templatePreview;	
-	private LinkedList <Template>	newFileTemplates	= new LinkedList <Template>();
-	private enum LanguageMode {verilog,vhdl};
-	private LanguageMode languageMode;
-
-
-	public NewHdlWizardPage(ISelection selection, String extension)
-	{
-		super("ModuleWizardPage");
-		this.extension = extension;
-		
-		if (extension.equals(".v"))
-		{
-			setTitle("Verilog module");
-			setDescription("Create a new Verilog module.");
-			languageMode=LanguageMode.verilog;
-		}
-		else
-		{
-			setTitle("VHDL entity");
-			setDescription("Create a new VHDL entity.");
-			languageMode=LanguageMode.vhdl;
-		}
-		this.selection = selection;
-	}
-
-	public void createControl(Composite parent)
-	{
-		Composite container = new Composite(parent, SWT.NULL);
-		GridLayout layout = new GridLayout();
-		container.setLayout(layout);
-		layout.numColumns = 3;
-		layout.verticalSpacing = 9;
-
-		containerText = createText(container, "&Folder:");
-		
-		Button button = new Button(container, SWT.PUSH);
-		button.setText("Browse...");
-		button.addSelectionListener(new SelectionAdapter()
-		{
-			public void widgetSelected(SelectionEvent e)
-			{
-				handleBrowse();
-			}
-		});
-
-		moduleText = createText(container,"&Module name:");
-		moduleText.forceFocus();
-		
-		//mg
-		GridData data = new GridData( GridData.GRAB_HORIZONTAL
-				+ GridData.FILL_HORIZONTAL );
-		data.horizontalSpan = 2;
-		data.minimumHeight = 20;		
-		
-		moduleText.setLayoutData( data );
-
-		//brief
-		briefText = createText( container, "&Brief description:" );
-		briefText.setLayoutData( data );
-
-		//template combo	
-		Template[] templates;
-		switch(languageMode){
-		case verilog:
-			templates = VerilogPlugin.getPlugin().getTemplateStore().getTemplates(VerilogNewFileContext.CONTEXT_TYPE);
-			break;
-		default:
-		case vhdl:
-			templates = VerilogPlugin.getPlugin().getTemplateStore().getTemplates(VhdlNewFileContext.CONTEXT_TYPE);
-			break;			
-		}		
-
-		Stack<Template> newFileTemplatesStack = new Stack<Template>();
-
-		for (Template template : templates) {
-			newFileTemplatesStack.add(template);
-		}		
-		
-		while ( !newFileTemplatesStack.isEmpty() ) {
-			newFileTemplates.add( newFileTemplatesStack.pop() );
-		}
-
-		templateCombo = createCombo( container, "Available templates:",
-				newFileTemplates );
-		templateCombo.setLayoutData( data );
-		templateCombo.select( 0 );
-		
-		//template description
-		templateDescription = createText( container, "&Description" );
-		templateDescription.setLayoutData( data );
-		templateDescription.setBackground( new Color( Display.getCurrent(),
-				255, 255, 255 ) );
-		templateDescription.setEditable( false );
-
-		//template preview
-		GridData previewData = new GridData( GridData.GRAB_HORIZONTAL
-				+ GridData.FILL_HORIZONTAL );
-		previewData.horizontalSpan = 3;
-		
-		templatePreview = createEditor( container, "editor" );
-		templatePreview.getTextWidget().setLayoutData( previewData );
-
-		//initialize description and preview
-		try {
-			int templateSelectedIndex = templateCombo.getSelectionIndex();
-			Template templateSelected = newFileTemplates
-					.get( templateSelectedIndex );
-
-			templateDescription.setText( templateSelected.getDescription() );
-			templatePreview.getDocument().set( templateSelected.getPattern() );
-		} catch ( IndexOutOfBoundsException e ) {
-		}
-
-		//mg------------------------
-
-		initialize();
-		setPageComplete(false);
-
-		ModifyTextListner listener = new ModifyTextListner();
-		containerText.addModifyListener(listener);
-		moduleText.addModifyListener(listener);
-
-		//mg
-		briefText.addModifyListener( listener );
-		templateCombo.addSelectionListener( new SelectionListener() {
-
-			public void widgetSelected( SelectionEvent e ) {
-
-				try {
-					final Template templateSelected = getTemplate();
-
-					templateDescription.setText( templateSelected
-							.getDescription() );
-					templatePreview.getDocument().set( templateSelected.getPattern() );
-				} catch ( Exception exception ) {
-				}
-			}
-
-			public void widgetDefaultSelected( SelectionEvent e ) {
-			}
-
-		} );
-		//mg-------------------------
-
-		
-		setControl(container);
-	}
-
-	//mg
-	private CCombo createCombo( final Composite container, final String name,
-			final LinkedList <Template> templates ) {
-		final Label label = new Label( container, SWT.NULL );
-		label.setText( name );
-		final CCombo combo = new CCombo( container, SWT.NONE );
-
-		for ( final Template template : templates ) {
-			combo.add( template.getName() );
-		}
-
-		return combo;
-	}
-	
-	private SourceViewer createEditor(Composite parent, String pattern) {
-		SourceViewer viewer= createViewer(parent);
-		viewer.setEditable(true);
-
-		IDocument document= viewer.getDocument();
-		if (document != null)
-			document.set(pattern);
-		else {
-			document= new Document(pattern);
-			viewer.setDocument(document);
-		}
-
-		int nLines= document.getNumberOfLines();
-		if (nLines < 5) {
-			nLines= 5;
-		} else if (nLines > 12) {
-			nLines= 12;
-		}
-
-		Control control= viewer.getControl();
-		GridData data= new GridData(GridData.FILL_BOTH);
-		data.widthHint= convertWidthInCharsToPixels(80);
-		data.heightHint= convertHeightInCharsToPixels(nLines);
-		control.setLayoutData(data);
-
-		return viewer;
-	}
-	
-	protected SourceViewer createViewer(Composite parent) {
-		SourceViewer viewer= new SourceViewer(parent, null, null, false, SWT.BORDER | SWT.V_SCROLL | SWT.H_SCROLL);
-		SourceViewerConfiguration configuration;
-		
-		switch(languageMode){
-		case verilog:
-			configuration = HdlSourceViewerConfiguration.createForVerilog( new VerilogEditor() );
-			break;
-		default:
-		case vhdl:
-			configuration = HdlSourceViewerConfiguration.createForVhdl( new VhdlEditor() );
-			break;			
-		}		
-		
-		viewer.configure(configuration);
-		return viewer;
-	}
-	
-
-	private Text createText(Composite container, String name)
-	{
-		Label label = new Label(container, SWT.NULL);
-		label.setText(name);
-		Text text = new Text(container, SWT.BORDER | SWT.SINGLE);
-		GridData gd = new GridData(GridData.FILL_HORIZONTAL);
-		text.setLayoutData(gd);
-
-		return text;
-	}
-	
-	private class ModifyTextListner implements ModifyListener
-	{
-		public void modifyText(ModifyEvent e)
-		{
-			dialogChanged();
-		}
-
-		private void dialogChanged()
-		{
-			// check container
-			String containerName = getContainerName();
-			IResource resource = ResourcesPlugin.getWorkspace().getRoot()
-					.findMember(new Path(containerName));
-			if (containerName.length() == 0)
-			{
-				updateStatus("Source folder must be specified");
-				return;
-			}
-			if (resource == null || !resource.exists()
-					|| !(resource instanceof IContainer))
-			{
-				updateStatus("Source folder must exist");
-				return;
-			}
-			if (!resource.isAccessible())
-			{
-				updateStatus("Project must be writable");
-				return;
-			}
-			IContainer container = (IContainer)resource;
-
-			// check module name
-			String moduleName = getModuleName();
-			if (Character.isLetter(moduleName.charAt(0)) == false)
-			{
-				updateStatus("Module/Entity name must start a letter");
-				return;
-			}
-			for (int i = 1; i < moduleName.length(); i++)
-			{
-				if (Character.isJavaIdentifierPart(moduleName.charAt(i)) == false)
-				{
-					updateStatus("Module/Entity name must be identifier");
-					return;
-				}
-			}
-			
-			// check file
-			String fileName = getFileName();
-			IFile file = container.getFile(new Path(fileName));
-			if (file.exists())
-				updateStatus("Module/Entity already exist");
-			else if (moduleName.length() == 0)
-				updateStatus("Module/Entity name must be specified");
-			else if (fileName.replace('\\', '/').indexOf('/', 1) > 0)
-				updateStatus("Module/Entity name must be valid");
-			else
-				updateStatus(null);
-		}
-
-		private void updateStatus(String message)
-		{
-			setErrorMessage(message);
-			setPageComplete(message == null);
-		}
-	}
-
-	private void initialize()
-	{
-		if (selection != null && selection.isEmpty() == false
-				&& selection instanceof IStructuredSelection)
-		{
-			IStructuredSelection ssel = (IStructuredSelection) selection;
-			if (ssel.size() > 1)
-				return;
-			Object obj = ssel.getFirstElement();
-			if (obj instanceof IResource)
-			{
-				IContainer container;
-				if (obj instanceof IContainer)
-					container = (IContainer) obj;
-				else
-					container = ((IResource) obj).getParent();
-				containerText.setText(container.getFullPath().toString());
-			}
-		}
-	}
-
-	private void handleBrowse()
-	{
-		ContainerSelectionDialog dialog = new ContainerSelectionDialog(
-				getShell(), ResourcesPlugin.getWorkspace().getRoot(), false,
-				"Select a source folder");
-		if (dialog.open() == ContainerSelectionDialog.OK)
-		{
-			Object[] result = dialog.getResult();
-			if (result.length == 1)
-			{
-				containerText.setText(((Path) result[0]).toString());
-			}
-		}
-	}
-
-	public String getContainerName()
-	{
-		return containerText.getText();
-	}
-
-	public String getModuleName()
-	{
-		return moduleText.getText();
-	}
-	
-	public String getFileName()
-	{
-		return getModuleName() + extension;
-	}
-	//mg
-	public String getBrief() {
-		return briefText.getText();
-	}
-	
-	public String getTemplatePattern() {
-		return templatePreview.getDocument().get();
-	}
-
-	public Template getTemplate() {
-		int templateSelectedIndex = templateCombo.getSelectionIndex();
-
-		try {
-			return newFileTemplates.get( templateSelectedIndex );
-		} catch ( IndexOutOfBoundsException exception ) {
-			return null;
-		}
-	}
-	//mg----------------------
-
-}
-
-
-
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+
+package com.elphel.vdt.veditor.wizard;
+
+import java.util.LinkedList;
+import java.util.Stack;
+
+import com.elphel.vdt.veditor.VerilogPlugin;
+import com.elphel.vdt.veditor.editor.HdlSourceViewerConfiguration;
+import com.elphel.vdt.veditor.editor.VerilogEditor;
+import com.elphel.vdt.veditor.editor.VhdlEditor;
+import com.elphel.vdt.veditor.templates.VerilogNewFileContext;
+import com.elphel.vdt.veditor.templates.VhdlNewFileContext;
+
+import org.eclipse.core.resources.IContainer;
+import org.eclipse.core.resources.IFile;
+import org.eclipse.core.resources.IResource;
+import org.eclipse.core.resources.ResourcesPlugin;
+import org.eclipse.core.runtime.Path;
+import org.eclipse.jface.text.Document;
+import org.eclipse.jface.text.IDocument;
+import org.eclipse.jface.text.source.SourceViewer;
+import org.eclipse.jface.text.source.SourceViewerConfiguration;
+import org.eclipse.jface.text.templates.Template;
+import org.eclipse.jface.viewers.ISelection;
+import org.eclipse.jface.viewers.IStructuredSelection;
+import org.eclipse.jface.wizard.WizardPage;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.custom.CCombo;
+import org.eclipse.swt.events.ModifyEvent;
+import org.eclipse.swt.events.ModifyListener;
+import org.eclipse.swt.events.SelectionAdapter;
+import org.eclipse.swt.events.SelectionEvent;
+import org.eclipse.swt.events.SelectionListener;
+import org.eclipse.swt.graphics.Color;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Display;
+import org.eclipse.swt.widgets.Label;
+import org.eclipse.swt.widgets.Text;
+import org.eclipse.ui.dialogs.ContainerSelectionDialog;
+
+public class NewHdlWizardPage extends WizardPage
+{
+	private Text containerText;
+	private Text moduleText;
+	private ISelection selection;
+	private String extension;
+	private CCombo				templateCombo;	
+	private Text				briefText;
+	private Text				templateDescription;
+	private SourceViewer		templatePreview;	
+	private LinkedList <Template>	newFileTemplates	= new LinkedList <Template>();
+	private enum LanguageMode {verilog,vhdl};
+	private LanguageMode languageMode;
+
+
+	public NewHdlWizardPage(ISelection selection, String extension)
+	{
+		super("ModuleWizardPage");
+		this.extension = extension;
+		String [] verilogPatterns=VerilogPlugin.getPreferenceString("Verilog.Extensions").split("[\\, ]+");
+		String [] vhdlPatterns=VerilogPlugin.getPreferenceString("VHDL.Extensions").split("[\\, ]+");
+		
+		for (int i=0;i<verilogPatterns.length;i++) if (extension.equals(verilogPatterns[i])){
+			setTitle("Verilog module");
+			setDescription("Create a new Verilog module.");
+			languageMode=LanguageMode.verilog;
+			this.selection = selection;
+			return;
+		}
+		for (int i=0;i<vhdlPatterns.length;i++) if (extension.equals(vhdlPatterns[i])){
+			setTitle("VHDL entity");
+			setDescription("Create a new VHDL entity.");
+			languageMode=LanguageMode.vhdl;
+			this.selection = selection;
+			return;
+		}
+/*		
+		if (extension.equals(".v"))
+		{
+			setTitle("Verilog module");
+			setDescription("Create a new Verilog module.");
+			languageMode=LanguageMode.verilog;
+		}
+		else
+		{
+			setTitle("VHDL entity");
+			setDescription("Create a new VHDL entity.");
+			languageMode=LanguageMode.vhdl;
+		}
+*/		
+		this.selection = selection;
+	}
+
+	public void createControl(Composite parent)
+	{
+		Composite container = new Composite(parent, SWT.NULL);
+		GridLayout layout = new GridLayout();
+		container.setLayout(layout);
+		layout.numColumns = 3;
+		layout.verticalSpacing = 9;
+
+		containerText = createText(container, "&Folder:");
+		
+		Button button = new Button(container, SWT.PUSH);
+		button.setText("Browse...");
+		button.addSelectionListener(new SelectionAdapter()
+		{
+			public void widgetSelected(SelectionEvent e)
+			{
+				handleBrowse();
+			}
+		});
+
+		moduleText = createText(container,"&Module name:");
+		moduleText.forceFocus();
+		
+		//mg
+		GridData data = new GridData( GridData.GRAB_HORIZONTAL
+				+ GridData.FILL_HORIZONTAL );
+		data.horizontalSpan = 2;
+		data.minimumHeight = 20;		
+		
+		moduleText.setLayoutData( data );
+
+		//brief
+		briefText = createText( container, "&Brief description:" );
+		briefText.setLayoutData( data );
+
+		//template combo	
+		Template[] templates;
+		switch(languageMode){
+		case verilog:
+			templates = VerilogPlugin.getPlugin().getTemplateStore().getTemplates(VerilogNewFileContext.CONTEXT_TYPE);
+			break;
+		default:
+		case vhdl:
+			templates = VerilogPlugin.getPlugin().getTemplateStore().getTemplates(VhdlNewFileContext.CONTEXT_TYPE);
+			break;			
+		}		
+
+		Stack<Template> newFileTemplatesStack = new Stack<Template>();
+
+		for (Template template : templates) {
+			newFileTemplatesStack.add(template);
+		}		
+		
+		while ( !newFileTemplatesStack.isEmpty() ) {
+			newFileTemplates.add( newFileTemplatesStack.pop() );
+		}
+
+		templateCombo = createCombo( container, "Available templates:",
+				newFileTemplates );
+		templateCombo.setLayoutData( data );
+		templateCombo.select( 0 );
+		
+		//template description
+		templateDescription = createText( container, "&Description" );
+		templateDescription.setLayoutData( data );
+		templateDescription.setBackground( new Color( Display.getCurrent(),
+				255, 255, 255 ) );
+		templateDescription.setEditable( false );
+
+		//template preview
+		GridData previewData = new GridData( GridData.GRAB_HORIZONTAL
+				+ GridData.FILL_HORIZONTAL );
+		previewData.horizontalSpan = 3;
+		
+		templatePreview = createEditor( container, "editor" );
+		templatePreview.getTextWidget().setLayoutData( previewData );
+
+		//initialize description and preview
+		try {
+			int templateSelectedIndex = templateCombo.getSelectionIndex();
+			Template templateSelected = newFileTemplates
+					.get( templateSelectedIndex );
+
+			templateDescription.setText( templateSelected.getDescription() );
+			templatePreview.getDocument().set( templateSelected.getPattern() );
+		} catch ( IndexOutOfBoundsException e ) {
+		}
+
+		//mg------------------------
+
+		initialize();
+		setPageComplete(false);
+
+		ModifyTextListner listener = new ModifyTextListner();
+		containerText.addModifyListener(listener);
+		moduleText.addModifyListener(listener);
+
+		//mg
+		briefText.addModifyListener( listener );
+		templateCombo.addSelectionListener( new SelectionListener() {
+
+			public void widgetSelected( SelectionEvent e ) {
+
+				try {
+					final Template templateSelected = getTemplate();
+
+					templateDescription.setText( templateSelected
+							.getDescription() );
+					templatePreview.getDocument().set( templateSelected.getPattern() );
+				} catch ( Exception exception ) {
+				}
+			}
+
+			public void widgetDefaultSelected( SelectionEvent e ) {
+			}
+
+		} );
+		//mg-------------------------
+
+		
+		setControl(container);
+	}
+
+	//mg
+	private CCombo createCombo( final Composite container, final String name,
+			final LinkedList <Template> templates ) {
+		final Label label = new Label( container, SWT.NULL );
+		label.setText( name );
+		final CCombo combo = new CCombo( container, SWT.NONE );
+
+		for ( final Template template : templates ) {
+			combo.add( template.getName() );
+		}
+
+		return combo;
+	}
+	
+	private SourceViewer createEditor(Composite parent, String pattern) {
+		SourceViewer viewer= createViewer(parent);
+		viewer.setEditable(true);
+
+		IDocument document= viewer.getDocument();
+		if (document != null)
+			document.set(pattern);
+		else {
+			document= new Document(pattern);
+			viewer.setDocument(document);
+		}
+
+		int nLines= document.getNumberOfLines();
+		if (nLines < 5) {
+			nLines= 5;
+		} else if (nLines > 12) {
+			nLines= 12;
+		}
+
+		Control control= viewer.getControl();
+		GridData data= new GridData(GridData.FILL_BOTH);
+		data.widthHint= convertWidthInCharsToPixels(80);
+		data.heightHint= convertHeightInCharsToPixels(nLines);
+		control.setLayoutData(data);
+
+		return viewer;
+	}
+	
+	protected SourceViewer createViewer(Composite parent) {
+		SourceViewer viewer= new SourceViewer(parent, null, null, false, SWT.BORDER | SWT.V_SCROLL | SWT.H_SCROLL);
+		SourceViewerConfiguration configuration;
+		
+		switch(languageMode){
+		case verilog:
+			configuration = HdlSourceViewerConfiguration.createForVerilog( new VerilogEditor() );
+			break;
+		default:
+		case vhdl:
+			configuration = HdlSourceViewerConfiguration.createForVhdl( new VhdlEditor() );
+			break;			
+		}		
+		
+		viewer.configure(configuration);
+		return viewer;
+	}
+	
+
+	private Text createText(Composite container, String name)
+	{
+		Label label = new Label(container, SWT.NULL);
+		label.setText(name);
+		Text text = new Text(container, SWT.BORDER | SWT.SINGLE);
+		GridData gd = new GridData(GridData.FILL_HORIZONTAL);
+		text.setLayoutData(gd);
+
+		return text;
+	}
+	
+	private class ModifyTextListner implements ModifyListener
+	{
+		public void modifyText(ModifyEvent e)
+		{
+			dialogChanged();
+		}
+
+		private void dialogChanged()
+		{
+			// check container
+			String containerName = getContainerName();
+			IResource resource = ResourcesPlugin.getWorkspace().getRoot()
+					.findMember(new Path(containerName));
+			if (containerName.length() == 0)
+			{
+				updateStatus("Source folder must be specified");
+				return;
+			}
+			if (resource == null || !resource.exists()
+					|| !(resource instanceof IContainer))
+			{
+				updateStatus("Source folder must exist");
+				return;
+			}
+			if (!resource.isAccessible())
+			{
+				updateStatus("Project must be writable");
+				return;
+			}
+			IContainer container = (IContainer)resource;
+
+			// check module name
+			String moduleName = getModuleName();
+			if (Character.isLetter(moduleName.charAt(0)) == false)
+			{
+				updateStatus("Module/Entity name must start a letter");
+				return;
+			}
+			for (int i = 1; i < moduleName.length(); i++)
+			{
+				if (Character.isJavaIdentifierPart(moduleName.charAt(i)) == false)
+				{
+					updateStatus("Module/Entity name must be identifier");
+					return;
+				}
+			}
+			
+			// check file
+			String fileName = getFileName();
+			IFile file = container.getFile(new Path(fileName));
+			if (file.exists())
+				updateStatus("Module/Entity already exist");
+			else if (moduleName.length() == 0)
+				updateStatus("Module/Entity name must be specified");
+			else if (fileName.replace('\\', '/').indexOf('/', 1) > 0)
+				updateStatus("Module/Entity name must be valid");
+			else
+				updateStatus(null);
+		}
+
+		private void updateStatus(String message)
+		{
+			setErrorMessage(message);
+			setPageComplete(message == null);
+		}
+	}
+
+	private void initialize()
+	{
+		if (selection != null && selection.isEmpty() == false
+				&& selection instanceof IStructuredSelection)
+		{
+			IStructuredSelection ssel = (IStructuredSelection) selection;
+			if (ssel.size() > 1)
+				return;
+			Object obj = ssel.getFirstElement();
+			if (obj instanceof IResource)
+			{
+				IContainer container;
+				if (obj instanceof IContainer)
+					container = (IContainer) obj;
+				else
+					container = ((IResource) obj).getParent();
+				containerText.setText(container.getFullPath().toString());
+			}
+		}
+	}
+
+	private void handleBrowse()
+	{
+		ContainerSelectionDialog dialog = new ContainerSelectionDialog(
+				getShell(), ResourcesPlugin.getWorkspace().getRoot(), false,
+				"Select a source folder");
+		if (dialog.open() == ContainerSelectionDialog.OK)
+		{
+			Object[] result = dialog.getResult();
+			if (result.length == 1)
+			{
+				containerText.setText(((Path) result[0]).toString());
+			}
+		}
+	}
+
+	public String getContainerName()
+	{
+		return containerText.getText();
+	}
+
+	public String getModuleName()
+	{
+		return moduleText.getText();
+	}
+	
+	public String getFileName()
+	{
+		return getModuleName() + extension;
+	}
+	//mg
+	public String getBrief() {
+		return briefText.getText();
+	}
+	
+	public String getTemplatePattern() {
+		return templatePreview.getDocument().get();
+	}
+
+	public Template getTemplate() {
+		int templateSelectedIndex = templateCombo.getSelectionIndex();
+
+		try {
+			return newFileTemplates.get( templateSelectedIndex );
+		} catch ( IndexOutOfBoundsException exception ) {
+			return null;
+		}
+	}
+	//mg----------------------
+
+}
+
+
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/wizard/NewProjectWizard.java vdt/src/com/elphel/vdt/veditor/wizard/NewProjectWizard.java
--- vdt-veditor/src/com/elphel/vdt/veditor/wizard/NewProjectWizard.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/wizard/NewProjectWizard.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,132 +1,264 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-
-package net.sourceforge.veditor.wizard;
-
-import java.lang.reflect.InvocationTargetException;
-
-import net.sourceforge.veditor.HdlNature;
-
-import org.eclipse.core.resources.IProject;
-import org.eclipse.core.resources.IProjectDescription;
-import org.eclipse.core.resources.IResource;
-import org.eclipse.core.resources.IWorkspace;
-import org.eclipse.core.resources.ResourcesPlugin;
-import org.eclipse.core.runtime.CoreException;
-import org.eclipse.core.runtime.IPath;
-import org.eclipse.core.runtime.IProgressMonitor;
-import org.eclipse.core.runtime.OperationCanceledException;
-import org.eclipse.ui.actions.WorkspaceModifyOperation;
-import org.eclipse.ui.dialogs.WizardNewProjectCreationPage;
-import org.eclipse.ui.wizards.newresource.BasicNewResourceWizard;
-
-public class NewProjectWizard extends BasicNewResourceWizard
-{
-	private WizardNewProjectCreationPage page;
-
-	public NewProjectWizard()
-	{
-		super();
-	}
-
-	public void addPages()
-	{
-		page = new WizardNewProjectCreationPage("NewProjectWizardPage");
-		page.setTitle("Verilog/VHDL Project");
-		page.setDescription("Create a new Verilog/VHDL project resource.");
-		addPage(page);
-	}
-
-	public boolean performFinish()
-	{
-        IProject newProject = page.getProjectHandle();
-
-		IPath newPath = null;
-		if (!page.useDefaults())
-			newPath = page.getLocationPath();
-
-		IWorkspace workspace = ResourcesPlugin.getWorkspace();
-		IProjectDescription description;
-		description = workspace.newProjectDescription(newProject.getName());
-		description.setLocation(newPath);
-
-		CreateProjectOperation op;
-		op = new CreateProjectOperation(newProject, description);
-
-		try
-		{
-			getContainer().run(true, true, op);			
-		}
-		catch (InterruptedException e)
-		{
-			e.printStackTrace();
-			return false;
-		}
-		catch (InvocationTargetException e)
-		{
-			e.printStackTrace();
-			return false;
-		}
-		
-		// add the nature if one does not exist yet
-		try {
-			String[] natures = description.getNatureIds();
-			String[] newNatures = new String[natures.length + 1];
-			System.arraycopy(natures, 0, newNatures, 0, natures.length);
-			newNatures[natures.length] = HdlNature.NATURE_ID;
-			description.setNatureIds(newNatures);
-			newProject.setDescription(description, null);
-		} catch (CoreException e) {
-			// Something went wrong
-			return false;
-		}
-		return true;
-	}
-
-	private class CreateProjectOperation extends WorkspaceModifyOperation
-	{
-		private IProject project;
-		private IProjectDescription description;
-		
-		public CreateProjectOperation(IProject project, IProjectDescription description)
-		{
-			this.project = project;
-			this.description = description;
-		}
-		protected void execute(IProgressMonitor monitor) throws CoreException,
-				InvocationTargetException, InterruptedException
-		{
-			try
-			{
-				monitor.beginTask("", 2000);
-
-				project.create(description, null);
-
-				monitor.worked(1000);
-				if (monitor.isCanceled())
-					throw new OperationCanceledException();
-
-				project.open(IResource.BACKGROUND_REFRESH, null);
-			}
-			finally
-			{
-				monitor.done();
-			}
-
-		}
-		
-	}
-}  
-
-
-
-
-
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+
+package com.elphel.vdt.veditor.wizard;
+
+import java.lang.reflect.InvocationTargetException;
+
+import com.elphel.vdt.VDT;
+import com.elphel.vdt.core.options.OptionsCore;
+import com.elphel.vdt.ui.MessageUI;
+import com.elphel.vdt.ui.wizards.project.NewProjectMainPage;
+import com.elphel.vdt.ui.wizards.project.NewProjectOperation;
+import com.elphel.vdt.ui.wizards.project.ProjectData;
+import com.elphel.vdt.veditor.HdlNature;
+import com.elphel.vdt.veditor.VerilogPlugin;
+
+import org.eclipse.core.resources.IFile;
+import org.eclipse.core.resources.IProject;
+import org.eclipse.core.resources.IProjectDescription;
+import org.eclipse.core.resources.IResource;
+import org.eclipse.core.resources.IWorkspace;
+import org.eclipse.core.resources.ResourcesPlugin;
+import org.eclipse.core.runtime.CoreException;
+import org.eclipse.core.runtime.IConfigurationElement;
+import org.eclipse.core.runtime.IPath;
+import org.eclipse.core.runtime.IProgressMonitor;
+import org.eclipse.core.runtime.OperationCanceledException;
+import org.eclipse.jface.viewers.IStructuredSelection;
+import org.eclipse.jface.wizard.Wizard;
+import org.eclipse.swt.widgets.Display;
+import org.eclipse.ui.INewWizard;
+import org.eclipse.ui.IWorkbench;
+import org.eclipse.ui.IWorkbenchPage;
+import org.eclipse.ui.IWorkbenchWindow;
+import org.eclipse.ui.IWorkbenchWizard;
+import org.eclipse.ui.PartInitException;
+import org.eclipse.ui.actions.WorkspaceModifyDelegatingOperation;
+import org.eclipse.ui.actions.WorkspaceModifyOperation;
+import org.eclipse.ui.dialogs.WizardNewProjectCreationPage;
+//import org.eclipse.ui.wizards.newresource.BasicNewResourceWizard;
+//import com.elphel.vdt.ui.wizards.project.NewProjectMainPage;
+import org.eclipse.ui.ide.IDE;
+import org.eclipse.ui.wizards.newresource.BasicNewProjectResourceWizard;
+import org.eclipse.ui.wizards.newresource.BasicNewResourceWizard;
+
+//public class NewProjectWizard extends BasicNewResourceWizard
+public class NewProjectWizard  extends Wizard implements INewWizard {
+    private IWorkbench workbench;
+    private IStructuredSelection selection;
+    private ProjectData projectData;
+    private NewProjectMainPage pageMain;
+
+	private WizardNewProjectCreationPage page;
+
+	public NewProjectWizard()
+	{
+		super();
+        projectData = new ProjectData();
+	}
+
+	public void addPages()
+	{
+/*		
+		page = new WizardNewProjectCreationPage("NewProjectWizardPage");
+		page.setTitle("Verilog/VHDL Project");
+		page.setDescription("Create a new Verilog/VHDL project resource.");
+		addPage(page); */
+        super.addPages();
+		pageMain = new NewProjectMainPage(projectData);
+        addPage(pageMain);
+	}
+
+	public boolean performFinish()
+	{
+//        IProject newProject = page.getProjectHandle();
+//        IProject newProject = pageMain.getProjectHandle();
+		
+        pageMain.updateData();
+//      pageOptions.updateData();
+      
+      NewProjectOperation opp = new NewProjectOperation(projectData);
+
+      org.eclipse.jface.operation.IRunnableWithProgress runnable = new WorkspaceModifyDelegatingOperation(opp);
+      try {
+          getContainer().run(true, false, runnable);
+      } catch (InterruptedException e) {
+          return false;
+      } catch (InvocationTargetException e) {
+          Throwable realException = e.getTargetException();
+          MessageUI.error(realException);
+          return false;
+      }
+      BasicNewProjectResourceWizard.updatePerspective(configElement);
+      IResource resource = opp.getElementToOpen();
+      if (resource != null)
+          openResource(resource);
+      
+/*      
+            
+        IProject newProject = page.getProjectHandle();
+		IPath newPath = null;
+	if (!page.useDefaults())
+			newPath = page.getLocationPath();
+		IWorkspace workspace = ResourcesPlugin.getWorkspace();
+		IProjectDescription description;
+		description = workspace.newProjectDescription(newProject.getName());
+		description.setLocation(newPath);
+		CreateProjectOperation op;
+		op = new CreateProjectOperation(newProject, description);
+
+		try
+		{
+			getContainer().run(true, true, op);			
+		}
+		catch (InterruptedException e)
+		{
+			e.printStackTrace();
+			return false;
+		}
+		catch (InvocationTargetException e)
+		{
+			e.printStackTrace();
+			return false;
+		}
+		
+		// add the nature if one does not exist yet
+		try {
+			String[] natures = description.getNatureIds();
+			String[] newNatures = new String[natures.length + 1];
+			System.arraycopy(natures, 0, newNatures, 0, natures.length);
+			newNatures[natures.length] = HdlNature.NATURE_ID;
+			description.setNatureIds(newNatures);
+			newProject.setDescription(description, null);
+		} catch (CoreException e) {
+			// Something went wrong
+			return false;
+		}
+*/		
+		return true;
+	}
+
+	
+	private void openResource(final IResource resource) {
+        if (resource.getType() != IResource.FILE)
+            return;
+        
+        IWorkbenchWindow window = VerilogPlugin.getDefault().getWorkbench().getActiveWorkbenchWindow();
+        if (window == null)
+            return;
+        final IWorkbenchPage activePage = window.getActivePage();
+        if (activePage != null) {
+            Display display = getShell().getDisplay();
+            display.asyncExec(new Runnable() {
+                public void run() {
+                    try {
+                        IDE.openEditor(activePage, (IFile)resource, true);
+                    } catch(PartInitException e) {
+                        MessageUI.log(e);
+                    }
+                }
+            });
+            BasicNewResourceWizard.selectAndReveal(resource, activePage.getWorkbenchWindow());
+        }
+    } // openResource()
+    
+
+    /**
+     * We will accept the selection in the workbench to see if
+     * we can initialize from it.
+     * @see IWorkbenchWizard#init(IWorkbench, IStructuredSelection)
+     */
+    public void init(IWorkbench workbench, IStructuredSelection selection) {
+        this.workbench = workbench;
+        this.selection = selection;
+    }
+    
+    public IWorkbench getWorkbench() {
+        return workbench;
+    }
+    
+    public IStructuredSelection getSelection() {
+        return selection;
+    }
+    
+    private IConfigurationElement configElement;
+	
+	
+	
+	private class CreateProjectOperation extends WorkspaceModifyOperation
+	{
+	    private ProjectData data; 
+	    /*	    private IResource elementToOpen;
+	    NewProjectOperation(ProjectData data) {
+	        this.data   = data;
+	    }
+*/
+		private IProject project;
+		private IProjectDescription description;
+		
+		public CreateProjectOperation(IProject project, IProjectDescription description)
+		{
+			this.project = project;
+			this.description = description;
+		}
+		protected void execute(IProgressMonitor monitor) throws CoreException,
+				InvocationTargetException, InterruptedException
+		{
+			try
+			{
+				monitor.beginTask("", 2000);
+
+				project.create(description, null);
+
+				monitor.worked(1000);
+				if (monitor.isCanceled())
+					throw new OperationCanceledException();
+
+				project.open(IResource.BACKGROUND_REFRESH, null);
+			}
+			finally
+			{
+				monitor.done();
+			}
+
+		}
+		private void setVdtProjectOptions( IProject project
+				, IProgressMonitor monitor ) throws CoreException 
+				{
+			if (monitor != null && monitor.isCanceled()) {
+				throw new OperationCanceledException();
+			}
+			OptionsCore.doStoreOption( VDT.OPTION_PROJECT_MENU
+					, data.getDesignMenu().getName()
+					, project );
+			monitor.worked(1);
+				} // setProjectOptions()
+
+
+	}
+}  
+
+
+
+
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/wizard/NewVerilogWizard.java vdt/src/com/elphel/vdt/veditor/wizard/NewVerilogWizard.java
--- vdt-veditor/src/com/elphel/vdt/veditor/wizard/NewVerilogWizard.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/wizard/NewVerilogWizard.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,46 +1,62 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-
-package net.sourceforge.veditor.wizard;
-
-import java.util.Calendar;
-
-public class NewVerilogWizard extends NewHdlWizard
-{
-	public void addPages()
-	{
-		super.addPages(".v");
-	}
-
-	
-	// isn't called in the code yet.
-	String getInitialContents( String templatePattern, String moduleName,
-			String brief ) {
-		String results= "module " + moduleName + "(\n" + ");\n" + "endmodule\n";
-		
-		results = templatePattern;
-		results = results.replaceAll( "\\$\\{brief\\}", brief );
-		
-		results=results.replaceAll("\\$\\{modulename\\}", moduleName);
-		results=results.replaceAll("\\$\\{user\\}", System.getProperty("user.name"));
-		results=results.replaceAll("\\$\\{year\\}", Integer.toString(Calendar.getInstance().get(Calendar.YEAR)));
-		String month = Integer.toString(Calendar.getInstance().get(Calendar.MONTH)+1);
-		if(month.length()<2) month = "0"+month;
-		String day = Integer.toString(Calendar.getInstance().get(Calendar.DAY_OF_MONTH));
-		if(day.length()<2) day = "0"+day;
-		results=results.replaceAll("\\$\\{month\\}", month);
-		results=results.replaceAll("\\$\\{day\\}", day);
-		
-		return results.toString();
-	
-	}	
-}
-
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+
+package com.elphel.vdt.veditor.wizard;
+
+import java.util.Calendar;
+
+import com.elphel.vdt.veditor.VerilogPlugin;
+
+public class NewVerilogWizard extends NewHdlWizard
+{
+	public void addPages()
+	{
+		String [] patterns=VerilogPlugin.getPreferenceString("Verilog.Extensions").split("[\\, ]+");
+//		for (int i=0;i<patterns.length;i++) super.addPages(patterns[i]);
+		 super.addPages(patterns[0]); // first .v, second .tf
+//		super.addPages(".v");
+	}
+
+	
+	// isn't called in the code yet.
+	String getInitialContents( String templatePattern, String moduleName,
+			String brief ) {
+		String results= "module " + moduleName + "(\n" + ");\n" + "endmodule\n";
+		
+		results = templatePattern;
+		results = results.replaceAll( "\\$\\{brief\\}", brief );
+		
+		results=results.replaceAll("\\$\\{modulename\\}", moduleName);
+		results=results.replaceAll("\\$\\{user\\}", System.getProperty("user.name"));
+		results=results.replaceAll("\\$\\{year\\}", Integer.toString(Calendar.getInstance().get(Calendar.YEAR)));
+		String month = Integer.toString(Calendar.getInstance().get(Calendar.MONTH)+1);
+		if(month.length()<2) month = "0"+month;
+		String day = Integer.toString(Calendar.getInstance().get(Calendar.DAY_OF_MONTH));
+		if(day.length()<2) day = "0"+day;
+		results=results.replaceAll("\\$\\{month\\}", month);
+		results=results.replaceAll("\\$\\{day\\}", day);
+		
+		return results.toString();
+	
+	}	
+}
+
diff -U 3 -dHrN -- vdt-veditor/src/com/elphel/vdt/veditor/wizard/NewVhdlWizard.java vdt/src/com/elphel/vdt/veditor/wizard/NewVhdlWizard.java
--- vdt-veditor/src/com/elphel/vdt/veditor/wizard/NewVhdlWizard.java	2016-06-24 10:29:40.864495296 -0600
+++ vdt/src/com/elphel/vdt/veditor/wizard/NewVhdlWizard.java	2016-06-24 10:29:40.824496406 -0600
@@ -1,45 +1,60 @@
-/*******************************************************************************
- * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    KOBAYASHI Tadashi - initial API and implementation
- *******************************************************************************/
-
-package net.sourceforge.veditor.wizard;
-
-import java.util.Calendar;
-
-public class NewVhdlWizard extends NewHdlWizard
-{
-	public void addPages()
-	{
-		super.addPages(".vhd");
-	}
-
-	String getInitialContents( String templatePattern,  String moduleName,  String brief ) {
-		String results;	
-
-
-		results = templatePattern;
-		results = results.replaceAll( "\\$\\{brief\\}", brief );
-		
-		results=results.replaceAll("\\$\\{modulename\\}", moduleName);
-		results=results.replaceAll("\\$\\{user\\}", System.getProperty("user.name"));
-		results=results.replaceAll("\\$\\{year\\}", Integer.toString(Calendar.getInstance().get(Calendar.YEAR)));
-		String month = Integer.toString(Calendar.getInstance().get(Calendar.MONTH)+1);
-		if(month.length()<2) month = "0"+month;
-		String day = Integer.toString(Calendar.getInstance().get(Calendar.DAY_OF_MONTH));
-		if(day.length()<2) day = "0"+day;
-		results=results.replaceAll("\\$\\{month\\}", month);
-		results=results.replaceAll("\\$\\{day\\}", day);
-
-		return results.toString();
-	}
-	
-
-}
-
+/*******************************************************************************
+ * Notice: This program DOES NOT have a valid distribution license and has to be
+ * re-generated by a user.
+ *
+ * This program is made of the original VEditor code released under Eclipse Public
+ * License v1.0 (http://www.eclipse.org/legal/epl-v10.html) by applying a patch
+ * vdt-veditor.patch released under GNU Public License v3.0 (or later).
+ *
+ * These two Free Software licenses are NOT compatible and none of them gives
+ * you the right to distribute the combined code. For this reason while the
+ * copyright notice of the original VEditor code is preserved, the license terms
+ * are removed. Copyright below is applicable to the original VEditor code only,
+ * vdt-veditor.patch is (C) 2014 Elphel, Inc
+ *******************************************************************************/
+
+ /*******************************************************************************
+ * Copyright (c) 2004, 2006 KOBAYASHI Tadashi and others.
+ *
+ * Contributors:
+ *    KOBAYASHI Tadashi - initial API and implementation
+ *******************************************************************************/
+
+package com.elphel.vdt.veditor.wizard;
+
+import java.util.Calendar;
+
+import com.elphel.vdt.veditor.VerilogPlugin;
+
+public class NewVhdlWizard extends NewHdlWizard
+{
+	public void addPages()
+	{
+		String [] patterns=VerilogPlugin.getPreferenceString("VHDL.Extensions").split("[\\, ]+");
+		for (int i=0;i<patterns.length;i++) super.addPages(patterns[i]);
+//		super.addPages(".vhd");
+	}
+
+	String getInitialContents( String templatePattern,  String moduleName,  String brief ) {
+		String results;	
+
+
+		results = templatePattern;
+		results = results.replaceAll( "\\$\\{brief\\}", brief );
+		
+		results=results.replaceAll("\\$\\{modulename\\}", moduleName);
+		results=results.replaceAll("\\$\\{user\\}", System.getProperty("user.name"));
+		results=results.replaceAll("\\$\\{year\\}", Integer.toString(Calendar.getInstance().get(Calendar.YEAR)));
+		String month = Integer.toString(Calendar.getInstance().get(Calendar.MONTH)+1);
+		if(month.length()<2) month = "0"+month;
+		String day = Integer.toString(Calendar.getInstance().get(Calendar.DAY_OF_MONTH));
+		if(day.length()<2) day = "0"+day;
+		results=results.replaceAll("\\$\\{month\\}", month);
+		results=results.replaceAll("\\$\\{day\\}", day);
+
+		return results.toString();
+	}
+	
+
+}
+
